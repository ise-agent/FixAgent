{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/astropy/astropy/wcs/wcs.py lines 1221-1225)": "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty arrays to prevent wcslib errors\n            if xy.size == 0:\n                # Create empty output array with proper shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n                if ra_dec_order and sky == 'output':\n                    output = self._normalize_sky(output)\n            \n            if ra_dec_order and sky == 'output' and xy.size > 0:\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            elif ra_dec_order and sky == 'output':\n                # Handle empty case for ra_dec_order output\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
    "Location 2 (/root/hy/projects_4/astropy/astropy/wcs/wcs.py lines 1226-1231)": "\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty arrays to prevent InconsistentAxisTypesError\n            if xy.size == 0:\n                # Create empty output array with correct shape\n                output_shape = (0, self.naxis)\n                output = np.empty(output_shape, dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n                \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/astropy/astropy/wcs/wcs.py lines 1221-1225)": [
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty arrays early to avoid wcslib errors\n            if xy.size == 0:\n                # Create empty output array with correct shape\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty arrays early to avoid C library errors\n            if xy.size == 0:\n                # Create empty output with appropriate shape\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty arrays to prevent InconsistentAxisTypesError\n            if xy.size == 0:\n                # Create empty output with correct shape\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty arrays to avoid InconsistentAxisTypesError\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty arrays to prevent InconsistentAxisTypesError\n            if xy.size == 0:\n                # Create empty output array with proper shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty arrays - return empty output without calling underlying function\n            if xy.size == 0:\n                output = np.empty((0, self.naxis))\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty arrays to avoid InconsistentAxisTypesError\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis))\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n                if ra_dec_order and sky == 'output':\n                    output = self._normalize_sky(output)\n            \n            if ra_dec_order and sky == 'output':\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n        def _return_list_of_arrays(axes, origin):\n            try:\n                axes = np.broadcast_arrays(*axes)\n            except ValueError:\n                raise ValueError(\n                    \"Coordinate arrays are not broadcastable to each other\")\n\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty arrays to avoid InconsistentAxisTypesError\n            if xy.size == 0:\n                # Create empty output array with correct shape (0, naxis)\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n"
    ],
    "Location 2 (/root/hy/projects_4/astropy/astropy/wcs/wcs.py lines 1226-1231)": [
      "\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty arrays early to avoid wcslib errors\n            if xy.size == 0:\n                # Create empty output array with correct shape\n                output_shape = (0, self.naxis if not (ra_dec_order and sky == 'output') else 2)\n                output = np.empty(output_shape, dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            \n            # Handle empty arrays to avoid InconsistentAxisTypesError\n            if xy.size == 0:\n                # Create empty output array with correct shape\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                output = func(xy, origin)\n                \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty arrays early to avoid wcslib errors\n            if xy.size == 0:\n                # Create empty output array with correct shape\n                if ra_dec_order and sky == 'output':\n                    output = np.empty((0, 2))\n                else:\n                    output = np.empty((0, self.naxis))\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n                \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            \n            # Handle empty arrays before calling the C library\n            if xy.size == 0:\n                # Create empty output array with correct shape\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                output = func(xy, origin)\n                \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            \n            # Handle empty arrays to avoid InconsistentAxisTypesError\n            if xy.size == 0:\n                # Create empty output array with correct shape\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                output = func(xy, origin)\n                \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            if ra_dec_order and sky == 'input':\n                xy = self._denormalize_sky(xy)\n            \n            # Handle empty arrays to avoid InconsistentAxisTypesError\n            if xy.size == 0:\n                # Create empty output array with correct shape\n                output = np.empty((0, self.naxis), dtype=float)\n            else:\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty arrays to avoid InconsistentAxisTypesError\n            if xy.size == 0:\n                # Create empty output array with correct shape\n                output_shape = (0, self.naxis)\n                output = np.empty(output_shape, dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n            \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n",
      "\n            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n\n            # Handle empty arrays to prevent InconsistentAxisTypesError\n            if xy.size == 0:\n                # Create empty output array with correct shape\n                output_shape = (0, self.naxis)\n                output = np.empty(output_shape, dtype=float)\n            else:\n                if ra_dec_order and sky == 'input':\n                    xy = self._denormalize_sky(xy)\n                output = func(xy, origin)\n                \n            if ra_dec_order and sky == 'output':\n                output = self._normalize_sky(output)\n                return (output[:, 0].reshape(axes[0].shape),\n                        output[:, 1].reshape(axes[0].shape))\n            return [output[:, i].reshape(axes[0].shape)\n                    for i in range(output.shape[1])]\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..91433a6891 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1218,11 +1218,19 @@ reduce these to 2 dimensions using the naxis kwarg.\n                 raise ValueError(\n                     \"Coordinate arrays are not broadcastable to each other\")\n \n+\n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n             if ra_dec_order and sky == 'input':\n                 xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            \n+            # Handle empty arrays to avoid C library error\n+            if xy.size == 0:\n+                # Create empty output array with correct shape\n+                output = np.empty((0, self.naxis))\n+            else:\n+                output = func(xy, origin)\n+\n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_0": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..9430cedd0b 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,39 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n-            if ra_dec_order and sky == 'input':\n-                xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            # Handle empty arrays to prevent wcslib errors\n+            if xy.size == 0:\n+                # Create empty output array with proper shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+                if ra_dec_order and sky == 'output':\n+                    output = self._normalize_sky(output)\n+            \n+            if ra_dec_order and sky == 'output' and xy.size > 0:\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            elif ra_dec_order and sky == 'output':\n+                # Handle empty case for ra_dec_order output\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n+            # Handle empty arrays to prevent InconsistentAxisTypesError\n+            if xy.size == 0:\n+                # Create empty output array with correct shape\n+                output_shape = (0, self.naxis)\n+                output = np.empty(output_shape, dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+                \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_1": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..1178bd69ee 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,33 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n-            if ra_dec_order and sky == 'input':\n-                xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            # Handle empty arrays early to avoid wcslib errors\n+            if xy.size == 0:\n+                # Create empty output array with correct shape\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            if ra_dec_order and sky == 'output':\n+                output = self._normalize_sky(output)\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n+            # Handle empty arrays early to avoid wcslib errors\n+            if xy.size == 0:\n+                # Create empty output array with correct shape\n+                output_shape = (0, self.naxis if not (ra_dec_order and sky == 'output') else 2)\n+                output = np.empty(output_shape, dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_2": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..0d478c693c 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,34 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n+            # Handle empty arrays early to avoid C library errors\n+            if xy.size == 0:\n+                # Create empty output with appropriate shape\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n+            if ra_dec_order and sky == 'output':\n+                output = self._normalize_sky(output)\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n             if ra_dec_order and sky == 'input':\n                 xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            \n+            # Handle empty arrays to avoid InconsistentAxisTypesError\n+            if xy.size == 0:\n+                # Create empty output array with correct shape\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                output = func(xy, origin)\n+                \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_3": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..9d869302cb 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,36 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n-            if ra_dec_order and sky == 'input':\n-                xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            # Handle empty arrays to prevent InconsistentAxisTypesError\n+            if xy.size == 0:\n+                # Create empty output with correct shape\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n+            if ra_dec_order and sky == 'output':\n+                output = self._normalize_sky(output)\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n+            # Handle empty arrays early to avoid wcslib errors\n+            if xy.size == 0:\n+                # Create empty output array with correct shape\n+                if ra_dec_order and sky == 'output':\n+                    output = np.empty((0, 2))\n+                else:\n+                    output = np.empty((0, self.naxis))\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+                \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_4": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..8d67d5179f 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,34 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n+            # Handle empty arrays to avoid InconsistentAxisTypesError\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n+            if ra_dec_order and sky == 'output':\n+                output = self._normalize_sky(output)\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n             if ra_dec_order and sky == 'input':\n                 xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            \n+            # Handle empty arrays before calling the C library\n+            if xy.size == 0:\n+                # Create empty output array with correct shape\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                output = func(xy, origin)\n+                \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_5": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..a0cef21d45 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,34 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n+            # Handle empty arrays to prevent InconsistentAxisTypesError\n+            if xy.size == 0:\n+                # Create empty output array with proper shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n+            if ra_dec_order and sky == 'output':\n+                output = self._normalize_sky(output)\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n             if ra_dec_order and sky == 'input':\n                 xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            \n+            # Handle empty arrays to avoid InconsistentAxisTypesError\n+            if xy.size == 0:\n+                # Create empty output array with correct shape\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                output = func(xy, origin)\n+                \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_6": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..449b8d2a15 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,32 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n+            # Handle empty arrays - return empty output without calling underlying function\n+            if xy.size == 0:\n+                output = np.empty((0, self.naxis))\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            if ra_dec_order and sky == 'output':\n+                output = self._normalize_sky(output)\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n             if ra_dec_order and sky == 'input':\n                 xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            \n+            # Handle empty arrays to avoid InconsistentAxisTypesError\n+            if xy.size == 0:\n+                # Create empty output array with correct shape\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                output = func(xy, origin)\n+            \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_7": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..2268c50aee 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,35 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n-            if ra_dec_order and sky == 'input':\n-                xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            # Handle empty arrays to avoid InconsistentAxisTypesError\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis))\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+                if ra_dec_order and sky == 'output':\n+                    output = self._normalize_sky(output)\n+            \n+            if ra_dec_order and sky == 'output':\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n+            # Handle empty arrays to avoid InconsistentAxisTypesError\n+            if xy.size == 0:\n+                # Create empty output array with correct shape\n+                output_shape = (0, self.naxis)\n+                output = np.empty(output_shape, dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n",
    "variant_8": "diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py\nindex d3a06f2b31..9aa4aacdf9 100644\n--- a/astropy/wcs/wcs.py\n+++ b/astropy/wcs/wcs.py\n@@ -1211,6 +1211,14 @@ reduce these to 2 dimensions using the naxis kwarg.\n         or a single Nx2 array.\n         \"\"\"\n \n+        def _return_list_of_arrays(axes, origin):\n+            try:\n+                axes = np.broadcast_arrays(*axes)\n+            except ValueError:\n+                raise ValueError(\n+                    \"Coordinate arrays are not broadcastable to each other\")\n+\n+\n         def _return_list_of_arrays(axes, origin):\n             try:\n                 axes = np.broadcast_arrays(*axes)\n@@ -1220,9 +1228,33 @@ reduce these to 2 dimensions using the naxis kwarg.\n \n             xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n \n-            if ra_dec_order and sky == 'input':\n-                xy = self._denormalize_sky(xy)\n-            output = func(xy, origin)\n+            # Handle empty arrays to avoid InconsistentAxisTypesError\n+            if xy.size == 0:\n+                # Create empty output array with correct shape (0, naxis)\n+                output = np.empty((0, self.naxis), dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+            if ra_dec_order and sky == 'output':\n+                output = self._normalize_sky(output)\n+                return (output[:, 0].reshape(axes[0].shape),\n+                        output[:, 1].reshape(axes[0].shape))\n+            return [output[:, i].reshape(axes[0].shape)\n+                    for i in range(output.shape[1])]\n+\n+            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n+\n+            # Handle empty arrays to prevent InconsistentAxisTypesError\n+            if xy.size == 0:\n+                # Create empty output array with correct shape\n+                output_shape = (0, self.naxis)\n+                output = np.empty(output_shape, dtype=float)\n+            else:\n+                if ra_dec_order and sky == 'input':\n+                    xy = self._denormalize_sky(xy)\n+                output = func(xy, origin)\n+                \n             if ra_dec_order and sky == 'output':\n                 output = self._normalize_sky(output)\n                 return (output[:, 0].reshape(axes[0].shape),\n"
  }
}