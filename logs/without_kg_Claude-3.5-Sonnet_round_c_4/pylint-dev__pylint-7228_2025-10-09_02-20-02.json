{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/pylint/pylint/config/option.py lines 23-26)": "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        return re.compile(value)\n    except re.error as e:\n        # Check if the error is due to unsupported Unicode property escapes\n        if \"bad escape \\\\p\" in str(e) or \"bad escape \\\\P\" in str(e):\n            # Strip Unicode property escapes and warn the user\n            import warnings\n            cleaned_pattern = re.sub(r'\\\\[pP]\\{[^}]*\\}', '', value)\n            warnings.warn(\n                f\"Unicode property escapes (\\\\p{{...}}) are not supported in Python regex. \"\n                f\"Pattern '{value}' has been modified to '{cleaned_pattern}'. \"\n                f\"Consider using standard Python regex character classes instead.\",\n                UserWarning,\n                stacklevel=2\n            )\n            try:\n                return re.compile(cleaned_pattern)\n            except re.error:\n                # If still invalid after cleaning, raise original error\n                raise e\n        else:\n            # Re-raise other regex errors as-is\n            raise e\n",
    "Location 2 (/root/hy/projects_4/pylint/pylint/config/option.py lines 106-106)": "\n    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n",
    "Location 3 (/root/hy/projects_4/pylint/pylint/config/argument.py lines 133-133)": "\n    \"regexp\": _safe_compile_regex,\n",
    "Location 4 (/root/hy/projects_4/pylint/pylint/config/argument.py lines 105-106)": "\ndef _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        try:\n            patterns.append(re.compile(pattern))\n        except re.error as e:\n            if \"bad escape \\\\p\" in str(e):\n                # Strip Unicode property escapes and warn\n                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n                if cleaned_pattern.strip():\n                    try:\n                        patterns.append(re.compile(cleaned_pattern))\n                        print(f\"Warning: Unicode property escapes like \\\\p{{}} are not supported in Python regex. \"\n                              f\"Pattern '{pattern}' has been simplified to '{cleaned_pattern}'.\", file=sys.stderr)\n                    except re.error:\n                        raise argparse.ArgumentTypeError(f\"Invalid regex pattern: {pattern}\")\n                else:\n                    raise argparse.ArgumentTypeError(f\"Invalid regex pattern: {pattern}\")\n            else:\n                raise argparse.ArgumentTypeError(f\"Invalid regex pattern: {pattern}\")\n    return patterns\n",
    "Location 5 (/root/hy/projects_4/pylint/pylint/config/argument.py lines 114-120)": "\ndef _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        try:\n            patterns.append(\n                re.compile(\n                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                    + \"|\"\n                    + pathlib.PureWindowsPath(pattern).as_posix()\n                )\n            )\n        except re.error as exc:\n            if \"bad escape \\\\p\" in str(exc):\n                # Strip Unicode property escapes like \\p{Han} which aren't supported by Python's re module\n                sanitized_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n                patterns.append(\n                    re.compile(\n                        str(pathlib.PureWindowsPath(sanitized_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                        + \"|\"\n                        + pathlib.PureWindowsPath(sanitized_pattern).as_posix()\n                    )\n                )\n            else:\n                raise exc\n    return patterns\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/pylint/pylint/config/option.py lines 23-26)": [
      "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        return re.compile(value)\n    except re.error as e:\n        if \"bad escape \\\\p\" in str(e):\n            warnings.warn(\n                f\"Unicode property escapes like \\\\p{{...}} are not supported in Python regex. \"\n                f\"Pattern '{value}' contains unsupported escape sequences. \"\n                f\"Consider using character classes or ranges instead.\",\n                UserWarning,\n                stacklevel=2\n            )\n            # Strip Unicode property escapes as a fallback\n            cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', value)\n            if cleaned_pattern:\n                return re.compile(cleaned_pattern)\n            else:\n                # If pattern becomes empty after cleaning, return a pattern that matches nothing\n                return re.compile(r'(?!)')\n        else:\n            raise\n",
      "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        return re.compile(value)\n    except re.error as e:\n        if \"bad escape \\\\p\" in str(e):\n            warnings.warn(\n                f\"Unicode property escapes like \\\\p{{...}} are not supported in Python regex. \"\n                f\"Pattern '{value}' contains unsupported escape sequences. \"\n                f\"Consider using character classes or other Python regex features instead.\",\n                UserWarning,\n                stacklevel=2\n            )\n            # Strip Unicode property escapes and try again\n            cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', value)\n            if cleaned_pattern:\n                return re.compile(cleaned_pattern)\n            else:\n                # If pattern becomes empty after cleaning, return a pattern that matches nothing\n                return re.compile(r'(?!.*)')\n        else:\n            raise\n",
      "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        return re.compile(value)\n    except re.error as exc:\n        if r'\\p{' in value:\n            # Remove Unicode property escapes which are not supported by Python's re module\n            cleaned_value = re.sub(r'\\\\p\\{[^}]+\\}', '', value)\n            warnings.warn(\n                f\"Unicode property escapes like \\\\p{{...}} are not supported by Python's re module. \"\n                f\"Removed from pattern: {value} -> {cleaned_value}\",\n                UserWarning,\n                stacklevel=2\n            )\n            if cleaned_value.strip():\n                return re.compile(cleaned_value)\n            else:\n                # If the pattern becomes empty after removing Unicode properties, use a pattern that matches nothing\n                return re.compile(r'(?!)')\n        else:\n            raise exc\n",
      "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        return re.compile(value)\n    except re.error as e:\n        if \"bad escape \\\\p\" in str(e):\n            warnings.warn(\n                f\"Unicode property escapes like \\\\p{{}} are not supported in Python regex. \"\n                f\"Pattern '{value}' contains unsupported syntax. \"\n                f\"Consider using character classes instead.\",\n                UserWarning,\n                stacklevel=2\n            )\n            # Strip Unicode property escapes and try again\n            cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', value)\n            if cleaned_pattern:\n                return re.compile(cleaned_pattern)\n            else:\n                # If pattern becomes empty after cleaning, return a pattern that matches nothing\n                return re.compile(r'(?!)')\n        else:\n            raise\n",
      "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        return re.compile(value)\n    except re.error as e:\n        if \"bad escape \\\\p\" in str(e):\n            warnings.warn(\n                f\"Unicode property escapes like '\\\\p{{...}}' are not supported in Python regex. \"\n                f\"Pattern '{value}' may not work as expected.\",\n                UserWarning,\n                stacklevel=2\n            )\n            # Strip Unicode property escapes and try again\n            cleaned_value = re.sub(r'\\\\p\\{[^}]+\\}', '', value)\n            if cleaned_value:\n                return re.compile(cleaned_value)\n            else:\n                # If pattern becomes empty after cleaning, return a pattern that matches nothing\n                return re.compile(r'(?!)')\n        else:\n            raise\n",
      "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        return re.compile(value)\n    except re.error as exc:\n        if \"bad escape \\\\p\" in str(exc):\n            # Unicode property escapes like \\p{Han} are not supported in Python's re module\n            # Strip them out and issue a warning\n            import re as re_module\n            cleaned_value = re_module.sub(r'\\\\p\\{[^}]+\\}', '', value)\n            warnings.warn(\n                f\"Unicode property escapes (\\\\p{{...}}) in regex '{value}' are not supported \"\n                f\"by Python's re module. Stripped to: '{cleaned_value}'\",\n                UserWarning,\n                stacklevel=2\n            )\n            try:\n                return re.compile(cleaned_value)\n            except re.error:\n                # If still invalid after stripping, raise original error\n                raise exc from None\n        else:\n            raise\n",
      "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        return re.compile(value)\n    except re.error as e:\n        if \"bad escape \\\\p\" in str(e):\n            # Strip Unicode property escapes like \\p{Han} which aren't supported by Python's re module\n            import warnings\n            cleaned_value = re.sub(r'\\\\p\\{[^}]+\\}', '', value)\n            warnings.warn(\n                f\"Unicode property escapes (\\\\p{{...}}) are not supported in Python regex. \"\n                f\"Stripped from pattern: {value!r} -> {cleaned_value!r}\",\n                UserWarning,\n                stacklevel=2\n            )\n            if cleaned_value:\n                return re.compile(cleaned_value)\n            else:\n                # If the pattern becomes empty after stripping, use a pattern that matches nothing\n                return re.compile(r'(?!)')\n        else:\n            raise\n",
      "\ndef _regexp_validator(_, name, value):\n    if hasattr(value, \"pattern\"):\n        return value\n    try:\n        return re.compile(value)\n    except re.error as e:\n        # Check if the error is due to Unicode property escapes\n        if \"bad escape \\\\p\" in str(e) or \"bad character range \\\\p\" in str(e):\n            # Strip Unicode property escapes and warn the user\n            import warnings\n            cleaned_pattern = re.sub(r'\\\\p\\{[^}]*\\}', '', value)\n            warnings.warn(\n                f\"Unicode property escapes like '\\\\p{{...}}' are not supported in Python regex. \"\n                f\"Pattern '{value}' has been simplified to '{cleaned_pattern}'. \"\n                f\"Consider using character classes or ranges instead.\",\n                UserWarning\n            )\n            try:\n                return re.compile(cleaned_pattern)\n            except re.error:\n                # If still invalid after cleaning, fall back to original error\n                raise e\n        else:\n            # Re-raise other regex errors as-is\n            raise e\n"
    ],
    "Location 2 (/root/hy/projects_4/pylint/pylint/config/option.py lines 106-106)": [
      "\n    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n",
      "\n    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n",
      "\n    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n",
      "\n    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n",
      "\n    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n",
      "\n    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n",
      "\n    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n",
      "\n    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n"
    ],
    "Location 3 (/root/hy/projects_4/pylint/pylint/config/argument.py lines 133-133)": [
      "\n    \"regexp\": _safe_compile_regex,\n",
      "\n\"regexp\": _safe_compile_regex,\n",
      "\n    \"regexp\": _safe_compile_regex,\n",
      "\n    \"regexp\": _safe_compile_regex,\n",
      "\n    \"regexp\": _safe_compile_regex,\n",
      "\n\"regexp\": _safe_compile_regex,\n",
      "\n\"regexp\": _safe_compile_regex,\n",
      "\n    \"regexp\": lambda value: _safe_compile_regex(value),\n"
    ],
    "Location 4 (/root/hy/projects_4/pylint/pylint/config/argument.py lines 105-106)": [
      "\ndef _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        try:\n            patterns.append(re.compile(pattern))\n        except re.error as e:\n            if \"bad escape \\\\p\" in str(e):\n                # Remove Unicode property escapes like \\p{Han} which are not supported in Python's re module\n                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n                if cleaned_pattern.strip():\n                    try:\n                        patterns.append(re.compile(cleaned_pattern))\n                        print(f\"Warning: Unicode property escapes removed from pattern '{pattern}'. Using '{cleaned_pattern}' instead.\", file=sys.stderr)\n                    except re.error:\n                        raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern}': {e}\")\n                else:\n                    print(f\"Warning: Pattern '{pattern}' contained only Unicode property escapes and was skipped.\", file=sys.stderr)\n            else:\n                raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern}': {e}\")\n    return patterns\n",
      "\ndef _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        try:\n            patterns.append(re.compile(pattern))\n        except re.error as e:\n            if \"bad escape \\\\p\" in str(e):\n                # Remove Unicode property escapes which are not supported by Python's re module\n                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n                if cleaned_pattern.strip():\n                    patterns.append(re.compile(cleaned_pattern))\n                # If pattern becomes empty after cleaning, skip it silently\n            else:\n                raise argparse.ArgumentTypeError(f\"Invalid regular expression '{pattern}': {e}\") from e\n    return patterns\n",
      "\ndef _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        patterns.append(_safe_compile_regex(pattern))\n    return patterns\n",
      "\ndef _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        try:\n            patterns.append(re.compile(pattern))\n        except re.error as e:\n            if \"bad escape \\\\p\" in str(e):\n                # Strip Unicode property escapes and try again\n                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n                if cleaned_pattern.strip():\n                    try:\n                        patterns.append(re.compile(cleaned_pattern))\n                        continue\n                    except re.error:\n                        pass\n                raise argparse.ArgumentTypeError(\n                    f\"Invalid regex pattern '{pattern}': Unicode property escapes like \\\\p{{Han}} \"\n                    f\"are not supported by Python's re module. Use character classes instead.\"\n                ) from None\n            raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern}': {e}\") from None\n    return patterns\n",
      "\ndef _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        try:\n            patterns.append(re.compile(pattern))\n        except re.error as e:\n            if \"bad escape \\\\p\" in str(e):\n                raise argparse.ArgumentTypeError(\n                    f\"Invalid regex pattern '{pattern}': Unicode property escapes like \\\\p{{...}} \"\n                    f\"are not supported by Python's re module. Use character classes like [\\\\u4e00-\\\\u9fff] instead.\"\n                ) from None\n            raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern}': {e}\") from None\n    return patterns\n",
      "\ndef _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        try:\n            patterns.append(re.compile(pattern))\n        except re.error as e:\n            if \"bad escape \\\\p\" in str(e):\n                # Strip Unicode property escapes like \\p{Han} which are not supported by Python's re module\n                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n                if cleaned_pattern.strip():\n                    try:\n                        patterns.append(re.compile(cleaned_pattern))\n                        print(f\"Warning: Unicode property escapes in regex '{pattern}' are not supported. Using '{cleaned_pattern}' instead.\", file=sys.stderr)\n                    except re.error:\n                        raise argparse.ArgumentTypeError(f\"Invalid regex pattern: {pattern}\")\n                else:\n                    print(f\"Warning: Regex pattern '{pattern}' contains only unsupported Unicode property escapes and will be ignored.\", file=sys.stderr)\n            else:\n                raise argparse.ArgumentTypeError(f\"Invalid regex pattern: {pattern}\")\n    return patterns\n",
      "\ndef _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        try:\n            patterns.append(re.compile(pattern))\n        except re.error as e:\n            if \"bad escape \\\\p\" in str(e).lower():\n                # Strip Unicode property escapes like \\p{Han} which are not supported by Python's re module\n                sanitized_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n                if sanitized_pattern.strip():\n                    try:\n                        patterns.append(re.compile(sanitized_pattern))\n                        continue\n                    except re.error:\n                        pass\n                raise argparse.ArgumentTypeError(\n                    f\"Invalid regular expression '{pattern}': Unicode property escapes like \\\\p{{...}} \"\n                    f\"are not supported by Python's re module. Please use standard Python regex syntax.\"\n                ) from e\n            else:\n                raise argparse.ArgumentTypeError(f\"Invalid regular expression '{pattern}': {e}\") from e\n    return patterns\n",
      "\ndef _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        try:\n            patterns.append(re.compile(pattern))\n        except re.error as e:\n            if \"bad escape \\\\p\" in str(e):\n                # Strip Unicode property escapes and try again\n                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n                if cleaned_pattern.strip():\n                    try:\n                        patterns.append(re.compile(cleaned_pattern))\n                        continue\n                    except re.error:\n                        pass\n                raise argparse.ArgumentTypeError(\n                    f\"Invalid regex pattern '{pattern}': Unicode property escapes like \\\\p{{Han}} \"\n                    f\"are not supported in Python's re module. Please use character classes instead.\"\n                ) from e\n            else:\n                raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern}': {e}\") from e\n    return patterns\n"
    ],
    "Location 5 (/root/hy/projects_4/pylint/pylint/config/argument.py lines 114-120)": [
      "\ndef _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        try:\n            patterns.append(\n                re.compile(\n                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                    + \"|\"\n                    + pathlib.PureWindowsPath(pattern).as_posix()\n                )\n            )\n        except re.error as e:\n            if \"bad escape \\\\p\" in str(e):\n                # Strip Unicode property escapes and retry\n                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n                patterns.append(\n                    re.compile(\n                        str(pathlib.PureWindowsPath(cleaned_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                        + \"|\"\n                        + pathlib.PureWindowsPath(cleaned_pattern).as_posix()\n                    )\n                )\n            else:\n                raise\n    return patterns\n",
      "\ndef _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        try:\n            patterns.append(\n                re.compile(\n                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                    + \"|\"\n                    + pathlib.PureWindowsPath(pattern).as_posix()\n                )\n            )\n        except re.error as e:\n            if \"bad escape \\\\p\" in str(e):\n                # Strip Unicode property escapes like \\p{Han} which aren't supported by Python's re module\n                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n                patterns.append(\n                    re.compile(\n                        str(pathlib.PureWindowsPath(cleaned_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                        + \"|\"\n                        + pathlib.PureWindowsPath(cleaned_pattern).as_posix()\n                    )\n                )\n            else:\n                raise\n    return patterns\n",
      "\ndef _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        try:\n            patterns.append(\n                re.compile(\n                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                    + \"|\"\n                    + pathlib.PureWindowsPath(pattern).as_posix()\n                )\n            )\n        except re.error as e:\n            if \"bad escape\" in str(e) and \"\\\\p\" in pattern:\n                # Remove Unicode property escapes and try again\n                sanitized_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n                if sanitized_pattern:\n                    patterns.append(\n                        re.compile(\n                            str(pathlib.PureWindowsPath(sanitized_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                            + \"|\"\n                            + pathlib.PureWindowsPath(sanitized_pattern).as_posix()\n                        )\n                    )\n            else:\n                raise\n    return patterns\n",
      "\ndef _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        try:\n            patterns.append(\n                re.compile(\n                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                    + \"|\"\n                    + pathlib.PureWindowsPath(pattern).as_posix()\n                )\n            )\n        except re.error as e:\n            if \"bad escape \\\\p\" in str(e):\n                # Strip Unicode property escapes and try again\n                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n                try:\n                    patterns.append(\n                        re.compile(\n                            str(pathlib.PureWindowsPath(cleaned_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                            + \"|\"\n                            + pathlib.PureWindowsPath(cleaned_pattern).as_posix()\n                        )\n                    )\n                    print(f\"Warning: Unicode property escapes are not supported in Python regex. \"\n                          f\"Stripped from pattern: {pattern}\", file=sys.stderr)\n                except re.error:\n                    raise argparse.ArgumentTypeError(f\"Invalid regex pattern: {pattern}\")\n            else:\n                raise argparse.ArgumentTypeError(f\"Invalid regex pattern: {pattern}\")\n    return patterns\n",
      "\ndef _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        try:\n            patterns.append(\n                re.compile(\n                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                    + \"|\"\n                    + pathlib.PureWindowsPath(pattern).as_posix()\n                )\n            )\n        except re.error as e:\n            if \"bad escape \\\\p\" in str(e):\n                # Strip Unicode property escapes and try again\n                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n                if cleaned_pattern.strip():\n                    print(f\"Warning: Unicode property escapes are not supported in Python regex. \"\n                          f\"Removed \\\\p{{}} escapes from pattern: {pattern}\", file=sys.stderr)\n                    patterns.append(\n                        re.compile(\n                            str(pathlib.PureWindowsPath(cleaned_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                            + \"|\"\n                            + pathlib.PureWindowsPath(cleaned_pattern).as_posix()\n                        )\n                    )\n                else:\n                    print(f\"Warning: Pattern '{pattern}' became empty after removing unsupported \"\n                          f\"Unicode property escapes. Skipping.\", file=sys.stderr)\n            else:\n                raise\n    return patterns\n",
      "\ndef _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        try:\n            patterns.append(\n                re.compile(\n                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                    + \"|\"\n                    + pathlib.PureWindowsPath(pattern).as_posix()\n                )\n            )\n        except re.error as e:\n            if \"bad escape \\\\p\" in str(e):\n                # Remove Unicode property escapes like \\p{Han} which are not supported by Python's re module\n                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n                if cleaned_pattern:\n                    patterns.append(\n                        re.compile(\n                            str(pathlib.PureWindowsPath(cleaned_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                            + \"|\"\n                            + pathlib.PureWindowsPath(cleaned_pattern).as_posix()\n                        )\n                    )\n            else:\n                raise\n    return patterns\n",
      "\ndef _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        try:\n            patterns.append(\n                re.compile(\n                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                    + \"|\"\n                    + pathlib.PureWindowsPath(pattern).as_posix()\n                )\n            )\n        except re.error as e:\n            if \"bad escape \\\\p\" in str(e):\n                # Strip Unicode property escapes and try again\n                cleaned_pattern = re.sub(r'\\\\p\\{[^}]*\\}', '', pattern)\n                patterns.append(\n                    re.compile(\n                        str(pathlib.PureWindowsPath(cleaned_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                        + \"|\"\n                        + pathlib.PureWindowsPath(cleaned_pattern).as_posix()\n                    )\n                )\n            else:\n                raise\n    return patterns\n",
      "\ndef _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n    patterns: list[Pattern[str]] = []\n    for pattern in _csv_transformer(value):\n        try:\n            patterns.append(\n                re.compile(\n                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                    + \"|\"\n                    + pathlib.PureWindowsPath(pattern).as_posix()\n                )\n            )\n        except re.error as e:\n            if \"bad escape \\\\p\" in str(e):\n                # Strip Unicode property escapes and warn\n                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n                print(f\"Warning: Unicode property escapes like \\\\p{{...}} are not supported in Python regex. \"\n                      f\"Stripped from pattern: {pattern}\", file=sys.stderr)\n                if cleaned_pattern.strip():\n                    patterns.append(\n                        re.compile(\n                            str(pathlib.PureWindowsPath(cleaned_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                            + \"|\"\n                            + pathlib.PureWindowsPath(cleaned_pattern).as_posix()\n                        )\n                    )\n            else:\n                raise\n    return patterns\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 3c2951517..62485ef58 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -102,8 +102,9 @@ def _py_version_transformer(value: str) -> tuple[int, ...]:\n def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n+\n     for pattern in _csv_transformer(value):\n-        patterns.append(re.compile(pattern))\n+        patterns.append(_safe_compile_regex(pattern))\n     return patterns\n \n \n@@ -111,8 +112,9 @@ def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n+\n         patterns.append(\n-            re.compile(\n+            _safe_compile_regex(\n                 str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n                 + \"|\"\n                 + pathlib.PureWindowsPath(pattern).as_posix()\n@@ -130,7 +132,8 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"non_empty_string\": _non_empty_string_transformer,\n     \"path\": _path_transformer,\n     \"py_version\": _py_version_transformer,\n-    \"regexp\": re.compile,\n+\n+    \"regexp\": _safe_compile_regex,\n     \"regexp_csv\": _regexp_csv_transfomer,\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\ndiff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..f3ad41f9f 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -20,10 +20,30 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n+def _safe_compile_regex(pattern: str) -> Pattern[str]:\n+    \"\"\"Safely compile a regex pattern, handling unsupported Unicode property escapes.\"\"\"\n+    try:\n+        return re.compile(pattern)\n+    except re.error as e:\n+        if \"bad escape \\\\p\" in str(e):\n+            warnings.warn(\n+                f\"Unicode property escapes like '\\\\p{{...}}' are not supported in Python's re module. \"\n+                f\"Pattern '{pattern}' contains unsupported escapes and will be ignored.\",\n+                UserWarning,\n+                stacklevel=3\n+            )\n+            # Return a pattern that matches nothing to avoid breaking the system\n+            return re.compile(\"(?!.*)\")\n+        else:\n+            # Re-raise other regex errors as they indicate genuine syntax issues\n+            raise\n+\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    return _safe_compile_regex(value)\n \n \n # pylint: disable=unused-argument\n@@ -103,7 +123,8 @@ VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+\n+    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n",
    "variant_0": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 3c2951517..e2483339a 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -99,11 +99,32 @@ def _py_version_transformer(value: str) -> tuple[int, ...]:\n     return version\n \n \n+def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+\n def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(re.compile(pattern))\n+        try:\n+            patterns.append(re.compile(pattern))\n+        except re.error as e:\n+            if \"bad escape \\\\p\" in str(e):\n+                # Strip Unicode property escapes and warn\n+                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n+                if cleaned_pattern.strip():\n+                    try:\n+                        patterns.append(re.compile(cleaned_pattern))\n+                        print(f\"Warning: Unicode property escapes like \\\\p{{}} are not supported in Python regex. \"\n+                              f\"Pattern '{pattern}' has been simplified to '{cleaned_pattern}'.\", file=sys.stderr)\n+                    except re.error:\n+                        raise argparse.ArgumentTypeError(f\"Invalid regex pattern: {pattern}\")\n+                else:\n+                    raise argparse.ArgumentTypeError(f\"Invalid regex pattern: {pattern}\")\n+            else:\n+                raise argparse.ArgumentTypeError(f\"Invalid regex pattern: {pattern}\")\n+    return patterns\n     return patterns\n \n \n@@ -111,13 +132,33 @@ def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(\n-            re.compile(\n-                str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n-                + \"|\"\n-                + pathlib.PureWindowsPath(pattern).as_posix()\n+\n+def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+    for pattern in _csv_transformer(value):\n+        try:\n+            patterns.append(\n+                re.compile(\n+                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                    + \"|\"\n+                    + pathlib.PureWindowsPath(pattern).as_posix()\n+                )\n             )\n-        )\n+        except re.error as exc:\n+            if \"bad escape \\\\p\" in str(exc):\n+                # Strip Unicode property escapes like \\p{Han} which aren't supported by Python's re module\n+                sanitized_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n+                patterns.append(\n+                    re.compile(\n+                        str(pathlib.PureWindowsPath(sanitized_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                        + \"|\"\n+                        + pathlib.PureWindowsPath(sanitized_pattern).as_posix()\n+                    )\n+                )\n+            else:\n+                raise exc\n+    return patterns\n     return patterns\n \n \n@@ -130,7 +171,8 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"non_empty_string\": _non_empty_string_transformer,\n     \"path\": _path_transformer,\n     \"py_version\": _py_version_transformer,\n-    \"regexp\": re.compile,\n+\n+    \"regexp\": _safe_compile_regex,\n     \"regexp_csv\": _regexp_csv_transfomer,\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\ndiff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..a619caf96 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -20,10 +20,33 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        return re.compile(value)\n+    except re.error as e:\n+        # Check if the error is due to unsupported Unicode property escapes\n+        if \"bad escape \\\\p\" in str(e) or \"bad escape \\\\P\" in str(e):\n+            # Strip Unicode property escapes and warn the user\n+            import warnings\n+            cleaned_pattern = re.sub(r'\\\\[pP]\\{[^}]*\\}', '', value)\n+            warnings.warn(\n+                f\"Unicode property escapes (\\\\p{{...}}) are not supported in Python regex. \"\n+                f\"Pattern '{value}' has been modified to '{cleaned_pattern}'. \"\n+                f\"Consider using standard Python regex character classes instead.\",\n+                UserWarning,\n+                stacklevel=2\n+            )\n+            try:\n+                return re.compile(cleaned_pattern)\n+            except re.error:\n+                # If still invalid after cleaning, raise original error\n+                raise e\n+        else:\n+            # Re-raise other regex errors as-is\n+            raise e\n \n \n # pylint: disable=unused-argument\n@@ -103,7 +126,8 @@ VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+\n+    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n",
    "variant_1": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 3c2951517..1d9cd34d3 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -99,11 +99,31 @@ def _py_version_transformer(value: str) -> tuple[int, ...]:\n     return version\n \n \n+def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+\n def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(re.compile(pattern))\n+        try:\n+            patterns.append(re.compile(pattern))\n+        except re.error as e:\n+            if \"bad escape \\\\p\" in str(e):\n+                # Remove Unicode property escapes like \\p{Han} which are not supported in Python's re module\n+                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n+                if cleaned_pattern.strip():\n+                    try:\n+                        patterns.append(re.compile(cleaned_pattern))\n+                        print(f\"Warning: Unicode property escapes removed from pattern '{pattern}'. Using '{cleaned_pattern}' instead.\", file=sys.stderr)\n+                    except re.error:\n+                        raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern}': {e}\")\n+                else:\n+                    print(f\"Warning: Pattern '{pattern}' contained only Unicode property escapes and was skipped.\", file=sys.stderr)\n+            else:\n+                raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern}': {e}\")\n+    return patterns\n     return patterns\n \n \n@@ -111,13 +131,33 @@ def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(\n-            re.compile(\n-                str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n-                + \"|\"\n-                + pathlib.PureWindowsPath(pattern).as_posix()\n+\n+def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+    for pattern in _csv_transformer(value):\n+        try:\n+            patterns.append(\n+                re.compile(\n+                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                    + \"|\"\n+                    + pathlib.PureWindowsPath(pattern).as_posix()\n+                )\n             )\n-        )\n+        except re.error as e:\n+            if \"bad escape \\\\p\" in str(e):\n+                # Strip Unicode property escapes and retry\n+                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n+                patterns.append(\n+                    re.compile(\n+                        str(pathlib.PureWindowsPath(cleaned_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                        + \"|\"\n+                        + pathlib.PureWindowsPath(cleaned_pattern).as_posix()\n+                    )\n+                )\n+            else:\n+                raise\n+    return patterns\n     return patterns\n \n \n@@ -130,7 +170,8 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"non_empty_string\": _non_empty_string_transformer,\n     \"path\": _path_transformer,\n     \"py_version\": _py_version_transformer,\n-    \"regexp\": re.compile,\n+\n+    \"regexp\": _safe_compile_regex,\n     \"regexp_csv\": _regexp_csv_transfomer,\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\ndiff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..036ae7b62 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -20,10 +20,30 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        return re.compile(value)\n+    except re.error as e:\n+        if \"bad escape \\\\p\" in str(e):\n+            warnings.warn(\n+                f\"Unicode property escapes like \\\\p{{...}} are not supported in Python regex. \"\n+                f\"Pattern '{value}' contains unsupported escape sequences. \"\n+                f\"Consider using character classes or ranges instead.\",\n+                UserWarning,\n+                stacklevel=2\n+            )\n+            # Strip Unicode property escapes as a fallback\n+            cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', value)\n+            if cleaned_pattern:\n+                return re.compile(cleaned_pattern)\n+            else:\n+                # If pattern becomes empty after cleaning, return a pattern that matches nothing\n+                return re.compile(r'(?!)')\n+        else:\n+            raise\n \n \n # pylint: disable=unused-argument\n@@ -103,7 +123,8 @@ VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+\n+    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n",
    "variant_2": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 3c2951517..732563ee3 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -99,11 +99,26 @@ def _py_version_transformer(value: str) -> tuple[int, ...]:\n     return version\n \n \n+def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+\n def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(re.compile(pattern))\n+        try:\n+            patterns.append(re.compile(pattern))\n+        except re.error as e:\n+            if \"bad escape \\\\p\" in str(e):\n+                # Remove Unicode property escapes which are not supported by Python's re module\n+                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n+                if cleaned_pattern.strip():\n+                    patterns.append(re.compile(cleaned_pattern))\n+                # If pattern becomes empty after cleaning, skip it silently\n+            else:\n+                raise argparse.ArgumentTypeError(f\"Invalid regular expression '{pattern}': {e}\") from e\n+    return patterns\n     return patterns\n \n \n@@ -111,13 +126,33 @@ def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(\n-            re.compile(\n-                str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n-                + \"|\"\n-                + pathlib.PureWindowsPath(pattern).as_posix()\n+\n+def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+    for pattern in _csv_transformer(value):\n+        try:\n+            patterns.append(\n+                re.compile(\n+                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                    + \"|\"\n+                    + pathlib.PureWindowsPath(pattern).as_posix()\n+                )\n             )\n-        )\n+        except re.error as e:\n+            if \"bad escape \\\\p\" in str(e):\n+                # Strip Unicode property escapes like \\p{Han} which aren't supported by Python's re module\n+                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n+                patterns.append(\n+                    re.compile(\n+                        str(pathlib.PureWindowsPath(cleaned_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                        + \"|\"\n+                        + pathlib.PureWindowsPath(cleaned_pattern).as_posix()\n+                    )\n+                )\n+            else:\n+                raise\n+    return patterns\n     return patterns\n \n \n@@ -130,7 +165,8 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"non_empty_string\": _non_empty_string_transformer,\n     \"path\": _path_transformer,\n     \"py_version\": _py_version_transformer,\n-    \"regexp\": re.compile,\n+\n+\"regexp\": _safe_compile_regex,\n     \"regexp_csv\": _regexp_csv_transfomer,\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\ndiff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..f8148141e 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -20,10 +20,30 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        return re.compile(value)\n+    except re.error as e:\n+        if \"bad escape \\\\p\" in str(e):\n+            warnings.warn(\n+                f\"Unicode property escapes like \\\\p{{...}} are not supported in Python regex. \"\n+                f\"Pattern '{value}' contains unsupported escape sequences. \"\n+                f\"Consider using character classes or other Python regex features instead.\",\n+                UserWarning,\n+                stacklevel=2\n+            )\n+            # Strip Unicode property escapes and try again\n+            cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', value)\n+            if cleaned_pattern:\n+                return re.compile(cleaned_pattern)\n+            else:\n+                # If pattern becomes empty after cleaning, return a pattern that matches nothing\n+                return re.compile(r'(?!.*)')\n+        else:\n+            raise\n \n \n # pylint: disable=unused-argument\n@@ -103,7 +123,8 @@ VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+\n+    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n",
    "variant_3": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 3c2951517..99b83f9b0 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -99,11 +99,16 @@ def _py_version_transformer(value: str) -> tuple[int, ...]:\n     return version\n \n \n+def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+\n def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(re.compile(pattern))\n+        patterns.append(_safe_compile_regex(pattern))\n+    return patterns\n     return patterns\n \n \n@@ -111,13 +116,34 @@ def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(\n-            re.compile(\n-                str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n-                + \"|\"\n-                + pathlib.PureWindowsPath(pattern).as_posix()\n+\n+def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+    for pattern in _csv_transformer(value):\n+        try:\n+            patterns.append(\n+                re.compile(\n+                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                    + \"|\"\n+                    + pathlib.PureWindowsPath(pattern).as_posix()\n+                )\n             )\n-        )\n+        except re.error as e:\n+            if \"bad escape\" in str(e) and \"\\\\p\" in pattern:\n+                # Remove Unicode property escapes and try again\n+                sanitized_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n+                if sanitized_pattern:\n+                    patterns.append(\n+                        re.compile(\n+                            str(pathlib.PureWindowsPath(sanitized_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                            + \"|\"\n+                            + pathlib.PureWindowsPath(sanitized_pattern).as_posix()\n+                        )\n+                    )\n+            else:\n+                raise\n+    return patterns\n     return patterns\n \n \n@@ -130,7 +156,8 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"non_empty_string\": _non_empty_string_transformer,\n     \"path\": _path_transformer,\n     \"py_version\": _py_version_transformer,\n-    \"regexp\": re.compile,\n+\n+    \"regexp\": _safe_compile_regex,\n     \"regexp_csv\": _regexp_csv_transfomer,\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\ndiff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..ec09107f2 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -20,10 +20,29 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        return re.compile(value)\n+    except re.error as exc:\n+        if r'\\p{' in value:\n+            # Remove Unicode property escapes which are not supported by Python's re module\n+            cleaned_value = re.sub(r'\\\\p\\{[^}]+\\}', '', value)\n+            warnings.warn(\n+                f\"Unicode property escapes like \\\\p{{...}} are not supported by Python's re module. \"\n+                f\"Removed from pattern: {value} -> {cleaned_value}\",\n+                UserWarning,\n+                stacklevel=2\n+            )\n+            if cleaned_value.strip():\n+                return re.compile(cleaned_value)\n+            else:\n+                # If the pattern becomes empty after removing Unicode properties, use a pattern that matches nothing\n+                return re.compile(r'(?!)')\n+        else:\n+            raise exc\n \n \n # pylint: disable=unused-argument\n@@ -103,7 +122,8 @@ VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+\n+    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n",
    "variant_4": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 3c2951517..68f353f37 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -99,11 +99,32 @@ def _py_version_transformer(value: str) -> tuple[int, ...]:\n     return version\n \n \n+def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+\n def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(re.compile(pattern))\n+        try:\n+            patterns.append(re.compile(pattern))\n+        except re.error as e:\n+            if \"bad escape \\\\p\" in str(e):\n+                # Strip Unicode property escapes and try again\n+                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n+                if cleaned_pattern.strip():\n+                    try:\n+                        patterns.append(re.compile(cleaned_pattern))\n+                        continue\n+                    except re.error:\n+                        pass\n+                raise argparse.ArgumentTypeError(\n+                    f\"Invalid regex pattern '{pattern}': Unicode property escapes like \\\\p{{Han}} \"\n+                    f\"are not supported by Python's re module. Use character classes instead.\"\n+                ) from None\n+            raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern}': {e}\") from None\n+    return patterns\n     return patterns\n \n \n@@ -111,13 +132,38 @@ def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(\n-            re.compile(\n-                str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n-                + \"|\"\n-                + pathlib.PureWindowsPath(pattern).as_posix()\n+\n+def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+    for pattern in _csv_transformer(value):\n+        try:\n+            patterns.append(\n+                re.compile(\n+                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                    + \"|\"\n+                    + pathlib.PureWindowsPath(pattern).as_posix()\n+                )\n             )\n-        )\n+        except re.error as e:\n+            if \"bad escape \\\\p\" in str(e):\n+                # Strip Unicode property escapes and try again\n+                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n+                try:\n+                    patterns.append(\n+                        re.compile(\n+                            str(pathlib.PureWindowsPath(cleaned_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                            + \"|\"\n+                            + pathlib.PureWindowsPath(cleaned_pattern).as_posix()\n+                        )\n+                    )\n+                    print(f\"Warning: Unicode property escapes are not supported in Python regex. \"\n+                          f\"Stripped from pattern: {pattern}\", file=sys.stderr)\n+                except re.error:\n+                    raise argparse.ArgumentTypeError(f\"Invalid regex pattern: {pattern}\")\n+            else:\n+                raise argparse.ArgumentTypeError(f\"Invalid regex pattern: {pattern}\")\n+    return patterns\n     return patterns\n \n \n@@ -130,7 +176,8 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"non_empty_string\": _non_empty_string_transformer,\n     \"path\": _path_transformer,\n     \"py_version\": _py_version_transformer,\n-    \"regexp\": re.compile,\n+\n+    \"regexp\": _safe_compile_regex,\n     \"regexp_csv\": _regexp_csv_transfomer,\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\ndiff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..327c49754 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -20,10 +20,30 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        return re.compile(value)\n+    except re.error as e:\n+        if \"bad escape \\\\p\" in str(e):\n+            warnings.warn(\n+                f\"Unicode property escapes like \\\\p{{}} are not supported in Python regex. \"\n+                f\"Pattern '{value}' contains unsupported syntax. \"\n+                f\"Consider using character classes instead.\",\n+                UserWarning,\n+                stacklevel=2\n+            )\n+            # Strip Unicode property escapes and try again\n+            cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', value)\n+            if cleaned_pattern:\n+                return re.compile(cleaned_pattern)\n+            else:\n+                # If pattern becomes empty after cleaning, return a pattern that matches nothing\n+                return re.compile(r'(?!)')\n+        else:\n+            raise\n \n \n # pylint: disable=unused-argument\n@@ -103,7 +123,8 @@ VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+\n+    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n",
    "variant_5": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 3c2951517..cae7dfbcf 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -99,11 +99,24 @@ def _py_version_transformer(value: str) -> tuple[int, ...]:\n     return version\n \n \n+def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+\n def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(re.compile(pattern))\n+        try:\n+            patterns.append(re.compile(pattern))\n+        except re.error as e:\n+            if \"bad escape \\\\p\" in str(e):\n+                raise argparse.ArgumentTypeError(\n+                    f\"Invalid regex pattern '{pattern}': Unicode property escapes like \\\\p{{...}} \"\n+                    f\"are not supported by Python's re module. Use character classes like [\\\\u4e00-\\\\u9fff] instead.\"\n+                ) from None\n+            raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern}': {e}\") from None\n+    return patterns\n     return patterns\n \n \n@@ -111,13 +124,39 @@ def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(\n-            re.compile(\n-                str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n-                + \"|\"\n-                + pathlib.PureWindowsPath(pattern).as_posix()\n+\n+def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+    for pattern in _csv_transformer(value):\n+        try:\n+            patterns.append(\n+                re.compile(\n+                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                    + \"|\"\n+                    + pathlib.PureWindowsPath(pattern).as_posix()\n+                )\n             )\n-        )\n+        except re.error as e:\n+            if \"bad escape \\\\p\" in str(e):\n+                # Strip Unicode property escapes and try again\n+                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n+                if cleaned_pattern.strip():\n+                    print(f\"Warning: Unicode property escapes are not supported in Python regex. \"\n+                          f\"Removed \\\\p{{}} escapes from pattern: {pattern}\", file=sys.stderr)\n+                    patterns.append(\n+                        re.compile(\n+                            str(pathlib.PureWindowsPath(cleaned_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                            + \"|\"\n+                            + pathlib.PureWindowsPath(cleaned_pattern).as_posix()\n+                        )\n+                    )\n+                else:\n+                    print(f\"Warning: Pattern '{pattern}' became empty after removing unsupported \"\n+                          f\"Unicode property escapes. Skipping.\", file=sys.stderr)\n+            else:\n+                raise\n+    return patterns\n     return patterns\n \n \n@@ -130,7 +169,8 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"non_empty_string\": _non_empty_string_transformer,\n     \"path\": _path_transformer,\n     \"py_version\": _py_version_transformer,\n-    \"regexp\": re.compile,\n+\n+    \"regexp\": _safe_compile_regex,\n     \"regexp_csv\": _regexp_csv_transfomer,\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\ndiff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..e407ab5ae 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -20,10 +20,29 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        return re.compile(value)\n+    except re.error as e:\n+        if \"bad escape \\\\p\" in str(e):\n+            warnings.warn(\n+                f\"Unicode property escapes like '\\\\p{{...}}' are not supported in Python regex. \"\n+                f\"Pattern '{value}' may not work as expected.\",\n+                UserWarning,\n+                stacklevel=2\n+            )\n+            # Strip Unicode property escapes and try again\n+            cleaned_value = re.sub(r'\\\\p\\{[^}]+\\}', '', value)\n+            if cleaned_value:\n+                return re.compile(cleaned_value)\n+            else:\n+                # If pattern becomes empty after cleaning, return a pattern that matches nothing\n+                return re.compile(r'(?!)')\n+        else:\n+            raise\n \n \n # pylint: disable=unused-argument\n@@ -103,7 +122,8 @@ VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+\n+    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n",
    "variant_6": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 3c2951517..34f3e19c8 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -99,11 +99,31 @@ def _py_version_transformer(value: str) -> tuple[int, ...]:\n     return version\n \n \n+def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+\n def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(re.compile(pattern))\n+        try:\n+            patterns.append(re.compile(pattern))\n+        except re.error as e:\n+            if \"bad escape \\\\p\" in str(e):\n+                # Strip Unicode property escapes like \\p{Han} which are not supported by Python's re module\n+                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n+                if cleaned_pattern.strip():\n+                    try:\n+                        patterns.append(re.compile(cleaned_pattern))\n+                        print(f\"Warning: Unicode property escapes in regex '{pattern}' are not supported. Using '{cleaned_pattern}' instead.\", file=sys.stderr)\n+                    except re.error:\n+                        raise argparse.ArgumentTypeError(f\"Invalid regex pattern: {pattern}\")\n+                else:\n+                    print(f\"Warning: Regex pattern '{pattern}' contains only unsupported Unicode property escapes and will be ignored.\", file=sys.stderr)\n+            else:\n+                raise argparse.ArgumentTypeError(f\"Invalid regex pattern: {pattern}\")\n+    return patterns\n     return patterns\n \n \n@@ -111,13 +131,34 @@ def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(\n-            re.compile(\n-                str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n-                + \"|\"\n-                + pathlib.PureWindowsPath(pattern).as_posix()\n+\n+def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+    for pattern in _csv_transformer(value):\n+        try:\n+            patterns.append(\n+                re.compile(\n+                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                    + \"|\"\n+                    + pathlib.PureWindowsPath(pattern).as_posix()\n+                )\n             )\n-        )\n+        except re.error as e:\n+            if \"bad escape \\\\p\" in str(e):\n+                # Remove Unicode property escapes like \\p{Han} which are not supported by Python's re module\n+                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n+                if cleaned_pattern:\n+                    patterns.append(\n+                        re.compile(\n+                            str(pathlib.PureWindowsPath(cleaned_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                            + \"|\"\n+                            + pathlib.PureWindowsPath(cleaned_pattern).as_posix()\n+                        )\n+                    )\n+            else:\n+                raise\n+    return patterns\n     return patterns\n \n \n@@ -130,7 +171,8 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"non_empty_string\": _non_empty_string_transformer,\n     \"path\": _path_transformer,\n     \"py_version\": _py_version_transformer,\n-    \"regexp\": re.compile,\n+\n+\"regexp\": _safe_compile_regex,\n     \"regexp_csv\": _regexp_csv_transfomer,\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\ndiff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..6a1484ed0 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -20,10 +20,31 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        return re.compile(value)\n+    except re.error as exc:\n+        if \"bad escape \\\\p\" in str(exc):\n+            # Unicode property escapes like \\p{Han} are not supported in Python's re module\n+            # Strip them out and issue a warning\n+            import re as re_module\n+            cleaned_value = re_module.sub(r'\\\\p\\{[^}]+\\}', '', value)\n+            warnings.warn(\n+                f\"Unicode property escapes (\\\\p{{...}}) in regex '{value}' are not supported \"\n+                f\"by Python's re module. Stripped to: '{cleaned_value}'\",\n+                UserWarning,\n+                stacklevel=2\n+            )\n+            try:\n+                return re.compile(cleaned_value)\n+            except re.error:\n+                # If still invalid after stripping, raise original error\n+                raise exc from None\n+        else:\n+            raise\n \n \n # pylint: disable=unused-argument\n@@ -103,7 +124,8 @@ VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+\n+    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n",
    "variant_7": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 3c2951517..42335609b 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -99,11 +99,33 @@ def _py_version_transformer(value: str) -> tuple[int, ...]:\n     return version\n \n \n+def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+\n def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(re.compile(pattern))\n+        try:\n+            patterns.append(re.compile(pattern))\n+        except re.error as e:\n+            if \"bad escape \\\\p\" in str(e).lower():\n+                # Strip Unicode property escapes like \\p{Han} which are not supported by Python's re module\n+                sanitized_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n+                if sanitized_pattern.strip():\n+                    try:\n+                        patterns.append(re.compile(sanitized_pattern))\n+                        continue\n+                    except re.error:\n+                        pass\n+                raise argparse.ArgumentTypeError(\n+                    f\"Invalid regular expression '{pattern}': Unicode property escapes like \\\\p{{...}} \"\n+                    f\"are not supported by Python's re module. Please use standard Python regex syntax.\"\n+                ) from e\n+            else:\n+                raise argparse.ArgumentTypeError(f\"Invalid regular expression '{pattern}': {e}\") from e\n+    return patterns\n     return patterns\n \n \n@@ -111,13 +133,33 @@ def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(\n-            re.compile(\n-                str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n-                + \"|\"\n-                + pathlib.PureWindowsPath(pattern).as_posix()\n+\n+def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+    for pattern in _csv_transformer(value):\n+        try:\n+            patterns.append(\n+                re.compile(\n+                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                    + \"|\"\n+                    + pathlib.PureWindowsPath(pattern).as_posix()\n+                )\n             )\n-        )\n+        except re.error as e:\n+            if \"bad escape \\\\p\" in str(e):\n+                # Strip Unicode property escapes and try again\n+                cleaned_pattern = re.sub(r'\\\\p\\{[^}]*\\}', '', pattern)\n+                patterns.append(\n+                    re.compile(\n+                        str(pathlib.PureWindowsPath(cleaned_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                        + \"|\"\n+                        + pathlib.PureWindowsPath(cleaned_pattern).as_posix()\n+                    )\n+                )\n+            else:\n+                raise\n+    return patterns\n     return patterns\n \n \n@@ -130,7 +172,8 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"non_empty_string\": _non_empty_string_transformer,\n     \"path\": _path_transformer,\n     \"py_version\": _py_version_transformer,\n-    \"regexp\": re.compile,\n+\n+\"regexp\": _safe_compile_regex,\n     \"regexp_csv\": _regexp_csv_transfomer,\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\ndiff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..67db87ac5 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -20,10 +20,30 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        return re.compile(value)\n+    except re.error as e:\n+        if \"bad escape \\\\p\" in str(e):\n+            # Strip Unicode property escapes like \\p{Han} which aren't supported by Python's re module\n+            import warnings\n+            cleaned_value = re.sub(r'\\\\p\\{[^}]+\\}', '', value)\n+            warnings.warn(\n+                f\"Unicode property escapes (\\\\p{{...}}) are not supported in Python regex. \"\n+                f\"Stripped from pattern: {value!r} -> {cleaned_value!r}\",\n+                UserWarning,\n+                stacklevel=2\n+            )\n+            if cleaned_value:\n+                return re.compile(cleaned_value)\n+            else:\n+                # If the pattern becomes empty after stripping, use a pattern that matches nothing\n+                return re.compile(r'(?!)')\n+        else:\n+            raise\n \n \n # pylint: disable=unused-argument\n@@ -103,7 +123,8 @@ VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+\n+    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n",
    "variant_8": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 3c2951517..acf3600d1 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -99,11 +99,33 @@ def _py_version_transformer(value: str) -> tuple[int, ...]:\n     return version\n \n \n+def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+\n def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(re.compile(pattern))\n+        try:\n+            patterns.append(re.compile(pattern))\n+        except re.error as e:\n+            if \"bad escape \\\\p\" in str(e):\n+                # Strip Unicode property escapes and try again\n+                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n+                if cleaned_pattern.strip():\n+                    try:\n+                        patterns.append(re.compile(cleaned_pattern))\n+                        continue\n+                    except re.error:\n+                        pass\n+                raise argparse.ArgumentTypeError(\n+                    f\"Invalid regex pattern '{pattern}': Unicode property escapes like \\\\p{{Han}} \"\n+                    f\"are not supported in Python's re module. Please use character classes instead.\"\n+                ) from e\n+            else:\n+                raise argparse.ArgumentTypeError(f\"Invalid regex pattern '{pattern}': {e}\") from e\n+    return patterns\n     return patterns\n \n \n@@ -111,13 +133,36 @@ def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n     patterns: list[Pattern[str]] = []\n     for pattern in _csv_transformer(value):\n-        patterns.append(\n-            re.compile(\n-                str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n-                + \"|\"\n-                + pathlib.PureWindowsPath(pattern).as_posix()\n+\n+def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n+    \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n+    patterns: list[Pattern[str]] = []\n+    for pattern in _csv_transformer(value):\n+        try:\n+            patterns.append(\n+                re.compile(\n+                    str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                    + \"|\"\n+                    + pathlib.PureWindowsPath(pattern).as_posix()\n+                )\n             )\n-        )\n+        except re.error as e:\n+            if \"bad escape \\\\p\" in str(e):\n+                # Strip Unicode property escapes and warn\n+                cleaned_pattern = re.sub(r'\\\\p\\{[^}]+\\}', '', pattern)\n+                print(f\"Warning: Unicode property escapes like \\\\p{{...}} are not supported in Python regex. \"\n+                      f\"Stripped from pattern: {pattern}\", file=sys.stderr)\n+                if cleaned_pattern.strip():\n+                    patterns.append(\n+                        re.compile(\n+                            str(pathlib.PureWindowsPath(cleaned_pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n+                            + \"|\"\n+                            + pathlib.PureWindowsPath(cleaned_pattern).as_posix()\n+                        )\n+                    )\n+            else:\n+                raise\n+    return patterns\n     return patterns\n \n \n@@ -130,7 +175,8 @@ _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n     \"non_empty_string\": _non_empty_string_transformer,\n     \"path\": _path_transformer,\n     \"py_version\": _py_version_transformer,\n-    \"regexp\": re.compile,\n+\n+    \"regexp\": lambda value: _safe_compile_regex(value),\n     \"regexp_csv\": _regexp_csv_transfomer,\n     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n     \"string\": pylint_utils._unquote,\ndiff --git a/pylint/config/option.py b/pylint/config/option.py\nindex 5043fe765..c340c671a 100644\n--- a/pylint/config/option.py\n+++ b/pylint/config/option.py\n@@ -20,10 +20,32 @@ def _csv_validator(_, name, value):\n \n \n # pylint: disable=unused-argument\n+\n def _regexp_validator(_, name, value):\n     if hasattr(value, \"pattern\"):\n         return value\n-    return re.compile(value)\n+    try:\n+        return re.compile(value)\n+    except re.error as e:\n+        # Check if the error is due to Unicode property escapes\n+        if \"bad escape \\\\p\" in str(e) or \"bad character range \\\\p\" in str(e):\n+            # Strip Unicode property escapes and warn the user\n+            import warnings\n+            cleaned_pattern = re.sub(r'\\\\p\\{[^}]*\\}', '', value)\n+            warnings.warn(\n+                f\"Unicode property escapes like '\\\\p{{...}}' are not supported in Python regex. \"\n+                f\"Pattern '{value}' has been simplified to '{cleaned_pattern}'. \"\n+                f\"Consider using character classes or ranges instead.\",\n+                UserWarning\n+            )\n+            try:\n+                return re.compile(cleaned_pattern)\n+            except re.error:\n+                # If still invalid after cleaning, fall back to original error\n+                raise e\n+        else:\n+            # Re-raise other regex errors as-is\n+            raise e\n \n \n # pylint: disable=unused-argument\n@@ -103,7 +125,8 @@ VALIDATORS = {\n     \"string\": utils._unquote,\n     \"int\": int,\n     \"float\": float,\n-    \"regexp\": lambda pattern: re.compile(pattern or \"\"),\n+\n+    \"regexp\": lambda pattern: _safe_compile_regex(pattern or \"\"),\n     \"regexp_csv\": _regexp_csv_validator,\n     \"regexp_paths_csv\": _regexp_paths_csv_validator,\n     \"csv\": _csv_validator,\n"
  }
}