{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 1252-1253)": "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
    "Location 2 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 1281-1286)": "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
    "Location 3 (/root/hy/projects_4/django/django/db/models/sql/query.py lines 775-790)": "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    select_mask[opts.pk] = {}\n    # Only include fields mentioned in the mask.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            self._get_only_select_mask(\n                related_model._meta, field_mask, field_select_mask\n            )\n    return select_mask\n",
    "Location 4 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 993-994)": "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
    "Location 5 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 1425-1426)": "\n        def _get_field_choices():\n            \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n            queue = collections.deque([(None, self.klass_info)])\n            while queue:\n                parent_path, klass_info = queue.popleft()\n                if parent_path is None:\n                    path = []\n                    yield \"self\"\n                else:\n                    field = klass_info[\"field\"]\n                    if klass_info[\"reverse\"]:\n                        field = field.remote_field\n                    path = parent_path + [field.name]\n                    yield LOOKUP_SEP.join(path)\n                queue.extend(\n                    (path, klass_info)\n                    for klass_info in _get_parent_klass_info(klass_info)\n                )\n                queue.extend(\n                    (path, klass_info)\n                    for klass_info in klass_info.get(\"related_klass_infos\", [])\n                )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 1252-1253)": [
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 1281-1286)": [
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n                klass_info = {\n                    \"model\": model,\n                    \"field\": related_field,\n                    \"reverse\": True,\n                    \"local_setter\": related_field.remote_field.set_cached_value,\n                    \"remote_setter\": related_field.set_cached_value,\n                    \"from_parent\": from_parent,\n                }\n                related_klass_infos.append(klass_info)\n                select_fields = []\n                columns = self.get_default_columns(\n                    related_select_mask,\n                    start_alias=alias,\n                    opts=model._meta,\n                    from_parent=opts.model,\n                )\n",
      "\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n                for related_field, model in related_fields:\n                    related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n"
    ],
    "Location 3 (/root/hy/projects_4/django/django/db/models/sql/query.py lines 775-790)": [
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    select_mask[opts.pk] = {}\n    # Only include fields mentioned in the mask.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            self._get_only_select_mask(\n                related_model._meta, field_mask, field_select_mask\n            )\n    return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    select_mask[opts.pk] = {}\n    # Only include fields mentioned in the mask.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            self._get_only_select_mask(\n                related_model._meta, field_mask, field_select_mask\n            )\n    return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        select_mask[opts.pk] = {}\n        # Only include fields mentioned in the mask.\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, field_select_mask\n                )\n        return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    select_mask[opts.pk] = {}\n    # Only include fields mentioned in the mask.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            self._get_only_select_mask(\n                related_model._meta, field_mask, field_select_mask\n            )\n    return select_mask\n",
      "\n    def _get_only_select_mask(self, opts, mask, select_mask=None):\n        if select_mask is None:\n            select_mask = {}\n        select_mask[opts.pk] = {}\n        # Only include fields mentioned in the mask.\n        for field_name, field_mask in mask.items():\n            field = opts.get_field(field_name)\n            field_select_mask = select_mask.setdefault(field, {})\n            if field_mask:\n                if not field.is_relation:\n                    raise FieldError(next(iter(field_mask)))\n                related_model = field.remote_field.model._meta.concrete_model\n                self._get_only_select_mask(\n                    related_model._meta, field_mask, field_select_mask\n                )\n        return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    select_mask[opts.pk] = {}\n    # Only include fields mentioned in the mask.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            self._get_only_select_mask(\n                related_model._meta, field_mask, field_select_mask\n            )\n    return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    select_mask[opts.pk] = {}\n    # Only include fields mentioned in the mask.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            self._get_only_select_mask(\n                related_model._meta, field_mask, field_select_mask\n            )\n    return select_mask\n",
      "\ndef _get_only_select_mask(self, opts, mask, select_mask=None):\n    if select_mask is None:\n        select_mask = {}\n    select_mask[opts.pk] = {}\n    # Only include fields mentioned in the mask.\n    for field_name, field_mask in mask.items():\n        field = opts.get_field(field_name)\n        field_select_mask = select_mask.setdefault(field, {})\n        if field_mask:\n            if not field.is_relation:\n                raise FieldError(next(iter(field_mask)))\n            related_model = field.remote_field.model._meta.concrete_model\n            self._get_only_select_mask(\n                related_model._meta, field_mask, field_select_mask\n            )\n    return select_mask\n"
    ],
    "Location 4 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 993-994)": [
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n",
      "\n            related_select_mask = select_mask.get(related_field.remote_field) or {}\n            columns = self.get_default_columns(\n",
      "\n            for related_field, model in related_fields:\n                related_select_mask = select_mask.get(related_field.remote_field) or {}\n"
    ],
    "Location 5 (/root/hy/projects_4/django/django/db/models/sql/compiler.py lines 1425-1426)": [
      "\n        def _get_field_choices():\n            \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n            queue = collections.deque([(None, self.klass_info)])\n            while queue:\n                parent_path, klass_info = queue.popleft()\n                if parent_path is None:\n                    path = []\n                    yield \"self\"\n                else:\n                    field = klass_info[\"field\"]\n                    if klass_info[\"reverse\"]:\n                        field = field.remote_field\n                    path = parent_path + [field.name]\n                    yield LOOKUP_SEP.join(path)\n                queue.extend(\n                    (path, klass_info)\n                    for klass_info in _get_parent_klass_info(klass_info)\n                )\n                queue.extend(\n                    (path, klass_info)\n                    for klass_info in klass_info.get(\"related_klass_infos\", [])\n                )\n",
      "\n        def _get_field_choices():\n            \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n            queue = collections.deque([(None, self.klass_info)])\n            while queue:\n                parent_path, klass_info = queue.popleft()\n                if parent_path is None:\n                    path = []\n                    yield \"self\"\n                else:\n                    field = klass_info[\"field\"]\n                    if klass_info[\"reverse\"]:\n                        field = field.remote_field\n                    path = parent_path + [field.name]\n                    yield LOOKUP_SEP.join(path)\n                queue.extend(\n                    (path, klass_info)\n                    for klass_info in _get_parent_klass_info(klass_info)\n                )\n                queue.extend(\n                    (path, klass_info)\n                    for klass_info in klass_info.get(\"related_klass_infos\", [])\n                )\n",
      "\n        def _get_field_choices():\n            \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n            queue = collections.deque([(None, self.klass_info)])\n            while queue:\n                parent_path, klass_info = queue.popleft()\n                if parent_path is None:\n                    path = []\n                    yield \"self\"\n                else:\n                    field = klass_info[\"field\"]\n                    if klass_info[\"reverse\"]:\n                        field = field.remote_field\n                    path = parent_path + [field.name]\n                    yield LOOKUP_SEP.join(path)\n                queue.extend(\n                    (path, klass_info)\n                    for klass_info in _get_parent_klass_info(klass_info)\n                )\n                queue.extend(\n                    (path, klass_info)\n                    for klass_info in klass_info.get(\"related_klass_infos\", [])\n                )\n",
      "\n        def _get_field_choices():\n            \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n            queue = collections.deque([(None, self.klass_info)])\n            while queue:\n                parent_path, klass_info = queue.popleft()\n                if parent_path is None:\n                    path = []\n                    yield \"self\"\n                else:\n                    field = klass_info[\"field\"]\n                    if klass_info[\"reverse\"]:\n                        field = field.remote_field\n                    path = parent_path + [field.name]\n                    yield LOOKUP_SEP.join(path)\n                queue.extend(\n                    (path, klass_info)\n                    for klass_info in _get_parent_klass_info(klass_info)\n                )\n                queue.extend(\n                    (path, klass_info)\n                    for klass_info in klass_info.get(\"related_klass_infos\", [])\n                )\n",
      "\n                    field = klass_info[\"field\"]\n                    if klass_info[\"reverse\"]:\n                        field = field.remote_field\n",
      "\n        def _get_field_choices():\n            \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n            queue = collections.deque([(None, self.klass_info)])\n            while queue:\n                parent_path, klass_info = queue.popleft()\n                if parent_path is None:\n                    path = []\n                    yield \"self\"\n                else:\n                    field = klass_info[\"field\"]\n                    if klass_info[\"reverse\"]:\n                        field = field.remote_field\n                    path = parent_path + [field.name]\n                    yield LOOKUP_SEP.join(path)\n                queue.extend(\n                    (path, klass_info)\n                    for klass_info in _get_parent_klass_info(klass_info)\n                )\n                queue.extend(\n                    (path, klass_info)\n                    for klass_info in klass_info.get(\"related_klass_infos\", [])\n                )\n",
      "\n        def _get_field_choices():\n            \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n            queue = collections.deque([(None, self.klass_info)])\n            while queue:\n                parent_path, klass_info = queue.popleft()\n                if parent_path is None:\n                    path = []\n                    yield \"self\"\n                else:\n                    field = klass_info[\"field\"]\n                    if klass_info[\"reverse\"]:\n                        field = field.remote_field\n                    path = parent_path + [field.name]\n                    yield LOOKUP_SEP.join(path)\n                queue.extend(\n                    (path, klass_info)\n                    for klass_info in _get_parent_klass_info(klass_info)\n                )\n                queue.extend(\n                    (path, klass_info)\n                    for klass_info in klass_info.get(\"related_klass_infos\", [])\n                )\n",
      "\n        def _get_field_choices():\n            \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n            queue = collections.deque([(None, self.klass_info)])\n            while queue:\n                parent_path, klass_info = queue.popleft()\n                if parent_path is None:\n                    path = []\n                    yield \"self\"\n                else:\n                    field = klass_info[\"field\"]\n                    if klass_info[\"reverse\"]:\n                        field = field.remote_field\n                    path = parent_path + [field.name]\n                    yield LOOKUP_SEP.join(path)\n                queue.extend(\n                    (path, klass_info)\n                    for klass_info in _get_parent_klass_info(klass_info)\n                )\n                queue.extend(\n                    (path, klass_info)\n                    for klass_info in klass_info.get(\"related_klass_infos\", [])\n                )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..6a06549c0d 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,6 +990,7 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n+\n             if select_mask and field not in select_mask:\n                 continue\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n@@ -1249,8 +1250,9 @@ class SQLCompiler:\n                 for o in opts.related_objects\n                 if o.field.unique and not o.many_to_many\n             ]\n+\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,6 +1280,7 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n+\n                 columns = self.get_default_columns(\n                     related_select_mask,\n                     start_alias=alias,\n@@ -1422,6 +1425,7 @@ class SQLCompiler:\n                     yield \"self\"\n                 else:\n                     field = klass_info[\"field\"]\n+\n                     if klass_info[\"reverse\"]:\n                         field = field.remote_field\n                     path = parent_path + [field.name]\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..58a2f1a992 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,6 +772,7 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n",
    "variant_0": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..c1d3229fa3 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,9 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+            for related_field, model in related_fields:\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1249,8 +1250,9 @@ class SQLCompiler:\n                 for o in opts.related_objects\n                 if o.field.unique and not o.many_to_many\n             ]\n+\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,12 +1280,9 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n-                columns = self.get_default_columns(\n-                    related_select_mask,\n-                    start_alias=alias,\n-                    opts=model._meta,\n-                    from_parent=opts.model,\n-                )\n+\n+            for related_field, model in related_fields:\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 for col in columns:\n                     select_fields.append(len(select))\n                     select.append((col, None))\n@@ -1412,6 +1411,17 @@ class SQLCompiler:\n                 if self.select[select_index][0].target.model == concrete_model:\n                     return self.select[select_index][0]\n \n+        def _get_field_choices():\n+            \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n+            queue = collections.deque([(None, self.klass_info)])\n+            while queue:\n+                parent_path, klass_info = queue.popleft()\n+                if parent_path is None:\n+                    path = []\n+                    yield \"self\"\n+                else:\n+                    field = klass_info[\"field\"]\n+\n         def _get_field_choices():\n             \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n             queue = collections.deque([(None, self.klass_info)])\n@@ -1434,6 +1444,16 @@ class SQLCompiler:\n                     (path, klass_info)\n                     for klass_info in klass_info.get(\"related_klass_infos\", [])\n                 )\n+                    path = parent_path + [field.name]\n+                    yield LOOKUP_SEP.join(path)\n+                queue.extend(\n+                    (path, klass_info)\n+                    for klass_info in _get_parent_klass_info(klass_info)\n+                )\n+                queue.extend(\n+                    (path, klass_info)\n+                    for klass_info in klass_info.get(\"related_klass_infos\", [])\n+                )\n \n         if not self.klass_info:\n             return []\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..2b3321bb5d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,22 +772,23 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n-    def _get_only_select_mask(self, opts, mask, select_mask=None):\n-        if select_mask is None:\n-            select_mask = {}\n-        select_mask[opts.pk] = {}\n-        # Only include fields mentioned in the mask.\n-        for field_name, field_mask in mask.items():\n-            field = opts.get_field(field_name)\n-            field_select_mask = select_mask.setdefault(field, {})\n-            if field_mask:\n-                if not field.is_relation:\n-                    raise FieldError(next(iter(field_mask)))\n-                related_model = field.remote_field.model._meta.concrete_model\n-                self._get_only_select_mask(\n-                    related_model._meta, field_mask, field_select_mask\n-                )\n-        return select_mask\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    select_mask[opts.pk] = {}\n+    # Only include fields mentioned in the mask.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, field_select_mask\n+            )\n+    return select_mask\n \n     def get_select_mask(self):\n         \"\"\"\n",
    "variant_1": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..c1d3229fa3 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,9 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+            for related_field, model in related_fields:\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1249,8 +1250,9 @@ class SQLCompiler:\n                 for o in opts.related_objects\n                 if o.field.unique and not o.many_to_many\n             ]\n+\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,12 +1280,9 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n-                columns = self.get_default_columns(\n-                    related_select_mask,\n-                    start_alias=alias,\n-                    opts=model._meta,\n-                    from_parent=opts.model,\n-                )\n+\n+            for related_field, model in related_fields:\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 for col in columns:\n                     select_fields.append(len(select))\n                     select.append((col, None))\n@@ -1412,6 +1411,17 @@ class SQLCompiler:\n                 if self.select[select_index][0].target.model == concrete_model:\n                     return self.select[select_index][0]\n \n+        def _get_field_choices():\n+            \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n+            queue = collections.deque([(None, self.klass_info)])\n+            while queue:\n+                parent_path, klass_info = queue.popleft()\n+                if parent_path is None:\n+                    path = []\n+                    yield \"self\"\n+                else:\n+                    field = klass_info[\"field\"]\n+\n         def _get_field_choices():\n             \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n             queue = collections.deque([(None, self.klass_info)])\n@@ -1434,6 +1444,16 @@ class SQLCompiler:\n                     (path, klass_info)\n                     for klass_info in klass_info.get(\"related_klass_infos\", [])\n                 )\n+                    path = parent_path + [field.name]\n+                    yield LOOKUP_SEP.join(path)\n+                queue.extend(\n+                    (path, klass_info)\n+                    for klass_info in _get_parent_klass_info(klass_info)\n+                )\n+                queue.extend(\n+                    (path, klass_info)\n+                    for klass_info in klass_info.get(\"related_klass_infos\", [])\n+                )\n \n         if not self.klass_info:\n             return []\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..2b3321bb5d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,22 +772,23 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n-    def _get_only_select_mask(self, opts, mask, select_mask=None):\n-        if select_mask is None:\n-            select_mask = {}\n-        select_mask[opts.pk] = {}\n-        # Only include fields mentioned in the mask.\n-        for field_name, field_mask in mask.items():\n-            field = opts.get_field(field_name)\n-            field_select_mask = select_mask.setdefault(field, {})\n-            if field_mask:\n-                if not field.is_relation:\n-                    raise FieldError(next(iter(field_mask)))\n-                related_model = field.remote_field.model._meta.concrete_model\n-                self._get_only_select_mask(\n-                    related_model._meta, field_mask, field_select_mask\n-                )\n-        return select_mask\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    select_mask[opts.pk] = {}\n+    # Only include fields mentioned in the mask.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, field_select_mask\n+            )\n+    return select_mask\n \n     def get_select_mask(self):\n         \"\"\"\n",
    "variant_2": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..b4ac5b88e2 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,9 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+            for related_field, model in related_fields:\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1249,8 +1250,9 @@ class SQLCompiler:\n                 for o in opts.related_objects\n                 if o.field.unique and not o.many_to_many\n             ]\n+\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1268,6 +1270,17 @@ class SQLCompiler:\n                 )\n                 alias = join_info.joins[-1]\n                 from_parent = issubclass(model, opts.model) and model is not opts.model\n+                klass_info = {\n+                    \"model\": model,\n+                    \"field\": related_field,\n+                    \"reverse\": True,\n+                    \"local_setter\": related_field.remote_field.set_cached_value,\n+                    \"remote_setter\": related_field.set_cached_value,\n+                    \"from_parent\": from_parent,\n+                }\n+                related_klass_infos.append(klass_info)\n+                select_fields = []\n+\n                 klass_info = {\n                     \"model\": model,\n                     \"field\": related_field,\n@@ -1412,6 +1425,17 @@ class SQLCompiler:\n                 if self.select[select_index][0].target.model == concrete_model:\n                     return self.select[select_index][0]\n \n+        def _get_field_choices():\n+            \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n+            queue = collections.deque([(None, self.klass_info)])\n+            while queue:\n+                parent_path, klass_info = queue.popleft()\n+                if parent_path is None:\n+                    path = []\n+                    yield \"self\"\n+                else:\n+                    field = klass_info[\"field\"]\n+\n         def _get_field_choices():\n             \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n             queue = collections.deque([(None, self.klass_info)])\n@@ -1434,6 +1458,16 @@ class SQLCompiler:\n                     (path, klass_info)\n                     for klass_info in klass_info.get(\"related_klass_infos\", [])\n                 )\n+                    path = parent_path + [field.name]\n+                    yield LOOKUP_SEP.join(path)\n+                queue.extend(\n+                    (path, klass_info)\n+                    for klass_info in _get_parent_klass_info(klass_info)\n+                )\n+                queue.extend(\n+                    (path, klass_info)\n+                    for klass_info in klass_info.get(\"related_klass_infos\", [])\n+                )\n \n         if not self.klass_info:\n             return []\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..2b3321bb5d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,22 +772,23 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n-    def _get_only_select_mask(self, opts, mask, select_mask=None):\n-        if select_mask is None:\n-            select_mask = {}\n-        select_mask[opts.pk] = {}\n-        # Only include fields mentioned in the mask.\n-        for field_name, field_mask in mask.items():\n-            field = opts.get_field(field_name)\n-            field_select_mask = select_mask.setdefault(field, {})\n-            if field_mask:\n-                if not field.is_relation:\n-                    raise FieldError(next(iter(field_mask)))\n-                related_model = field.remote_field.model._meta.concrete_model\n-                self._get_only_select_mask(\n-                    related_model._meta, field_mask, field_select_mask\n-                )\n-        return select_mask\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    select_mask[opts.pk] = {}\n+    # Only include fields mentioned in the mask.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, field_select_mask\n+            )\n+    return select_mask\n \n     def get_select_mask(self):\n         \"\"\"\n",
    "variant_3": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..70fd73747f 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,9 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+            for related_field, model in related_fields:\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1249,8 +1250,9 @@ class SQLCompiler:\n                 for o in opts.related_objects\n                 if o.field.unique and not o.many_to_many\n             ]\n+\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,12 +1280,8 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n-                columns = self.get_default_columns(\n-                    related_select_mask,\n-                    start_alias=alias,\n-                    opts=model._meta,\n-                    from_parent=opts.model,\n-                )\n+\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 for col in columns:\n                     select_fields.append(len(select))\n                     select.append((col, None))\n@@ -1412,6 +1410,17 @@ class SQLCompiler:\n                 if self.select[select_index][0].target.model == concrete_model:\n                     return self.select[select_index][0]\n \n+        def _get_field_choices():\n+            \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n+            queue = collections.deque([(None, self.klass_info)])\n+            while queue:\n+                parent_path, klass_info = queue.popleft()\n+                if parent_path is None:\n+                    path = []\n+                    yield \"self\"\n+                else:\n+                    field = klass_info[\"field\"]\n+\n         def _get_field_choices():\n             \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n             queue = collections.deque([(None, self.klass_info)])\n@@ -1434,6 +1443,16 @@ class SQLCompiler:\n                     (path, klass_info)\n                     for klass_info in klass_info.get(\"related_klass_infos\", [])\n                 )\n+                    path = parent_path + [field.name]\n+                    yield LOOKUP_SEP.join(path)\n+                queue.extend(\n+                    (path, klass_info)\n+                    for klass_info in _get_parent_klass_info(klass_info)\n+                )\n+                queue.extend(\n+                    (path, klass_info)\n+                    for klass_info in klass_info.get(\"related_klass_infos\", [])\n+                )\n \n         if not self.klass_info:\n             return []\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..58a2f1a992 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,6 +772,7 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n",
    "variant_4": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..c1d3229fa3 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,9 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+            for related_field, model in related_fields:\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1249,8 +1250,9 @@ class SQLCompiler:\n                 for o in opts.related_objects\n                 if o.field.unique and not o.many_to_many\n             ]\n+\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,12 +1280,9 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n-                columns = self.get_default_columns(\n-                    related_select_mask,\n-                    start_alias=alias,\n-                    opts=model._meta,\n-                    from_parent=opts.model,\n-                )\n+\n+            for related_field, model in related_fields:\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 for col in columns:\n                     select_fields.append(len(select))\n                     select.append((col, None))\n@@ -1412,6 +1411,17 @@ class SQLCompiler:\n                 if self.select[select_index][0].target.model == concrete_model:\n                     return self.select[select_index][0]\n \n+        def _get_field_choices():\n+            \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n+            queue = collections.deque([(None, self.klass_info)])\n+            while queue:\n+                parent_path, klass_info = queue.popleft()\n+                if parent_path is None:\n+                    path = []\n+                    yield \"self\"\n+                else:\n+                    field = klass_info[\"field\"]\n+\n         def _get_field_choices():\n             \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n             queue = collections.deque([(None, self.klass_info)])\n@@ -1434,6 +1444,16 @@ class SQLCompiler:\n                     (path, klass_info)\n                     for klass_info in klass_info.get(\"related_klass_infos\", [])\n                 )\n+                    path = parent_path + [field.name]\n+                    yield LOOKUP_SEP.join(path)\n+                queue.extend(\n+                    (path, klass_info)\n+                    for klass_info in _get_parent_klass_info(klass_info)\n+                )\n+                queue.extend(\n+                    (path, klass_info)\n+                    for klass_info in klass_info.get(\"related_klass_infos\", [])\n+                )\n \n         if not self.klass_info:\n             return []\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..2b3321bb5d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,22 +772,23 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n-    def _get_only_select_mask(self, opts, mask, select_mask=None):\n-        if select_mask is None:\n-            select_mask = {}\n-        select_mask[opts.pk] = {}\n-        # Only include fields mentioned in the mask.\n-        for field_name, field_mask in mask.items():\n-            field = opts.get_field(field_name)\n-            field_select_mask = select_mask.setdefault(field, {})\n-            if field_mask:\n-                if not field.is_relation:\n-                    raise FieldError(next(iter(field_mask)))\n-                related_model = field.remote_field.model._meta.concrete_model\n-                self._get_only_select_mask(\n-                    related_model._meta, field_mask, field_select_mask\n-                )\n-        return select_mask\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    select_mask[opts.pk] = {}\n+    # Only include fields mentioned in the mask.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, field_select_mask\n+            )\n+    return select_mask\n \n     def get_select_mask(self):\n         \"\"\"\n",
    "variant_5": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..8a0c3025fe 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,9 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+            for related_field, model in related_fields:\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1249,8 +1250,9 @@ class SQLCompiler:\n                 for o in opts.related_objects\n                 if o.field.unique and not o.many_to_many\n             ]\n+\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,12 +1280,9 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n-                columns = self.get_default_columns(\n-                    related_select_mask,\n-                    start_alias=alias,\n-                    opts=model._meta,\n-                    from_parent=opts.model,\n-                )\n+\n+            for related_field, model in related_fields:\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 for col in columns:\n                     select_fields.append(len(select))\n                     select.append((col, None))\n@@ -1421,6 +1420,8 @@ class SQLCompiler:\n                     path = []\n                     yield \"self\"\n                 else:\n+                    field = klass_info[\"field\"]\n+\n                     field = klass_info[\"field\"]\n                     if klass_info[\"reverse\"]:\n                         field = field.remote_field\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..58a2f1a992 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,6 +772,7 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n+\n     def _get_only_select_mask(self, opts, mask, select_mask=None):\n         if select_mask is None:\n             select_mask = {}\n",
    "variant_6": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..7a3b90e4f3 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,9 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+            for related_field, model in related_fields:\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1249,8 +1250,9 @@ class SQLCompiler:\n                 for o in opts.related_objects\n                 if o.field.unique and not o.many_to_many\n             ]\n+\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,12 +1280,9 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n-                columns = self.get_default_columns(\n-                    related_select_mask,\n-                    start_alias=alias,\n-                    opts=model._meta,\n-                    from_parent=opts.model,\n-                )\n+\n+                for related_field, model in related_fields:\n+                    related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 for col in columns:\n                     select_fields.append(len(select))\n                     select.append((col, None))\n@@ -1412,6 +1411,17 @@ class SQLCompiler:\n                 if self.select[select_index][0].target.model == concrete_model:\n                     return self.select[select_index][0]\n \n+        def _get_field_choices():\n+            \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n+            queue = collections.deque([(None, self.klass_info)])\n+            while queue:\n+                parent_path, klass_info = queue.popleft()\n+                if parent_path is None:\n+                    path = []\n+                    yield \"self\"\n+                else:\n+                    field = klass_info[\"field\"]\n+\n         def _get_field_choices():\n             \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n             queue = collections.deque([(None, self.klass_info)])\n@@ -1434,6 +1444,16 @@ class SQLCompiler:\n                     (path, klass_info)\n                     for klass_info in klass_info.get(\"related_klass_infos\", [])\n                 )\n+                    path = parent_path + [field.name]\n+                    yield LOOKUP_SEP.join(path)\n+                queue.extend(\n+                    (path, klass_info)\n+                    for klass_info in _get_parent_klass_info(klass_info)\n+                )\n+                queue.extend(\n+                    (path, klass_info)\n+                    for klass_info in klass_info.get(\"related_klass_infos\", [])\n+                )\n \n         if not self.klass_info:\n             return []\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..2b3321bb5d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,22 +772,23 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n-    def _get_only_select_mask(self, opts, mask, select_mask=None):\n-        if select_mask is None:\n-            select_mask = {}\n-        select_mask[opts.pk] = {}\n-        # Only include fields mentioned in the mask.\n-        for field_name, field_mask in mask.items():\n-            field = opts.get_field(field_name)\n-            field_select_mask = select_mask.setdefault(field, {})\n-            if field_mask:\n-                if not field.is_relation:\n-                    raise FieldError(next(iter(field_mask)))\n-                related_model = field.remote_field.model._meta.concrete_model\n-                self._get_only_select_mask(\n-                    related_model._meta, field_mask, field_select_mask\n-                )\n-        return select_mask\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    select_mask[opts.pk] = {}\n+    # Only include fields mentioned in the mask.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, field_select_mask\n+            )\n+    return select_mask\n \n     def get_select_mask(self):\n         \"\"\"\n",
    "variant_7": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..cc3fcd303c 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,9 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+            related_select_mask = select_mask.get(related_field.remote_field) or {}\n+            columns = self.get_default_columns(\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1249,8 +1250,9 @@ class SQLCompiler:\n                 for o in opts.related_objects\n                 if o.field.unique and not o.many_to_many\n             ]\n+\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,12 +1280,9 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n-                columns = self.get_default_columns(\n-                    related_select_mask,\n-                    start_alias=alias,\n-                    opts=model._meta,\n-                    from_parent=opts.model,\n-                )\n+\n+            for related_field, model in related_fields:\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 for col in columns:\n                     select_fields.append(len(select))\n                     select.append((col, None))\n@@ -1412,6 +1411,17 @@ class SQLCompiler:\n                 if self.select[select_index][0].target.model == concrete_model:\n                     return self.select[select_index][0]\n \n+        def _get_field_choices():\n+            \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n+            queue = collections.deque([(None, self.klass_info)])\n+            while queue:\n+                parent_path, klass_info = queue.popleft()\n+                if parent_path is None:\n+                    path = []\n+                    yield \"self\"\n+                else:\n+                    field = klass_info[\"field\"]\n+\n         def _get_field_choices():\n             \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n             queue = collections.deque([(None, self.klass_info)])\n@@ -1434,6 +1444,16 @@ class SQLCompiler:\n                     (path, klass_info)\n                     for klass_info in klass_info.get(\"related_klass_infos\", [])\n                 )\n+                    path = parent_path + [field.name]\n+                    yield LOOKUP_SEP.join(path)\n+                queue.extend(\n+                    (path, klass_info)\n+                    for klass_info in _get_parent_klass_info(klass_info)\n+                )\n+                queue.extend(\n+                    (path, klass_info)\n+                    for klass_info in klass_info.get(\"related_klass_infos\", [])\n+                )\n \n         if not self.klass_info:\n             return []\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..2b3321bb5d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,22 +772,23 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n-    def _get_only_select_mask(self, opts, mask, select_mask=None):\n-        if select_mask is None:\n-            select_mask = {}\n-        select_mask[opts.pk] = {}\n-        # Only include fields mentioned in the mask.\n-        for field_name, field_mask in mask.items():\n-            field = opts.get_field(field_name)\n-            field_select_mask = select_mask.setdefault(field, {})\n-            if field_mask:\n-                if not field.is_relation:\n-                    raise FieldError(next(iter(field_mask)))\n-                related_model = field.remote_field.model._meta.concrete_model\n-                self._get_only_select_mask(\n-                    related_model._meta, field_mask, field_select_mask\n-                )\n-        return select_mask\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    select_mask[opts.pk] = {}\n+    # Only include fields mentioned in the mask.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, field_select_mask\n+            )\n+    return select_mask\n \n     def get_select_mask(self):\n         \"\"\"\n",
    "variant_8": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex b28dc925ba..70fd73747f 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -990,8 +990,9 @@ class SQLCompiler:\n                 # parent model data is already present in the SELECT clause,\n                 # and we want to avoid reloading the same data again.\n                 continue\n-            if select_mask and field not in select_mask:\n-                continue\n+\n+            for related_field, model in related_fields:\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n             alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n             column = field.get_col(alias)\n             result.append(column)\n@@ -1249,8 +1250,9 @@ class SQLCompiler:\n                 for o in opts.related_objects\n                 if o.field.unique and not o.many_to_many\n             ]\n+\n             for related_field, model in related_fields:\n-                related_select_mask = select_mask.get(related_field) or {}\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 if not select_related_descend(\n                     related_field,\n                     restricted,\n@@ -1278,12 +1280,8 @@ class SQLCompiler:\n                 }\n                 related_klass_infos.append(klass_info)\n                 select_fields = []\n-                columns = self.get_default_columns(\n-                    related_select_mask,\n-                    start_alias=alias,\n-                    opts=model._meta,\n-                    from_parent=opts.model,\n-                )\n+\n+                related_select_mask = select_mask.get(related_field.remote_field) or {}\n                 for col in columns:\n                     select_fields.append(len(select))\n                     select.append((col, None))\n@@ -1412,6 +1410,17 @@ class SQLCompiler:\n                 if self.select[select_index][0].target.model == concrete_model:\n                     return self.select[select_index][0]\n \n+        def _get_field_choices():\n+            \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n+            queue = collections.deque([(None, self.klass_info)])\n+            while queue:\n+                parent_path, klass_info = queue.popleft()\n+                if parent_path is None:\n+                    path = []\n+                    yield \"self\"\n+                else:\n+                    field = klass_info[\"field\"]\n+\n         def _get_field_choices():\n             \"\"\"Yield all allowed field paths in breadth-first search order.\"\"\"\n             queue = collections.deque([(None, self.klass_info)])\n@@ -1434,6 +1443,16 @@ class SQLCompiler:\n                     (path, klass_info)\n                     for klass_info in klass_info.get(\"related_klass_infos\", [])\n                 )\n+                    path = parent_path + [field.name]\n+                    yield LOOKUP_SEP.join(path)\n+                queue.extend(\n+                    (path, klass_info)\n+                    for klass_info in _get_parent_klass_info(klass_info)\n+                )\n+                queue.extend(\n+                    (path, klass_info)\n+                    for klass_info in klass_info.get(\"related_klass_infos\", [])\n+                )\n \n         if not self.klass_info:\n             return []\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 781dfd5499..2b3321bb5d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -772,22 +772,23 @@ class Query(BaseExpression):\n             )\n         return select_mask\n \n-    def _get_only_select_mask(self, opts, mask, select_mask=None):\n-        if select_mask is None:\n-            select_mask = {}\n-        select_mask[opts.pk] = {}\n-        # Only include fields mentioned in the mask.\n-        for field_name, field_mask in mask.items():\n-            field = opts.get_field(field_name)\n-            field_select_mask = select_mask.setdefault(field, {})\n-            if field_mask:\n-                if not field.is_relation:\n-                    raise FieldError(next(iter(field_mask)))\n-                related_model = field.remote_field.model._meta.concrete_model\n-                self._get_only_select_mask(\n-                    related_model._meta, field_mask, field_select_mask\n-                )\n-        return select_mask\n+\n+def _get_only_select_mask(self, opts, mask, select_mask=None):\n+    if select_mask is None:\n+        select_mask = {}\n+    select_mask[opts.pk] = {}\n+    # Only include fields mentioned in the mask.\n+    for field_name, field_mask in mask.items():\n+        field = opts.get_field(field_name)\n+        field_select_mask = select_mask.setdefault(field, {})\n+        if field_mask:\n+            if not field.is_relation:\n+                raise FieldError(next(iter(field_mask)))\n+            related_model = field.remote_field.model._meta.concrete_model\n+            self._get_only_select_mask(\n+                related_model._meta, field_mask, field_select_mask\n+            )\n+    return select_mask\n \n     def get_select_mask(self):\n         \"\"\"\n"
  }
}