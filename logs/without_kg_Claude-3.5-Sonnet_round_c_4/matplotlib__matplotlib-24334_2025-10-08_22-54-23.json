{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/matplotlib/lib/matplotlib/axis.py lines 2024-2027)": "\n        result = self._set_tick_locations(ticks, minor=minor)\n        if labels is not None:\n            self.set_ticklabels(labels, minor=minor, **kwargs)\n        elif kwargs:\n            # Validate kwargs even when labels is None by testing on existing tick\n            if minor:\n                tick = self.get_minor_ticks(1)[0]\n            else:\n                tick = self.get_major_ticks(1)[0]\n            # Validate kwargs without applying them\n            tick.label1._internal_update(kwargs)\n        return result\n",
    "Location 2 (/root/hy/projects_4/matplotlib/lib/matplotlib/axis.py lines 1523-1534)": "\n    def get_major_ticks(self, numticks=None):\n        r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_majorticklocs())\n\n        while len(self.majorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=True)\n            self.majorTicks.append(tick)\n            if len(self.majorTicks) > 1:\n                self._copy_tick_props(self.majorTicks[0], tick)\n\n        return self.majorTicks[:numticks]\n",
    "Location 3 (/root/hy/projects_4/matplotlib/lib/matplotlib/axis.py lines 1536-1540)": "\n    def get_minor_ticks(self, numticks=None):\n        r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_minorticklocs())\n\n        while len(self.minorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=False)\n            self.minorTicks.append(tick)\n            if len(self.minorTicks) > 1:\n                self._copy_tick_props(self.minorTicks[0], tick)\n\n        return self.minorTicks[:numticks]\n",
    "Location 4 (/root/hy/projects_4/matplotlib/lib/matplotlib/artist.py lines 1179-1188)": "\ndef _internal_update(self, kwargs):\n    \"\"\"\n    Update artist properties without prenormalizing them, but generating\n    errors as if calling `set`.\n\n    The lack of prenormalization is to maintain backcompatibility.\n    \"\"\"\n    return self._update_props(\n        kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n        \"{prop_name!r}\")\n",
    "Location 5 (/root/hy/projects_4/matplotlib/lib/matplotlib/axes/_base.py lines 3741-3741)": "\ndef set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n    \"\"\"\n    Set this Axis' tick locations and optionally labels.\n\n    If necessary, the view limits of the Axis are expanded so that all\n    given ticks are visible.\n\n    Parameters\n    ----------\n    ticks : list of floats\n        List of tick locations.  The axis `.Locator` is replaced by a\n        `~.ticker.FixedLocator`.\n\n        Some tick formatters will not label arbitrary tick positions;\n        e.g. log formatters only label decade ticks.\n\n    labels : list of str, optional\n        List of tick labels. If not set, the labels are generated with\n        the axis tick `.Formatter`.\n\n    minor : bool, default: False\n        If ``False``, set the major ticks; if ``True``, the minor ticks.\n\n    **kwargs\n        `.Text` properties for the labels. These take effect only if you\n        pass *labels*. In other cases, please use `~.Axes.tick_params`.\n\n    Notes\n    -----\n    The mandatory expansion of the view limits is an intentional design\n    choice to prevent the surprise of a non-visible tick. If you need\n    other behavior, use `~.Axes.tick_params` combined with\n    `~.ticker.FixedLocator`.\n\n    Some tick formatters will not label arbitrary tick positions;\n    e.g. log formatters only label decade ticks.\n\n    Examples\n    --------\n    >>> ax.set_xticks([0, 1, 2])\n    >>> ax.set_xticks([0, 1, 2], ['a', 'b', 'c'])\n    >>> ax.set_xticks([0, 1, 2], ['a', 'b', 'c'], fontsize=16)\n    >>> ax.set_xticks([0, 1, 2], labels=['a', 'b', 'c'],\n    ...                fontweight='bold', color='red')\n    \"\"\"\n    result = self._set_tick_locations(ticks, minor=minor)\n    if labels is not None:\n        self.set_ticklabels(labels, minor=minor, **kwargs)\n    elif kwargs:\n        # Validate kwargs even when labels is None by using existing tick\n        if minor:\n            existing_ticks = self.get_minor_ticks(1)\n        else:\n            existing_ticks = self.get_major_ticks(1)\n        if existing_ticks:\n            # Use the first tick's label to validate Text properties\n            existing_ticks[0].label1._internal_update(kwargs)\n    return result\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/matplotlib/lib/matplotlib/axis.py lines 2024-2027)": [
      "\n        result = self._set_tick_locations(ticks, minor=minor)\n        if labels is not None:\n            self.set_ticklabels(labels, minor=minor, **kwargs)\n        elif kwargs:\n            # Validate kwargs even when labels is None by testing against existing tick\n            existing_ticks = self.get_minor_ticks(1) if minor else self.get_major_ticks(1)\n            if existing_ticks:\n                existing_ticks[0].label1._internal_update(kwargs)\n        return result\n",
      "\n        result = self._set_tick_locations(ticks, minor=minor)\n        if labels is not None:\n            self.set_ticklabels(labels, minor=minor, **kwargs)\n        elif kwargs:\n            # Validate kwargs even when labels is None by testing on existing tick\n            if minor:\n                tick = self.get_minor_ticks(1)[0]\n            else:\n                tick = self.get_major_ticks(1)[0]\n            # Validate Text properties without applying them\n            tick.label1._internal_update(kwargs)\n        return result\n",
      "\n        result = self._set_tick_locations(ticks, minor=minor)\n        if labels is not None:\n            self.set_ticklabels(labels, minor=minor, **kwargs)\n        elif kwargs:\n            # Validate kwargs even when labels is None by testing on existing tick\n            if minor:\n                existing_tick = self.get_minor_ticks(1)[0]\n            else:\n                existing_tick = self.get_major_ticks(1)[0]\n            # Validate kwargs without applying them\n            existing_tick.label1._internal_update(kwargs)\n        return result\n",
      "\n        result = self._set_tick_locations(ticks, minor=minor)\n        if labels is not None:\n            self.set_ticklabels(labels, minor=minor, **kwargs)\n        elif kwargs:\n            # Validate kwargs even when labels is None by testing on existing tick\n            existing_ticks = self.get_minor_ticks(1) if minor else self.get_major_ticks(1)\n            if existing_ticks:\n                # Use _internal_update to validate Text properties without applying them\n                existing_ticks[0].label1._internal_update(kwargs)\n        return result\n",
      "\n        result = self._set_tick_locations(ticks, minor=minor)\n        if labels is not None:\n            self.set_ticklabels(labels, minor=minor, **kwargs)\n        elif kwargs:\n            # Validate kwargs even when labels is None by testing on existing tick\n            if minor:\n                test_tick = self.get_minor_ticks(1)[0]\n            else:\n                test_tick = self.get_major_ticks(1)[0]\n            # Use _internal_update to validate Text properties without applying them\n            test_tick.label1._internal_update(kwargs)\n        return result\n",
      "\n        result = self._set_tick_locations(ticks, minor=minor)\n        if labels is not None:\n            self.set_ticklabels(labels, minor=minor, **kwargs)\n        elif kwargs:\n            # Validate kwargs even when labels is None by testing on existing ticks\n            if minor:\n                existing_ticks = self.get_minor_ticks(1)\n            else:\n                existing_ticks = self.get_major_ticks(1)\n            if existing_ticks:\n                # Use the first tick's label to validate kwargs without applying them\n                existing_ticks[0].label1._internal_update(kwargs)\n        return result\n",
      "\n        result = self._set_tick_locations(ticks, minor=minor)\n        if labels is not None:\n            self.set_ticklabels(labels, minor=minor, **kwargs)\n        elif kwargs:\n            # Validate kwargs by testing them on existing tick labels\n            existing_ticks = self.get_minor_ticks(1) if minor else self.get_major_ticks(1)\n            if existing_ticks:\n                # Use _internal_update to validate kwargs without applying them\n                existing_ticks[0].label1._internal_update(kwargs)\n        return result\n",
      "\n        result = self._set_tick_locations(ticks, minor=minor)\n        if labels is not None:\n            self.set_ticklabels(labels, minor=minor, **kwargs)\n        elif kwargs:\n            # Validate kwargs even when labels is None by testing on existing tick\n            if minor:\n                existing_tick = self.get_minor_ticks(1)[0]\n            else:\n                existing_tick = self.get_major_ticks(1)[0]\n            existing_tick.label1._internal_update(kwargs)\n        return result\n"
    ],
    "Location 2 (/root/hy/projects_4/matplotlib/lib/matplotlib/axis.py lines 1523-1534)": [
      "\n    def get_major_ticks(self, numticks=None):\n        r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_majorticklocs())\n\n        while len(self.majorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=True)\n            self.majorTicks.append(tick)\n            self._copy_tick_props(self.majorTicks[0], tick)\n\n        return self.majorTicks[:numticks]\n",
      "\n    def get_major_ticks(self, numticks=None):\n        r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_majorticklocs())\n\n        while len(self.majorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=True)\n            self.majorTicks.append(tick)\n            self._copy_tick_props(self.majorTicks[0], tick)\n\n        return self.majorTicks[:numticks]\n",
      "\n    def get_major_ticks(self, numticks=None):\n        r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_majorticklocs())\n\n        while len(self.majorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=True)\n            self.majorTicks.append(tick)\n            self._copy_tick_props(self.majorTicks[0], tick)\n\n        return self.majorTicks[:numticks]\n",
      "\n    def get_major_ticks(self, numticks=None):\n        r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_majorticklocs())\n\n        while len(self.majorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=True)\n            self.majorTicks.append(tick)\n            if len(self.majorTicks) > 1:\n                self._copy_tick_props(self.majorTicks[0], tick)\n\n        return self.majorTicks[:numticks]\n",
      "\n    def get_major_ticks(self, numticks=None):\n        r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_majorticklocs())\n\n        while len(self.majorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=True)\n            self.majorTicks.append(tick)\n            self._copy_tick_props(self.majorTicks[0], tick)\n\n        return self.majorTicks[:numticks]\n",
      "\n    def get_major_ticks(self, numticks=None):\n        r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_majorticklocs())\n\n        while len(self.majorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=True)\n            self.majorTicks.append(tick)\n            self._copy_tick_props(self.majorTicks[0], tick)\n\n        return self.majorTicks[:numticks]\n",
      "\n    def get_major_ticks(self, numticks=None):\n        r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_majorticklocs())\n\n        while len(self.majorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=True)\n            self.majorTicks.append(tick)\n            if len(self.majorTicks) > 1:\n                self._copy_tick_props(self.majorTicks[0], tick)\n\n        return self.majorTicks[:numticks]\n",
      "\n    def get_major_ticks(self, numticks=None):\n        r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_majorticklocs())\n\n        while len(self.majorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=True)\n            self.majorTicks.append(tick)\n            if len(self.majorTicks) > 1:\n                self._copy_tick_props(self.majorTicks[0], tick)\n\n        return self.majorTicks[:numticks]\n"
    ],
    "Location 3 (/root/hy/projects_4/matplotlib/lib/matplotlib/axis.py lines 1536-1540)": [
      "\n    def get_minor_ticks(self, numticks=None):\n        r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_minorticklocs())\n\n        while len(self.minorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=False)\n            self.minorTicks.append(tick)\n            if len(self.minorTicks) > 1:\n                self._copy_tick_props(self.minorTicks[0], tick)\n\n        return self.minorTicks[:numticks]\n",
      "\n    def get_minor_ticks(self, numticks=None):\n        r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_minorticklocs())\n\n        while len(self.minorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=False)\n            self.minorTicks.append(tick)\n            if len(self.minorTicks) > 1:\n                self._copy_tick_props(self.minorTicks[0], tick)\n\n        return self.minorTicks[:numticks]\n",
      "\ndef get_minor_ticks(self, numticks=None):\n    r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n    if numticks is None:\n        numticks = len(self.get_minorticklocs())\n\n    while len(self.minorTicks) < numticks:\n        # Update the new tick label properties from the old.\n        tick = self._get_tick(major=False)\n        self.minorTicks.append(tick)\n        if len(self.minorTicks) > 1:\n            self._copy_tick_props(self.minorTicks[0], tick)\n\n    return self.minorTicks[:numticks]\n",
      "\ndef get_minor_ticks(self, numticks=None):\n    r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n    if numticks is None:\n        numticks = len(self.get_minorticklocs())\n\n    while len(self.minorTicks) < numticks:\n        # Update the new tick label properties from the old.\n        tick = self._get_tick(major=False)\n        self.minorTicks.append(tick)\n        if len(self.minorTicks) > 1:\n            self._copy_tick_props(self.minorTicks[0], tick)\n\n    return self.minorTicks[:numticks]\n",
      "\n    def get_minor_ticks(self, numticks=None):\n        r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_minorticklocs())\n\n        while len(self.minorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=False)\n            self.minorTicks.append(tick)\n            if len(self.minorTicks) > 1:\n                self._copy_tick_props(self.minorTicks[0], tick)\n\n        return self.minorTicks[:numticks]\n",
      "\n    def get_minor_ticks(self, numticks=None):\n        r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_minorticklocs())\n\n        while len(self.minorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=False)\n            self.minorTicks.append(tick)\n            if self.minorTicks:\n                self._copy_tick_props(self.minorTicks[0], tick)\n\n        return self.minorTicks[:numticks]\n",
      "\ndef get_minor_ticks(self, numticks=None):\n    r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n    if numticks is None:\n        numticks = len(self.get_minorticklocs())\n\n    while len(self.minorTicks) < numticks:\n        # Update the new tick label properties from the old.\n        tick = self._get_tick(major=False)\n        self.minorTicks.append(tick)\n        if len(self.minorTicks) > 1:\n            self._copy_tick_props(self.minorTicks[0], tick)\n\n    return self.minorTicks[:numticks]\n",
      "\n    def get_minor_ticks(self, numticks=None):\n        r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n        if numticks is None:\n            numticks = len(self.get_minorticklocs())\n\n        while len(self.minorTicks) < numticks:\n            # Update the new tick label properties from the old.\n            tick = self._get_tick(major=False)\n            self.minorTicks.append(tick)\n            if len(self.minorTicks) > 1:\n                self._copy_tick_props(self.minorTicks[0], tick)\n\n        return self.minorTicks[:numticks]\n"
    ],
    "Location 4 (/root/hy/projects_4/matplotlib/lib/matplotlib/artist.py lines 1179-1188)": [
      "\n    def _internal_update(self, kwargs):\n        \"\"\"\n        Update artist properties without prenormalizing them, but generating\n        errors as if calling `set`.\n\n        The lack of prenormalization is to maintain backcompatibility.\n        \"\"\"\n        return self._update_props(\n            kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n            \"{prop_name!r}\")\n",
      "\ndef _internal_update(self, kwargs):\n    \"\"\"\n    Update artist properties without prenormalizing them, but generating\n    errors as if calling `set`.\n\n    The lack of prenormalization is to maintain backcompatibility.\n    \"\"\"\n    return self._update_props(\n        kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n        \"{prop_name!r}\")\n",
      "\ndef _internal_update(self, kwargs):\n    \"\"\"\n    Update artist properties without prenormalizing them, but generating\n    errors as if calling `set`.\n\n    The lack of prenormalization is to maintain backcompatibility.\n    \"\"\"\n    return self._update_props(\n        kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n        \"{prop_name!r}\")\n",
      "\ndef _internal_update(self, kwargs):\n    \"\"\"\n    Update artist properties without prenormalizing them, but generating\n    errors as if calling `set`.\n\n    The lack of prenormalization is to maintain backcompatibility.\n    \"\"\"\n    return self._update_props(\n        kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n        \"{prop_name!r}\")\n",
      "\ndef set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n    \"\"\"\n    Set this Axis' tick locations and optionally labels.\n\n    If necessary, the view limits of the Axis are expanded so that all\n    given ticks are visible.\n\n    Parameters\n    ----------\n    ticks : list of floats\n        List of tick locations.  The axis `.Locator` is replaced by a\n        `~.ticker.FixedLocator`.\n\n        Some tick formatters will not label arbitrary tick positions;\n        e.g. log formatters only label decade ticks.\n\n    labels : list of str, optional\n        List of tick labels. If not set, the labels are generated with\n        the axis tick `.Formatter`.\n\n    minor : bool, default: False\n        If ``False``, set the major ticks; if ``True``, the minor ticks.\n\n    **kwargs\n        `.Text` properties for the labels. These take effect only if you\n        pass *labels*. In other cases, please use `~.Axes.tick_params`.\n\n    Notes\n    -----\n    The mandatory expansion of the view limits is an intentional design\n    choice to prevent the surprise of a non-visible tick. If you need\n    other behavior, use `~.Axis.set_major_locator` or\n    `~.Axis.set_minor_locator` to set a `~.ticker.Locator` object on the\n    respective axis.\n    \"\"\"\n    result = self._set_tick_locations(ticks, minor=minor)\n    if labels is not None:\n        self.set_ticklabels(labels, minor=minor, **kwargs)\n    elif kwargs:\n        # Validate kwargs even when labels=None by checking against existing tick\n        if minor:\n            tick = self.get_minor_ticks(1)[0]\n        else:\n            tick = self.get_major_ticks(1)[0]\n        # Use _internal_update to validate Text properties without applying them\n        tick.label1._internal_update(kwargs)\n    return result\n",
      "\n    def _internal_update(self, kwargs):\n        \"\"\"\n        Update artist properties without prenormalizing them, but generating\n        errors as if calling `set`.\n\n        The lack of prenormalization is to maintain backcompatibility.\n        \"\"\"\n        return self._update_props(\n            kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n            \"{prop_name!r}\")\n",
      "\n    def _internal_update(self, kwargs):\n        \"\"\"\n        Update artist properties without prenormalizing them, but generating\n        errors as if calling `set`.\n\n        The lack of prenormalization is to maintain backcompatibility.\n        \"\"\"\n        return self._update_props(\n            kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n            \"{prop_name!r}\")\n",
      "\ndef _internal_update(self, kwargs):\n    \"\"\"\n    Update artist properties without prenormalizing them, but generating\n    errors as if calling `set`.\n\n    The lack of prenormalization is to maintain backcompatibility.\n    \"\"\"\n    return self._update_props(\n        kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n        \"{prop_name!r}\")\n"
    ],
    "Location 5 (/root/hy/projects_4/matplotlib/lib/matplotlib/axes/_base.py lines 3741-3741)": [
      "\ndef set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n    \"\"\"\n    Set this Axis' tick locations and optionally labels.\n\n    If necessary, the view limits of the Axis are expanded so that all\n    given ticks are visible.\n\n    Parameters\n    ----------\n    ticks : list of floats\n        List of tick locations.  The axis `.Locator` is replaced by a\n        `~.ticker.FixedLocator`.\n\n        Some tick formatters will not label arbitrary tick positions;\n        e.g. log formatters only label decade ticks.\n\n    labels : list of str, optional\n        List of tick labels. If not set, the labels are generated with\n        the axis tick `.Formatter`.\n\n    minor : bool, default: False\n        If ``False``, set the major ticks; if ``True``, the minor ticks.\n\n    **kwargs\n        `.Text` properties for the labels. These take effect only if you\n        pass *labels*. In other cases, please use `~.Axes.tick_params`.\n\n    Notes\n    -----\n    The mandatory expansion of the view limits is an intentional design\n    choice to prevent the surprise of a non-visible tick. If you need\n    other behavior, use `~.Axis.set_major_locator` or\n    `~.Axis.set_minor_locator` to explicitly control the ticking.\n\n    The focus of this method is to set the tick positions. To control\n    tick formatting, use one of the formatting-related methods or\n    properties of the `Axis`, e.g. `.Axis.set_major_formatter` or\n    `.Axis.set_minor_formatter`.\n\n    Examples\n    --------\n    >>> ax.set_xticks([1, 2, 3])\n    >>> ax.set_xticks([1, 2, 3], ['red', 'green', 'blue'])\n    \"\"\"\n    result = self._set_tick_locations(ticks, minor=minor)\n    if labels is not None:\n        self.set_ticklabels(labels, minor=minor, **kwargs)\n    elif kwargs:\n        # Validate kwargs even when labels are not being set\n        # Get at least one existing tick to validate Text properties\n        existing_ticks = self.get_minor_ticks(1) if minor else self.get_major_ticks(1)\n        if existing_ticks:\n            # Use the first tick's label to validate kwargs without applying them\n            existing_ticks[0].label1._internal_update(kwargs)\n    return result\n",
      "\ndef set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n    \"\"\"\n    Set this Axis' tick locations and optionally labels.\n\n    If necessary, the view limits of the Axis are expanded so that all\n    given ticks are visible.\n\n    Parameters\n    ----------\n    ticks : list of floats\n        List of tick locations.  The axis `.Locator` is replaced by a\n        `~.ticker.FixedLocator`.\n\n        Some tick formatters will not label arbitrary tick positions;\n        e.g. log formatters only label decade ticks.\n\n    labels : list of str, optional\n        List of tick labels. If not set, the labels are generated with\n        the axis tick `.Formatter`.\n\n    minor : bool, default: False\n        If ``False``, set the major ticks; if ``True``, the minor ticks.\n\n    **kwargs\n        `.Text` properties for the labels. These take effect only if you\n        pass *labels*. In other cases, please use `~.Axes.tick_params`.\n\n    Notes\n    -----\n    The mandatory expansion of the view limits is an intentional design\n    choice to prevent the surprise of a non-visible tick. If you need\n    other behavior, use `~.Axis.set_major_locator` or\n    `~.Axis.set_minor_locator` and `~.Axis.set_major_formatter` or\n    `~.Axis.set_minor_formatter`.\n    \"\"\"\n    result = self._set_tick_locations(ticks, minor=minor)\n    if labels is not None:\n        self.set_ticklabels(labels, minor=minor, **kwargs)\n    elif kwargs:\n        # Validate kwargs even when labels is None by using existing tick objects\n        if minor:\n            existing_ticks = self.get_minor_ticks(1)\n        else:\n            existing_ticks = self.get_major_ticks(1)\n        # Use the first tick's label to validate the kwargs\n        existing_ticks[0].label1._internal_update(kwargs)\n    return result\n",
      "\ndef set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n    \"\"\"\n    Set this Axis' tick locations and optionally labels.\n\n    If necessary, the view limits of the Axis are expanded so that all\n    given ticks are visible.\n\n    Parameters\n    ----------\n    ticks : list of floats\n        List of tick locations.  The axis `.Locator` is replaced by a\n        `~.ticker.FixedLocator`.\n\n        Some tick formatters will not label arbitrary tick positions;\n        e.g. log formatters only label decade ticks.\n\n    labels : list of str, optional\n        List of tick labels. If not set, the labels are generated with\n        the axis tick `.Formatter`.\n\n    minor : bool, default: False\n        If ``False``, set the major ticks; if ``True``, the minor ticks.\n\n    **kwargs\n        `.Text` properties for the labels. These take effect only if you\n        pass *labels*. In other cases, please use `~.Axes.tick_params`.\n\n    Notes\n    -----\n    The mandatory expansion of the view limits is an intentional design\n    choice to prevent the surprise of a non-visible tick. If you need\n    other behavior, use `~.Axis.set_major_locator` or\n    `~.Axis.set_minor_locator` to set a `~.ticker.Locator` object on a\n    given axis.\n    \"\"\"\n    result = self._set_tick_locations(ticks, minor=minor)\n    if labels is not None:\n        self.set_ticklabels(labels, minor=minor, **kwargs)\n    elif kwargs:\n        # Validate kwargs even when labels is None by testing on existing ticks\n        if minor:\n            existing_ticks = self.get_minor_ticks(1)\n        else:\n            existing_ticks = self.get_major_ticks(1)\n        if existing_ticks:\n            # Validate kwargs using existing tick's label without modifying it\n            existing_ticks[0].label1._internal_update(kwargs)\n    return result\n",
      "\n    def set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n        \"\"\"\n        Set this Axis' tick locations and optionally labels.\n\n        If necessary, the view limits of the Axis are expanded so that all\n        given ticks are visible.\n\n        Parameters\n        ----------\n        ticks : list of floats\n            List of tick locations.  The axis `.Locator` is replaced by a\n            `~.ticker.FixedLocator`.\n\n            Some tick formatters will not label arbitrary tick positions;\n            e.g. log formatters only label decade ticks.\n\n        labels : list of str, optional\n            List of tick labels. If not set, the labels are generated with\n            the axis tick `.Formatter`.\n\n        minor : bool, default: False\n            If ``False``, set the major ticks; if ``True``, the minor ticks.\n\n        **kwargs\n            `.Text` properties for the labels. These take effect only if you\n            pass *labels*. In other cases, please use `~.Axes.tick_params`.\n\n        Notes\n        -----\n        The mandatory expansion of the view limits is an intentional design\n        choice to prevent the surprise of a non-visible tick. If you need\n        other behavior, use `~.Axes.tick_params` and\n        `~.ticker.Locator.tick_values`.\n        \"\"\"\n        result = self._set_tick_locations(ticks, minor=minor)\n        if labels is not None:\n            self.set_ticklabels(labels, minor=minor, **kwargs)\n        elif kwargs:\n            # Validate kwargs even when labels is None by using existing tick objects\n            if minor:\n                existing_ticks = self.get_minor_ticks(1)\n            else:\n                existing_ticks = self.get_major_ticks(1)\n            # Use the first tick's label to validate Text properties\n            existing_ticks[0].label1._internal_update(kwargs)\n        return result\n",
      "\n    def set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n        \"\"\"\n        Set this Axis' tick locations and optionally labels.\n\n        If necessary, the view limits of the Axis are expanded so that all\n        given ticks are visible.\n\n        Parameters\n        ----------\n        ticks : list of floats\n            List of tick locations.  The axis `.Locator` is replaced by a\n            `~.ticker.FixedLocator`.\n\n            Some tick formatters will not label arbitrary tick positions;\n            e.g. log formatters only label decade ticks by default. In\n            such a case you can set a formatter explicitly on the axis\n            using `.Axis.set_major_formatter` or provide formatted\n            *labels* yourself.\n        labels : list of str, optional\n            List of tick labels. If not set, the labels are generated with\n            the axis tick `.Formatter`.\n        minor : bool, default: False\n            If ``False``, set the major ticks; if ``True``, the minor ticks.\n        **kwargs\n            `.Text` properties for the labels. These take effect only if you\n            pass *labels*. In other cases, please use `~.Axes.tick_params`.\n\n        Notes\n        -----\n        The mandatory expansion of the view limits is an intentional design\n        choice to prevent the surprise of a non-visible tick. If you need\n        other behavior, use `~.Axes.tick_params` and\n        `~.ticker.Locator.tick_values`.\n        \"\"\"\n        result = self._set_tick_locations(ticks, minor=minor)\n        if labels is not None:\n            self.set_ticklabels(labels, minor=minor, **kwargs)\n        elif kwargs:\n            # Validate kwargs even when labels is None by using existing tick objects\n            tick_getter = self.get_minor_ticks if minor else self.get_major_ticks\n            existing_tick = tick_getter(1)[0]  # Get at least one tick to validate kwargs\n            existing_tick.label1._internal_update(kwargs)  # This will raise AttributeError for invalid Text properties\n        return result\n",
      "\ndef set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n    \"\"\"\n    Set this Axis' tick locations and optionally labels.\n\n    If necessary, the view limits of the Axis are expanded so that all\n    given ticks are visible.\n\n    Parameters\n    ----------\n    ticks : list of floats\n        List of tick locations.  The axis `.Locator` is replaced by a\n        `~.ticker.FixedLocator`.\n\n        Some tick formatters will not label arbitrary tick positions;\n        e.g. log formatters only label decade ticks.\n\n    labels : list of str, optional\n        List of tick labels. If not set, the labels are generated with\n        the axis tick `.Formatter`.\n\n    minor : bool, default: False\n        If ``False``, set the major ticks; if ``True``, the minor ticks.\n\n    **kwargs\n        `.Text` properties for the labels. These take effect only if you\n        pass *labels*. In other cases, please use `~.Axes.tick_params`.\n\n    Notes\n    -----\n    The mandatory expansion of the view limits is an intentional design\n    choice to prevent the surprise of a non-visible tick. If you need\n    other behavior, use `~.Axis.set_major_locator` or\n    `~.Axis.set_minor_locator` and `~.Axis.set_major_formatter` or\n    `~.Axis.set_minor_formatter`.\n    \"\"\"\n    if labels is not None:\n        self.set_ticklabels(labels, minor=minor, **kwargs)\n    elif kwargs:\n        # Validate kwargs even when labels is None by using existing tick\n        if minor:\n            existing_tick = self.get_minor_ticks(1)[0]\n        else:\n            existing_tick = self.get_major_ticks(1)[0]\n        # Validate kwargs using existing tick's label without applying them\n        existing_tick.label1._internal_update(kwargs)\n    \n    result = self.set_major_locator(mticker.FixedLocator(ticks))\n    if minor:\n        result = self.set_minor_locator(mticker.FixedLocator(ticks))\n    return result\n",
      "\n    def set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n        \"\"\"\n        Set this Axis' tick locations and optionally labels.\n\n        If necessary, the view limits of the Axis are expanded so that all\n        given ticks are visible.\n\n        Parameters\n        ----------\n        ticks : list of floats\n            List of tick locations.  The axis `.Locator` is replaced by a\n            `~.ticker.FixedLocator`.\n\n            Some tick formatters will not label arbitrary tick positions;\n            e.g. log formatters only label decade ticks.\n\n        labels : list of str, optional\n            List of tick labels. If not set, the labels are generated with\n            the axis tick `.Formatter`.\n\n        minor : bool, default: False\n            If ``False``, set the major ticks; if ``True``, the minor ticks.\n\n        **kwargs\n            `.Text` properties for the labels. These take effect only if you\n            pass *labels*. In other cases, please use `~.Axes.tick_params`.\n\n        Notes\n        -----\n        The mandatory expansion of the view limits is an intentional design\n        choice to prevent the surprise of a non-visible tick. If you need\n        other behavior, use `~.Axis.set_major_locator` or\n        `~.Axis.set_minor_locator` to explicitly control the ticking.\n\n        Examples\n        --------\n        >>> ax.set_xticks([1, 2, 3])\n        >>> ax.set_xticks([1, 2, 3], ['A', 'B', 'C'])\n        \"\"\"\n        if labels is not None:\n            self.set_ticklabels(labels, minor=minor, **kwargs)\n        elif kwargs:\n            # Validate kwargs even when labels is None by using existing tick objects\n            existing_ticks = self.get_minor_ticks(1) if minor else self.get_major_ticks(1)\n            if existing_ticks:\n                # Use the first tick's label to validate kwargs without applying them\n                existing_ticks[0].label1._internal_update(kwargs)\n        \n        self.set_major_locator(mticker.FixedLocator(ticks))\n        if minor:\n            self.set_minor_locator(mticker.FixedLocator(ticks))\n        else:\n            self.set_major_locator(mticker.FixedLocator(ticks))\n        return self.get_ticklocs(minor=minor)\n",
      "\ndef set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n    \"\"\"\n    Set this Axis' tick locations and optionally labels.\n\n    If necessary, the view limits of the Axis are expanded so that all\n    given ticks are visible.\n\n    Parameters\n    ----------\n    ticks : list of floats\n        List of tick locations.  The axis `.Locator` is replaced by a\n        `~.ticker.FixedLocator`.\n\n        Some tick formatters will not label arbitrary tick positions;\n        e.g. log formatters only label decade ticks.\n\n    labels : list of str, optional\n        List of tick labels. If not set, the labels are generated with\n        the axis tick `.Formatter`.\n\n    minor : bool, default: False\n        If ``False``, set the major ticks; if ``True``, the minor ticks.\n\n    **kwargs\n        `.Text` properties for the labels. These take effect only if you\n        pass *labels*. In other cases, please use `~.Axes.tick_params`.\n\n    Notes\n    -----\n    The mandatory expansion of the view limits is an intentional design\n    choice to prevent the surprise of a non-visible tick. If you need\n    other behavior, use `~.Axis.set_major_locator` or\n    `~.Axis.set_minor_locator`.\n\n    Examples\n    --------\n    >>> ax.set_xticks([1, 2, 3])\n    >>> ax.set_xticks([1, 2, 3], ['A', 'B', 'C'])\n    \"\"\"\n    if labels is not None:\n        self.set_ticklabels(labels, minor=minor, **kwargs)\n    elif kwargs:\n        # Validate kwargs even when labels is None by using existing tick\n        if minor:\n            existing_ticks = self.get_minor_ticks(1)\n        else:\n            existing_ticks = self.get_major_ticks(1)\n        # Use the first tick's label to validate kwargs\n        existing_ticks[0].label1._internal_update(kwargs)\n    \n    result = self.set_major_locator(mticker.FixedLocator(ticks))\n    if minor:\n        result = self.set_minor_locator(mticker.FixedLocator(ticks))\n    return result\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1ca1c1d3e3..d777b30e44 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1176,6 +1176,7 @@ class Artist:\n         return self._update_props(\n             props, \"{cls.__name__!r} object has no property {prop_name!r}\")\n \n+\n     def _internal_update(self, kwargs):\n         \"\"\"\n         Update artist properties without prenormalizing them, but generating\ndiff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 015fd32945..98292ecbe8 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3738,6 +3738,7 @@ class _AxesBase(martist.Artist):\n     get_xscale = _axis_method_wrapper(\"xaxis\", \"get_scale\")\n     set_xscale = _axis_method_wrapper(\"xaxis\", \"_set_axes_scale\")\n     get_xticks = _axis_method_wrapper(\"xaxis\", \"get_ticklocs\")\n+\n     set_xticks = _axis_method_wrapper(\"xaxis\", \"set_ticks\")\n     get_xmajorticklabels = _axis_method_wrapper(\"xaxis\", \"get_majorticklabels\")\n     get_xminorticklabels = _axis_method_wrapper(\"xaxis\", \"get_minorticklabels\")\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex af0815d41d..540a38cda6 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1520,6 +1520,7 @@ class Axis(martist.Artist):\n         \"\"\"Get the formatter of the minor ticker.\"\"\"\n         return self.minor.formatter\n \n+\n     def get_major_ticks(self, numticks=None):\n         r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n         if numticks is None:\n@@ -1533,11 +1534,11 @@ class Axis(martist.Artist):\n \n         return self.majorTicks[:numticks]\n \n+\n     def get_minor_ticks(self, numticks=None):\n         r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n         if numticks is None:\n             numticks = len(self.get_minorticklocs())\n-\n         while len(self.minorTicks) < numticks:\n             # Update the new tick label properties from the old.\n             tick = self._get_tick(major=False)\n@@ -2021,9 +2022,19 @@ class Axis(martist.Artist):\n         other limits, you should set the limits explicitly after setting the\n         ticks.\n         \"\"\"\n+\n         result = self._set_tick_locations(ticks, minor=minor)\n         if labels is not None:\n             self.set_ticklabels(labels, minor=minor, **kwargs)\n+        elif kwargs:\n+            # Validate kwargs even when labels=None by using existing tick objects\n+            if minor:\n+                existing_ticks = self.get_minor_ticks(1)\n+            else:\n+                existing_ticks = self.get_major_ticks(1)\n+            if existing_ticks:\n+                # Use the first tick's label to validate kwargs without applying them\n+                existing_ticks[0].label1._internal_update(kwargs)\n         return result\n \n     def _get_tick_boxes_siblings(self, renderer):\n",
    "variant_0": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1ca1c1d3e3..4faba2222c 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1176,16 +1176,17 @@ class Artist:\n         return self._update_props(\n             props, \"{cls.__name__!r} object has no property {prop_name!r}\")\n \n-    def _internal_update(self, kwargs):\n-        \"\"\"\n-        Update artist properties without prenormalizing them, but generating\n-        errors as if calling `set`.\n \n-        The lack of prenormalization is to maintain backcompatibility.\n-        \"\"\"\n-        return self._update_props(\n-            kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n-            \"{prop_name!r}\")\n+def _internal_update(self, kwargs):\n+    \"\"\"\n+    Update artist properties without prenormalizing them, but generating\n+    errors as if calling `set`.\n+\n+    The lack of prenormalization is to maintain backcompatibility.\n+    \"\"\"\n+    return self._update_props(\n+        kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n+        \"{prop_name!r}\")\n \n     def set(self, **kwargs):\n         # docstring and signature are auto-generated via\ndiff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 015fd32945..7202c1a600 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3738,7 +3738,65 @@ class _AxesBase(martist.Artist):\n     get_xscale = _axis_method_wrapper(\"xaxis\", \"get_scale\")\n     set_xscale = _axis_method_wrapper(\"xaxis\", \"_set_axes_scale\")\n     get_xticks = _axis_method_wrapper(\"xaxis\", \"get_ticklocs\")\n-    set_xticks = _axis_method_wrapper(\"xaxis\", \"set_ticks\")\n+\n+def set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n+    \"\"\"\n+    Set this Axis' tick locations and optionally labels.\n+\n+    If necessary, the view limits of the Axis are expanded so that all\n+    given ticks are visible.\n+\n+    Parameters\n+    ----------\n+    ticks : list of floats\n+        List of tick locations.  The axis `.Locator` is replaced by a\n+        `~.ticker.FixedLocator`.\n+\n+        Some tick formatters will not label arbitrary tick positions;\n+        e.g. log formatters only label decade ticks.\n+\n+    labels : list of str, optional\n+        List of tick labels. If not set, the labels are generated with\n+        the axis tick `.Formatter`.\n+\n+    minor : bool, default: False\n+        If ``False``, set the major ticks; if ``True``, the minor ticks.\n+\n+    **kwargs\n+        `.Text` properties for the labels. These take effect only if you\n+        pass *labels*. In other cases, please use `~.Axes.tick_params`.\n+\n+    Notes\n+    -----\n+    The mandatory expansion of the view limits is an intentional design\n+    choice to prevent the surprise of a non-visible tick. If you need\n+    other behavior, use `~.Axes.tick_params` combined with\n+    `~.ticker.FixedLocator`.\n+\n+    Some tick formatters will not label arbitrary tick positions;\n+    e.g. log formatters only label decade ticks.\n+\n+    Examples\n+    --------\n+    >>> ax.set_xticks([0, 1, 2])\n+    >>> ax.set_xticks([0, 1, 2], ['a', 'b', 'c'])\n+    >>> ax.set_xticks([0, 1, 2], ['a', 'b', 'c'], fontsize=16)\n+    >>> ax.set_xticks([0, 1, 2], labels=['a', 'b', 'c'],\n+    ...                fontweight='bold', color='red')\n+    \"\"\"\n+    result = self._set_tick_locations(ticks, minor=minor)\n+    if labels is not None:\n+        self.set_ticklabels(labels, minor=minor, **kwargs)\n+    elif kwargs:\n+        # Validate kwargs even when labels is None by using existing tick\n+        if minor:\n+            existing_ticks = self.get_minor_ticks(1)\n+        else:\n+            existing_ticks = self.get_major_ticks(1)\n+        if existing_ticks:\n+            # Use the first tick's label to validate Text properties\n+            existing_ticks[0].label1._internal_update(kwargs)\n+    return result\n     get_xmajorticklabels = _axis_method_wrapper(\"xaxis\", \"get_majorticklabels\")\n     get_xminorticklabels = _axis_method_wrapper(\"xaxis\", \"get_minorticklabels\")\n     get_xticklabels = _axis_method_wrapper(\"xaxis\", \"get_ticklabels\")\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex af0815d41d..f7027eace1 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1520,6 +1520,7 @@ class Axis(martist.Artist):\n         \"\"\"Get the formatter of the minor ticker.\"\"\"\n         return self.minor.formatter\n \n+\n     def get_major_ticks(self, numticks=None):\n         r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n         if numticks is None:\n@@ -1529,15 +1530,25 @@ class Axis(martist.Artist):\n             # Update the new tick label properties from the old.\n             tick = self._get_tick(major=True)\n             self.majorTicks.append(tick)\n-            self._copy_tick_props(self.majorTicks[0], tick)\n+            if len(self.majorTicks) > 1:\n+                self._copy_tick_props(self.majorTicks[0], tick)\n \n         return self.majorTicks[:numticks]\n \n+\n     def get_minor_ticks(self, numticks=None):\n         r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n         if numticks is None:\n             numticks = len(self.get_minorticklocs())\n \n+        while len(self.minorTicks) < numticks:\n+            # Update the new tick label properties from the old.\n+            tick = self._get_tick(major=False)\n+            self.minorTicks.append(tick)\n+            if len(self.minorTicks) > 1:\n+                self._copy_tick_props(self.minorTicks[0], tick)\n+\n+        return self.minorTicks[:numticks]\n         while len(self.minorTicks) < numticks:\n             # Update the new tick label properties from the old.\n             tick = self._get_tick(major=False)\n@@ -2021,9 +2032,18 @@ class Axis(martist.Artist):\n         other limits, you should set the limits explicitly after setting the\n         ticks.\n         \"\"\"\n+\n         result = self._set_tick_locations(ticks, minor=minor)\n         if labels is not None:\n             self.set_ticklabels(labels, minor=minor, **kwargs)\n+        elif kwargs:\n+            # Validate kwargs even when labels is None by testing on existing tick\n+            if minor:\n+                tick = self.get_minor_ticks(1)[0]\n+            else:\n+                tick = self.get_major_ticks(1)[0]\n+            # Validate kwargs without applying them\n+            tick.label1._internal_update(kwargs)\n         return result\n \n     def _get_tick_boxes_siblings(self, renderer):\n",
    "variant_1": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1ca1c1d3e3..d777b30e44 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1176,6 +1176,7 @@ class Artist:\n         return self._update_props(\n             props, \"{cls.__name__!r} object has no property {prop_name!r}\")\n \n+\n     def _internal_update(self, kwargs):\n         \"\"\"\n         Update artist properties without prenormalizing them, but generating\ndiff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 015fd32945..4923136554 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3738,7 +3738,62 @@ class _AxesBase(martist.Artist):\n     get_xscale = _axis_method_wrapper(\"xaxis\", \"get_scale\")\n     set_xscale = _axis_method_wrapper(\"xaxis\", \"_set_axes_scale\")\n     get_xticks = _axis_method_wrapper(\"xaxis\", \"get_ticklocs\")\n-    set_xticks = _axis_method_wrapper(\"xaxis\", \"set_ticks\")\n+\n+def set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n+    \"\"\"\n+    Set this Axis' tick locations and optionally labels.\n+\n+    If necessary, the view limits of the Axis are expanded so that all\n+    given ticks are visible.\n+\n+    Parameters\n+    ----------\n+    ticks : list of floats\n+        List of tick locations.  The axis `.Locator` is replaced by a\n+        `~.ticker.FixedLocator`.\n+\n+        Some tick formatters will not label arbitrary tick positions;\n+        e.g. log formatters only label decade ticks.\n+\n+    labels : list of str, optional\n+        List of tick labels. If not set, the labels are generated with\n+        the axis tick `.Formatter`.\n+\n+    minor : bool, default: False\n+        If ``False``, set the major ticks; if ``True``, the minor ticks.\n+\n+    **kwargs\n+        `.Text` properties for the labels. These take effect only if you\n+        pass *labels*. In other cases, please use `~.Axes.tick_params`.\n+\n+    Notes\n+    -----\n+    The mandatory expansion of the view limits is an intentional design\n+    choice to prevent the surprise of a non-visible tick. If you need\n+    other behavior, use `~.Axis.set_major_locator` or\n+    `~.Axis.set_minor_locator` to explicitly control the ticking.\n+\n+    The focus of this method is to set the tick positions. To control\n+    tick formatting, use one of the formatting-related methods or\n+    properties of the `Axis`, e.g. `.Axis.set_major_formatter` or\n+    `.Axis.set_minor_formatter`.\n+\n+    Examples\n+    --------\n+    >>> ax.set_xticks([1, 2, 3])\n+    >>> ax.set_xticks([1, 2, 3], ['red', 'green', 'blue'])\n+    \"\"\"\n+    result = self._set_tick_locations(ticks, minor=minor)\n+    if labels is not None:\n+        self.set_ticklabels(labels, minor=minor, **kwargs)\n+    elif kwargs:\n+        # Validate kwargs even when labels are not being set\n+        # Get at least one existing tick to validate Text properties\n+        existing_ticks = self.get_minor_ticks(1) if minor else self.get_major_ticks(1)\n+        if existing_ticks:\n+            # Use the first tick's label to validate kwargs without applying them\n+            existing_ticks[0].label1._internal_update(kwargs)\n+    return result\n     get_xmajorticklabels = _axis_method_wrapper(\"xaxis\", \"get_majorticklabels\")\n     get_xminorticklabels = _axis_method_wrapper(\"xaxis\", \"get_minorticklabels\")\n     get_xticklabels = _axis_method_wrapper(\"xaxis\", \"get_ticklabels\")\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex af0815d41d..20560203bc 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1520,6 +1520,7 @@ class Axis(martist.Artist):\n         \"\"\"Get the formatter of the minor ticker.\"\"\"\n         return self.minor.formatter\n \n+\n     def get_major_ticks(self, numticks=None):\n         r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n         if numticks is None:\n@@ -1533,11 +1534,20 @@ class Axis(martist.Artist):\n \n         return self.majorTicks[:numticks]\n \n+\n     def get_minor_ticks(self, numticks=None):\n         r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n         if numticks is None:\n             numticks = len(self.get_minorticklocs())\n \n+        while len(self.minorTicks) < numticks:\n+            # Update the new tick label properties from the old.\n+            tick = self._get_tick(major=False)\n+            self.minorTicks.append(tick)\n+            if len(self.minorTicks) > 1:\n+                self._copy_tick_props(self.minorTicks[0], tick)\n+\n+        return self.minorTicks[:numticks]\n         while len(self.minorTicks) < numticks:\n             # Update the new tick label properties from the old.\n             tick = self._get_tick(major=False)\n@@ -2021,9 +2031,15 @@ class Axis(martist.Artist):\n         other limits, you should set the limits explicitly after setting the\n         ticks.\n         \"\"\"\n+\n         result = self._set_tick_locations(ticks, minor=minor)\n         if labels is not None:\n             self.set_ticklabels(labels, minor=minor, **kwargs)\n+        elif kwargs:\n+            # Validate kwargs even when labels is None by testing against existing tick\n+            existing_ticks = self.get_minor_ticks(1) if minor else self.get_major_ticks(1)\n+            if existing_ticks:\n+                existing_ticks[0].label1._internal_update(kwargs)\n         return result\n \n     def _get_tick_boxes_siblings(self, renderer):\n",
    "variant_2": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1ca1c1d3e3..4faba2222c 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1176,16 +1176,17 @@ class Artist:\n         return self._update_props(\n             props, \"{cls.__name__!r} object has no property {prop_name!r}\")\n \n-    def _internal_update(self, kwargs):\n-        \"\"\"\n-        Update artist properties without prenormalizing them, but generating\n-        errors as if calling `set`.\n \n-        The lack of prenormalization is to maintain backcompatibility.\n-        \"\"\"\n-        return self._update_props(\n-            kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n-            \"{prop_name!r}\")\n+def _internal_update(self, kwargs):\n+    \"\"\"\n+    Update artist properties without prenormalizing them, but generating\n+    errors as if calling `set`.\n+\n+    The lack of prenormalization is to maintain backcompatibility.\n+    \"\"\"\n+    return self._update_props(\n+        kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n+        \"{prop_name!r}\")\n \n     def set(self, **kwargs):\n         # docstring and signature are auto-generated via\ndiff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 015fd32945..3e4c27cfff 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3738,7 +3738,54 @@ class _AxesBase(martist.Artist):\n     get_xscale = _axis_method_wrapper(\"xaxis\", \"get_scale\")\n     set_xscale = _axis_method_wrapper(\"xaxis\", \"_set_axes_scale\")\n     get_xticks = _axis_method_wrapper(\"xaxis\", \"get_ticklocs\")\n-    set_xticks = _axis_method_wrapper(\"xaxis\", \"set_ticks\")\n+\n+def set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n+    \"\"\"\n+    Set this Axis' tick locations and optionally labels.\n+\n+    If necessary, the view limits of the Axis are expanded so that all\n+    given ticks are visible.\n+\n+    Parameters\n+    ----------\n+    ticks : list of floats\n+        List of tick locations.  The axis `.Locator` is replaced by a\n+        `~.ticker.FixedLocator`.\n+\n+        Some tick formatters will not label arbitrary tick positions;\n+        e.g. log formatters only label decade ticks.\n+\n+    labels : list of str, optional\n+        List of tick labels. If not set, the labels are generated with\n+        the axis tick `.Formatter`.\n+\n+    minor : bool, default: False\n+        If ``False``, set the major ticks; if ``True``, the minor ticks.\n+\n+    **kwargs\n+        `.Text` properties for the labels. These take effect only if you\n+        pass *labels*. In other cases, please use `~.Axes.tick_params`.\n+\n+    Notes\n+    -----\n+    The mandatory expansion of the view limits is an intentional design\n+    choice to prevent the surprise of a non-visible tick. If you need\n+    other behavior, use `~.Axis.set_major_locator` or\n+    `~.Axis.set_minor_locator` and `~.Axis.set_major_formatter` or\n+    `~.Axis.set_minor_formatter`.\n+    \"\"\"\n+    result = self._set_tick_locations(ticks, minor=minor)\n+    if labels is not None:\n+        self.set_ticklabels(labels, minor=minor, **kwargs)\n+    elif kwargs:\n+        # Validate kwargs even when labels is None by using existing tick objects\n+        if minor:\n+            existing_ticks = self.get_minor_ticks(1)\n+        else:\n+            existing_ticks = self.get_major_ticks(1)\n+        # Use the first tick's label to validate the kwargs\n+        existing_ticks[0].label1._internal_update(kwargs)\n+    return result\n     get_xmajorticklabels = _axis_method_wrapper(\"xaxis\", \"get_majorticklabels\")\n     get_xminorticklabels = _axis_method_wrapper(\"xaxis\", \"get_minorticklabels\")\n     get_xticklabels = _axis_method_wrapper(\"xaxis\", \"get_ticklabels\")\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex af0815d41d..4f4c8f8179 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1520,6 +1520,7 @@ class Axis(martist.Artist):\n         \"\"\"Get the formatter of the minor ticker.\"\"\"\n         return self.minor.formatter\n \n+\n     def get_major_ticks(self, numticks=None):\n         r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n         if numticks is None:\n@@ -1533,11 +1534,20 @@ class Axis(martist.Artist):\n \n         return self.majorTicks[:numticks]\n \n+\n     def get_minor_ticks(self, numticks=None):\n         r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n         if numticks is None:\n             numticks = len(self.get_minorticklocs())\n \n+        while len(self.minorTicks) < numticks:\n+            # Update the new tick label properties from the old.\n+            tick = self._get_tick(major=False)\n+            self.minorTicks.append(tick)\n+            if len(self.minorTicks) > 1:\n+                self._copy_tick_props(self.minorTicks[0], tick)\n+\n+        return self.minorTicks[:numticks]\n         while len(self.minorTicks) < numticks:\n             # Update the new tick label properties from the old.\n             tick = self._get_tick(major=False)\n@@ -2021,9 +2031,18 @@ class Axis(martist.Artist):\n         other limits, you should set the limits explicitly after setting the\n         ticks.\n         \"\"\"\n+\n         result = self._set_tick_locations(ticks, minor=minor)\n         if labels is not None:\n             self.set_ticklabels(labels, minor=minor, **kwargs)\n+        elif kwargs:\n+            # Validate kwargs even when labels is None by testing on existing tick\n+            if minor:\n+                tick = self.get_minor_ticks(1)[0]\n+            else:\n+                tick = self.get_major_ticks(1)[0]\n+            # Validate Text properties without applying them\n+            tick.label1._internal_update(kwargs)\n         return result\n \n     def _get_tick_boxes_siblings(self, renderer):\n",
    "variant_3": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1ca1c1d3e3..4faba2222c 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1176,16 +1176,17 @@ class Artist:\n         return self._update_props(\n             props, \"{cls.__name__!r} object has no property {prop_name!r}\")\n \n-    def _internal_update(self, kwargs):\n-        \"\"\"\n-        Update artist properties without prenormalizing them, but generating\n-        errors as if calling `set`.\n \n-        The lack of prenormalization is to maintain backcompatibility.\n-        \"\"\"\n-        return self._update_props(\n-            kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n-            \"{prop_name!r}\")\n+def _internal_update(self, kwargs):\n+    \"\"\"\n+    Update artist properties without prenormalizing them, but generating\n+    errors as if calling `set`.\n+\n+    The lack of prenormalization is to maintain backcompatibility.\n+    \"\"\"\n+    return self._update_props(\n+        kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n+        \"{prop_name!r}\")\n \n     def set(self, **kwargs):\n         # docstring and signature are auto-generated via\ndiff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 015fd32945..b7b893353a 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3738,7 +3738,55 @@ class _AxesBase(martist.Artist):\n     get_xscale = _axis_method_wrapper(\"xaxis\", \"get_scale\")\n     set_xscale = _axis_method_wrapper(\"xaxis\", \"_set_axes_scale\")\n     get_xticks = _axis_method_wrapper(\"xaxis\", \"get_ticklocs\")\n-    set_xticks = _axis_method_wrapper(\"xaxis\", \"set_ticks\")\n+\n+def set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n+    \"\"\"\n+    Set this Axis' tick locations and optionally labels.\n+\n+    If necessary, the view limits of the Axis are expanded so that all\n+    given ticks are visible.\n+\n+    Parameters\n+    ----------\n+    ticks : list of floats\n+        List of tick locations.  The axis `.Locator` is replaced by a\n+        `~.ticker.FixedLocator`.\n+\n+        Some tick formatters will not label arbitrary tick positions;\n+        e.g. log formatters only label decade ticks.\n+\n+    labels : list of str, optional\n+        List of tick labels. If not set, the labels are generated with\n+        the axis tick `.Formatter`.\n+\n+    minor : bool, default: False\n+        If ``False``, set the major ticks; if ``True``, the minor ticks.\n+\n+    **kwargs\n+        `.Text` properties for the labels. These take effect only if you\n+        pass *labels*. In other cases, please use `~.Axes.tick_params`.\n+\n+    Notes\n+    -----\n+    The mandatory expansion of the view limits is an intentional design\n+    choice to prevent the surprise of a non-visible tick. If you need\n+    other behavior, use `~.Axis.set_major_locator` or\n+    `~.Axis.set_minor_locator` to set a `~.ticker.Locator` object on a\n+    given axis.\n+    \"\"\"\n+    result = self._set_tick_locations(ticks, minor=minor)\n+    if labels is not None:\n+        self.set_ticklabels(labels, minor=minor, **kwargs)\n+    elif kwargs:\n+        # Validate kwargs even when labels is None by testing on existing ticks\n+        if minor:\n+            existing_ticks = self.get_minor_ticks(1)\n+        else:\n+            existing_ticks = self.get_major_ticks(1)\n+        if existing_ticks:\n+            # Validate kwargs using existing tick's label without modifying it\n+            existing_ticks[0].label1._internal_update(kwargs)\n+    return result\n     get_xmajorticklabels = _axis_method_wrapper(\"xaxis\", \"get_majorticklabels\")\n     get_xminorticklabels = _axis_method_wrapper(\"xaxis\", \"get_minorticklabels\")\n     get_xticklabels = _axis_method_wrapper(\"xaxis\", \"get_ticklabels\")\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex af0815d41d..03f56682a2 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1520,6 +1520,7 @@ class Axis(martist.Artist):\n         \"\"\"Get the formatter of the minor ticker.\"\"\"\n         return self.minor.formatter\n \n+\n     def get_major_ticks(self, numticks=None):\n         r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n         if numticks is None:\n@@ -1533,11 +1534,20 @@ class Axis(martist.Artist):\n \n         return self.majorTicks[:numticks]\n \n-    def get_minor_ticks(self, numticks=None):\n-        r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n-        if numticks is None:\n-            numticks = len(self.get_minorticklocs())\n \n+def get_minor_ticks(self, numticks=None):\n+    r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n+    if numticks is None:\n+        numticks = len(self.get_minorticklocs())\n+\n+    while len(self.minorTicks) < numticks:\n+        # Update the new tick label properties from the old.\n+        tick = self._get_tick(major=False)\n+        self.minorTicks.append(tick)\n+        if len(self.minorTicks) > 1:\n+            self._copy_tick_props(self.minorTicks[0], tick)\n+\n+    return self.minorTicks[:numticks]\n         while len(self.minorTicks) < numticks:\n             # Update the new tick label properties from the old.\n             tick = self._get_tick(major=False)\n@@ -2021,9 +2031,18 @@ class Axis(martist.Artist):\n         other limits, you should set the limits explicitly after setting the\n         ticks.\n         \"\"\"\n+\n         result = self._set_tick_locations(ticks, minor=minor)\n         if labels is not None:\n             self.set_ticklabels(labels, minor=minor, **kwargs)\n+        elif kwargs:\n+            # Validate kwargs even when labels is None by testing on existing tick\n+            if minor:\n+                existing_tick = self.get_minor_ticks(1)[0]\n+            else:\n+                existing_tick = self.get_major_ticks(1)[0]\n+            # Validate kwargs without applying them\n+            existing_tick.label1._internal_update(kwargs)\n         return result\n \n     def _get_tick_boxes_siblings(self, renderer):\n",
    "variant_4": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1ca1c1d3e3..4faba2222c 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1176,16 +1176,17 @@ class Artist:\n         return self._update_props(\n             props, \"{cls.__name__!r} object has no property {prop_name!r}\")\n \n-    def _internal_update(self, kwargs):\n-        \"\"\"\n-        Update artist properties without prenormalizing them, but generating\n-        errors as if calling `set`.\n \n-        The lack of prenormalization is to maintain backcompatibility.\n-        \"\"\"\n-        return self._update_props(\n-            kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n-            \"{prop_name!r}\")\n+def _internal_update(self, kwargs):\n+    \"\"\"\n+    Update artist properties without prenormalizing them, but generating\n+    errors as if calling `set`.\n+\n+    The lack of prenormalization is to maintain backcompatibility.\n+    \"\"\"\n+    return self._update_props(\n+        kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n+        \"{prop_name!r}\")\n \n     def set(self, **kwargs):\n         # docstring and signature are auto-generated via\ndiff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 015fd32945..4958492eb4 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3738,7 +3738,53 @@ class _AxesBase(martist.Artist):\n     get_xscale = _axis_method_wrapper(\"xaxis\", \"get_scale\")\n     set_xscale = _axis_method_wrapper(\"xaxis\", \"_set_axes_scale\")\n     get_xticks = _axis_method_wrapper(\"xaxis\", \"get_ticklocs\")\n-    set_xticks = _axis_method_wrapper(\"xaxis\", \"set_ticks\")\n+\n+    def set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n+        \"\"\"\n+        Set this Axis' tick locations and optionally labels.\n+\n+        If necessary, the view limits of the Axis are expanded so that all\n+        given ticks are visible.\n+\n+        Parameters\n+        ----------\n+        ticks : list of floats\n+            List of tick locations.  The axis `.Locator` is replaced by a\n+            `~.ticker.FixedLocator`.\n+\n+            Some tick formatters will not label arbitrary tick positions;\n+            e.g. log formatters only label decade ticks.\n+\n+        labels : list of str, optional\n+            List of tick labels. If not set, the labels are generated with\n+            the axis tick `.Formatter`.\n+\n+        minor : bool, default: False\n+            If ``False``, set the major ticks; if ``True``, the minor ticks.\n+\n+        **kwargs\n+            `.Text` properties for the labels. These take effect only if you\n+            pass *labels*. In other cases, please use `~.Axes.tick_params`.\n+\n+        Notes\n+        -----\n+        The mandatory expansion of the view limits is an intentional design\n+        choice to prevent the surprise of a non-visible tick. If you need\n+        other behavior, use `~.Axes.tick_params` and\n+        `~.ticker.Locator.tick_values`.\n+        \"\"\"\n+        result = self._set_tick_locations(ticks, minor=minor)\n+        if labels is not None:\n+            self.set_ticklabels(labels, minor=minor, **kwargs)\n+        elif kwargs:\n+            # Validate kwargs even when labels is None by using existing tick objects\n+            if minor:\n+                existing_ticks = self.get_minor_ticks(1)\n+            else:\n+                existing_ticks = self.get_major_ticks(1)\n+            # Use the first tick's label to validate Text properties\n+            existing_ticks[0].label1._internal_update(kwargs)\n+        return result\n     get_xmajorticklabels = _axis_method_wrapper(\"xaxis\", \"get_majorticklabels\")\n     get_xminorticklabels = _axis_method_wrapper(\"xaxis\", \"get_minorticklabels\")\n     get_xticklabels = _axis_method_wrapper(\"xaxis\", \"get_ticklabels\")\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex af0815d41d..dd3414d484 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1520,6 +1520,7 @@ class Axis(martist.Artist):\n         \"\"\"Get the formatter of the minor ticker.\"\"\"\n         return self.minor.formatter\n \n+\n     def get_major_ticks(self, numticks=None):\n         r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n         if numticks is None:\n@@ -1529,15 +1530,25 @@ class Axis(martist.Artist):\n             # Update the new tick label properties from the old.\n             tick = self._get_tick(major=True)\n             self.majorTicks.append(tick)\n-            self._copy_tick_props(self.majorTicks[0], tick)\n+            if len(self.majorTicks) > 1:\n+                self._copy_tick_props(self.majorTicks[0], tick)\n \n         return self.majorTicks[:numticks]\n \n-    def get_minor_ticks(self, numticks=None):\n-        r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n-        if numticks is None:\n-            numticks = len(self.get_minorticklocs())\n \n+def get_minor_ticks(self, numticks=None):\n+    r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n+    if numticks is None:\n+        numticks = len(self.get_minorticklocs())\n+\n+    while len(self.minorTicks) < numticks:\n+        # Update the new tick label properties from the old.\n+        tick = self._get_tick(major=False)\n+        self.minorTicks.append(tick)\n+        if len(self.minorTicks) > 1:\n+            self._copy_tick_props(self.minorTicks[0], tick)\n+\n+    return self.minorTicks[:numticks]\n         while len(self.minorTicks) < numticks:\n             # Update the new tick label properties from the old.\n             tick = self._get_tick(major=False)\n@@ -2021,9 +2032,16 @@ class Axis(martist.Artist):\n         other limits, you should set the limits explicitly after setting the\n         ticks.\n         \"\"\"\n+\n         result = self._set_tick_locations(ticks, minor=minor)\n         if labels is not None:\n             self.set_ticklabels(labels, minor=minor, **kwargs)\n+        elif kwargs:\n+            # Validate kwargs even when labels is None by testing on existing tick\n+            existing_ticks = self.get_minor_ticks(1) if minor else self.get_major_ticks(1)\n+            if existing_ticks:\n+                # Use _internal_update to validate Text properties without applying them\n+                existing_ticks[0].label1._internal_update(kwargs)\n         return result\n \n     def _get_tick_boxes_siblings(self, renderer):\n",
    "variant_5": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1ca1c1d3e3..a81847ab7d 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1176,16 +1176,54 @@ class Artist:\n         return self._update_props(\n             props, \"{cls.__name__!r} object has no property {prop_name!r}\")\n \n-    def _internal_update(self, kwargs):\n-        \"\"\"\n-        Update artist properties without prenormalizing them, but generating\n-        errors as if calling `set`.\n \n-        The lack of prenormalization is to maintain backcompatibility.\n-        \"\"\"\n-        return self._update_props(\n-            kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n-            \"{prop_name!r}\")\n+def set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n+    \"\"\"\n+    Set this Axis' tick locations and optionally labels.\n+\n+    If necessary, the view limits of the Axis are expanded so that all\n+    given ticks are visible.\n+\n+    Parameters\n+    ----------\n+    ticks : list of floats\n+        List of tick locations.  The axis `.Locator` is replaced by a\n+        `~.ticker.FixedLocator`.\n+\n+        Some tick formatters will not label arbitrary tick positions;\n+        e.g. log formatters only label decade ticks.\n+\n+    labels : list of str, optional\n+        List of tick labels. If not set, the labels are generated with\n+        the axis tick `.Formatter`.\n+\n+    minor : bool, default: False\n+        If ``False``, set the major ticks; if ``True``, the minor ticks.\n+\n+    **kwargs\n+        `.Text` properties for the labels. These take effect only if you\n+        pass *labels*. In other cases, please use `~.Axes.tick_params`.\n+\n+    Notes\n+    -----\n+    The mandatory expansion of the view limits is an intentional design\n+    choice to prevent the surprise of a non-visible tick. If you need\n+    other behavior, use `~.Axis.set_major_locator` or\n+    `~.Axis.set_minor_locator` to set a `~.ticker.Locator` object on the\n+    respective axis.\n+    \"\"\"\n+    result = self._set_tick_locations(ticks, minor=minor)\n+    if labels is not None:\n+        self.set_ticklabels(labels, minor=minor, **kwargs)\n+    elif kwargs:\n+        # Validate kwargs even when labels=None by checking against existing tick\n+        if minor:\n+            tick = self.get_minor_ticks(1)[0]\n+        else:\n+            tick = self.get_major_ticks(1)[0]\n+        # Use _internal_update to validate Text properties without applying them\n+        tick.label1._internal_update(kwargs)\n+    return result\n \n     def set(self, **kwargs):\n         # docstring and signature are auto-generated via\ndiff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 015fd32945..e71fdddeff 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3738,7 +3738,50 @@ class _AxesBase(martist.Artist):\n     get_xscale = _axis_method_wrapper(\"xaxis\", \"get_scale\")\n     set_xscale = _axis_method_wrapper(\"xaxis\", \"_set_axes_scale\")\n     get_xticks = _axis_method_wrapper(\"xaxis\", \"get_ticklocs\")\n-    set_xticks = _axis_method_wrapper(\"xaxis\", \"set_ticks\")\n+\n+    def set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n+        \"\"\"\n+        Set this Axis' tick locations and optionally labels.\n+\n+        If necessary, the view limits of the Axis are expanded so that all\n+        given ticks are visible.\n+\n+        Parameters\n+        ----------\n+        ticks : list of floats\n+            List of tick locations.  The axis `.Locator` is replaced by a\n+            `~.ticker.FixedLocator`.\n+\n+            Some tick formatters will not label arbitrary tick positions;\n+            e.g. log formatters only label decade ticks by default. In\n+            such a case you can set a formatter explicitly on the axis\n+            using `.Axis.set_major_formatter` or provide formatted\n+            *labels* yourself.\n+        labels : list of str, optional\n+            List of tick labels. If not set, the labels are generated with\n+            the axis tick `.Formatter`.\n+        minor : bool, default: False\n+            If ``False``, set the major ticks; if ``True``, the minor ticks.\n+        **kwargs\n+            `.Text` properties for the labels. These take effect only if you\n+            pass *labels*. In other cases, please use `~.Axes.tick_params`.\n+\n+        Notes\n+        -----\n+        The mandatory expansion of the view limits is an intentional design\n+        choice to prevent the surprise of a non-visible tick. If you need\n+        other behavior, use `~.Axes.tick_params` and\n+        `~.ticker.Locator.tick_values`.\n+        \"\"\"\n+        result = self._set_tick_locations(ticks, minor=minor)\n+        if labels is not None:\n+            self.set_ticklabels(labels, minor=minor, **kwargs)\n+        elif kwargs:\n+            # Validate kwargs even when labels is None by using existing tick objects\n+            tick_getter = self.get_minor_ticks if minor else self.get_major_ticks\n+            existing_tick = tick_getter(1)[0]  # Get at least one tick to validate kwargs\n+            existing_tick.label1._internal_update(kwargs)  # This will raise AttributeError for invalid Text properties\n+        return result\n     get_xmajorticklabels = _axis_method_wrapper(\"xaxis\", \"get_majorticklabels\")\n     get_xminorticklabels = _axis_method_wrapper(\"xaxis\", \"get_minorticklabels\")\n     get_xticklabels = _axis_method_wrapper(\"xaxis\", \"get_ticklabels\")\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex af0815d41d..0b26f46821 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1520,6 +1520,7 @@ class Axis(martist.Artist):\n         \"\"\"Get the formatter of the minor ticker.\"\"\"\n         return self.minor.formatter\n \n+\n     def get_major_ticks(self, numticks=None):\n         r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n         if numticks is None:\n@@ -1533,11 +1534,20 @@ class Axis(martist.Artist):\n \n         return self.majorTicks[:numticks]\n \n+\n     def get_minor_ticks(self, numticks=None):\n         r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n         if numticks is None:\n             numticks = len(self.get_minorticklocs())\n \n+        while len(self.minorTicks) < numticks:\n+            # Update the new tick label properties from the old.\n+            tick = self._get_tick(major=False)\n+            self.minorTicks.append(tick)\n+            if len(self.minorTicks) > 1:\n+                self._copy_tick_props(self.minorTicks[0], tick)\n+\n+        return self.minorTicks[:numticks]\n         while len(self.minorTicks) < numticks:\n             # Update the new tick label properties from the old.\n             tick = self._get_tick(major=False)\n@@ -2021,9 +2031,18 @@ class Axis(martist.Artist):\n         other limits, you should set the limits explicitly after setting the\n         ticks.\n         \"\"\"\n+\n         result = self._set_tick_locations(ticks, minor=minor)\n         if labels is not None:\n             self.set_ticklabels(labels, minor=minor, **kwargs)\n+        elif kwargs:\n+            # Validate kwargs even when labels is None by testing on existing tick\n+            if minor:\n+                test_tick = self.get_minor_ticks(1)[0]\n+            else:\n+                test_tick = self.get_major_ticks(1)[0]\n+            # Use _internal_update to validate Text properties without applying them\n+            test_tick.label1._internal_update(kwargs)\n         return result\n \n     def _get_tick_boxes_siblings(self, renderer):\n",
    "variant_6": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1ca1c1d3e3..d777b30e44 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1176,6 +1176,7 @@ class Artist:\n         return self._update_props(\n             props, \"{cls.__name__!r} object has no property {prop_name!r}\")\n \n+\n     def _internal_update(self, kwargs):\n         \"\"\"\n         Update artist properties without prenormalizing them, but generating\ndiff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 015fd32945..26db321713 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3738,7 +3738,57 @@ class _AxesBase(martist.Artist):\n     get_xscale = _axis_method_wrapper(\"xaxis\", \"get_scale\")\n     set_xscale = _axis_method_wrapper(\"xaxis\", \"_set_axes_scale\")\n     get_xticks = _axis_method_wrapper(\"xaxis\", \"get_ticklocs\")\n-    set_xticks = _axis_method_wrapper(\"xaxis\", \"set_ticks\")\n+\n+def set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n+    \"\"\"\n+    Set this Axis' tick locations and optionally labels.\n+\n+    If necessary, the view limits of the Axis are expanded so that all\n+    given ticks are visible.\n+\n+    Parameters\n+    ----------\n+    ticks : list of floats\n+        List of tick locations.  The axis `.Locator` is replaced by a\n+        `~.ticker.FixedLocator`.\n+\n+        Some tick formatters will not label arbitrary tick positions;\n+        e.g. log formatters only label decade ticks.\n+\n+    labels : list of str, optional\n+        List of tick labels. If not set, the labels are generated with\n+        the axis tick `.Formatter`.\n+\n+    minor : bool, default: False\n+        If ``False``, set the major ticks; if ``True``, the minor ticks.\n+\n+    **kwargs\n+        `.Text` properties for the labels. These take effect only if you\n+        pass *labels*. In other cases, please use `~.Axes.tick_params`.\n+\n+    Notes\n+    -----\n+    The mandatory expansion of the view limits is an intentional design\n+    choice to prevent the surprise of a non-visible tick. If you need\n+    other behavior, use `~.Axis.set_major_locator` or\n+    `~.Axis.set_minor_locator` and `~.Axis.set_major_formatter` or\n+    `~.Axis.set_minor_formatter`.\n+    \"\"\"\n+    if labels is not None:\n+        self.set_ticklabels(labels, minor=minor, **kwargs)\n+    elif kwargs:\n+        # Validate kwargs even when labels is None by using existing tick\n+        if minor:\n+            existing_tick = self.get_minor_ticks(1)[0]\n+        else:\n+            existing_tick = self.get_major_ticks(1)[0]\n+        # Validate kwargs using existing tick's label without applying them\n+        existing_tick.label1._internal_update(kwargs)\n+    \n+    result = self.set_major_locator(mticker.FixedLocator(ticks))\n+    if minor:\n+        result = self.set_minor_locator(mticker.FixedLocator(ticks))\n+    return result\n     get_xmajorticklabels = _axis_method_wrapper(\"xaxis\", \"get_majorticklabels\")\n     get_xminorticklabels = _axis_method_wrapper(\"xaxis\", \"get_minorticklabels\")\n     get_xticklabels = _axis_method_wrapper(\"xaxis\", \"get_ticklabels\")\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex af0815d41d..1c3cb122eb 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1520,6 +1520,7 @@ class Axis(martist.Artist):\n         \"\"\"Get the formatter of the minor ticker.\"\"\"\n         return self.minor.formatter\n \n+\n     def get_major_ticks(self, numticks=None):\n         r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n         if numticks is None:\n@@ -1533,11 +1534,20 @@ class Axis(martist.Artist):\n \n         return self.majorTicks[:numticks]\n \n+\n     def get_minor_ticks(self, numticks=None):\n         r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n         if numticks is None:\n             numticks = len(self.get_minorticklocs())\n \n+        while len(self.minorTicks) < numticks:\n+            # Update the new tick label properties from the old.\n+            tick = self._get_tick(major=False)\n+            self.minorTicks.append(tick)\n+            if self.minorTicks:\n+                self._copy_tick_props(self.minorTicks[0], tick)\n+\n+        return self.minorTicks[:numticks]\n         while len(self.minorTicks) < numticks:\n             # Update the new tick label properties from the old.\n             tick = self._get_tick(major=False)\n@@ -2021,9 +2031,19 @@ class Axis(martist.Artist):\n         other limits, you should set the limits explicitly after setting the\n         ticks.\n         \"\"\"\n+\n         result = self._set_tick_locations(ticks, minor=minor)\n         if labels is not None:\n             self.set_ticklabels(labels, minor=minor, **kwargs)\n+        elif kwargs:\n+            # Validate kwargs even when labels is None by testing on existing ticks\n+            if minor:\n+                existing_ticks = self.get_minor_ticks(1)\n+            else:\n+                existing_ticks = self.get_major_ticks(1)\n+            if existing_ticks:\n+                # Use the first tick's label to validate kwargs without applying them\n+                existing_ticks[0].label1._internal_update(kwargs)\n         return result\n \n     def _get_tick_boxes_siblings(self, renderer):\n",
    "variant_7": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1ca1c1d3e3..d777b30e44 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1176,6 +1176,7 @@ class Artist:\n         return self._update_props(\n             props, \"{cls.__name__!r} object has no property {prop_name!r}\")\n \n+\n     def _internal_update(self, kwargs):\n         \"\"\"\n         Update artist properties without prenormalizing them, but generating\ndiff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 015fd32945..a4f4505981 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3738,7 +3738,61 @@ class _AxesBase(martist.Artist):\n     get_xscale = _axis_method_wrapper(\"xaxis\", \"get_scale\")\n     set_xscale = _axis_method_wrapper(\"xaxis\", \"_set_axes_scale\")\n     get_xticks = _axis_method_wrapper(\"xaxis\", \"get_ticklocs\")\n-    set_xticks = _axis_method_wrapper(\"xaxis\", \"set_ticks\")\n+\n+    def set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n+        \"\"\"\n+        Set this Axis' tick locations and optionally labels.\n+\n+        If necessary, the view limits of the Axis are expanded so that all\n+        given ticks are visible.\n+\n+        Parameters\n+        ----------\n+        ticks : list of floats\n+            List of tick locations.  The axis `.Locator` is replaced by a\n+            `~.ticker.FixedLocator`.\n+\n+            Some tick formatters will not label arbitrary tick positions;\n+            e.g. log formatters only label decade ticks.\n+\n+        labels : list of str, optional\n+            List of tick labels. If not set, the labels are generated with\n+            the axis tick `.Formatter`.\n+\n+        minor : bool, default: False\n+            If ``False``, set the major ticks; if ``True``, the minor ticks.\n+\n+        **kwargs\n+            `.Text` properties for the labels. These take effect only if you\n+            pass *labels*. In other cases, please use `~.Axes.tick_params`.\n+\n+        Notes\n+        -----\n+        The mandatory expansion of the view limits is an intentional design\n+        choice to prevent the surprise of a non-visible tick. If you need\n+        other behavior, use `~.Axis.set_major_locator` or\n+        `~.Axis.set_minor_locator` to explicitly control the ticking.\n+\n+        Examples\n+        --------\n+        >>> ax.set_xticks([1, 2, 3])\n+        >>> ax.set_xticks([1, 2, 3], ['A', 'B', 'C'])\n+        \"\"\"\n+        if labels is not None:\n+            self.set_ticklabels(labels, minor=minor, **kwargs)\n+        elif kwargs:\n+            # Validate kwargs even when labels is None by using existing tick objects\n+            existing_ticks = self.get_minor_ticks(1) if minor else self.get_major_ticks(1)\n+            if existing_ticks:\n+                # Use the first tick's label to validate kwargs without applying them\n+                existing_ticks[0].label1._internal_update(kwargs)\n+        \n+        self.set_major_locator(mticker.FixedLocator(ticks))\n+        if minor:\n+            self.set_minor_locator(mticker.FixedLocator(ticks))\n+        else:\n+            self.set_major_locator(mticker.FixedLocator(ticks))\n+        return self.get_ticklocs(minor=minor)\n     get_xmajorticklabels = _axis_method_wrapper(\"xaxis\", \"get_majorticklabels\")\n     get_xminorticklabels = _axis_method_wrapper(\"xaxis\", \"get_minorticklabels\")\n     get_xticklabels = _axis_method_wrapper(\"xaxis\", \"get_ticklabels\")\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex af0815d41d..390423cdfa 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1520,6 +1520,7 @@ class Axis(martist.Artist):\n         \"\"\"Get the formatter of the minor ticker.\"\"\"\n         return self.minor.formatter\n \n+\n     def get_major_ticks(self, numticks=None):\n         r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n         if numticks is None:\n@@ -1529,15 +1530,25 @@ class Axis(martist.Artist):\n             # Update the new tick label properties from the old.\n             tick = self._get_tick(major=True)\n             self.majorTicks.append(tick)\n-            self._copy_tick_props(self.majorTicks[0], tick)\n+            if len(self.majorTicks) > 1:\n+                self._copy_tick_props(self.majorTicks[0], tick)\n \n         return self.majorTicks[:numticks]\n \n-    def get_minor_ticks(self, numticks=None):\n-        r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n-        if numticks is None:\n-            numticks = len(self.get_minorticklocs())\n \n+def get_minor_ticks(self, numticks=None):\n+    r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n+    if numticks is None:\n+        numticks = len(self.get_minorticklocs())\n+\n+    while len(self.minorTicks) < numticks:\n+        # Update the new tick label properties from the old.\n+        tick = self._get_tick(major=False)\n+        self.minorTicks.append(tick)\n+        if len(self.minorTicks) > 1:\n+            self._copy_tick_props(self.minorTicks[0], tick)\n+\n+    return self.minorTicks[:numticks]\n         while len(self.minorTicks) < numticks:\n             # Update the new tick label properties from the old.\n             tick = self._get_tick(major=False)\n@@ -2021,9 +2032,16 @@ class Axis(martist.Artist):\n         other limits, you should set the limits explicitly after setting the\n         ticks.\n         \"\"\"\n+\n         result = self._set_tick_locations(ticks, minor=minor)\n         if labels is not None:\n             self.set_ticklabels(labels, minor=minor, **kwargs)\n+        elif kwargs:\n+            # Validate kwargs by testing them on existing tick labels\n+            existing_ticks = self.get_minor_ticks(1) if minor else self.get_major_ticks(1)\n+            if existing_ticks:\n+                # Use _internal_update to validate kwargs without applying them\n+                existing_ticks[0].label1._internal_update(kwargs)\n         return result\n \n     def _get_tick_boxes_siblings(self, renderer):\n",
    "variant_8": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1ca1c1d3e3..4faba2222c 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1176,16 +1176,17 @@ class Artist:\n         return self._update_props(\n             props, \"{cls.__name__!r} object has no property {prop_name!r}\")\n \n-    def _internal_update(self, kwargs):\n-        \"\"\"\n-        Update artist properties without prenormalizing them, but generating\n-        errors as if calling `set`.\n \n-        The lack of prenormalization is to maintain backcompatibility.\n-        \"\"\"\n-        return self._update_props(\n-            kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n-            \"{prop_name!r}\")\n+def _internal_update(self, kwargs):\n+    \"\"\"\n+    Update artist properties without prenormalizing them, but generating\n+    errors as if calling `set`.\n+\n+    The lack of prenormalization is to maintain backcompatibility.\n+    \"\"\"\n+    return self._update_props(\n+        kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n+        \"{prop_name!r}\")\n \n     def set(self, **kwargs):\n         # docstring and signature are auto-generated via\ndiff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 015fd32945..3cf13a903c 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3738,7 +3738,61 @@ class _AxesBase(martist.Artist):\n     get_xscale = _axis_method_wrapper(\"xaxis\", \"get_scale\")\n     set_xscale = _axis_method_wrapper(\"xaxis\", \"_set_axes_scale\")\n     get_xticks = _axis_method_wrapper(\"xaxis\", \"get_ticklocs\")\n-    set_xticks = _axis_method_wrapper(\"xaxis\", \"set_ticks\")\n+\n+def set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n+    \"\"\"\n+    Set this Axis' tick locations and optionally labels.\n+\n+    If necessary, the view limits of the Axis are expanded so that all\n+    given ticks are visible.\n+\n+    Parameters\n+    ----------\n+    ticks : list of floats\n+        List of tick locations.  The axis `.Locator` is replaced by a\n+        `~.ticker.FixedLocator`.\n+\n+        Some tick formatters will not label arbitrary tick positions;\n+        e.g. log formatters only label decade ticks.\n+\n+    labels : list of str, optional\n+        List of tick labels. If not set, the labels are generated with\n+        the axis tick `.Formatter`.\n+\n+    minor : bool, default: False\n+        If ``False``, set the major ticks; if ``True``, the minor ticks.\n+\n+    **kwargs\n+        `.Text` properties for the labels. These take effect only if you\n+        pass *labels*. In other cases, please use `~.Axes.tick_params`.\n+\n+    Notes\n+    -----\n+    The mandatory expansion of the view limits is an intentional design\n+    choice to prevent the surprise of a non-visible tick. If you need\n+    other behavior, use `~.Axis.set_major_locator` or\n+    `~.Axis.set_minor_locator`.\n+\n+    Examples\n+    --------\n+    >>> ax.set_xticks([1, 2, 3])\n+    >>> ax.set_xticks([1, 2, 3], ['A', 'B', 'C'])\n+    \"\"\"\n+    if labels is not None:\n+        self.set_ticklabels(labels, minor=minor, **kwargs)\n+    elif kwargs:\n+        # Validate kwargs even when labels is None by using existing tick\n+        if minor:\n+            existing_ticks = self.get_minor_ticks(1)\n+        else:\n+            existing_ticks = self.get_major_ticks(1)\n+        # Use the first tick's label to validate kwargs\n+        existing_ticks[0].label1._internal_update(kwargs)\n+    \n+    result = self.set_major_locator(mticker.FixedLocator(ticks))\n+    if minor:\n+        result = self.set_minor_locator(mticker.FixedLocator(ticks))\n+    return result\n     get_xmajorticklabels = _axis_method_wrapper(\"xaxis\", \"get_majorticklabels\")\n     get_xminorticklabels = _axis_method_wrapper(\"xaxis\", \"get_minorticklabels\")\n     get_xticklabels = _axis_method_wrapper(\"xaxis\", \"get_ticklabels\")\ndiff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex af0815d41d..cdd7358cca 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -1520,6 +1520,7 @@ class Axis(martist.Artist):\n         \"\"\"Get the formatter of the minor ticker.\"\"\"\n         return self.minor.formatter\n \n+\n     def get_major_ticks(self, numticks=None):\n         r\"\"\"Return the list of major `.Tick`\\s.\"\"\"\n         if numticks is None:\n@@ -1529,15 +1530,25 @@ class Axis(martist.Artist):\n             # Update the new tick label properties from the old.\n             tick = self._get_tick(major=True)\n             self.majorTicks.append(tick)\n-            self._copy_tick_props(self.majorTicks[0], tick)\n+            if len(self.majorTicks) > 1:\n+                self._copy_tick_props(self.majorTicks[0], tick)\n \n         return self.majorTicks[:numticks]\n \n+\n     def get_minor_ticks(self, numticks=None):\n         r\"\"\"Return the list of minor `.Tick`\\s.\"\"\"\n         if numticks is None:\n             numticks = len(self.get_minorticklocs())\n \n+        while len(self.minorTicks) < numticks:\n+            # Update the new tick label properties from the old.\n+            tick = self._get_tick(major=False)\n+            self.minorTicks.append(tick)\n+            if len(self.minorTicks) > 1:\n+                self._copy_tick_props(self.minorTicks[0], tick)\n+\n+        return self.minorTicks[:numticks]\n         while len(self.minorTicks) < numticks:\n             # Update the new tick label properties from the old.\n             tick = self._get_tick(major=False)\n@@ -2021,9 +2032,17 @@ class Axis(martist.Artist):\n         other limits, you should set the limits explicitly after setting the\n         ticks.\n         \"\"\"\n+\n         result = self._set_tick_locations(ticks, minor=minor)\n         if labels is not None:\n             self.set_ticklabels(labels, minor=minor, **kwargs)\n+        elif kwargs:\n+            # Validate kwargs even when labels is None by testing on existing tick\n+            if minor:\n+                existing_tick = self.get_minor_ticks(1)[0]\n+            else:\n+                existing_tick = self.get_major_ticks(1)[0]\n+            existing_tick.label1._internal_update(kwargs)\n         return result\n \n     def _get_tick_boxes_siblings(self, renderer):\n"
  }
}