{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/query_utils.py lines 115-152)": "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n        instance.__dict__[self.field.attname] = self.field.to_python(value)\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n",
    "Location 2 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 1010-1017)": "\n    def to_python(self, value):\n        if isinstance(value, str) or value is None:\n            return value\n        # Handle enum objects by converting to their string value\n        if hasattr(value, 'value'):\n            return str(value.value)\n        return str(value)\n\n    def get_prep_value(self, value):\n        value = super().get_prep_value(value)\n        return self.to_python(value)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/query_utils.py lines 115-152)": [
      "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n        instance.__dict__[self.field.attname] = self.field.to_python(value)\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n",
      "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n        instance.__dict__[self.field.attname] = self.field.to_python(value)\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n",
      "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n        instance.__dict__[self.field.attname] = self.field.to_python(value)\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n",
      "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n        instance.__dict__[self.field.attname] = self.field.to_python(value)\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n",
      "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n        instance.__dict__[self.field.attname] = self.field.to_python(value)\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n",
      "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n        instance.__dict__[self.field.attname] = self.field.to_python(value)\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n",
      "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n        instance.__dict__[self.field.attname] = self.field.to_python(value)\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n",
      "\nclass DeferredAttribute:\n    \"\"\"\n    A wrapper for a deferred-loading field. When the value is read from this\n    object the first time, the query is executed.\n    \"\"\"\n    def __init__(self, field):\n        self.field = field\n\n    def __get__(self, instance, cls=None):\n        \"\"\"\n        Retrieve and caches the value from the datastore on the first lookup.\n        Return the cached value.\n        \"\"\"\n        if instance is None:\n            return self\n        data = instance.__dict__\n        field_name = self.field.attname\n        if data.get(field_name, self) is self:\n            # Let's see if the field is part of the parent chain. If so we\n            # might be able to reuse the already loaded value. Refs #18343.\n            val = self._check_parent_chain(instance)\n            if val is None:\n                instance.refresh_from_db(fields=[field_name])\n                val = getattr(instance, field_name)\n            data[field_name] = val\n        return data[field_name]\n\n    def __set__(self, instance, value):\n        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n        instance.__dict__[self.field.attname] = self.field.to_python(value)\n\n    def _check_parent_chain(self, instance):\n        \"\"\"\n        Check if the field value can be fetched from a parent field already\n        loaded in the instance. This can be done if the to-be fetched\n        field is a primary key field.\n        \"\"\"\n        opts = instance._meta\n        link_field = opts.get_ancestor_link(self.field.model)\n        if self.field.primary_key and self.field != link_field:\n            return getattr(instance, link_field.attname)\n        return None\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 1010-1017)": [
      "\n    def to_python(self, value):\n        if isinstance(value, str) or value is None:\n            return value\n        # Handle enum objects by converting to their value\n        if hasattr(value, 'value'):\n            return str(value.value)\n        return str(value)\n\n    def get_prep_value(self, value):\n        value = super().get_prep_value(value)\n        return self.to_python(value)\n",
      "\n    def to_python(self, value):\n        if isinstance(value, str) or value is None:\n            return value\n        # Handle enum objects by converting to their string value\n        if hasattr(value, 'value'):\n            return str(value.value)\n        return str(value)\n\n    def get_prep_value(self, value):\n        value = super().get_prep_value(value)\n        return self.to_python(value)\n",
      "\n    def to_python(self, value):\n        if isinstance(value, str) or value is None:\n            return value\n        # Handle enum objects by converting to their value\n        if hasattr(value, 'value'):\n            return str(value.value)\n        return str(value)\n\n    def get_prep_value(self, value):\n        value = super().get_prep_value(value)\n        return self.to_python(value)\n",
      "\n    def to_python(self, value):\n        if isinstance(value, str) or value is None:\n            return value\n        # Handle enum objects by converting to their value\n        if hasattr(value, 'value'):\n            return str(value.value)\n        return str(value)\n\n    def get_prep_value(self, value):\n        value = super().get_prep_value(value)\n        return self.to_python(value)\n",
      "\n    def to_python(self, value):\n        if isinstance(value, str) or value is None:\n            return value\n        # Handle enum objects by converting to their string value\n        if hasattr(value, 'value'):\n            return str(value.value)\n        return str(value)\n\n    def get_prep_value(self, value):\n        value = super().get_prep_value(value)\n        return self.to_python(value)\n",
      "\n    def to_python(self, value):\n        if isinstance(value, str) or value is None:\n            return value\n        # Handle enum objects by converting to their string value\n        if hasattr(value, 'value') and hasattr(value, 'name'):\n            return str(value.value)\n        return str(value)\n\n    def get_prep_value(self, value):\n        value = super().get_prep_value(value)\n        return self.to_python(value)\n",
      "\n    def to_python(self, value):\n        if isinstance(value, str) or value is None:\n            return value\n        # Handle enum objects by converting to their value\n        if hasattr(value, 'value'):\n            return str(value.value)\n        return str(value)\n\n    def get_prep_value(self, value):\n        value = super().get_prep_value(value)\n        return self.to_python(value)\n",
      "\n    def to_python(self, value):\n        if isinstance(value, str) or value is None:\n            return value\n        # Handle enum objects by converting to their string value\n        if hasattr(value, 'value'):\n            return str(value.value)\n        return str(value)\n\n    def get_prep_value(self, value):\n        value = super().get_prep_value(value)\n        return self.to_python(value)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..21b7181adc 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1007,6 +1007,7 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..47cc4eaf85 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -112,6 +112,7 @@ class Q(tree.Node):\n \n \n class DeferredAttribute:\n+\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n     object the first time, the query is executed.\n@@ -138,6 +139,13 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"\n+        Convert and store the value using the field's to_python method.\n+        This ensures consistent behavior between fresh and database-retrieved instances.\n+        \"\"\"\n+        instance.__dict__[self.field.attname] = self.field.to_python(value)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,7 +158,6 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n-\n class RegisterLookupMixin:\n \n     @classmethod\n",
    "variant_0": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..594a7b9d69 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1007,9 +1007,13 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\n+        # Handle enum objects by converting to their string value\n+        if hasattr(value, 'value'):\n+            return str(value.value)\n         return str(value)\n \n     def get_prep_value(self, value):\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..4a134346d5 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,8 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+class DeferredAttribute:\n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +140,10 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n+        instance.__dict__[self.field.attname] = self.field.to_python(value)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,7 +156,6 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n-\n class RegisterLookupMixin:\n \n     @classmethod\n",
    "variant_1": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..a50338e1c9 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1007,9 +1007,13 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\n+        # Handle enum objects by converting to their value\n+        if hasattr(value, 'value'):\n+            return str(value.value)\n         return str(value)\n \n     def get_prep_value(self, value):\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..4a134346d5 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,8 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+class DeferredAttribute:\n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +140,10 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n+        instance.__dict__[self.field.attname] = self.field.to_python(value)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,7 +156,6 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n-\n class RegisterLookupMixin:\n \n     @classmethod\n",
    "variant_2": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..594a7b9d69 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1007,9 +1007,13 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\n+        # Handle enum objects by converting to their string value\n+        if hasattr(value, 'value'):\n+            return str(value.value)\n         return str(value)\n \n     def get_prep_value(self, value):\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..4a134346d5 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,8 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+class DeferredAttribute:\n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +140,10 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n+        instance.__dict__[self.field.attname] = self.field.to_python(value)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,7 +156,6 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n-\n class RegisterLookupMixin:\n \n     @classmethod\n",
    "variant_3": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..a50338e1c9 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1007,9 +1007,13 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\n+        # Handle enum objects by converting to their value\n+        if hasattr(value, 'value'):\n+            return str(value.value)\n         return str(value)\n \n     def get_prep_value(self, value):\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..4a134346d5 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,8 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+class DeferredAttribute:\n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +140,10 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n+        instance.__dict__[self.field.attname] = self.field.to_python(value)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,7 +156,6 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n-\n class RegisterLookupMixin:\n \n     @classmethod\n",
    "variant_4": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..a50338e1c9 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1007,9 +1007,13 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\n+        # Handle enum objects by converting to their value\n+        if hasattr(value, 'value'):\n+            return str(value.value)\n         return str(value)\n \n     def get_prep_value(self, value):\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..4a134346d5 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,8 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+class DeferredAttribute:\n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +140,10 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n+        instance.__dict__[self.field.attname] = self.field.to_python(value)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,7 +156,6 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n-\n class RegisterLookupMixin:\n \n     @classmethod\n",
    "variant_5": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..594a7b9d69 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1007,9 +1007,13 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\n+        # Handle enum objects by converting to their string value\n+        if hasattr(value, 'value'):\n+            return str(value.value)\n         return str(value)\n \n     def get_prep_value(self, value):\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..4a134346d5 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,8 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+class DeferredAttribute:\n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +140,10 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n+        instance.__dict__[self.field.attname] = self.field.to_python(value)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,7 +156,6 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n-\n class RegisterLookupMixin:\n \n     @classmethod\n",
    "variant_6": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..a6ac9ae96f 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1007,9 +1007,13 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\n+        # Handle enum objects by converting to their string value\n+        if hasattr(value, 'value') and hasattr(value, 'name'):\n+            return str(value.value)\n         return str(value)\n \n     def get_prep_value(self, value):\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..4a134346d5 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,8 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+class DeferredAttribute:\n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +140,10 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n+        instance.__dict__[self.field.attname] = self.field.to_python(value)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,7 +156,6 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n-\n class RegisterLookupMixin:\n \n     @classmethod\n",
    "variant_7": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..a50338e1c9 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1007,9 +1007,13 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\n+        # Handle enum objects by converting to their value\n+        if hasattr(value, 'value'):\n+            return str(value.value)\n         return str(value)\n \n     def get_prep_value(self, value):\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..4a134346d5 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,8 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+class DeferredAttribute:\n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +140,10 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n+        instance.__dict__[self.field.attname] = self.field.to_python(value)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,7 +156,6 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n-\n class RegisterLookupMixin:\n \n     @classmethod\n",
    "variant_8": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex d610dc86f0..594a7b9d69 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1007,9 +1007,13 @@ class CharField(Field):\n     def get_internal_type(self):\n         return \"CharField\"\n \n+\n     def to_python(self, value):\n         if isinstance(value, str) or value is None:\n             return value\n+        # Handle enum objects by converting to their string value\n+        if hasattr(value, 'value'):\n+            return str(value.value)\n         return str(value)\n \n     def get_prep_value(self, value):\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 189fb4fa44..4a134346d5 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -111,6 +111,8 @@ class Q(tree.Node):\n         return path, args, kwargs\n \n \n+class DeferredAttribute:\n+\n class DeferredAttribute:\n     \"\"\"\n     A wrapper for a deferred-loading field. When the value is read from this\n@@ -138,6 +140,10 @@ class DeferredAttribute:\n             data[field_name] = val\n         return data[field_name]\n \n+    def __set__(self, instance, value):\n+        \"\"\"Convert and store the value using the field's to_python method.\"\"\"\n+        instance.__dict__[self.field.attname] = self.field.to_python(value)\n+\n     def _check_parent_chain(self, instance):\n         \"\"\"\n         Check if the field value can be fetched from a parent field already\n@@ -150,7 +156,6 @@ class DeferredAttribute:\n             return getattr(instance, link_field.attname)\n         return None\n \n-\n class RegisterLookupMixin:\n \n     @classmethod\n"
  }
}