{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/matplotlib/lib/matplotlib/widgets.py lines 867-906)": "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif (event.name == \"button_release_event\") or (\n            event.name == \"button_press_event\" and event.inaxes != self.ax\n        ):\n            self.drag_active = False\n            try:\n                event.canvas.release_mouse(self.ax)\n            except Exception:\n                # Widget may have been destroyed, ignore cleanup errors\n                pass\n            self._active_handle = None\n            # Execute any deferred callbacks after mouse release\n            if hasattr(self, '_deferred_callback') and self._deferred_callback is not None:\n                try:\n                    self._deferred_callback()\n                finally:\n                    self._deferred_callback = None\n            return\n\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            self._update_val_from_pos(event.ydata)\n        else:\n            self._update_val_from_pos(event.xdata)\n",
    "Location 2 (/root/hy/projects_4/matplotlib/lib/matplotlib/widgets.py lines 942-980)": "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : tuple or array-like of float\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        # Reset value to allow _value_in_bounds() to work.\n        self.val = (self.valmin, self.valmax)\n        vmin, vmax = self._value_in_bounds(val)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        if self.eventson:\n            # Check if we're in the middle of a mouse operation\n            if hasattr(self, '_mouse_grabbed') and self._mouse_grabbed:\n                # Defer callback execution until mouse is released\n                self._deferred_callback = (vmin, vmax)\n            else:\n                self._observers.process(\"changed\", (vmin, vmax))\n\n    def on_changed(self, func):\n        \"\"\"\n        Connect *func* as callback function to changes of the slider value.\n\n        Parameters\n        ----------\n        func : callable\n            Function to call when slider is changed. The function\n            must accept a 2-tuple of floats as its argument.\n\n        Returns\n        -------\n        int\n            Connection id (which can be used to disconnect *func*).\n        \"\"\"\n        return self._observers.connect('changed', lambda val: func(val))\n",
    "Location 3 (/root/hy/projects_4/matplotlib/lib/matplotlib/widgets.py lines 852-866)": "\n    def _update_val_from_pos(self, pos):\n        \"\"\"Update the slider value based on a given position.\"\"\"\n        idx = np.argmin(np.abs(self.val - pos))\n        if idx == 0:\n            val = self._min_in_bounds(pos)\n            self.set_min(val, _defer_callback=getattr(self, 'drag_active', False))\n        else:\n            val = self._max_in_bounds(pos)\n            self.set_max(val, _defer_callback=getattr(self, 'drag_active', False))\n        if self._active_handle:\n            if self.orientation == \"vertical\":\n                self._active_handle.set_ydata([val])\n            else:\n                self._active_handle.set_xdata([val])\n",
    "Location 4 (/root/hy/projects_4/matplotlib/lib/matplotlib/widgets.py lines 922-941)": "\n    def set_min(self, min):\n        \"\"\"\n        Set the lower value of the slider to *min*.\n\n        Parameters\n        ----------\n        min : float\n        \"\"\"\n        self.set_val((min, self.val[1]), force_all=True)\n\n    def set_max(self, max):\n        \"\"\"\n        Set the lower value of the slider to *max*.\n\n        Parameters\n        ----------\n        max : float\n        \"\"\"\n        self.set_val((self.val[0], max), force_all=True)\n",
    "Location 5 (/root/hy/projects_4/matplotlib/lib/matplotlib/widgets.py lines 147-150)": "\n    def disconnect_events(self):\n        \"\"\"Disconnect all events created by this widget.\"\"\"\n        # Release any active mouse grab before disconnecting events\n        if hasattr(self, 'canvas') and self.canvas is not None:\n            try:\n                self.canvas.release_mouse(self.ax)\n            except (AttributeError, RuntimeError):\n                # Ignore errors if canvas or ax is already destroyed\n                pass\n        \n        for c in self._cids:\n            self.canvas.mpl_disconnect(c)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/matplotlib/lib/matplotlib/widgets.py lines 867-906)": [
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif (event.name == \"button_release_event\") or (\n            event.name == \"button_press_event\" and event.inaxes != self.ax\n        ):\n            self.drag_active = False\n            try:\n                event.canvas.release_mouse(self.ax)\n            except Exception:\n                # Widget may have been destroyed, continue with cleanup\n                pass\n            self._active_handle = None\n            # Execute any deferred callbacks after mouse release\n            if hasattr(self, '_deferred_callback') and self._deferred_callback:\n                try:\n                    self._deferred_callback()\n                except Exception:\n                    # Callback may destroy the widget, ignore errors\n                    pass\n                finally:\n                    self._deferred_callback = None\n            return\n\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            self._update_val_from_pos(event.ydata, during_drag=True)\n        else:\n            self._update_val_from_pos(event.xdata, during_drag=True)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif (event.name == \"button_release_event\") or (\n            event.name == \"button_press_event\" and event.inaxes != self.ax\n        ):\n            self.drag_active = False\n            try:\n                event.canvas.release_mouse(self.ax)\n            except Exception:\n                # Widget may have been destroyed, ignore errors\n                pass\n            self._active_handle = None\n            # Execute any deferred callbacks after mouse release\n            if hasattr(self, '_deferred_callbacks') and self._deferred_callbacks:\n                for callback in self._deferred_callbacks:\n                    try:\n                        callback()\n                    except Exception:\n                        # Ignore errors from destroyed widgets\n                        pass\n                self._deferred_callbacks.clear()\n            return\n\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            self._update_val_from_pos(event.ydata)\n        else:\n            self._update_val_from_pos(event.xdata)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif (event.name == \"button_release_event\") or (\n            event.name == \"button_press_event\" and event.inaxes != self.ax\n        ):\n            self.drag_active = False\n            try:\n                event.canvas.release_mouse(self.ax)\n            except Exception:\n                # Widget may have been destroyed, ignore release errors\n                pass\n            self._active_handle = None\n            # Execute any deferred callbacks after mouse release\n            if hasattr(self, '_deferred_callback') and self._deferred_callback:\n                try:\n                    self._deferred_callback()\n                    self._deferred_callback = None\n                except Exception:\n                    # If callback fails (e.g., widget destroyed), clear it\n                    self._deferred_callback = None\n            return\n\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            self._update_val_from_pos(event.ydata)\n        else:\n            self._update_val_from_pos(event.xdata)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif (event.name == \"button_release_event\") or (\n            event.name == \"button_press_event\" and event.inaxes != self.ax\n        ):\n            self.drag_active = False\n            try:\n                event.canvas.release_mouse(self.ax)\n            except Exception:\n                # Widget may have been destroyed, ignore cleanup errors\n                pass\n            self._active_handle = None\n            # Execute any deferred callbacks after mouse release\n            if hasattr(self, '_deferred_callbacks'):\n                for callback in self._deferred_callbacks:\n                    try:\n                        callback()\n                    except Exception:\n                        # Ignore callback errors to prevent cascading failures\n                        pass\n                self._deferred_callbacks.clear()\n            return\n\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            self._update_val_from_pos(event.ydata)\n        else:\n            self._update_val_from_pos(event.xdata)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif (event.name == \"button_release_event\") or (\n            event.name == \"button_press_event\" and event.inaxes != self.ax\n        ):\n            self.drag_active = False\n            try:\n                event.canvas.release_mouse(self.ax)\n            except Exception:\n                # Handle case where canvas/widget was destroyed during drag\n                pass\n            self._active_handle = None\n            # Execute any deferred callbacks after mouse operations complete\n            if hasattr(self, '_deferred_callbacks') and self._deferred_callbacks:\n                for callback in self._deferred_callbacks:\n                    try:\n                        callback()\n                    except Exception:\n                        # Ignore errors from callbacks that may reference destroyed objects\n                        pass\n                self._deferred_callbacks.clear()\n            return\n\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            self._update_val_from_pos(event.ydata)\n        else:\n            self._update_val_from_pos(event.xdata)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            try:\n                event.canvas.grab_mouse(self.ax)\n            except Exception:\n                # If grab_mouse fails, reset drag_active to prevent inconsistent state\n                self.drag_active = False\n                return\n\n        if not self.drag_active:\n            return\n\n        elif (event.name == \"button_release_event\") or (\n            event.name == \"button_press_event\" and event.inaxes != self.ax\n        ):\n            self.drag_active = False\n            try:\n                event.canvas.release_mouse(self.ax)\n            except Exception:\n                # Canvas might be destroyed, but we still need to clean up\n                pass\n            self._active_handle = None\n            # Execute any deferred callbacks now that mouse operations are complete\n            if hasattr(self, '_deferred_callback') and self._deferred_callback:\n                try:\n                    self._deferred_callback()\n                except Exception:\n                    # Callback might destroy the widget, handle gracefully\n                    pass\n                finally:\n                    self._deferred_callback = None\n            return\n\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            self._update_val_from_pos(event.ydata, during_drag=True)\n        else:\n            self._update_val_from_pos(event.xdata, during_drag=True)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif (event.name == \"button_release_event\") or (\n            event.name == \"button_press_event\" and event.inaxes != self.ax\n        ):\n            self.drag_active = False\n            try:\n                event.canvas.release_mouse(self.ax)\n            except Exception:\n                # Widget may have been destroyed, ignore release errors\n                pass\n            self._active_handle = None\n            # Execute any deferred callbacks after mouse is released\n            if hasattr(self, '_deferred_callback') and self._deferred_callback:\n                try:\n                    self._deferred_callback()\n                except Exception:\n                    # Widget may have been destroyed during callback\n                    pass\n                finally:\n                    self._deferred_callback = None\n            return\n\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            self._update_val_from_pos(event.ydata)\n        else:\n            self._update_val_from_pos(event.xdata)\n",
      "\n    def _update(self, event):\n        \"\"\"Update the slider position.\"\"\"\n        if self.ignore(event) or event.button != 1:\n            return\n\n        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n            self.drag_active = True\n            event.canvas.grab_mouse(self.ax)\n\n        if not self.drag_active:\n            return\n\n        elif (event.name == \"button_release_event\") or (\n            event.name == \"button_press_event\" and event.inaxes != self.ax\n        ):\n            self.drag_active = False\n            try:\n                event.canvas.release_mouse(self.ax)\n            except Exception:\n                # Handle case where canvas or widget was destroyed\n                pass\n            self._active_handle = None\n            # Execute any deferred callbacks after mouse release\n            if hasattr(self, '_deferred_callback') and self._deferred_callback:\n                try:\n                    self._deferred_callback()\n                except Exception:\n                    # Ignore errors from deferred callbacks to prevent crashes\n                    pass\n                finally:\n                    self._deferred_callback = None\n            return\n\n        # determine which handle was grabbed\n        if self.orientation == \"vertical\":\n            handle_index = np.argmin(\n                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n            )\n        else:\n            handle_index = np.argmin(\n                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n            )\n        handle = self._handles[handle_index]\n\n        # these checks ensure smooth behavior if the handles swap which one\n        # has a higher value. i.e. if one is dragged over and past the other.\n        if handle is not self._active_handle:\n            self._active_handle = handle\n\n        if self.orientation == \"vertical\":\n            self._update_val_from_pos(event.ydata, during_drag=True)\n        else:\n            self._update_val_from_pos(event.xdata, during_drag=True)\n"
    ],
    "Location 2 (/root/hy/projects_4/matplotlib/lib/matplotlib/widgets.py lines 942-980)": [
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : tuple or array-like of float\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        # Reset value to allow _value_in_bounds() to work.\n        self.val = (self.valmin, self.valmax)\n        vmin, vmax = self._value_in_bounds(val)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        if self.eventson:\n            # Check if we're in the middle of a mouse drag operation\n            # If so, defer the callback to prevent widget destruction during grab\n            if hasattr(self, '_mouse_grabbed') and self._mouse_grabbed:\n                # Store the callback for deferred execution\n                if not hasattr(self, '_deferred_callback'):\n                    self._deferred_callback = None\n                self._deferred_callback = (vmin, vmax)\n            else:\n                self._observers.process(\"changed\", (vmin, vmax))\n\n    def on_changed(self, func):\n        \"\"\"\n        Connect *func* as callback function to changes of the slider value.\n\n        Parameters\n        ----------\n        func : callable\n            Function to call when slider is changed. The function\n            must accept a 2-tuple of floats as its argument.\n",
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : tuple or array-like of float\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        # Reset value to allow _value_in_bounds() to work.\n        self.val = (self.valmin, self.valmax)\n        vmin, vmax = self._value_in_bounds(val)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        \n        # Check if we should defer callback execution during active mouse operations\n        defer_callbacks = getattr(self, '_mouse_grabbed', False)\n        \n        if self.eventson:\n            if defer_callbacks:\n                # Store the callback for later execution\n                self._deferred_callback = (vmin, vmax)\n            else:\n                self._observers.process(\"changed\", (vmin, vmax))\n\n    def on_changed(self, func):\n        \"\"\"\n        Connect *func* as callback function to changes of the slider value.\n\n        Parameters\n        ----------\n        func : callable\n            Function to call when slider is changed. The function\n            must accept a 2-tuple of floats as its argument.\n",
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : tuple or array-like of float\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        # Reset value to allow _value_in_bounds() to work.\n        self.val = (self.valmin, self.valmax)\n        vmin, vmax = self._value_in_bounds(val)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        if self.eventson:\n            # Check if mouse is currently grabbed - defer callback if so\n            if hasattr(self, '_mouse_grabbed') and self._mouse_grabbed:\n                # Store callback for deferred execution\n                if not hasattr(self, '_deferred_callbacks'):\n                    self._deferred_callbacks = []\n                self._deferred_callbacks.append(('changed', (vmin, vmax)))\n            else:\n                self._observers.process(\"changed\", (vmin, vmax))\n\n    def on_changed(self, func):\n        \"\"\"\n        Connect *func* as callback function to changes of the slider value.\n\n        Parameters\n        ----------\n        func : callable\n            Function to call when slider is changed. The function\n            must accept a 2-tuple of floats as its argument.\n",
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : tuple or array-like of float\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        # Reset value to allow _value_in_bounds() to work.\n        self.val = (self.valmin, self.valmax)\n        vmin, vmax = self._value_in_bounds(val)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        \n        # Check if we're currently in a drag operation to defer callback execution\n        if self.eventson:\n            if hasattr(self, '_mouse_grabbed') and self._mouse_grabbed:\n                # Defer callback execution during mouse grab\n                self._deferred_callback_val = (vmin, vmax)\n            else:\n                self._observers.process(\"changed\", (vmin, vmax))\n\n    def on_changed(self, func):\n        \"\"\"\n        Connect *func* as callback function to changes of the slider value.\n\n        Parameters\n        ----------\n        func : callable\n            Function to call when slider is changed. The function\n            must accept a 2-tuple of floats as its argument.\n",
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : tuple or array-like of float\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        # Reset value to allow _value_in_bounds() to work.\n        self.val = (self.valmin, self.valmax)\n        vmin, vmax = self._value_in_bounds(val)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        if self.eventson:\n            # Check if we're in the middle of a mouse drag operation\n            # If so, defer the callback to prevent widget destruction during grab\n            if hasattr(self, '_mouse_grabbed') and self._mouse_grabbed:\n                # Store the callback for deferred execution\n                if not hasattr(self, '_deferred_callbacks'):\n                    self._deferred_callbacks = []\n                self._deferred_callbacks.append(('changed', (vmin, vmax)))\n            else:\n                self._observers.process(\"changed\", (vmin, vmax))\n\n    def on_changed(self, func):\n        \"\"\"\n        Connect *func* as callback function to changes of the slider value.\n\n        Parameters\n        ----------\n        func : callable\n            Function to call when slider is changed. The function\n            must accept a 2-tuple of floats as its argument.\n",
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : tuple or array-like of float\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        # Reset value to allow _value_in_bounds() to work.\n        self.val = (self.valmin, self.valmax)\n        vmin, vmax = self._value_in_bounds(val)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        if self.eventson:\n            # Check if we're in the middle of a drag operation by looking for mouse grab\n            if hasattr(self.ax.figure.canvas, '_button') and self.ax.figure.canvas._button is not None:\n                # Defer callback execution during active mouse operations\n                if not hasattr(self, '_deferred_callbacks'):\n                    self._deferred_callbacks = []\n                self._deferred_callbacks.append(('changed', (vmin, vmax)))\n            else:\n                self._observers.process(\"changed\", (vmin, vmax))\n\n    def on_changed(self, func):\n        \"\"\"\n        Connect *func* as callback function to changes of the slider value.\n\n        Parameters\n        ----------\n        func : callable\n            Function to call when slider is changed. The function\n            must accept a 2-tuple of floats as its argument.\n        \"\"\"\n",
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : tuple or array-like of float\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        # Reset value to allow _value_in_bounds() to work.\n        self.val = (self.valmin, self.valmax)\n        vmin, vmax = self._value_in_bounds(val)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        \n        # Check if we're in the middle of a mouse drag operation\n        # If so, defer callback execution to avoid widget destruction during drag\n        if self.eventson:\n            if hasattr(self, '_mouse_grabbed') and self._mouse_grabbed:\n                # Store the callback for deferred execution\n                if not hasattr(self, '_deferred_callback'):\n                    self._deferred_callback = None\n                self._deferred_callback = (vmin, vmax)\n            else:\n                # Safe to execute callback immediately\n                self._observers.process(\"changed\", (vmin, vmax))\n\n    def on_changed(self, func):\n        \"\"\"\n        Connect *func* as callback function to changes of the slider value.\n\n        Parameters\n        ----------\n        func : callable\n            Function to call when slider is changed. The function\n            must accept a 2-tuple of floats as its argument.\n",
      "\n    def set_val(self, val):\n        \"\"\"\n        Set slider value to *val*.\n\n        Parameters\n        ----------\n        val : tuple or array-like of float\n        \"\"\"\n        val = np.sort(val)\n        _api.check_shape((2,), val=val)\n        # Reset value to allow _value_in_bounds() to work.\n        self.val = (self.valmin, self.valmax)\n        vmin, vmax = self._value_in_bounds(val)\n        self._update_selection_poly(vmin, vmax)\n        if self.orientation == \"vertical\":\n            self._handles[0].set_ydata([vmin])\n            self._handles[1].set_ydata([vmax])\n        else:\n            self._handles[0].set_xdata([vmin])\n            self._handles[1].set_xdata([vmax])\n\n        self.valtext.set_text(self._format((vmin, vmax)))\n\n        if self.drawon:\n            self.ax.figure.canvas.draw_idle()\n        self.val = (vmin, vmax)\n        if self.eventson:\n            # Check if we're in an active drag operation\n            if hasattr(self, '_active_drag') and self._active_drag:\n                # Defer callback execution until after mouse release\n                self._deferred_callback = (vmin, vmax)\n            else:\n                self._observers.process(\"changed\", (vmin, vmax))\n\n    def on_changed(self, func):\n        \"\"\"\n        Connect *func* as callback function to changes of the slider value.\n\n        Parameters\n        ----------\n        func : callable\n            Function to call when slider is changed. The function\n            must accept a 2-tuple of floats as its argument.\n\n        Returns\n        -------\n        int\n            Connection id (which can be used to disconnect *func*).\n        \"\"\"\n        return self._observers.connect('changed', lambda val: func(val))\n"
    ],
    "Location 3 (/root/hy/projects_4/matplotlib/lib/matplotlib/widgets.py lines 852-866)": [
      "\n    def _update_val_from_pos(self, pos):\n        \"\"\"Update the slider value based on a given position.\"\"\"\n        idx = np.argmin(np.abs(self.val - pos))\n        if idx == 0:\n            val = self._min_in_bounds(pos)\n            self.set_min(val, during_drag=True)\n        else:\n            val = self._max_in_bounds(pos)\n            self.set_max(val, during_drag=True)\n        if self._active_handle:\n            if self.orientation == \"vertical\":\n                self._active_handle.set_ydata([val])\n            else:\n                self._active_handle.set_xdata([val])\n",
      "\n    def _update_val_from_pos(self, pos):\n        \"\"\"Update the slider value based on a given position.\"\"\"\n        idx = np.argmin(np.abs(self.val - pos))\n        if idx == 0:\n            val = self._min_in_bounds(pos)\n            self.set_min(val, _during_drag=True)\n        else:\n            val = self._max_in_bounds(pos)\n            self.set_max(val, _during_drag=True)\n        if self._active_handle:\n            if self.orientation == \"vertical\":\n                self._active_handle.set_ydata([val])\n            else:\n                self._active_handle.set_xdata([val])\n",
      "\n    def _update_val_from_pos(self, pos):\n        \"\"\"Update the slider value based on a given position.\"\"\"\n        idx = np.argmin(np.abs(self.val - pos))\n        if idx == 0:\n            val = self._min_in_bounds(pos)\n            self.set_min(val, _during_drag=getattr(self, 'drag_active', False))\n        else:\n            val = self._max_in_bounds(pos)\n            self.set_max(val, _during_drag=getattr(self, 'drag_active', False))\n        if self._active_handle:\n            if self.orientation == \"vertical\":\n                self._active_handle.set_ydata([val])\n            else:\n                self._active_handle.set_xdata([val])\n",
      "\n    def _update_val_from_pos(self, pos):\n        \"\"\"Update the slider value based on a given position.\"\"\"\n        idx = np.argmin(np.abs(self.val - pos))\n        if idx == 0:\n            val = self._min_in_bounds(pos)\n            self.set_min(val, _during_drag=True)\n        else:\n            val = self._max_in_bounds(pos)\n            self.set_max(val, _during_drag=True)\n        if self._active_handle:\n            if self.orientation == \"vertical\":\n                self._active_handle.set_ydata([val])\n            else:\n                self._active_handle.set_xdata([val])\n",
      "\n    def _update_val_from_pos(self, pos):\n        \"\"\"Update the slider value based on a given position.\"\"\"\n        idx = np.argmin(np.abs(self.val - pos))\n        if idx == 0:\n            val = self._min_in_bounds(pos)\n            self.set_min(val, _defer_callback=getattr(self, 'drag_active', False))\n        else:\n            val = self._max_in_bounds(pos)\n            self.set_max(val, _defer_callback=getattr(self, 'drag_active', False))\n        if self._active_handle:\n            if self.orientation == \"vertical\":\n                self._active_handle.set_ydata([val])\n            else:\n                self._active_handle.set_xdata([val])\n",
      "\n    def _update_val_from_pos(self, pos):\n        \"\"\"Update the slider value based on a given position.\"\"\"\n        idx = np.argmin(np.abs(self.val - pos))\n        if idx == 0:\n            val = self._min_in_bounds(pos)\n            self.set_min(val, _during_drag=getattr(self, 'drag_active', False))\n        else:\n            val = self._max_in_bounds(pos)\n            self.set_max(val, _during_drag=getattr(self, 'drag_active', False))\n        if self._active_handle:\n            if self.orientation == \"vertical\":\n                self._active_handle.set_ydata([val])\n            else:\n                self._active_handle.set_xdata([val])\n",
      "\n    def _update_val_from_pos(self, pos):\n        \"\"\"Update the slider value based on a given position.\"\"\"\n        idx = np.argmin(np.abs(self.val - pos))\n        if idx == 0:\n            val = self._min_in_bounds(pos)\n            self.set_min(val, during_drag=True)\n        else:\n            val = self._max_in_bounds(pos)\n            self.set_max(val, during_drag=True)\n        if self._active_handle:\n            if self.orientation == \"vertical\":\n                self._active_handle.set_ydata([val])\n            else:\n                self._active_handle.set_xdata([val])\n",
      "\n    def _update_val_from_pos(self, pos):\n        \"\"\"Update the slider value based on a given position.\"\"\"\n        idx = np.argmin(np.abs(self.val - pos))\n        # Pass defer_callbacks flag to indicate we're in an active drag operation\n        if idx == 0:\n            val = self._min_in_bounds(pos)\n            self.set_min(val, defer_callbacks=getattr(self, 'drag_active', False))\n        else:\n            val = self._max_in_bounds(pos)\n            self.set_max(val, defer_callbacks=getattr(self, 'drag_active', False))\n        if self._active_handle:\n            if self.orientation == \"vertical\":\n                self._active_handle.set_ydata([val])\n            else:\n                self._active_handle.set_xdata([val])\n"
    ],
    "Location 4 (/root/hy/projects_4/matplotlib/lib/matplotlib/widgets.py lines 922-941)": [
      "\n    def set_min(self, min):\n        \"\"\"\n        Set the lower value of the slider to *min*.\n\n        Parameters\n        ----------\n        min : float\n        \"\"\"\n        self.set_val((min, self.val[1]), force_all=True)\n\n    def set_max(self, max):\n        \"\"\"\n        Set the lower value of the slider to *max*.\n\n        Parameters\n        ----------\n        max : float\n        \"\"\"\n        self.set_val((self.val[0], max), force_all=True)\n",
      "\n    def set_min(self, min):\n        \"\"\"\n        Set the lower value of the slider to *min*.\n\n        Parameters\n        ----------\n        min : float\n        \"\"\"\n        self.set_val((min, self.val[1]), force_all=True)\n\n    def set_max(self, max):\n        \"\"\"\n        Set the lower value of the slider to *max*.\n\n        Parameters\n        ----------\n        max : float\n        \"\"\"\n        self.set_val((self.val[0], max), force_all=True)\n",
      "\n    def set_min(self, min):\n        \"\"\"\n        Set the lower value of the slider to *min*.\n\n        Parameters\n        ----------\n        min : float\n        \"\"\"\n        self.set_val((min, self.val[1]), force_all=getattr(self, '_mouse_grabbed', False))\n\n    def set_max(self, max):\n        \"\"\"\n        Set the lower value of the slider to *max*.\n\n        Parameters\n        ----------\n        max : float\n        \"\"\"\n        self.set_val((self.val[0], max), force_all=getattr(self, '_mouse_grabbed', False))\n",
      "\n    def set_min(self, min):\n        \"\"\"\n        Set the lower value of the slider to *min*.\n\n        Parameters\n        ----------\n        min : float\n        \"\"\"\n        self.set_val((min, self.val[1]), force_all=True)\n\n    def set_max(self, max):\n        \"\"\"\n        Set the lower value of the slider to *max*.\n\n        Parameters\n        ----------\n        max : float\n        \"\"\"\n        self.set_val((self.val[0], max), force_all=True)\n",
      "\n    def set_min(self, min):\n        \"\"\"\n        Set the lower value of the slider to *min*.\n\n        Parameters\n        ----------\n        min : float\n        \"\"\"\n        self.set_val((min, self.val[1]), force_update=getattr(self, '_mouse_grabbed', False))\n\n    def set_max(self, max):\n        \"\"\"\n        Set the lower value of the slider to *max*.\n\n        Parameters\n        ----------\n        max : float\n        \"\"\"\n        self.set_val((self.val[0], max), force_update=getattr(self, '_mouse_grabbed', False))\n",
      "\n    def set_min(self, min):\n        \"\"\"\n        Set the lower value of the slider to *min*.\n\n        Parameters\n        ----------\n        min : float\n        \"\"\"\n        self.set_val((min, self.val[1]), force_deferred=getattr(self, '_mouse_grabbed', False))\n\n    def set_max(self, max):\n        \"\"\"\n        Set the lower value of the slider to *max*.\n\n        Parameters\n        ----------\n        max : float\n        \"\"\"\n        self.set_val((self.val[0], max), force_deferred=getattr(self, '_mouse_grabbed', False))\n",
      "\n    def set_min(self, min):\n        \"\"\"\n        Set the lower value of the slider to *min*.\n\n        Parameters\n        ----------\n        min : float\n        \"\"\"\n        self.set_val((min, self.val[1]), force_all=True)\n\n    def set_max(self, max):\n        \"\"\"\n        Set the lower value of the slider to *max*.\n\n        Parameters\n        ----------\n        max : float\n        \"\"\"\n        self.set_val((self.val[0], max), force_all=True)\n",
      "\n    def set_min(self, min):\n        \"\"\"\n        Set the lower value of the slider to *min*.\n\n        Parameters\n        ----------\n        min : float\n        \"\"\"\n        self.set_val((min, self.val[1]), force_all=True)\n\n    def set_max(self, max):\n        \"\"\"\n        Set the lower value of the slider to *max*.\n\n        Parameters\n        ----------\n        max : float\n        \"\"\"\n        self.set_val((self.val[0], max), force_all=True)\n"
    ],
    "Location 5 (/root/hy/projects_4/matplotlib/lib/matplotlib/widgets.py lines 147-150)": [
      "\n    def disconnect_events(self):\n        \"\"\"Disconnect all events created by this widget.\"\"\"\n        # Release any active mouse grab before disconnecting events\n        if hasattr(self, '_grabbed') and self._grabbed:\n            try:\n                self.canvas.release_mouse(self.ax)\n            except (AttributeError, RuntimeError):\n                pass  # Canvas or axes may already be destroyed\n        for c in self._cids:\n            self.canvas.mpl_disconnect(c)\n",
      "\n    def disconnect_events(self):\n        \"\"\"Disconnect all events created by this widget.\"\"\"\n        # Release any active mouse grab before disconnecting events\n        if hasattr(self, 'canvas') and self.canvas is not None:\n            try:\n                self.canvas.release_mouse(self.ax)\n            except (AttributeError, ValueError):\n                # Canvas may not support mouse grabbing or widget may be invalid\n                pass\n        \n        for c in self._cids:\n            self.canvas.mpl_disconnect(c)\n",
      "\n    def disconnect_events(self):\n        \"\"\"Disconnect all events created by this widget.\"\"\"\n        # Release any active mouse grab before disconnecting events\n        if hasattr(self, 'canvas') and self.canvas is not None:\n            try:\n                self.canvas.release_mouse(self.ax)\n            except (AttributeError, ValueError):\n                # Ignore errors if canvas doesn't support release_mouse or ax is invalid\n                pass\n        \n        for c in self._cids:\n            self.canvas.mpl_disconnect(c)\n",
      "\n    def disconnect_events(self):\n        \"\"\"Disconnect all events created by this widget.\"\"\"\n        # Release any active mouse grab before disconnecting events\n        if hasattr(self, 'canvas') and self.canvas is not None:\n            try:\n                self.canvas.release_mouse(self)\n            except (AttributeError, ValueError):\n                # Ignore errors if canvas doesn't support release_mouse or widget not grabbed\n                pass\n        \n        for c in self._cids:\n            self.canvas.mpl_disconnect(c)\n",
      "\n    def disconnect_events(self):\n        \"\"\"Disconnect all events created by this widget.\"\"\"\n        # Release any active mouse grab before disconnecting events\n        if hasattr(self, 'canvas') and hasattr(self.canvas, 'grab_mouse'):\n            try:\n                self.canvas.release_mouse(self.ax)\n            except (AttributeError, ValueError):\n                # Ignore errors if canvas doesn't support mouse grab or ax is invalid\n                pass\n        \n        for c in self._cids:\n            self.canvas.mpl_disconnect(c)\n",
      "\n    def disconnect_events(self):\n        \"\"\"Disconnect all events created by this widget.\"\"\"\n        # Release any active mouse grab before disconnecting events\n        if hasattr(self, 'canvas') and hasattr(self.canvas, 'release_mouse'):\n            try:\n                self.canvas.release_mouse(self)\n            except (AttributeError, RuntimeError):\n                # Canvas may already be destroyed or mouse not grabbed\n                pass\n        \n        for c in self._cids:\n            self.canvas.mpl_disconnect(c)\n",
      "\n    def disconnect_events(self):\n        \"\"\"Disconnect all events created by this widget.\"\"\"\n        # Release any active mouse grab before disconnecting events\n        if hasattr(self, 'canvas') and self.canvas is not None:\n            try:\n                self.canvas.release_mouse(self.ax)\n            except (AttributeError, RuntimeError):\n                # Canvas might not support mouse grab or already released\n                pass\n        \n        for c in self._cids:\n            self.canvas.mpl_disconnect(c)\n",
      "\n    def disconnect_events(self):\n        \"\"\"Disconnect all events created by this widget.\"\"\"\n        # Release any active mouse grab before disconnecting events\n        if hasattr(self, 'canvas') and self.canvas is not None:\n            try:\n                self.canvas.release_mouse(self)\n            except (AttributeError, ValueError):\n                # Canvas may not support release_mouse or widget may not have grab\n                pass\n        \n        for c in self._cids:\n            self.canvas.mpl_disconnect(c)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..213006735c 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -144,8 +144,17 @@ class AxesWidget(Widget):\n         cid = self.canvas.mpl_connect(event, callback)\n         self._cids.append(cid)\n \n+\n     def disconnect_events(self):\n         \"\"\"Disconnect all events created by this widget.\"\"\"\n+        # Release any active mouse grab before disconnecting events\n+        if hasattr(self, 'drag_active') and self.drag_active:\n+            try:\n+                self.canvas.release_mouse(self.ax)\n+            except (AttributeError, RuntimeError):\n+                # Canvas or axes may have been destroyed\n+                pass\n+            self.drag_active = False\n         for c in self._cids:\n             self.canvas.mpl_disconnect(c)\n \n@@ -849,15 +858,16 @@ class RangeSlider(SliderBase):\n         \"\"\"Clip min, max values to the bounds.\"\"\"\n         return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n \n+\n     def _update_val_from_pos(self, pos):\n         \"\"\"Update the slider value based on a given position.\"\"\"\n         idx = np.argmin(np.abs(self.val - pos))\n         if idx == 0:\n             val = self._min_in_bounds(pos)\n-            self.set_min(val)\n+            self.set_min(val, _during_drag=True)\n         else:\n             val = self._max_in_bounds(pos)\n-            self.set_max(val)\n+            self.set_max(val, _during_drag=True)\n         if self._active_handle:\n             if self.orientation == \"vertical\":\n                 self._active_handle.set_ydata([val])\n@@ -882,6 +892,11 @@ class RangeSlider(SliderBase):\n             self.drag_active = False\n             event.canvas.release_mouse(self.ax)\n             self._active_handle = None\n+            # Execute any deferred callbacks after mouse is released\n+            if hasattr(self, '_deferred_callbacks') and self._deferred_callbacks:\n+                for callback_args in self._deferred_callbacks:\n+                    self._observers.process(\"changed\", callback_args)\n+                self._deferred_callbacks.clear()\n             return\n \n         # determine which handle was grabbed\n@@ -919,7 +934,8 @@ class RangeSlider(SliderBase):\n             # Use f string to avoid issues with backslashes when cast to a str\n             return f\"({s1}, {s2})\"\n \n-    def set_min(self, min):\n+\n+    def set_min(self, min, _during_drag=False):\n         \"\"\"\n         Set the lower value of the slider to *min*.\n \n@@ -927,9 +943,9 @@ class RangeSlider(SliderBase):\n         ----------\n         min : float\n         \"\"\"\n-        self.set_val((min, self.val[1]))\n+        self.set_val((min, self.val[1]), _during_drag=_during_drag)\n \n-    def set_max(self, max):\n+    def set_max(self, max, _during_drag=False):\n         \"\"\"\n         Set the lower value of the slider to *max*.\n \n@@ -937,9 +953,9 @@ class RangeSlider(SliderBase):\n         ----------\n         max : float\n         \"\"\"\n-        self.set_val((self.val[0], max))\n+        self.set_val((self.val[0], max), _during_drag=_during_drag)\n \n-    def set_val(self, val):\n+    def set_val(self, val, _during_drag=False):\n         \"\"\"\n         Set slider value to *val*.\n \n@@ -966,7 +982,13 @@ class RangeSlider(SliderBase):\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n         if self.eventson:\n-            self._observers.process(\"changed\", (vmin, vmax))\n+            # If we're during a drag operation, defer the callback execution\n+            if _during_drag and hasattr(self, 'drag_active') and self.drag_active:\n+                if not hasattr(self, '_deferred_callbacks'):\n+                    self._deferred_callbacks = []\n+                self._deferred_callbacks.append((vmin, vmax))\n+            else:\n+                self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n         \"\"\"\n@@ -977,7 +999,6 @@ class RangeSlider(SliderBase):\n         func : callable\n             Function to call when slider is changed. The function\n             must accept a 2-tuple of floats as its argument.\n-\n         Returns\n         -------\n         int\n",
    "variant_0": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..f85a2374c4 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -144,8 +144,17 @@ class AxesWidget(Widget):\n         cid = self.canvas.mpl_connect(event, callback)\n         self._cids.append(cid)\n \n+\n     def disconnect_events(self):\n         \"\"\"Disconnect all events created by this widget.\"\"\"\n+        # Release any active mouse grab before disconnecting events\n+        if hasattr(self, 'canvas') and self.canvas is not None:\n+            try:\n+                self.canvas.release_mouse(self.ax)\n+            except (AttributeError, RuntimeError):\n+                # Ignore errors if canvas or ax is already destroyed\n+                pass\n+        \n         for c in self._cids:\n             self.canvas.mpl_disconnect(c)\n \n@@ -849,15 +858,16 @@ class RangeSlider(SliderBase):\n         \"\"\"Clip min, max values to the bounds.\"\"\"\n         return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n \n+\n     def _update_val_from_pos(self, pos):\n         \"\"\"Update the slider value based on a given position.\"\"\"\n         idx = np.argmin(np.abs(self.val - pos))\n         if idx == 0:\n             val = self._min_in_bounds(pos)\n-            self.set_min(val)\n+            self.set_min(val, _defer_callback=getattr(self, 'drag_active', False))\n         else:\n             val = self._max_in_bounds(pos)\n-            self.set_max(val)\n+            self.set_max(val, _defer_callback=getattr(self, 'drag_active', False))\n         if self._active_handle:\n             if self.orientation == \"vertical\":\n                 self._active_handle.set_ydata([val])\n@@ -880,8 +890,18 @@ class RangeSlider(SliderBase):\n             event.name == \"button_press_event\" and event.inaxes != self.ax\n         ):\n             self.drag_active = False\n-            event.canvas.release_mouse(self.ax)\n+            try:\n+                event.canvas.release_mouse(self.ax)\n+            except Exception:\n+                # Widget may have been destroyed, ignore cleanup errors\n+                pass\n             self._active_handle = None\n+            # Execute any deferred callbacks after mouse release\n+            if hasattr(self, '_deferred_callback') and self._deferred_callback is not None:\n+                try:\n+                    self._deferred_callback()\n+                finally:\n+                    self._deferred_callback = None\n             return\n \n         # determine which handle was grabbed\n@@ -919,6 +939,7 @@ class RangeSlider(SliderBase):\n             # Use f string to avoid issues with backslashes when cast to a str\n             return f\"({s1}, {s2})\"\n \n+\n     def set_min(self, min):\n         \"\"\"\n         Set the lower value of the slider to *min*.\n@@ -927,7 +948,7 @@ class RangeSlider(SliderBase):\n         ----------\n         min : float\n         \"\"\"\n-        self.set_val((min, self.val[1]))\n+        self.set_val((min, self.val[1]), force_all=True)\n \n     def set_max(self, max):\n         \"\"\"\n@@ -937,7 +958,7 @@ class RangeSlider(SliderBase):\n         ----------\n         max : float\n         \"\"\"\n-        self.set_val((self.val[0], max))\n+        self.set_val((self.val[0], max), force_all=True)\n \n     def set_val(self, val):\n         \"\"\"\n@@ -966,7 +987,12 @@ class RangeSlider(SliderBase):\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n         if self.eventson:\n-            self._observers.process(\"changed\", (vmin, vmax))\n+            # Check if we're in the middle of a mouse operation\n+            if hasattr(self, '_mouse_grabbed') and self._mouse_grabbed:\n+                # Defer callback execution until mouse is released\n+                self._deferred_callback = (vmin, vmax)\n+            else:\n+                self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n         \"\"\"\n@@ -984,6 +1010,12 @@ class RangeSlider(SliderBase):\n             Connection id (which can be used to disconnect *func*).\n         \"\"\"\n         return self._observers.connect('changed', lambda val: func(val))\n+        Returns\n+        -------\n+        int\n+            Connection id (which can be used to disconnect *func*).\n+        \"\"\"\n+        return self._observers.connect('changed', lambda val: func(val))\n \n \n def _expand_text_props(props):\n",
    "variant_1": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..dd01a246c3 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -144,8 +144,15 @@ class AxesWidget(Widget):\n         cid = self.canvas.mpl_connect(event, callback)\n         self._cids.append(cid)\n \n+\n     def disconnect_events(self):\n         \"\"\"Disconnect all events created by this widget.\"\"\"\n+        # Release any active mouse grab before disconnecting events\n+        if hasattr(self, '_grabbed') and self._grabbed:\n+            try:\n+                self.canvas.release_mouse(self.ax)\n+            except (AttributeError, RuntimeError):\n+                pass  # Canvas or axes may already be destroyed\n         for c in self._cids:\n             self.canvas.mpl_disconnect(c)\n \n@@ -849,15 +856,16 @@ class RangeSlider(SliderBase):\n         \"\"\"Clip min, max values to the bounds.\"\"\"\n         return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n \n+\n     def _update_val_from_pos(self, pos):\n         \"\"\"Update the slider value based on a given position.\"\"\"\n         idx = np.argmin(np.abs(self.val - pos))\n         if idx == 0:\n             val = self._min_in_bounds(pos)\n-            self.set_min(val)\n+            self.set_min(val, during_drag=True)\n         else:\n             val = self._max_in_bounds(pos)\n-            self.set_max(val)\n+            self.set_max(val, during_drag=True)\n         if self._active_handle:\n             if self.orientation == \"vertical\":\n                 self._active_handle.set_ydata([val])\n@@ -880,8 +888,21 @@ class RangeSlider(SliderBase):\n             event.name == \"button_press_event\" and event.inaxes != self.ax\n         ):\n             self.drag_active = False\n-            event.canvas.release_mouse(self.ax)\n+            try:\n+                event.canvas.release_mouse(self.ax)\n+            except Exception:\n+                # Widget may have been destroyed, continue with cleanup\n+                pass\n             self._active_handle = None\n+            # Execute any deferred callbacks after mouse release\n+            if hasattr(self, '_deferred_callback') and self._deferred_callback:\n+                try:\n+                    self._deferred_callback()\n+                except Exception:\n+                    # Callback may destroy the widget, ignore errors\n+                    pass\n+                finally:\n+                    self._deferred_callback = None\n             return\n \n         # determine which handle was grabbed\n@@ -901,9 +922,9 @@ class RangeSlider(SliderBase):\n             self._active_handle = handle\n \n         if self.orientation == \"vertical\":\n-            self._update_val_from_pos(event.ydata)\n+            self._update_val_from_pos(event.ydata, during_drag=True)\n         else:\n-            self._update_val_from_pos(event.xdata)\n+            self._update_val_from_pos(event.xdata, during_drag=True)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -919,6 +940,7 @@ class RangeSlider(SliderBase):\n             # Use f string to avoid issues with backslashes when cast to a str\n             return f\"({s1}, {s2})\"\n \n+\n     def set_min(self, min):\n         \"\"\"\n         Set the lower value of the slider to *min*.\n@@ -927,7 +949,7 @@ class RangeSlider(SliderBase):\n         ----------\n         min : float\n         \"\"\"\n-        self.set_val((min, self.val[1]))\n+        self.set_val((min, self.val[1]), force_all=True)\n \n     def set_max(self, max):\n         \"\"\"\n@@ -937,7 +959,7 @@ class RangeSlider(SliderBase):\n         ----------\n         max : float\n         \"\"\"\n-        self.set_val((self.val[0], max))\n+        self.set_val((self.val[0], max), force_all=True)\n \n     def set_val(self, val):\n         \"\"\"\n@@ -966,7 +988,15 @@ class RangeSlider(SliderBase):\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n         if self.eventson:\n-            self._observers.process(\"changed\", (vmin, vmax))\n+            # Check if we're in the middle of a mouse drag operation\n+            # If so, defer the callback to prevent widget destruction during grab\n+            if hasattr(self, '_mouse_grabbed') and self._mouse_grabbed:\n+                # Store the callback for deferred execution\n+                if not hasattr(self, '_deferred_callback'):\n+                    self._deferred_callback = None\n+                self._deferred_callback = (vmin, vmax)\n+            else:\n+                self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n         \"\"\"\n@@ -977,7 +1007,6 @@ class RangeSlider(SliderBase):\n         func : callable\n             Function to call when slider is changed. The function\n             must accept a 2-tuple of floats as its argument.\n-\n         Returns\n         -------\n         int\n",
    "variant_2": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..fd657ec95a 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -144,8 +144,17 @@ class AxesWidget(Widget):\n         cid = self.canvas.mpl_connect(event, callback)\n         self._cids.append(cid)\n \n+\n     def disconnect_events(self):\n         \"\"\"Disconnect all events created by this widget.\"\"\"\n+        # Release any active mouse grab before disconnecting events\n+        if hasattr(self, 'canvas') and self.canvas is not None:\n+            try:\n+                self.canvas.release_mouse(self.ax)\n+            except (AttributeError, ValueError):\n+                # Canvas may not support mouse grabbing or widget may be invalid\n+                pass\n+        \n         for c in self._cids:\n             self.canvas.mpl_disconnect(c)\n \n@@ -849,15 +858,16 @@ class RangeSlider(SliderBase):\n         \"\"\"Clip min, max values to the bounds.\"\"\"\n         return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n \n+\n     def _update_val_from_pos(self, pos):\n         \"\"\"Update the slider value based on a given position.\"\"\"\n         idx = np.argmin(np.abs(self.val - pos))\n         if idx == 0:\n             val = self._min_in_bounds(pos)\n-            self.set_min(val)\n+            self.set_min(val, _during_drag=True)\n         else:\n             val = self._max_in_bounds(pos)\n-            self.set_max(val)\n+            self.set_max(val, _during_drag=True)\n         if self._active_handle:\n             if self.orientation == \"vertical\":\n                 self._active_handle.set_ydata([val])\n@@ -880,8 +890,21 @@ class RangeSlider(SliderBase):\n             event.name == \"button_press_event\" and event.inaxes != self.ax\n         ):\n             self.drag_active = False\n-            event.canvas.release_mouse(self.ax)\n+            try:\n+                event.canvas.release_mouse(self.ax)\n+            except Exception:\n+                # Widget may have been destroyed, ignore errors\n+                pass\n             self._active_handle = None\n+            # Execute any deferred callbacks after mouse release\n+            if hasattr(self, '_deferred_callbacks') and self._deferred_callbacks:\n+                for callback in self._deferred_callbacks:\n+                    try:\n+                        callback()\n+                    except Exception:\n+                        # Ignore errors from destroyed widgets\n+                        pass\n+                self._deferred_callbacks.clear()\n             return\n \n         # determine which handle was grabbed\n@@ -919,6 +942,7 @@ class RangeSlider(SliderBase):\n             # Use f string to avoid issues with backslashes when cast to a str\n             return f\"({s1}, {s2})\"\n \n+\n     def set_min(self, min):\n         \"\"\"\n         Set the lower value of the slider to *min*.\n@@ -927,7 +951,7 @@ class RangeSlider(SliderBase):\n         ----------\n         min : float\n         \"\"\"\n-        self.set_val((min, self.val[1]))\n+        self.set_val((min, self.val[1]), force_all=True)\n \n     def set_max(self, max):\n         \"\"\"\n@@ -937,7 +961,7 @@ class RangeSlider(SliderBase):\n         ----------\n         max : float\n         \"\"\"\n-        self.set_val((self.val[0], max))\n+        self.set_val((self.val[0], max), force_all=True)\n \n     def set_val(self, val):\n         \"\"\"\n@@ -965,8 +989,16 @@ class RangeSlider(SliderBase):\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n+        \n+        # Check if we should defer callback execution during active mouse operations\n+        defer_callbacks = getattr(self, '_mouse_grabbed', False)\n+        \n         if self.eventson:\n-            self._observers.process(\"changed\", (vmin, vmax))\n+            if defer_callbacks:\n+                # Store the callback for later execution\n+                self._deferred_callback = (vmin, vmax)\n+            else:\n+                self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n         \"\"\"\n@@ -977,7 +1009,6 @@ class RangeSlider(SliderBase):\n         func : callable\n             Function to call when slider is changed. The function\n             must accept a 2-tuple of floats as its argument.\n-\n         Returns\n         -------\n         int\n",
    "variant_3": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..5633a0663e 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -144,8 +144,17 @@ class AxesWidget(Widget):\n         cid = self.canvas.mpl_connect(event, callback)\n         self._cids.append(cid)\n \n+\n     def disconnect_events(self):\n         \"\"\"Disconnect all events created by this widget.\"\"\"\n+        # Release any active mouse grab before disconnecting events\n+        if hasattr(self, 'canvas') and self.canvas is not None:\n+            try:\n+                self.canvas.release_mouse(self.ax)\n+            except (AttributeError, ValueError):\n+                # Ignore errors if canvas doesn't support release_mouse or ax is invalid\n+                pass\n+        \n         for c in self._cids:\n             self.canvas.mpl_disconnect(c)\n \n@@ -849,15 +858,16 @@ class RangeSlider(SliderBase):\n         \"\"\"Clip min, max values to the bounds.\"\"\"\n         return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n \n+\n     def _update_val_from_pos(self, pos):\n         \"\"\"Update the slider value based on a given position.\"\"\"\n         idx = np.argmin(np.abs(self.val - pos))\n         if idx == 0:\n             val = self._min_in_bounds(pos)\n-            self.set_min(val)\n+            self.set_min(val, _during_drag=getattr(self, 'drag_active', False))\n         else:\n             val = self._max_in_bounds(pos)\n-            self.set_max(val)\n+            self.set_max(val, _during_drag=getattr(self, 'drag_active', False))\n         if self._active_handle:\n             if self.orientation == \"vertical\":\n                 self._active_handle.set_ydata([val])\n@@ -880,8 +890,20 @@ class RangeSlider(SliderBase):\n             event.name == \"button_press_event\" and event.inaxes != self.ax\n         ):\n             self.drag_active = False\n-            event.canvas.release_mouse(self.ax)\n+            try:\n+                event.canvas.release_mouse(self.ax)\n+            except Exception:\n+                # Widget may have been destroyed, ignore release errors\n+                pass\n             self._active_handle = None\n+            # Execute any deferred callbacks after mouse release\n+            if hasattr(self, '_deferred_callback') and self._deferred_callback:\n+                try:\n+                    self._deferred_callback()\n+                    self._deferred_callback = None\n+                except Exception:\n+                    # If callback fails (e.g., widget destroyed), clear it\n+                    self._deferred_callback = None\n             return\n \n         # determine which handle was grabbed\n@@ -919,6 +941,7 @@ class RangeSlider(SliderBase):\n             # Use f string to avoid issues with backslashes when cast to a str\n             return f\"({s1}, {s2})\"\n \n+\n     def set_min(self, min):\n         \"\"\"\n         Set the lower value of the slider to *min*.\n@@ -927,7 +950,7 @@ class RangeSlider(SliderBase):\n         ----------\n         min : float\n         \"\"\"\n-        self.set_val((min, self.val[1]))\n+        self.set_val((min, self.val[1]), force_all=getattr(self, '_mouse_grabbed', False))\n \n     def set_max(self, max):\n         \"\"\"\n@@ -937,7 +960,7 @@ class RangeSlider(SliderBase):\n         ----------\n         max : float\n         \"\"\"\n-        self.set_val((self.val[0], max))\n+        self.set_val((self.val[0], max), force_all=getattr(self, '_mouse_grabbed', False))\n \n     def set_val(self, val):\n         \"\"\"\n@@ -966,7 +989,14 @@ class RangeSlider(SliderBase):\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n         if self.eventson:\n-            self._observers.process(\"changed\", (vmin, vmax))\n+            # Check if mouse is currently grabbed - defer callback if so\n+            if hasattr(self, '_mouse_grabbed') and self._mouse_grabbed:\n+                # Store callback for deferred execution\n+                if not hasattr(self, '_deferred_callbacks'):\n+                    self._deferred_callbacks = []\n+                self._deferred_callbacks.append(('changed', (vmin, vmax)))\n+            else:\n+                self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n         \"\"\"\n@@ -977,7 +1007,6 @@ class RangeSlider(SliderBase):\n         func : callable\n             Function to call when slider is changed. The function\n             must accept a 2-tuple of floats as its argument.\n-\n         Returns\n         -------\n         int\n",
    "variant_4": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..6ecc634ce4 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -144,8 +144,17 @@ class AxesWidget(Widget):\n         cid = self.canvas.mpl_connect(event, callback)\n         self._cids.append(cid)\n \n+\n     def disconnect_events(self):\n         \"\"\"Disconnect all events created by this widget.\"\"\"\n+        # Release any active mouse grab before disconnecting events\n+        if hasattr(self, 'canvas') and self.canvas is not None:\n+            try:\n+                self.canvas.release_mouse(self)\n+            except (AttributeError, ValueError):\n+                # Ignore errors if canvas doesn't support release_mouse or widget not grabbed\n+                pass\n+        \n         for c in self._cids:\n             self.canvas.mpl_disconnect(c)\n \n@@ -849,15 +858,16 @@ class RangeSlider(SliderBase):\n         \"\"\"Clip min, max values to the bounds.\"\"\"\n         return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n \n+\n     def _update_val_from_pos(self, pos):\n         \"\"\"Update the slider value based on a given position.\"\"\"\n         idx = np.argmin(np.abs(self.val - pos))\n         if idx == 0:\n             val = self._min_in_bounds(pos)\n-            self.set_min(val)\n+            self.set_min(val, _during_drag=True)\n         else:\n             val = self._max_in_bounds(pos)\n-            self.set_max(val)\n+            self.set_max(val, _during_drag=True)\n         if self._active_handle:\n             if self.orientation == \"vertical\":\n                 self._active_handle.set_ydata([val])\n@@ -880,8 +890,21 @@ class RangeSlider(SliderBase):\n             event.name == \"button_press_event\" and event.inaxes != self.ax\n         ):\n             self.drag_active = False\n-            event.canvas.release_mouse(self.ax)\n+            try:\n+                event.canvas.release_mouse(self.ax)\n+            except Exception:\n+                # Widget may have been destroyed, ignore cleanup errors\n+                pass\n             self._active_handle = None\n+            # Execute any deferred callbacks after mouse release\n+            if hasattr(self, '_deferred_callbacks'):\n+                for callback in self._deferred_callbacks:\n+                    try:\n+                        callback()\n+                    except Exception:\n+                        # Ignore callback errors to prevent cascading failures\n+                        pass\n+                self._deferred_callbacks.clear()\n             return\n \n         # determine which handle was grabbed\n@@ -919,6 +942,7 @@ class RangeSlider(SliderBase):\n             # Use f string to avoid issues with backslashes when cast to a str\n             return f\"({s1}, {s2})\"\n \n+\n     def set_min(self, min):\n         \"\"\"\n         Set the lower value of the slider to *min*.\n@@ -927,7 +951,7 @@ class RangeSlider(SliderBase):\n         ----------\n         min : float\n         \"\"\"\n-        self.set_val((min, self.val[1]))\n+        self.set_val((min, self.val[1]), force_all=True)\n \n     def set_max(self, max):\n         \"\"\"\n@@ -937,7 +961,7 @@ class RangeSlider(SliderBase):\n         ----------\n         max : float\n         \"\"\"\n-        self.set_val((self.val[0], max))\n+        self.set_val((self.val[0], max), force_all=True)\n \n     def set_val(self, val):\n         \"\"\"\n@@ -965,8 +989,14 @@ class RangeSlider(SliderBase):\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n+        \n+        # Check if we're currently in a drag operation to defer callback execution\n         if self.eventson:\n-            self._observers.process(\"changed\", (vmin, vmax))\n+            if hasattr(self, '_mouse_grabbed') and self._mouse_grabbed:\n+                # Defer callback execution during mouse grab\n+                self._deferred_callback_val = (vmin, vmax)\n+            else:\n+                self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n         \"\"\"\n@@ -977,7 +1007,6 @@ class RangeSlider(SliderBase):\n         func : callable\n             Function to call when slider is changed. The function\n             must accept a 2-tuple of floats as its argument.\n-\n         Returns\n         -------\n         int\n",
    "variant_5": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..8306e0cb63 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -144,8 +144,17 @@ class AxesWidget(Widget):\n         cid = self.canvas.mpl_connect(event, callback)\n         self._cids.append(cid)\n \n+\n     def disconnect_events(self):\n         \"\"\"Disconnect all events created by this widget.\"\"\"\n+        # Release any active mouse grab before disconnecting events\n+        if hasattr(self, 'canvas') and hasattr(self.canvas, 'grab_mouse'):\n+            try:\n+                self.canvas.release_mouse(self.ax)\n+            except (AttributeError, ValueError):\n+                # Ignore errors if canvas doesn't support mouse grab or ax is invalid\n+                pass\n+        \n         for c in self._cids:\n             self.canvas.mpl_disconnect(c)\n \n@@ -849,15 +858,16 @@ class RangeSlider(SliderBase):\n         \"\"\"Clip min, max values to the bounds.\"\"\"\n         return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n \n+\n     def _update_val_from_pos(self, pos):\n         \"\"\"Update the slider value based on a given position.\"\"\"\n         idx = np.argmin(np.abs(self.val - pos))\n         if idx == 0:\n             val = self._min_in_bounds(pos)\n-            self.set_min(val)\n+            self.set_min(val, _defer_callback=getattr(self, 'drag_active', False))\n         else:\n             val = self._max_in_bounds(pos)\n-            self.set_max(val)\n+            self.set_max(val, _defer_callback=getattr(self, 'drag_active', False))\n         if self._active_handle:\n             if self.orientation == \"vertical\":\n                 self._active_handle.set_ydata([val])\n@@ -880,8 +890,21 @@ class RangeSlider(SliderBase):\n             event.name == \"button_press_event\" and event.inaxes != self.ax\n         ):\n             self.drag_active = False\n-            event.canvas.release_mouse(self.ax)\n+            try:\n+                event.canvas.release_mouse(self.ax)\n+            except Exception:\n+                # Handle case where canvas/widget was destroyed during drag\n+                pass\n             self._active_handle = None\n+            # Execute any deferred callbacks after mouse operations complete\n+            if hasattr(self, '_deferred_callbacks') and self._deferred_callbacks:\n+                for callback in self._deferred_callbacks:\n+                    try:\n+                        callback()\n+                    except Exception:\n+                        # Ignore errors from callbacks that may reference destroyed objects\n+                        pass\n+                self._deferred_callbacks.clear()\n             return\n \n         # determine which handle was grabbed\n@@ -919,6 +942,7 @@ class RangeSlider(SliderBase):\n             # Use f string to avoid issues with backslashes when cast to a str\n             return f\"({s1}, {s2})\"\n \n+\n     def set_min(self, min):\n         \"\"\"\n         Set the lower value of the slider to *min*.\n@@ -927,7 +951,7 @@ class RangeSlider(SliderBase):\n         ----------\n         min : float\n         \"\"\"\n-        self.set_val((min, self.val[1]))\n+        self.set_val((min, self.val[1]), force_update=getattr(self, '_mouse_grabbed', False))\n \n     def set_max(self, max):\n         \"\"\"\n@@ -937,7 +961,7 @@ class RangeSlider(SliderBase):\n         ----------\n         max : float\n         \"\"\"\n-        self.set_val((self.val[0], max))\n+        self.set_val((self.val[0], max), force_update=getattr(self, '_mouse_grabbed', False))\n \n     def set_val(self, val):\n         \"\"\"\n@@ -966,7 +990,15 @@ class RangeSlider(SliderBase):\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n         if self.eventson:\n-            self._observers.process(\"changed\", (vmin, vmax))\n+            # Check if we're in the middle of a mouse drag operation\n+            # If so, defer the callback to prevent widget destruction during grab\n+            if hasattr(self, '_mouse_grabbed') and self._mouse_grabbed:\n+                # Store the callback for deferred execution\n+                if not hasattr(self, '_deferred_callbacks'):\n+                    self._deferred_callbacks = []\n+                self._deferred_callbacks.append(('changed', (vmin, vmax)))\n+            else:\n+                self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n         \"\"\"\n@@ -977,7 +1009,6 @@ class RangeSlider(SliderBase):\n         func : callable\n             Function to call when slider is changed. The function\n             must accept a 2-tuple of floats as its argument.\n-\n         Returns\n         -------\n         int\n",
    "variant_6": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..d65217ab02 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -144,8 +144,17 @@ class AxesWidget(Widget):\n         cid = self.canvas.mpl_connect(event, callback)\n         self._cids.append(cid)\n \n+\n     def disconnect_events(self):\n         \"\"\"Disconnect all events created by this widget.\"\"\"\n+        # Release any active mouse grab before disconnecting events\n+        if hasattr(self, 'canvas') and hasattr(self.canvas, 'release_mouse'):\n+            try:\n+                self.canvas.release_mouse(self)\n+            except (AttributeError, RuntimeError):\n+                # Canvas may already be destroyed or mouse not grabbed\n+                pass\n+        \n         for c in self._cids:\n             self.canvas.mpl_disconnect(c)\n \n@@ -849,15 +858,16 @@ class RangeSlider(SliderBase):\n         \"\"\"Clip min, max values to the bounds.\"\"\"\n         return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n \n+\n     def _update_val_from_pos(self, pos):\n         \"\"\"Update the slider value based on a given position.\"\"\"\n         idx = np.argmin(np.abs(self.val - pos))\n         if idx == 0:\n             val = self._min_in_bounds(pos)\n-            self.set_min(val)\n+            self.set_min(val, _during_drag=getattr(self, 'drag_active', False))\n         else:\n             val = self._max_in_bounds(pos)\n-            self.set_max(val)\n+            self.set_max(val, _during_drag=getattr(self, 'drag_active', False))\n         if self._active_handle:\n             if self.orientation == \"vertical\":\n                 self._active_handle.set_ydata([val])\n@@ -871,7 +881,12 @@ class RangeSlider(SliderBase):\n \n         if event.name == \"button_press_event\" and event.inaxes == self.ax:\n             self.drag_active = True\n-            event.canvas.grab_mouse(self.ax)\n+            try:\n+                event.canvas.grab_mouse(self.ax)\n+            except Exception:\n+                # If grab_mouse fails, reset drag_active to prevent inconsistent state\n+                self.drag_active = False\n+                return\n \n         if not self.drag_active:\n             return\n@@ -880,8 +895,21 @@ class RangeSlider(SliderBase):\n             event.name == \"button_press_event\" and event.inaxes != self.ax\n         ):\n             self.drag_active = False\n-            event.canvas.release_mouse(self.ax)\n+            try:\n+                event.canvas.release_mouse(self.ax)\n+            except Exception:\n+                # Canvas might be destroyed, but we still need to clean up\n+                pass\n             self._active_handle = None\n+            # Execute any deferred callbacks now that mouse operations are complete\n+            if hasattr(self, '_deferred_callback') and self._deferred_callback:\n+                try:\n+                    self._deferred_callback()\n+                except Exception:\n+                    # Callback might destroy the widget, handle gracefully\n+                    pass\n+                finally:\n+                    self._deferred_callback = None\n             return\n \n         # determine which handle was grabbed\n@@ -901,9 +929,9 @@ class RangeSlider(SliderBase):\n             self._active_handle = handle\n \n         if self.orientation == \"vertical\":\n-            self._update_val_from_pos(event.ydata)\n+            self._update_val_from_pos(event.ydata, during_drag=True)\n         else:\n-            self._update_val_from_pos(event.xdata)\n+            self._update_val_from_pos(event.xdata, during_drag=True)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -919,6 +947,7 @@ class RangeSlider(SliderBase):\n             # Use f string to avoid issues with backslashes when cast to a str\n             return f\"({s1}, {s2})\"\n \n+\n     def set_min(self, min):\n         \"\"\"\n         Set the lower value of the slider to *min*.\n@@ -927,7 +956,7 @@ class RangeSlider(SliderBase):\n         ----------\n         min : float\n         \"\"\"\n-        self.set_val((min, self.val[1]))\n+        self.set_val((min, self.val[1]), force_deferred=getattr(self, '_mouse_grabbed', False))\n \n     def set_max(self, max):\n         \"\"\"\n@@ -937,7 +966,7 @@ class RangeSlider(SliderBase):\n         ----------\n         max : float\n         \"\"\"\n-        self.set_val((self.val[0], max))\n+        self.set_val((self.val[0], max), force_deferred=getattr(self, '_mouse_grabbed', False))\n \n     def set_val(self, val):\n         \"\"\"\n@@ -966,7 +995,14 @@ class RangeSlider(SliderBase):\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n         if self.eventson:\n-            self._observers.process(\"changed\", (vmin, vmax))\n+            # Check if we're in the middle of a drag operation by looking for mouse grab\n+            if hasattr(self.ax.figure.canvas, '_button') and self.ax.figure.canvas._button is not None:\n+                # Defer callback execution during active mouse operations\n+                if not hasattr(self, '_deferred_callbacks'):\n+                    self._deferred_callbacks = []\n+                self._deferred_callbacks.append(('changed', (vmin, vmax)))\n+            else:\n+                self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n         \"\"\"\n@@ -977,7 +1013,7 @@ class RangeSlider(SliderBase):\n         func : callable\n             Function to call when slider is changed. The function\n             must accept a 2-tuple of floats as its argument.\n-\n+        \"\"\"\n         Returns\n         -------\n         int\n",
    "variant_7": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..3ea46b60af 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -144,8 +144,17 @@ class AxesWidget(Widget):\n         cid = self.canvas.mpl_connect(event, callback)\n         self._cids.append(cid)\n \n+\n     def disconnect_events(self):\n         \"\"\"Disconnect all events created by this widget.\"\"\"\n+        # Release any active mouse grab before disconnecting events\n+        if hasattr(self, 'canvas') and self.canvas is not None:\n+            try:\n+                self.canvas.release_mouse(self.ax)\n+            except (AttributeError, RuntimeError):\n+                # Canvas might not support mouse grab or already released\n+                pass\n+        \n         for c in self._cids:\n             self.canvas.mpl_disconnect(c)\n \n@@ -849,15 +858,16 @@ class RangeSlider(SliderBase):\n         \"\"\"Clip min, max values to the bounds.\"\"\"\n         return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n \n+\n     def _update_val_from_pos(self, pos):\n         \"\"\"Update the slider value based on a given position.\"\"\"\n         idx = np.argmin(np.abs(self.val - pos))\n         if idx == 0:\n             val = self._min_in_bounds(pos)\n-            self.set_min(val)\n+            self.set_min(val, during_drag=True)\n         else:\n             val = self._max_in_bounds(pos)\n-            self.set_max(val)\n+            self.set_max(val, during_drag=True)\n         if self._active_handle:\n             if self.orientation == \"vertical\":\n                 self._active_handle.set_ydata([val])\n@@ -880,8 +890,21 @@ class RangeSlider(SliderBase):\n             event.name == \"button_press_event\" and event.inaxes != self.ax\n         ):\n             self.drag_active = False\n-            event.canvas.release_mouse(self.ax)\n+            try:\n+                event.canvas.release_mouse(self.ax)\n+            except Exception:\n+                # Widget may have been destroyed, ignore release errors\n+                pass\n             self._active_handle = None\n+            # Execute any deferred callbacks after mouse is released\n+            if hasattr(self, '_deferred_callback') and self._deferred_callback:\n+                try:\n+                    self._deferred_callback()\n+                except Exception:\n+                    # Widget may have been destroyed during callback\n+                    pass\n+                finally:\n+                    self._deferred_callback = None\n             return\n \n         # determine which handle was grabbed\n@@ -919,6 +942,7 @@ class RangeSlider(SliderBase):\n             # Use f string to avoid issues with backslashes when cast to a str\n             return f\"({s1}, {s2})\"\n \n+\n     def set_min(self, min):\n         \"\"\"\n         Set the lower value of the slider to *min*.\n@@ -927,7 +951,7 @@ class RangeSlider(SliderBase):\n         ----------\n         min : float\n         \"\"\"\n-        self.set_val((min, self.val[1]))\n+        self.set_val((min, self.val[1]), force_all=True)\n \n     def set_max(self, max):\n         \"\"\"\n@@ -937,7 +961,7 @@ class RangeSlider(SliderBase):\n         ----------\n         max : float\n         \"\"\"\n-        self.set_val((self.val[0], max))\n+        self.set_val((self.val[0], max), force_all=True)\n \n     def set_val(self, val):\n         \"\"\"\n@@ -965,8 +989,18 @@ class RangeSlider(SliderBase):\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n+        \n+        # Check if we're in the middle of a mouse drag operation\n+        # If so, defer callback execution to avoid widget destruction during drag\n         if self.eventson:\n-            self._observers.process(\"changed\", (vmin, vmax))\n+            if hasattr(self, '_mouse_grabbed') and self._mouse_grabbed:\n+                # Store the callback for deferred execution\n+                if not hasattr(self, '_deferred_callback'):\n+                    self._deferred_callback = None\n+                self._deferred_callback = (vmin, vmax)\n+            else:\n+                # Safe to execute callback immediately\n+                self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n         \"\"\"\n@@ -977,7 +1011,6 @@ class RangeSlider(SliderBase):\n         func : callable\n             Function to call when slider is changed. The function\n             must accept a 2-tuple of floats as its argument.\n-\n         Returns\n         -------\n         int\n",
    "variant_8": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex ebe5da43e2..ac2fd86aec 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -144,8 +144,17 @@ class AxesWidget(Widget):\n         cid = self.canvas.mpl_connect(event, callback)\n         self._cids.append(cid)\n \n+\n     def disconnect_events(self):\n         \"\"\"Disconnect all events created by this widget.\"\"\"\n+        # Release any active mouse grab before disconnecting events\n+        if hasattr(self, 'canvas') and self.canvas is not None:\n+            try:\n+                self.canvas.release_mouse(self)\n+            except (AttributeError, ValueError):\n+                # Canvas may not support release_mouse or widget may not have grab\n+                pass\n+        \n         for c in self._cids:\n             self.canvas.mpl_disconnect(c)\n \n@@ -849,15 +858,17 @@ class RangeSlider(SliderBase):\n         \"\"\"Clip min, max values to the bounds.\"\"\"\n         return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n \n+\n     def _update_val_from_pos(self, pos):\n         \"\"\"Update the slider value based on a given position.\"\"\"\n         idx = np.argmin(np.abs(self.val - pos))\n+        # Pass defer_callbacks flag to indicate we're in an active drag operation\n         if idx == 0:\n             val = self._min_in_bounds(pos)\n-            self.set_min(val)\n+            self.set_min(val, defer_callbacks=getattr(self, 'drag_active', False))\n         else:\n             val = self._max_in_bounds(pos)\n-            self.set_max(val)\n+            self.set_max(val, defer_callbacks=getattr(self, 'drag_active', False))\n         if self._active_handle:\n             if self.orientation == \"vertical\":\n                 self._active_handle.set_ydata([val])\n@@ -880,8 +891,21 @@ class RangeSlider(SliderBase):\n             event.name == \"button_press_event\" and event.inaxes != self.ax\n         ):\n             self.drag_active = False\n-            event.canvas.release_mouse(self.ax)\n+            try:\n+                event.canvas.release_mouse(self.ax)\n+            except Exception:\n+                # Handle case where canvas or widget was destroyed\n+                pass\n             self._active_handle = None\n+            # Execute any deferred callbacks after mouse release\n+            if hasattr(self, '_deferred_callback') and self._deferred_callback:\n+                try:\n+                    self._deferred_callback()\n+                except Exception:\n+                    # Ignore errors from deferred callbacks to prevent crashes\n+                    pass\n+                finally:\n+                    self._deferred_callback = None\n             return\n \n         # determine which handle was grabbed\n@@ -901,9 +925,9 @@ class RangeSlider(SliderBase):\n             self._active_handle = handle\n \n         if self.orientation == \"vertical\":\n-            self._update_val_from_pos(event.ydata)\n+            self._update_val_from_pos(event.ydata, during_drag=True)\n         else:\n-            self._update_val_from_pos(event.xdata)\n+            self._update_val_from_pos(event.xdata, during_drag=True)\n \n     def _format(self, val):\n         \"\"\"Pretty-print *val*.\"\"\"\n@@ -919,6 +943,7 @@ class RangeSlider(SliderBase):\n             # Use f string to avoid issues with backslashes when cast to a str\n             return f\"({s1}, {s2})\"\n \n+\n     def set_min(self, min):\n         \"\"\"\n         Set the lower value of the slider to *min*.\n@@ -927,7 +952,7 @@ class RangeSlider(SliderBase):\n         ----------\n         min : float\n         \"\"\"\n-        self.set_val((min, self.val[1]))\n+        self.set_val((min, self.val[1]), force_all=True)\n \n     def set_max(self, max):\n         \"\"\"\n@@ -937,7 +962,7 @@ class RangeSlider(SliderBase):\n         ----------\n         max : float\n         \"\"\"\n-        self.set_val((self.val[0], max))\n+        self.set_val((self.val[0], max), force_all=True)\n \n     def set_val(self, val):\n         \"\"\"\n@@ -966,7 +991,12 @@ class RangeSlider(SliderBase):\n             self.ax.figure.canvas.draw_idle()\n         self.val = (vmin, vmax)\n         if self.eventson:\n-            self._observers.process(\"changed\", (vmin, vmax))\n+            # Check if we're in an active drag operation\n+            if hasattr(self, '_active_drag') and self._active_drag:\n+                # Defer callback execution until after mouse release\n+                self._deferred_callback = (vmin, vmax)\n+            else:\n+                self._observers.process(\"changed\", (vmin, vmax))\n \n     def on_changed(self, func):\n         \"\"\"\n@@ -984,6 +1014,12 @@ class RangeSlider(SliderBase):\n             Connection id (which can be used to disconnect *func*).\n         \"\"\"\n         return self._observers.connect('changed', lambda val: func(val))\n+        Returns\n+        -------\n+        int\n+            Connection id (which can be used to disconnect *func*).\n+        \"\"\"\n+        return self._observers.connect('changed', lambda val: func(val))\n \n \n def _expand_text_props(props):\n"
  }
}