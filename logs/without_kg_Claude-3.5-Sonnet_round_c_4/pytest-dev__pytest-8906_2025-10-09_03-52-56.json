{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/pytest/src/_pytest/python.py lines 610-615)": "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n                \"any problematic imports or syntax.\"\n            ) from e\n",
    "Location 2 (/root/hy/projects_4/pytest/src/_pytest/outcomes.py lines 124-144)": "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False. Use this when you need to skip\n        a module before imports or syntax that would cause parsing errors\n        in certain Python versions.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies. However, use \n        ``allow_module_level=True`` or ``skip_module()`` when the module\n        contains syntax incompatible with the current Python version.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\n@_with_exception(Skipped)\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=True)\n",
    "Location 3 (/root/hy/projects_4/pytest/src/_pytest/outcomes.py lines 145-150)": "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False. Use this when you need to skip\n        a module before imports or syntax that would cause parsing errors\n        in certain Python versions.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies. However, use \n        ``allow_module_level=True`` or ``skip_module()`` when the module\n        contains syntax incompatible with the current Python version.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    return skip(msg, allow_module_level=True)\n\n\n@_with_exception(Failed)\ndef fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n    \"\"\"Explicitly fail an executing test with the given message.\n\n    :param str msg:\n        The message to show the user as reason for the failure.\n    :param bool pytrace:\n        If False, msg represents the full failure information and no\n        python traceback will be reported.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Failed(msg=msg, pytrace=pytrace)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/pytest/src/_pytest/python.py lines 610-615)": [
      "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n                \"any problematic imports or syntax.\"\n            ) from e\n",
      "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n                \"any problematic imports or syntax.\"\n            ) from e\n",
      "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n                \"any problematic imports or syntax.\"\n            ) from e\n",
      "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n                \"any problematic imports or syntax.\"\n            ) from e\n",
      "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n                \"any problematic imports or syntax.\"\n            ) from e\n",
      "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n                \"any problematic imports or syntax.\"\n            ) from e\n",
      "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n                \"any problematic imports or syntax.\"\n            ) from e\n",
      "\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead. To skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n                \"any problematic imports or syntax.\"\n            ) from e\n"
    ],
    "Location 2 (/root/hy/projects_4/pytest/src/_pytest/outcomes.py lines 124-144)": [
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False. Use this when you need to skip\n        a module before imports or syntax that would cause parsing errors\n        in certain Python versions.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies. However, use \n        ``allow_module_level=True`` or ``skip_module()`` when the module\n        contains syntax incompatible with the current Python version.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    return skip(msg, allow_module_level=True)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False. Use this when you need to skip\n        a module before imports or syntax that would cause parsing errors\n        in certain Python versions.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies. However, use \n        ``allow_module_level=True`` or ``skip_module()`` when the module\n        contains syntax incompatible with the current Python version.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    return skip(msg, allow_module_level=True)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False. Use this when you need to skip\n        a module before imports or syntax that would cause parsing errors\n        in certain Python versions.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies. However, use \n        ``allow_module_level=True`` or ``skip_module()`` when the module\n        contains syntax incompatible with the current Python version.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    return skip(msg, allow_module_level=True)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False. Use this when you need to skip\n        a module before imports or syntax that would cause parsing errors\n        in certain Python versions.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies. However, use \n        ``allow_module_level=True`` or ``skip_module()`` when the module\n        contains syntax incompatible with the current Python version.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    return skip(msg, allow_module_level=True)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False. Use this when you need to skip\n        a module before imports or syntax that would cause parsing errors\n        in certain Python versions.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies. However, use \n        ``allow_module_level=True`` or ``skip_module()`` when the module\n        contains syntax incompatible with the current Python version.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    return skip(msg, allow_module_level=True)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False. Use this when you need to skip\n        a module before imports or syntax that would cause parsing errors\n        in certain Python versions.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies. However, use \n        ``allow_module_level=True`` or ``skip_module()`` when the module\n        contains syntax incompatible with the current Python version.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    return skip(msg, allow_module_level=True)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False. Use this when you need to skip\n        a module before imports or syntax that would cause parsing errors\n        in certain Python versions.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies. However, use \n        ``allow_module_level=True`` or ``skip_module()`` when the module\n        contains syntax incompatible with the current Python version.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    return skip(msg, allow_module_level=True)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False. Use this when you need to skip\n        a module before imports or syntax that would cause parsing errors\n        in certain Python versions.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies. However, use \n        ``allow_module_level=True`` or ``skip_module()`` when the module\n        contains syntax incompatible with the current Python version.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    return skip(msg, allow_module_level=True)\n"
    ],
    "Location 3 (/root/hy/projects_4/pytest/src/_pytest/outcomes.py lines 145-150)": [
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False. Use this when you need to skip\n        a module before imports or syntax that would cause parsing errors\n        in certain Python versions.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies. However, use \n        ``allow_module_level=True`` or ``skip_module()`` when the module\n        contains syntax incompatible with the current Python version.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    return skip(msg, allow_module_level=True)\n\n\n@_with_exception(Failed)\ndef fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n    \"\"\"Explicitly fail an executing test with the given message.\n\n    :param str msg:\n        The message to show the user as reason for the failure.\n    :param bool pytrace:\n        If False, msg represents the full failure information and no\n        python traceback will be reported.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Failed(msg=msg, pytrace=pytrace)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False. Use this when you need to skip\n        a module before imports or syntax that would cause parsing errors\n        in certain Python versions.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies. However, use \n        ``allow_module_level=True`` or ``skip_module()`` when the module\n        contains syntax incompatible with the current Python version.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    return skip(msg, allow_module_level=True)\n\n\n@_with_exception(Failed)\ndef fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n    \"\"\"Explicitly fail an executing test with the given message.\n\n    :param str msg:\n        The message to show the user as reason for the failure.\n    :param bool pytrace:\n        If False, msg represents the full failure information and no\n        python traceback will be reported.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Failed(msg=msg, pytrace=pytrace)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False. Use this when you need to skip\n        a module before imports or syntax that would cause parsing errors\n        in certain Python versions.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies. However, use \n        ``allow_module_level=True`` or ``skip_module()`` when the module\n        contains syntax incompatible with the current Python version.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to-doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    return skip(msg, allow_module_level=True)\n\n\n@_with_exception(Failed)\ndef fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n    \"\"\"Explicitly fail an executing test with the given message.\n\n    :param str msg:\n        The message to show the user as reason for the failure.\n    :param bool pytrace:\n        If False, msg represents the full failure information and no\n        python traceback will be reported.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Failed(msg=msg, pytrace=pytrace)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False. Use this when you need to skip\n        a module before imports or syntax that would cause parsing errors\n        in certain Python versions.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies. However, use \n        ``allow_module_level=True`` or ``skip_module()`` when the module\n        contains syntax incompatible with the current Python version.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    return skip(msg, allow_module_level=True)\n\n\n@_with_exception(Failed)\ndef fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n    \"\"\"Explicitly fail an executing test with the given message.\n\n    :param str msg:\n        The message to show the user as reason for the failure.\n    :param bool pytrace:\n        If False, msg represents the full failure information and no\n        python traceback will be reported.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Failed(msg=msg, pytrace=pytrace)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False. Use this when you need to skip\n        a module before imports or syntax that would cause parsing errors\n        in certain Python versions.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies. However, use \n        ``allow_module_level=True`` or ``skip_module()`` when the module\n        contains syntax incompatible with the current Python version.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    return skip(msg, allow_module_level=True)\n\n\n@_with_exception(Failed)\ndef fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n    \"\"\"Explicitly fail an executing test with the given message.\n\n    :param str msg:\n        The message to show the user as reason for the failure.\n    :param bool pytrace:\n        If False, msg represents the full failure information and no\n        python traceback will be reported.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Failed(msg=msg, pytrace=pytrace)\n",
      "\n@_with_exception(Failed)\ndef fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n    \"\"\"Explicitly fail an executing test with the given message.\n\n    :param str msg:\n        The message to show the user as reason for the failure.\n    :param bool pytrace:\n        If False, msg represents the full failure information and no\n        python traceback will be reported.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Failed(msg=msg, pytrace=pytrace)\n\n\n@_with_exception(Skipped)\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=True)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False. Use this when you need to skip\n        a module before imports or syntax that would cause parsing errors\n        in certain Python versions.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies. However, use \n        ``allow_module_level=True`` or ``skip_module()`` when the module\n        contains syntax incompatible with the current Python version.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    return skip(msg, allow_module_level=True)\n\n\n@_with_exception(Failed)\ndef fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n    \"\"\"Explicitly fail an executing test with the given message.\n\n    :param str msg:\n        The message to show the user as reason for the failure.\n    :param bool pytrace:\n        If False, msg represents the full failure information and no\n        python traceback will be reported.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Failed(msg=msg, pytrace=pytrace)\n",
      "\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :param bool allow_module_level:\n        Allows this function to be called at module level, skipping the rest\n        of the module. Defaults to False. Use this when you need to skip\n        a module before imports or syntax that would cause parsing errors\n        in certain Python versions.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n        possible to declare a test to be skipped under certain conditions\n        like mismatching platforms or dependencies. However, use \n        ``allow_module_level=True`` or ``skip_module()`` when the module\n        contains syntax incompatible with the current Python version.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/how-to-doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n\n\ndef skip_module(msg: str = \"\") -> \"NoReturn\":\n    \"\"\"Skip the entire module with the given message.\n    \n    This is a convenience function equivalent to calling\n    skip(msg, allow_module_level=True). Use this when you need\n    to skip a module before problematic imports or syntax.\n    \n    :param str msg: The reason for skipping the module.\n    \"\"\"\n    __tracebackhide__ = True\n    return skip(msg, allow_module_level=True)\n\n\n@_with_exception(Failed)\ndef fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n    \"\"\"Explicitly fail an executing test with the given message.\n\n    :param str msg:\n        The message to show the user as reason for the failure.\n    :param bool pytrace:\n        If False, msg represents the full failure information and no\n        python traceback will be reported.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Failed(msg=msg, pytrace=pytrace)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..19ac55e39 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -121,6 +121,7 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n \n \n @_with_exception(Skipped)\n+\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n \n@@ -130,12 +131,16 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n \n     :param bool allow_module_level:\n         Allows this function to be called at module level, skipping the rest\n-        of the module. Defaults to False.\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n \n     .. note::\n         It is better to use the :ref:`pytest.mark.skipif ref` marker when\n         possible to declare a test to be skipped under certain conditions\n-        like mismatching platforms or dependencies.\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n         Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n         <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n         to skip a doctest statically.\n@@ -144,10 +149,24 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+\n+@_with_exception(Skipped)\n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    return skip(msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\n-\n     :param str msg:\n         The message to show the user as reason for the failure.\n     :param bool pytrace:\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..551c58589 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,14 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n+                \"any problematic imports or syntax.\"\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\n",
    "variant_0": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..9674f27b8 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -120,6 +120,49 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n+@_with_exception(Skipped)\n+def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n+    \"\"\"Skip an executing test with the given message.\n+\n+    This function should be called only during testing (setup, call or teardown) or\n+    during collection by using the ``allow_module_level`` flag.  This function can\n+    be called in doctests as well.\n+\n+    :param bool allow_module_level:\n+        Allows this function to be called at module level, skipping the rest\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n+\n+    .. note::\n+        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n+        possible to declare a test to be skipped under certain conditions\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n+        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n+        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n+        to skip a doctest statically.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n+\n+\n+@_with_exception(Skipped)\n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Skipped(msg=msg, allow_module_level=True)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -130,12 +173,16 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n \n     :param bool allow_module_level:\n         Allows this function to be called at module level, skipping the rest\n-        of the module. Defaults to False.\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n \n     .. note::\n         It is better to use the :ref:`pytest.mark.skipif ref` marker when\n         possible to declare a test to be skipped under certain conditions\n-        like mismatching platforms or dependencies.\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n         Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n         <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n         to skip a doctest statically.\n@@ -144,6 +191,19 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    return skip(msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\n@@ -156,6 +216,14 @@ def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"\n     __tracebackhide__ = True\n     raise Failed(msg=msg, pytrace=pytrace)\n+    :param str msg:\n+        The message to show the user as reason for the failure.\n+    :param bool pytrace:\n+        If False, msg represents the full failure information and no\n+        python traceback will be reported.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Failed(msg=msg, pytrace=pytrace)\n \n \n class XFailed(Failed):\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..551c58589 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,14 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n+                \"any problematic imports or syntax.\"\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\n",
    "variant_1": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..e66c790d1 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -120,6 +120,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -130,12 +132,16 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n \n     :param bool allow_module_level:\n         Allows this function to be called at module level, skipping the rest\n-        of the module. Defaults to False.\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n \n     .. note::\n         It is better to use the :ref:`pytest.mark.skipif ref` marker when\n         possible to declare a test to be skipped under certain conditions\n-        like mismatching platforms or dependencies.\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n         Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n         <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n         to skip a doctest statically.\n@@ -144,6 +150,59 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    return skip(msg, allow_module_level=True)\n+\n+@_with_exception(Skipped)\n+def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n+    \"\"\"Skip an executing test with the given message.\n+\n+    This function should be called only during testing (setup, call or teardown) or\n+    during collection by using the ``allow_module_level`` flag.  This function can\n+    be called in doctests as well.\n+\n+    :param bool allow_module_level:\n+        Allows this function to be called at module level, skipping the rest\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n+\n+    .. note::\n+        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n+        possible to declare a test to be skipped under certain conditions\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n+        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n+        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n+        to skip a doctest statically.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n+\n+\n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    return skip(msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\n@@ -156,6 +215,14 @@ def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"\n     __tracebackhide__ = True\n     raise Failed(msg=msg, pytrace=pytrace)\n+    :param str msg:\n+        The message to show the user as reason for the failure.\n+    :param bool pytrace:\n+        If False, msg represents the full failure information and no\n+        python traceback will be reported.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Failed(msg=msg, pytrace=pytrace)\n \n \n class XFailed(Failed):\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..551c58589 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,14 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n+                \"any problematic imports or syntax.\"\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\n",
    "variant_2": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..e66c790d1 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -120,6 +120,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -130,12 +132,16 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n \n     :param bool allow_module_level:\n         Allows this function to be called at module level, skipping the rest\n-        of the module. Defaults to False.\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n \n     .. note::\n         It is better to use the :ref:`pytest.mark.skipif ref` marker when\n         possible to declare a test to be skipped under certain conditions\n-        like mismatching platforms or dependencies.\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n         Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n         <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n         to skip a doctest statically.\n@@ -144,6 +150,59 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    return skip(msg, allow_module_level=True)\n+\n+@_with_exception(Skipped)\n+def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n+    \"\"\"Skip an executing test with the given message.\n+\n+    This function should be called only during testing (setup, call or teardown) or\n+    during collection by using the ``allow_module_level`` flag.  This function can\n+    be called in doctests as well.\n+\n+    :param bool allow_module_level:\n+        Allows this function to be called at module level, skipping the rest\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n+\n+    .. note::\n+        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n+        possible to declare a test to be skipped under certain conditions\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n+        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n+        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n+        to skip a doctest statically.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n+\n+\n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    return skip(msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\n@@ -156,6 +215,14 @@ def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"\n     __tracebackhide__ = True\n     raise Failed(msg=msg, pytrace=pytrace)\n+    :param str msg:\n+        The message to show the user as reason for the failure.\n+    :param bool pytrace:\n+        If False, msg represents the full failure information and no\n+        python traceback will be reported.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Failed(msg=msg, pytrace=pytrace)\n \n \n class XFailed(Failed):\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..551c58589 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,14 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n+                \"any problematic imports or syntax.\"\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\n",
    "variant_3": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..a3280961a 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -120,6 +120,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -130,12 +132,16 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n \n     :param bool allow_module_level:\n         Allows this function to be called at module level, skipping the rest\n-        of the module. Defaults to False.\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n \n     .. note::\n         It is better to use the :ref:`pytest.mark.skipif ref` marker when\n         possible to declare a test to be skipped under certain conditions\n-        like mismatching platforms or dependencies.\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n         Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n         <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n         to skip a doctest statically.\n@@ -144,6 +150,59 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    return skip(msg, allow_module_level=True)\n+\n+@_with_exception(Skipped)\n+def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n+    \"\"\"Skip an executing test with the given message.\n+\n+    This function should be called only during testing (setup, call or teardown) or\n+    during collection by using the ``allow_module_level`` flag.  This function can\n+    be called in doctests as well.\n+\n+    :param bool allow_module_level:\n+        Allows this function to be called at module level, skipping the rest\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n+\n+    .. note::\n+        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n+        possible to declare a test to be skipped under certain conditions\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n+        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n+        <https://docs.python.org/3/library/how-to-doctest.html#doctest.SKIP>`_)\n+        to skip a doctest statically.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n+\n+\n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    return skip(msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\n@@ -156,6 +215,14 @@ def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"\n     __tracebackhide__ = True\n     raise Failed(msg=msg, pytrace=pytrace)\n+    :param str msg:\n+        The message to show the user as reason for the failure.\n+    :param bool pytrace:\n+        If False, msg represents the full failure information and no\n+        python traceback will be reported.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Failed(msg=msg, pytrace=pytrace)\n \n \n class XFailed(Failed):\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..551c58589 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,14 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n+                \"any problematic imports or syntax.\"\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\n",
    "variant_4": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..e66c790d1 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -120,6 +120,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -130,12 +132,16 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n \n     :param bool allow_module_level:\n         Allows this function to be called at module level, skipping the rest\n-        of the module. Defaults to False.\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n \n     .. note::\n         It is better to use the :ref:`pytest.mark.skipif ref` marker when\n         possible to declare a test to be skipped under certain conditions\n-        like mismatching platforms or dependencies.\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n         Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n         <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n         to skip a doctest statically.\n@@ -144,6 +150,59 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    return skip(msg, allow_module_level=True)\n+\n+@_with_exception(Skipped)\n+def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n+    \"\"\"Skip an executing test with the given message.\n+\n+    This function should be called only during testing (setup, call or teardown) or\n+    during collection by using the ``allow_module_level`` flag.  This function can\n+    be called in doctests as well.\n+\n+    :param bool allow_module_level:\n+        Allows this function to be called at module level, skipping the rest\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n+\n+    .. note::\n+        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n+        possible to declare a test to be skipped under certain conditions\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n+        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n+        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n+        to skip a doctest statically.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n+\n+\n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    return skip(msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\n@@ -156,6 +215,14 @@ def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"\n     __tracebackhide__ = True\n     raise Failed(msg=msg, pytrace=pytrace)\n+    :param str msg:\n+        The message to show the user as reason for the failure.\n+    :param bool pytrace:\n+        If False, msg represents the full failure information and no\n+        python traceback will be reported.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Failed(msg=msg, pytrace=pytrace)\n \n \n class XFailed(Failed):\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..551c58589 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,14 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n+                \"any problematic imports or syntax.\"\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\n",
    "variant_5": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..e66c790d1 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -120,6 +120,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -130,12 +132,16 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n \n     :param bool allow_module_level:\n         Allows this function to be called at module level, skipping the rest\n-        of the module. Defaults to False.\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n \n     .. note::\n         It is better to use the :ref:`pytest.mark.skipif ref` marker when\n         possible to declare a test to be skipped under certain conditions\n-        like mismatching platforms or dependencies.\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n         Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n         <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n         to skip a doctest statically.\n@@ -144,6 +150,59 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    return skip(msg, allow_module_level=True)\n+\n+@_with_exception(Skipped)\n+def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n+    \"\"\"Skip an executing test with the given message.\n+\n+    This function should be called only during testing (setup, call or teardown) or\n+    during collection by using the ``allow_module_level`` flag.  This function can\n+    be called in doctests as well.\n+\n+    :param bool allow_module_level:\n+        Allows this function to be called at module level, skipping the rest\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n+\n+    .. note::\n+        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n+        possible to declare a test to be skipped under certain conditions\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n+        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n+        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n+        to skip a doctest statically.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n+\n+\n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    return skip(msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\n@@ -156,6 +215,14 @@ def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"\n     __tracebackhide__ = True\n     raise Failed(msg=msg, pytrace=pytrace)\n+    :param str msg:\n+        The message to show the user as reason for the failure.\n+    :param bool pytrace:\n+        If False, msg represents the full failure information and no\n+        python traceback will be reported.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Failed(msg=msg, pytrace=pytrace)\n \n \n class XFailed(Failed):\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..551c58589 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,14 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n+                \"any problematic imports or syntax.\"\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\n",
    "variant_6": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..d365a8788 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -120,6 +120,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -130,12 +132,16 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n \n     :param bool allow_module_level:\n         Allows this function to be called at module level, skipping the rest\n-        of the module. Defaults to False.\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n \n     .. note::\n         It is better to use the :ref:`pytest.mark.skipif ref` marker when\n         possible to declare a test to be skipped under certain conditions\n-        like mismatching platforms or dependencies.\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n         Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n         <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n         to skip a doctest statically.\n@@ -144,6 +150,18 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    return skip(msg, allow_module_level=True)\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\n@@ -158,6 +176,28 @@ def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     raise Failed(msg=msg, pytrace=pytrace)\n \n \n+@_with_exception(Skipped)\n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Skipped(msg=msg, allow_module_level=True)\n+    :param str msg:\n+        The message to show the user as reason for the failure.\n+    :param bool pytrace:\n+        If False, msg represents the full failure information and no\n+        python traceback will be reported.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Failed(msg=msg, pytrace=pytrace)\n+\n+\n class XFailed(Failed):\n     \"\"\"Raised from an explicit call to pytest.xfail().\"\"\"\n \ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..551c58589 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,14 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n+                \"any problematic imports or syntax.\"\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\n",
    "variant_7": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..e66c790d1 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -120,6 +120,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -130,12 +132,16 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n \n     :param bool allow_module_level:\n         Allows this function to be called at module level, skipping the rest\n-        of the module. Defaults to False.\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n \n     .. note::\n         It is better to use the :ref:`pytest.mark.skipif ref` marker when\n         possible to declare a test to be skipped under certain conditions\n-        like mismatching platforms or dependencies.\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n         Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n         <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n         to skip a doctest statically.\n@@ -144,6 +150,59 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    return skip(msg, allow_module_level=True)\n+\n+@_with_exception(Skipped)\n+def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n+    \"\"\"Skip an executing test with the given message.\n+\n+    This function should be called only during testing (setup, call or teardown) or\n+    during collection by using the ``allow_module_level`` flag.  This function can\n+    be called in doctests as well.\n+\n+    :param bool allow_module_level:\n+        Allows this function to be called at module level, skipping the rest\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n+\n+    .. note::\n+        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n+        possible to declare a test to be skipped under certain conditions\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n+        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n+        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n+        to skip a doctest statically.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n+\n+\n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    return skip(msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\n@@ -156,6 +215,14 @@ def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"\n     __tracebackhide__ = True\n     raise Failed(msg=msg, pytrace=pytrace)\n+    :param str msg:\n+        The message to show the user as reason for the failure.\n+    :param bool pytrace:\n+        If False, msg represents the full failure information and no\n+        python traceback will be reported.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Failed(msg=msg, pytrace=pytrace)\n \n \n class XFailed(Failed):\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..551c58589 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,14 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n+                \"any problematic imports or syntax.\"\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\n",
    "variant_8": "diff --git a/src/_pytest/outcomes.py b/src/_pytest/outcomes.py\nindex 2addf5572..a3280961a 100644\n--- a/src/_pytest/outcomes.py\n+++ b/src/_pytest/outcomes.py\n@@ -120,6 +120,8 @@ def exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n     raise Exit(msg, returncode)\n \n \n+@_with_exception(Skipped)\n+\n @_with_exception(Skipped)\n def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     \"\"\"Skip an executing test with the given message.\n@@ -130,12 +132,16 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n \n     :param bool allow_module_level:\n         Allows this function to be called at module level, skipping the rest\n-        of the module. Defaults to False.\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n \n     .. note::\n         It is better to use the :ref:`pytest.mark.skipif ref` marker when\n         possible to declare a test to be skipped under certain conditions\n-        like mismatching platforms or dependencies.\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n         Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n         <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n         to skip a doctest statically.\n@@ -144,6 +150,59 @@ def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n     raise Skipped(msg=msg, allow_module_level=allow_module_level)\n \n \n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    return skip(msg, allow_module_level=True)\n+\n+@_with_exception(Skipped)\n+def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n+    \"\"\"Skip an executing test with the given message.\n+\n+    This function should be called only during testing (setup, call or teardown) or\n+    during collection by using the ``allow_module_level`` flag.  This function can\n+    be called in doctests as well.\n+\n+    :param bool allow_module_level:\n+        Allows this function to be called at module level, skipping the rest\n+        of the module. Defaults to False. Use this when you need to skip\n+        a module before imports or syntax that would cause parsing errors\n+        in certain Python versions.\n+\n+    .. note::\n+        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n+        possible to declare a test to be skipped under certain conditions\n+        like mismatching platforms or dependencies. However, use \n+        ``allow_module_level=True`` or ``skip_module()`` when the module\n+        contains syntax incompatible with the current Python version.\n+        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n+        <https://docs.python.org/3/library/how-to-doctest.html#doctest.SKIP>`_)\n+        to skip a doctest statically.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n+\n+\n+def skip_module(msg: str = \"\") -> \"NoReturn\":\n+    \"\"\"Skip the entire module with the given message.\n+    \n+    This is a convenience function equivalent to calling\n+    skip(msg, allow_module_level=True). Use this when you need\n+    to skip a module before problematic imports or syntax.\n+    \n+    :param str msg: The reason for skipping the module.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    return skip(msg, allow_module_level=True)\n+\n+\n @_with_exception(Failed)\n def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"Explicitly fail an executing test with the given message.\n@@ -156,6 +215,14 @@ def fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n     \"\"\"\n     __tracebackhide__ = True\n     raise Failed(msg=msg, pytrace=pytrace)\n+    :param str msg:\n+        The message to show the user as reason for the failure.\n+    :param bool pytrace:\n+        If False, msg represents the full failure information and no\n+        python traceback will be reported.\n+    \"\"\"\n+    __tracebackhide__ = True\n+    raise Failed(msg=msg, pytrace=pytrace)\n \n \n class XFailed(Failed):\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 79dfb7320..551c58589 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -607,11 +607,14 @@ class Module(nodes.File, PyCollector):\n         except skip.Exception as e:\n             if e.allow_module_level:\n                 raise\n+\n             raise self.CollectError(\n                 \"Using pytest.skip outside of a test is not allowed. \"\n                 \"To decorate a test function, use the @pytest.mark.skip \"\n-                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n-                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n+                \"or @pytest.mark.skipif decorators instead. To skip a \"\n+                \"module use `pytestmark = pytest.mark.{skip,skipif}` or \"\n+                \"call `pytest.skip(msg, allow_module_level=True)` before \"\n+                \"any problematic imports or syntax.\"\n             ) from e\n         self.config.pluginmanager.consider_module(mod)\n         return mod\n"
  }
}