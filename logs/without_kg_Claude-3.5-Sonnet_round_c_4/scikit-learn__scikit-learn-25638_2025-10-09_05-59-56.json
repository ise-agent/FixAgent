{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/scikit-learn/sklearn/utils/multiclass.py lines 305-314)": "\n    # DeprecationWarning will be replaced by ValueError, see NEP 34\n    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n    # We therefore catch both deprecation (NumPy < 1.24) warning and\n    # value error (NumPy >= 1.24).\n    \n    # Check if y is a pandas nullable dtype before conversion\n    pandas_nullable_dtype = False\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        nullable_dtypes = {'Int8', 'Int16', 'Int32', 'Int64', 'UInt8', 'UInt16', 'UInt32', 'UInt64', 'Float32', 'Float64', 'boolean'}\n        if y.dtype.name in nullable_dtypes:\n            pandas_nullable_dtype = True\n    \n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n        if not issparse(y):\n            try:\n                if pandas_nullable_dtype:\n                    # Convert pandas nullable dtype to regular numpy dtype to preserve semantics\n                    y = y.to_numpy(dtype=y.dtype.numpy_dtype, na_value=np.nan)\n                else:\n                    y = xp.asarray(y)\n            except (np.VisibleDeprecationWarning, ValueError):\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = xp.asarray(y, dtype=object)\n",
    "Location 2 (/root/hy/projects_4/scikit-learn/sklearn/utils/multiclass.py lines 343-345)": "\n    if not issparse(y) and y.dtype == object:\n        # Check if this is a pandas nullable dtype converted to object\n        if hasattr(y, '__array_function__') and len(y) > 0:\n            # Try to determine if object array contains numeric data from nullable dtypes\n            first_val = y.flat[0]\n            if first_val is not None and not isinstance(first_val, str):\n                # Check if all non-null values are numeric\n                try:\n                    non_null_vals = [val for val in y.flat if val is not None]\n                    if non_null_vals and all(isinstance(val, (int, float, np.integer, np.floating)) for val in non_null_vals):\n                        # This appears to be numeric data, continue with normal classification\n                        pass\n                    else:\n                        return \"unknown\"\n                except (TypeError, ValueError):\n                    return \"unknown\"\n            elif not isinstance(first_val, str):\n                # [obj_1] and not [\"label_1\"]\n                return \"unknown\"\n        elif not isinstance(y.flat[0], str):\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n",
    "Location 3 (/root/hy/projects_4/scikit-learn/sklearn/utils/multiclass.py lines 361-367)": "\ndef type_of_target(y, input_name=\"\"):\n    \"\"\"Determine the type of data indicated by the target.\n\n    Note that this type is the most specific type that can be inferred.\n    For example:\n\n        * ``binary`` is more specific but compatible with ``multiclass``.\n        * ``multiclass`` is more specific but compatible with ``continuous``.\n        * ``multilabel-indicator`` is more specific but compatible with\n          ``multiclass-multioutput``.\n\n    Parameters\n    ----------\n    y : {array-like, sparse matrix}\n        Target values. If a sparse matrix, a CSR matrix is expected.\n\n    input_name : str, default=\"\"\n        The data name used to construct the error message.\n\n        .. versionadded:: 1.1.0\n\n    Returns\n    -------\n    target_type : str\n        One of:\n\n        * 'continuous': `y` is an array-like of floats that are not all\n          integers, and is 1d or a column vector.\n        * 'continuous-multioutput': `y` is a 2d array of floats that are\n          not all integers, and both dimensions are of size > 1.\n        * 'binary': `y` contains <= 2 discrete values and is 1d or a column\n          vector.\n        * 'multiclass': `y` contains more than two discrete values, is not a\n          sequence of sequences, and is 1d or a column vector.\n        * 'multiclass-multioutput': `y` is a 2d array that contains more\n          than two discrete values, is not a sequence of sequences, and both\n          dimensions are of size > 1.\n        * 'multilabel-indicator': `y` is a label indicator matrix, an array\n          of two dimensions with at least two columns, and at most 2 unique\n          values.\n        * 'unknown': `y` is array-like but none of the above, such as a 3d\n          array, or an array of non-sequence objects.\n\n    Examples\n    --------\n    >>> from sklearn.utils.multiclass import type_of_target\n    >>> import numpy as np\n    >>> type_of_target([0.1, 0.6])\n    'continuous'\n    >>> type_of_target([1, -1, -1, 1])\n    'binary'\n    >>> type_of_target(['a', 'b', 'a'])\n    'binary'\n    >>> type_of_target([1.0, 2.0])\n    'binary'\n    >>> type_of_target([1, 0, 2])\n    'multiclass'\n    >>> type_of_target([1.0, 0.0, 3.0])\n    'multiclass'\n    >>> type_of_target(['a', 'b', 'c'])\n    'multiclass'\n    >>> type_of_target(np.array([[1, 2], [3, 1]]))\n    'multiclass-multioutput'\n    >>> type_of_target([[1, 2]])\n    'multilabel-indicator'\n    >>> type_of_target(np.array([[1.5, 2.0], [3.0, 1.6]]))\n    'continuous-multioutput'\n    >>> type_of_target(np.array([[0, 1], [1, 1]]))\n    'multilabel-indicator'\n    \"\"\"\n    xp, is_array_api_compliant = get_namespace(y)\n    \n    # Store original pandas nullable dtype info if present\n    original_pandas_dtype = None\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        if y.dtype.name in ['Int8', 'Int16', 'Int32', 'Int64', 'UInt8', 'UInt16', 'UInt32', 'UInt64', 'Float32', 'Float64', 'boolean']:\n            original_pandas_dtype = y.dtype.name\n\n    if is_array_api_compliant:\n        y = xp.asarray(y)\n    else:\n        y = check_array(y, accept_sparse=True, ensure_2d=False, dtype=None)\n\n    # Check if sparse matrix\n    if issparse(y):\n        if y.format not in [\"csr\", \"csc\", \"coo\"]:\n            raise ValueError(\n                \"Sparse matrix in format {} is not supported\".format(y.format)\n            )\n\n    # The targets are empty, consider them as binary.\n    if y.size == 0:\n        return \"binary\"\n\n    # The targets are of a valid type?\n    valid = (\n        (issparse(y) or hasattr(y, \"__array__\"))\n        and hasattr(y, \"shape\")\n        and hasattr(y, \"dtype\")\n    )\n\n    if not valid:\n        return \"unknown\"\n\n    # Check if y is a string array\n    if y.dtype.kind in \"SUVO\":\n        # Check if y is a sequence of sequences\n        if y.ndim == 2 and y.shape[1] > 1:\n            suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n        else:\n            suffix = \"\"  # [1, 2, 3] or [[1], [2], [3]]\n\n        # Special handling for object dtype that might be from pandas nullable types\n        if y.dtype == object and original_pandas_dtype:\n            # For converted pandas nullable types, treat as numeric\n            if original_pandas_dtype in ['Int8', 'Int16', 'Int32', 'Int64', 'UInt8', 'UInt16', 'UInt32', 'UInt64']:\n                # Integer nullable types - check for binary vs multiclass\n                try:\n                    unique_vals = xp.unique_values(y)\n                    if unique_vals.shape[0] > 2 or (y.ndim == 2 and y.shape[1] > 1):\n                        return \"multiclass\" + suffix\n                    else:\n                        return \"binary\"\n                except:\n                    # Fallback to checking first few elements\n                    first_row = y[0] if not issparse(y) else y.getrow(0).data\n                    if y.ndim == 2 and len(first_row) > 1:\n                        return \"multiclass\" + suffix\n                    else:\n                        return \"binary\"\n            elif original_pandas_dtype in ['Float32', 'Float64']:\n                # Float nullable types - check if they're all integers\n                try:\n                    data = y.data if issparse(y) else y\n                    # Convert to float for comparison\n                    float_data = data.astype(float)\n                    if xp.any(float_data != float_data.astype(int)):\n                        return \"continuous\" + suffix\n                    else:\n                        # All floats are integers, treat as discrete\n                        unique_vals = xp.unique_values(y)\n                        if unique_vals.shape[0] > 2 or (y.ndim == 2 and y.shape[1] > 1):\n                            return \"multiclass\" + suffix\n                        else:\n                            return \"binary\"\n                except:\n                    return \"continuous\" + suffix\n            elif original_pandas_dtype == 'boolean':\n                return \"binary\"\n        \n        # Original string/object logic for non-pandas cases\n        if y.dtype != object:\n            # [1, 2, 3] or [[1], [2], [3]] or [[1, 2], [1, 2]]\n            return \"multiclass\" + suffix\n        else:\n            return \"unknown\"\n\n    # Check if y is a sequence of sequences\n    if y.ndim == 2 and y.shape[1] > 1:\n        suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n    else:\n        suffix = \"\"  # [1, 2, 3] or [[1], [2], [3]]\n\n    # Check float and contains non-integer float values\n    if y.dtype.kind == \"f\":\n        # [.1, .2, 3] or [[.1, .2, 3]] or [[1., .2]] and not [1., 2., 3.]\n        data = y.data if issparse(y) else y\n        if xp.any(data != data.astype(int)):\n            _assert_all_finite(data, input_name=input_name)\n            return \"continuous\" + suffix\n\n    # Check multiclass\n    first_row = y[0] if not issparse(y) else y.getrow(0).data\n    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n",
    "Location 4 (/root/hy/projects_4/scikit-learn/sklearn/utils/multiclass.py lines 23-28)": "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    if hasattr(y, \"__array__\") or is_array_api:\n        # Handle pandas nullable dtypes that get converted to object arrays\n        y_array = xp.asarray(y)\n        if hasattr(y, 'dtype') and str(y.dtype) in ['Int64', 'Float64', 'boolean']:\n            # For pandas nullable dtypes, convert to regular numpy array\n            y_array = np.asarray(y.to_numpy(dtype=y.dtype.numpy_dtype, na_value=np.nan))\n        elif y_array.dtype == object and hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n            # Check if this is a converted pandas nullable dtype\n            if str(y.dtype).endswith('64') or str(y.dtype) == 'boolean':\n                try:\n                    # Try to convert back to numeric if possible\n                    y_array = np.asarray(y.to_numpy(na_value=np.nan))\n                except:\n                    pass\n        return xp.unique_values(y_array)\n    else:\n        return set(y)\n",
    "Location 5 (/root/hy/projects_4/scikit-learn/sklearn/utils/multiclass.py lines 81-85)": "\n    ys_types = set(type_of_target(x) for x in ys)\n    # Handle pandas nullable dtypes that get misclassified as 'unknown'\n    if 'unknown' in ys_types and len(ys_types) > 1:\n        # Check if 'unknown' types are actually pandas nullable dtypes\n        refined_types = set()\n        for x in ys:\n            target_type = type_of_target(x)\n            if target_type == 'unknown':\n                # Try to infer the actual type for pandas nullable dtypes\n                try:\n                    # Convert to numpy array and check if it's actually numeric\n                    arr = np.asarray(x)\n                    if arr.dtype == object and len(arr) > 0:\n                        # Check if all non-null values are numeric\n                        non_null_vals = [v for v in arr if v is not None and not (isinstance(v, float) and np.isnan(v))]\n                        if non_null_vals and all(isinstance(v, (int, float, np.integer, np.floating)) for v in non_null_vals):\n                            # Determine if binary or multiclass based on unique values\n                            unique_vals = np.unique([v for v in non_null_vals])\n                            if len(unique_vals) <= 2:\n                                refined_types.add('binary')\n                            else:\n                                refined_types.add('multiclass')\n                        else:\n                            refined_types.add('unknown')\n                    else:\n                        refined_types.add('unknown')\n                except:\n                    refined_types.add('unknown')\n            else:\n                refined_types.add(target_type)\n        ys_types = refined_types\n    \n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/scikit-learn/sklearn/utils/multiclass.py lines 305-314)": [
      "\n    # Check for pandas nullable dtypes before conversion\n    pandas_nullable_dtype = False\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        pandas_nullable_dtype = y.dtype.name in {'Int64', 'Float64', 'boolean'}\n    \n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n        if not issparse(y):\n            try:\n                if pandas_nullable_dtype:\n                    # Convert pandas nullable dtypes to their non-nullable equivalents\n                    # to preserve semantic meaning and avoid object dtype\n                    y = xp.asarray(y.astype(y.dtype.name.lower()))\n                else:\n                    y = xp.asarray(y)\n            except (np.VisibleDeprecationWarning, ValueError):\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = xp.asarray(y, dtype=object)\n",
      "\n    # Check for pandas nullable dtypes before conversion\n    pandas_nullable_dtype = False\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        pandas_nullable_dtype = y.dtype.name in ('Int8', 'Int16', 'Int32', 'Int64', \n                                                 'Float32', 'Float64', 'boolean')\n    \n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n        if not issparse(y):\n            try:\n                # For pandas nullable dtypes, convert to non-nullable equivalent\n                if pandas_nullable_dtype:\n                    if y.dtype.name == 'boolean':\n                        y = xp.asarray(y.astype('bool'))\n                    else:\n                        # Convert nullable numeric types to their non-nullable equivalents\n                        y = xp.asarray(y.astype(y.dtype.name.lower()))\n                else:\n                    y = xp.asarray(y)\n            except (np.VisibleDeprecationWarning, ValueError):\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = xp.asarray(y, dtype=object)\n",
      "\n    # Check for pandas nullable dtypes before conversion\n    pandas_nullable_dtype = False\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        pandas_nullable_dtype = y.dtype.name in ('Int64', 'Float64', 'boolean')\n    \n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n        if not issparse(y):\n            try:\n                if pandas_nullable_dtype:\n                    # Convert pandas nullable dtypes to their non-nullable equivalents\n                    # to preserve semantic meaning and avoid object dtype\n                    y = xp.asarray(y.astype(str(y.dtype).lower()))\n                else:\n                    y = xp.asarray(y)\n            except (np.VisibleDeprecationWarning, ValueError):\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = xp.asarray(y, dtype=object)\n",
      "\n    # DeprecationWarning will be replaced by ValueError, see NEP 34\n    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n    # We therefore catch both deprecation (NumPy < 1.24) warning and\n    # value error (NumPy >= 1.24).\n    \n    # Check for pandas nullable dtypes before conversion\n    pandas_nullable_dtype = False\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        pandas_nullable_dtype = y.dtype.name in ('Int64', 'Float64', 'boolean', 'string')\n    \n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n        if not issparse(y):\n            try:\n                # For pandas nullable dtypes, convert to non-nullable equivalent\n                if pandas_nullable_dtype:\n                    if y.dtype.name == 'boolean':\n                        y = xp.asarray(y.astype('bool'))\n                    elif y.dtype.name in ('Int64', 'Float64'):\n                        y = xp.asarray(y.astype(y.dtype.name.lower()))\n                    elif y.dtype.name == 'string':\n                        y = xp.asarray(y.astype('object'))\n                    else:\n                        y = xp.asarray(y)\n                else:\n                    y = xp.asarray(y)\n            except (np.VisibleDeprecationWarning, ValueError):\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = xp.asarray(y, dtype=object)\n",
      "\n    # Check for pandas nullable dtypes before conversion\n    pandas_nullable_dtype = False\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        pandas_nullable_dtype = y.dtype.name in ['Int64', 'Float64', 'boolean']\n    \n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n        if not issparse(y):\n            try:\n                # For pandas nullable dtypes, convert to non-nullable equivalent\n                if pandas_nullable_dtype:\n                    if y.dtype.name == 'boolean':\n                        y = xp.asarray(y.astype('bool'))\n                    elif y.dtype.name in ['Int64', 'Float64']:\n                        y = xp.asarray(y.astype(y.dtype.name.lower()))\n                else:\n                    y = xp.asarray(y)\n            except (np.VisibleDeprecationWarning, ValueError):\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = xp.asarray(y, dtype=object)\n",
      "\n    # DeprecationWarning will be replaced by ValueError, see NEP 34\n    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n    # We therefore catch both deprecation (NumPy < 1.24) warning and\n    # value error (NumPy >= 1.24).\n    \n    # Check for pandas nullable dtypes before conversion\n    pandas_nullable_dtype = False\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        nullable_dtypes = {'Int8', 'Int16', 'Int32', 'Int64', \n                          'Float32', 'Float64', 'boolean'}\n        if y.dtype.name in nullable_dtypes:\n            pandas_nullable_dtype = True\n    \n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n        if not issparse(y):\n            try:\n                # Convert pandas nullable dtypes to their non-nullable equivalents\n                if pandas_nullable_dtype:\n                    y = y.astype(str(y.dtype).lower())\n                y = xp.asarray(y)\n            except (np.VisibleDeprecationWarning, ValueError):\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = xp.asarray(y, dtype=object)\n",
      "\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n        if not issparse(y):\n            # Check if y is a pandas nullable dtype before conversion\n            pandas_nullable_dtype = False\n            if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n                # Check for pandas nullable dtypes\n                nullable_dtypes = {'Int8', 'Int16', 'Int32', 'Int64', \n                                 'UInt8', 'UInt16', 'UInt32', 'UInt64',\n                                 'Float32', 'Float64', 'boolean', 'string'}\n                if y.dtype.name in nullable_dtypes:\n                    pandas_nullable_dtype = True\n                    # Convert to non-nullable equivalent to preserve numeric nature\n                    if y.dtype.name in {'Int8', 'Int16', 'Int32', 'Int64', \n                                       'UInt8', 'UInt16', 'UInt32', 'UInt64'}:\n                        y = y.astype('int64')\n                    elif y.dtype.name in {'Float32', 'Float64'}:\n                        y = y.astype('float64')\n                    elif y.dtype.name == 'boolean':\n                        y = y.astype('bool')\n                    # For string dtype, let it convert to object as intended\n            \n            if not pandas_nullable_dtype:\n                try:\n                    y = xp.asarray(y)\n                except (np.VisibleDeprecationWarning, ValueError):\n                    # dtype=object should be provided explicitly for ragged arrays,\n                    # see NEP 34\n                    y = xp.asarray(y, dtype=object)\n            else:\n                y = xp.asarray(y)\n",
      "\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n        if not issparse(y):\n            # Check if y has pandas nullable dtype before conversion\n            pandas_nullable_dtype = False\n            if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n                pandas_nullable_dtype = y.dtype.name in ('Int64', 'Float64', 'boolean')\n            \n            try:\n                if pandas_nullable_dtype:\n                    # Convert pandas nullable dtype to regular numpy dtype to avoid object conversion\n                    y = xp.asarray(y.to_numpy(dtype=y.dtype.numpy_dtype, na_value=np.nan))\n                else:\n                    y = xp.asarray(y)\n            except (np.VisibleDeprecationWarning, ValueError):\n                # dtype=object should be provided explicitly for ragged arrays,\n                # see NEP 34\n                y = xp.asarray(y, dtype=object)\n"
    ],
    "Location 2 (/root/hy/projects_4/scikit-learn/sklearn/utils/multiclass.py lines 343-345)": [
      "\nif not issparse(y) and y.dtype == object:\n    # Check if this is a pandas nullable dtype converted to object\n    if hasattr(y, '__array_function__') and len(y) > 0:\n        # Try to detect if object array contains numeric data from nullable dtypes\n        first_val = y.flat[0]\n        if first_val is not None and not isinstance(first_val, str):\n            # Check if all non-None values are numeric\n            try:\n                non_none_vals = [val for val in y.flat if val is not None]\n                if non_none_vals and all(isinstance(val, (int, float, np.integer, np.floating)) for val in non_none_vals):\n                    # This appears to be numeric data, continue with normal classification\n                    pass\n                else:\n                    return \"unknown\"\n            except:\n                return \"unknown\"\n        elif not isinstance(first_val, str):\n            return \"unknown\"\n    elif len(y) > 0 and not isinstance(y.flat[0], str):\n        # [obj_1] and not [\"label_1\"]\n        return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n        # Check if this is a converted pandas nullable dtype containing numeric data\n        try:\n            # Try to get a sample of non-null values to check if they're numeric\n            sample_values = [val for val in y.flat[:min(10, len(y.flat))] if val is not None and not np.isnan(val) if isinstance(val, (int, float, np.integer, np.floating)) else False]\n            if sample_values and all(isinstance(val, (int, float, np.integer, np.floating)) for val in sample_values):\n                # This appears to be numeric data in object dtype, continue with normal classification\n                pass\n            else:\n                # [obj_1] and not [\"label_1\"] - truly non-numeric objects\n                return \"unknown\"\n        except (TypeError, ValueError):\n            # [obj_1] and not [\"label_1\"] - objects that can't be processed\n            return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object:\n        # Check if this is a pandas nullable dtype converted to object\n        if hasattr(y, '__array__') and len(y) > 0:\n            # Try to get a sample value to check if it's numeric\n            sample_val = None\n            for val in y.flat:\n                if val is not None and not (isinstance(val, str) and val != val):  # Skip NaN strings\n                    sample_val = val\n                    break\n            \n            # If we found a numeric sample, this likely came from a nullable dtype\n            if sample_val is not None and not isinstance(sample_val, str):\n                # Continue with normal classification instead of returning \"unknown\"\n                pass\n            else:\n                # [obj_1] and not [\"label_1\"]\n                return \"unknown\"\n        elif not isinstance(y.flat[0], str):\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object:\n        # Check if this is a pandas nullable dtype converted to object\n        if hasattr(y, '__array__') and len(y) > 0:\n            # Try to get a sample value to check if it's numeric\n            sample_val = None\n            for val in y.flat:\n                if val is not None and not pd.isna(val) if 'pd' in globals() else val is not None:\n                    sample_val = val\n                    break\n            \n            # If we found a numeric sample, treat as numeric array\n            if sample_val is not None and isinstance(sample_val, (int, float, np.integer, np.floating)):\n                pass  # Continue with normal numeric processing\n            elif not isinstance(y.flat[0], str):\n                # [obj_1] and not [\"label_1\"] - original object array logic\n                return \"unknown\"\n        elif not isinstance(y.flat[0], str):\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object:\n        # Check if this is a pandas nullable dtype converted to object\n        if hasattr(y, '__array_function__') or (\n            len(y) > 0 and hasattr(y.flat[0], '__class__') and \n            y.flat[0].__class__.__module__ in ('pandas._libs.missing', 'numpy')\n        ):\n            # Handle pandas nullable dtypes that became object arrays\n            # Try to extract the actual values, skipping pandas NA/None\n            non_null_values = []\n            for val in y.flat:\n                if val is not None and not (hasattr(val, '__class__') and \n                                          val.__class__.__name__ in ('NAType', 'NaTType')):\n                    non_null_values.append(val)\n            \n            # If we have non-null values, determine type based on them\n            if non_null_values:\n                # Check if all values are numeric (int/float/bool)\n                if all(isinstance(val, (int, float, bool, np.integer, np.floating, np.bool_)) \n                       for val in non_null_values):\n                    # Continue with normal classification logic instead of returning \"unknown\"\n                    pass\n                else:\n                    return \"unknown\"\n            else:\n                # All values are null, treat as binary for empty case\n                return \"binary\"\n        elif not isinstance(y.flat[0], str):\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object:\n        # Check if this is a pandas nullable dtype converted to object\n        if hasattr(y, '__array_function__') or str(type(y)).startswith('<class \\'pandas.'):\n            # Handle pandas nullable dtypes that got converted to object\n            try:\n                # Try to convert to numeric to see if it's actually numeric data\n                numeric_y = np.asarray(y, dtype=float)\n                if not np.isnan(numeric_y).all():\n                    # This is numeric data, treat it as such\n                    pass\n                else:\n                    return \"unknown\"\n            except (ValueError, TypeError):\n                # Not numeric, check if string-like\n                if not isinstance(y.flat[0], str):\n                    return \"unknown\"\n        elif not isinstance(y.flat[0], str):\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object:\n        # Check if this is a pandas nullable dtype converted to object\n        try:\n            # Try to convert back to numeric to see if it's actually numeric data\n            import pandas as pd\n            if hasattr(y, '__array__') and len(y) > 0:\n                # Check if all non-null values are numeric\n                flat_y = y.flat\n                first_val = next(iter(flat_y), None)\n                if first_val is not None and not isinstance(first_val, str):\n                    # Try to determine if this came from a pandas nullable dtype\n                    try:\n                        # Attempt to convert to float to check if numeric\n                        numeric_vals = []\n                        for val in y.flat:\n                            if val is not None and not pd.isna(val):\n                                numeric_vals.append(float(val))\n                        if numeric_vals:  # If we have numeric values, continue processing\n                            pass\n                        else:\n                            return \"unknown\"\n                    except (ValueError, TypeError):\n                        return \"unknown\"\n                else:\n                    return \"unknown\"\n            else:\n                return \"unknown\"\n        except ImportError:\n            # pandas not available, fall back to original logic\n            if not isinstance(y.flat[0], str):\n                return \"unknown\"\n",
      "\n    if not issparse(y) and y.dtype == object:\n        # Check if this is a pandas nullable dtype converted to object\n        if hasattr(y, '__array__') and len(y) > 0:\n            # Try to get a sample value to check if it's numeric\n            sample_val = None\n            for val in y.flat:\n                if val is not None and not pd.isna(val):\n                    sample_val = val\n                    break\n            \n            # If we found a numeric sample, treat as numeric array\n            if sample_val is not None and not isinstance(sample_val, str):\n                # Convert to appropriate numeric type for further processing\n                try:\n                    # Try to convert to float to handle both int and float nullable types\n                    y_converted = np.asarray(y, dtype=float)\n                    # Check if all values are integers (for Int64 nullable type)\n                    if np.all(np.isnan(y_converted) | (y_converted == np.asarray(y_converted, dtype=int))):\n                        y = np.asarray(y, dtype=float)  # Keep as float to handle NaN\n                    else:\n                        y = y_converted\n                except (ValueError, TypeError):\n                    # If conversion fails, fall back to original object handling\n                    if not isinstance(y.flat[0], str):\n                        return \"unknown\"\n            elif not isinstance(y.flat[0], str):\n                # [obj_1] and not [\"label_1\"]\n                return \"unknown\"\n        elif not isinstance(y.flat[0], str):\n            # [obj_1] and not [\"label_1\"]\n            return \"unknown\"\n"
    ],
    "Location 3 (/root/hy/projects_4/scikit-learn/sklearn/utils/multiclass.py lines 361-367)": [
      "\ndef type_of_target(y, input_name=\"\"):\n    \"\"\"Determine the type of data indicated by the target.\n\n    Note that this type is the most specific type that can be inferred.\n    For example:\n\n        * ``binary`` is more specific but compatible with ``multiclass``.\n        * ``multiclass`` is more specific but compatible with ``continuous``.\n        * ``multilabel-indicator`` is more specific but compatible with\n          ``multiclass-multioutput``.\n\n    Parameters\n    ----------\n    y : {array-like, sparse matrix}\n        Target values. If a sparse matrix, ``y`` is expected to be a\n        CSR/CSC matrix.\n\n    input_name : str, default=\"\"\n        The data name used to construct the error message.\n\n        .. versionadded:: 1.1.0\n\n    Returns\n    -------\n    target_type : str\n        One of:\n\n        * 'continuous': `y` is an array-like of floats that are not all\n          integers, and is 1d or a column vector.\n        * 'continuous-multioutput': `y` is a 2d array of floats that are\n          not all integers, and both dimensions are of size > 1.\n        * 'binary': `y` contains <= 2 discrete values and is 1d or a column\n          vector.\n        * 'multiclass': `y` contains more than two discrete values, is not a\n          sequence of sequences, and is 1d or a column vector.\n        * 'multiclass-multioutput': `y` is a 2d array that contains more\n          than two discrete values, is not a sequence of sequences, and both\n          dimensions are of size > 1.\n        * 'multilabel-indicator': `y` is a label indicator matrix, an array\n          of two dimensions with at least two columns, and at most 2 unique\n          values.\n        * 'unknown': `y` is array-like but none of the above, such as a 3d\n          array, or an array of non-sequence objects.\n\n    Examples\n    --------\n    >>> from sklearn.utils.multiclass import type_of_target\n    >>> import numpy as np\n    >>> type_of_target([0.1, 0.6])\n    'continuous'\n    >>> type_of_target([1, -1, -1, 1])\n    'binary'\n    >>> type_of_target(['a', 'b', 'a'])\n    'binary'\n    >>> type_of_target([1.0, 2.0])\n    'binary'\n    >>> type_of_target([1, 0, 2])\n    'multiclass'\n    >>> type_of_target([1.0, 0.0, 3.0])\n    'multiclass'\n    >>> type_of_target(['a', 'b', 'c'])\n    'multiclass'\n    >>> type_of_target(np.array([[1, 2], [3, 1]]))\n    'multiclass-multioutput'\n    >>> type_of_target([[1, 2]])\n    'multilabel-indicator'\n    >>> type_of_target(np.array([[1.5, 2.0], [3.0, 1.6]]))\n    'continuous-multioutput'\n    >>> type_of_target(np.array([[0, 1], [1, 1]]))\n    'multilabel-indicator'\n    \"\"\"\n    xp, is_array_api_compliant = get_namespace(y)\n    \n    # Store original pandas nullable dtype info if present\n    pandas_nullable_dtype = None\n    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n        dtype_name = y.dtype.name\n        if dtype_name in ['Int8', 'Int16', 'Int32', 'Int64', 'UInt8', 'UInt16', 'UInt32', 'UInt64', 'Float32', 'Float64', 'boolean']:\n            pandas_nullable_dtype = dtype_name\n\n    y = xp.asarray(y)\n\n    # The old sequence of sequences format\n    try:\n        if (\n            not hasattr(y, \"shape\")\n            and isinstance(y, Sequence)\n            and not isinstance(y, str)\n        ):\n            raise ValueError(\n                \"You appear to be using a legacy multi-label data\"\n                \" representation. Sequence of sequences are no\"\n                \" longer supported; use a binary array or sparse\"\n                \" matrix instead - the MultiLabelBinarizer\"\n                \" transformer can convert to this format.\"\n            )\n    except ValueError:\n        # This is a sparse matrix, do nothing\n        pass\n\n    # Invalid inputs\n    if y.ndim not in (1, 2):\n        # Number of dimension greater than 2: [[[1, 2]]]\n        return \"unknown\"\n\n    # The multilabel-indicator case\n    if y.ndim == 2 and y.shape[1] > 1:\n        suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n    else:\n        suffix = \"\"  # [1, 2, 3] or [[1], [2], [3]]\n\n    # Check float and contains non-integer float values\n    if y.dtype.kind == \"f\":\n        # [.1, .2, 3] or [[.1, .2, 3]] or [[1., .2]] and not [1., 2., 3.]\n        data = y.data if issparse(y) else y\n        if xp.any(data != data.astype(int)):\n            _assert_all_finite(data, input_name=input_name)\n            return \"continuous\" + suffix\n\n    # Check if this is an object array from pandas nullable dtype\n    if y.dtype == object and pandas_nullable_dtype is not None:\n        # Handle pandas nullable dtypes that were converted to object arrays\n        # Convert to appropriate numpy dtype for further processing\n        if pandas_nullable_dtype == 'boolean':\n            # Convert to bool, handling pd.NA as False for type determination\n            try:\n                y_converted = np.array([bool(x) if x is not None and str(x).lower() != 'nan' else False for x in y.flat]).reshape(y.shape)\n                y = xp.asarray(y_converted)\n            except (ValueError, TypeError):\n                return \"unknown\"\n        elif pandas_nullable_dtype.startswith(('Int', 'UInt')):\n            # Convert to int, handling pd.NA as 0 for type determination\n            try:\n                y_converted = np.array([int(x) if x is not None and str(x).lower() != 'nan' else 0 for x in y.flat]).reshape(y.shape)\n                y = xp.asarray(y_converted)\n            except (ValueError, TypeError):\n                return \"unknown\"\n        elif pandas_nullable_dtype.startswith('Float'):\n            # Convert to float, handling pd.NA as 0.0 for type determination\n            try:\n                y_converted = np.array([float(x) if x is not None and str(x).lower() != 'nan' else 0.0 for x in y.flat]).reshape(y.shape)\n                y = xp.asarray(y_converted)\n            except (ValueError, TypeError):\n                return \"unknown\"\n    elif y.dtype == object:\n        # Check if the object array contains strings\n        if len(y) and isinstance(y.flat[0], str):\n            # [[\"a\"], [\"b\"]] or [\"a\", \"b\"]\n            pass\n        else:\n            # [array([1]), array([2])] or [1, 2, 3] but y.dtype == object\n            return \"unknown\"\n\n    # Check multiclass\n    first_row = y[0] if not issparse(y) else y.getrow(0).data\n    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n",
      "\n    # Check multiclass\n    first_row = y[0] if not issparse(y) else y.getrow(0).data\n    \n    # For object dtype arrays that may have come from pandas nullable dtypes,\n    # check if they contain numeric data that should be treated as multiclass/binary\n    if y.dtype == object and not issparse(y):\n        # Try to determine if this is numeric data in object array\n        try:\n            # Check if all non-null values can be converted to numeric\n            flat_y = y.ravel() if y.ndim > 1 else y\n            non_null_mask = flat_y != None\n            if xp.any(non_null_mask):\n                non_null_values = flat_y[non_null_mask]\n                # Check if values are numeric (int, float, or convertible)\n                if all(isinstance(val, (int, float, np.integer, np.floating)) or \n                       (hasattr(val, 'dtype') and val.dtype.kind in 'iuf') for val in non_null_values):\n                    # This appears to be numeric data, check unique count\n                    unique_vals = xp.unique_values(non_null_values)\n                    if unique_vals.shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n                        return \"multiclass\" + suffix\n                    else:\n                        return \"binary\" + suffix\n        except (TypeError, ValueError):\n            # If we can't determine it's numeric, fall through to normal logic\n            pass\n    \n    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n",
      "\n    # Check multiclass\n    first_row = y[0] if not issparse(y) else y.getrow(0).data\n    \n    # For object dtype arrays that may contain numeric data from pandas nullable dtypes,\n    # check if all values are numeric and can be treated as binary/multiclass\n    if y.dtype == object and not issparse(y):\n        try:\n            # Try to convert to numeric to check if this is a converted nullable dtype\n            numeric_y = xp.asarray(y, dtype=float)\n            if xp.all(xp.isfinite(numeric_y)):\n                # Use numeric version for unique value counting\n                unique_count = xp.unique_values(numeric_y).shape[0]\n            else:\n                unique_count = xp.unique_values(y).shape[0]\n        except (ValueError, TypeError):\n            unique_count = xp.unique_values(y).shape[0]\n    else:\n        unique_count = xp.unique_values(y).shape[0]\n    \n    if unique_count > 2 or (y.ndim == 2 and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n",
      "\n    # Check multiclass\n    first_row = y[0] if not issparse(y) else y.getrow(0).data\n    \n    # For object dtype arrays that may come from pandas nullable dtypes,\n    # check if they contain numeric data that should be treated as multiclass/binary\n    if y.dtype == object and not issparse(y):\n        # Try to determine if this is numeric data in object array\n        try:\n            # Flatten the array to check all values\n            flat_y = y.ravel() if y.ndim > 1 else y\n            # Check if all non-null values can be converted to numeric\n            non_null_mask = flat_y != np.array(None)\n            if non_null_mask.any():\n                non_null_values = flat_y[non_null_mask]\n                # Try to convert to float to check if numeric\n                numeric_values = np.asarray(non_null_values, dtype=float)\n                # If successful, use numeric logic for classification\n                unique_vals = xp.unique_values(numeric_values)\n                if unique_vals.shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n                    return \"multiclass\" + suffix\n                else:\n                    return \"binary\" + suffix\n        except (ValueError, TypeError):\n            # If conversion fails, fall through to original logic\n            pass\n    \n    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n",
      "\n    # Check multiclass\n    first_row = y[0] if not issparse(y) else y.getrow(0).data\n    \n    # For object arrays that might come from pandas nullable dtypes,\n    # check if all values are numeric and can be safely converted\n    if y.dtype == object and not issparse(y):\n        try:\n            # Try to convert to numeric to check if it's actually numeric data\n            flat_y = y.ravel()\n            if len(flat_y) > 0:\n                # Check if all non-null values are numeric\n                non_null_mask = flat_y != None\n                if xp.any(non_null_mask):\n                    non_null_values = flat_y[non_null_mask]\n                    # Try converting first non-null value to see if it's numeric\n                    test_val = non_null_values[0]\n                    if isinstance(test_val, (int, float, np.integer, np.floating)):\n                        # All values appear to be numeric, treat as numeric array\n                        unique_vals = xp.unique_values(flat_y[non_null_mask])\n                        if len(unique_vals) > 2:\n                            return \"multiclass\" + suffix\n                        else:\n                            return \"binary\" + suffix\n        except (TypeError, ValueError):\n            # Not numeric, continue with original logic\n            pass\n    \n    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n",
      "\n    # Check multiclass\n    first_row = y[0] if not issparse(y) else y.getrow(0).data\n    \n    # For object arrays that might contain numeric data from pandas nullable dtypes,\n    # try to get unique values more carefully\n    if y.dtype == object and not issparse(y):\n        try:\n            # Convert to numeric if possible to get proper unique count\n            numeric_y = xp.asarray(y, dtype=float)\n            n_unique = xp.unique_values(numeric_y).shape[0]\n        except (ValueError, TypeError):\n            # Fall back to regular unique if conversion fails\n            n_unique = xp.unique_values(y).shape[0]\n    else:\n        n_unique = xp.unique_values(y).shape[0]\n    \n    if n_unique > 2 or (y.ndim == 2 and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n",
      "\n    # Check multiclass\n    first_row = y[0] if not issparse(y) else y.getrow(0).data\n    \n    # For object arrays that might contain numeric data from pandas nullable dtypes,\n    # check if all values are numeric before determining multiclass vs binary\n    if y.dtype == object and not issparse(y):\n        # Check if this is a numeric object array (e.g., from pandas nullable types)\n        try:\n            # Try to convert to numeric - if successful, it's numeric data in object array\n            flat_y = y.ravel()\n            # Check if all non-null values are numeric\n            numeric_mask = []\n            for val in flat_y:\n                if val is None or (hasattr(val, '__class__') and val.__class__.__name__ == 'NAType'):\n                    continue  # Skip pandas NA values\n                try:\n                    float(val)\n                    numeric_mask.append(True)\n                except (ValueError, TypeError):\n                    numeric_mask.append(False)\n            \n            if numeric_mask and all(numeric_mask):\n                # This is numeric data in object array, proceed with normal logic\n                pass\n            else:\n                # Non-numeric object array, use original logic\n                if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n                    return \"multiclass\" + suffix\n                else:\n                    return \"binary\"\n        except:\n            # If any error occurs, fall back to original logic\n            if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n                return \"multiclass\" + suffix\n            else:\n                return \"binary\"\n    \n    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n",
      "\n    # Check multiclass\n    first_row = y[0] if not issparse(y) else y.getrow(0).data\n    \n    # Handle object dtype arrays that may contain numeric data from nullable dtypes\n    if y.dtype == object and not issparse(y):\n        # Check if all elements are numeric (int or float)\n        try:\n            # Convert to numeric array to check unique values properly\n            numeric_y = xp.asarray([float(val) if val is not None else xp.nan for val in y.ravel()])\n            if not xp.any(xp.isnan(numeric_y)):\n                # All values are numeric, use numeric array for unique check\n                unique_count = xp.unique_values(numeric_y).shape[0]\n            else:\n                unique_count = xp.unique_values(y).shape[0]\n        except (ValueError, TypeError):\n            # Not all numeric, use original array\n            unique_count = xp.unique_values(y).shape[0]\n    else:\n        unique_count = xp.unique_values(y).shape[0]\n    \n    if unique_count > 2 or (y.ndim == 2 and len(first_row) > 1):\n        # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n        return \"multiclass\" + suffix\n    else:\n        return \"binary\"  # [1, 2] or [[\"a\"], [\"b\"]]\n"
    ],
    "Location 4 (/root/hy/projects_4/scikit-learn/sklearn/utils/multiclass.py lines 23-28)": [
      "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    if hasattr(y, \"__array__\") or is_array_api:\n        # Handle pandas nullable dtypes that get converted to object dtype\n        y_array = xp.asarray(y)\n        if hasattr(y, 'dtype') and str(y.dtype) in ['Int64', 'Float64', 'boolean']:\n            # Convert pandas nullable dtype to regular numpy array\n            y_array = y_array.astype(y.dtype.numpy_dtype)\n        elif y_array.dtype == object and hasattr(y, 'dtype') and hasattr(y.dtype, 'numpy_dtype'):\n            # Handle case where pandas nullable dtype was already converted to object\n            try:\n                y_array = y_array.astype(y.dtype.numpy_dtype)\n            except (AttributeError, TypeError):\n                pass\n        return xp.unique_values(y_array)\n    else:\n        return set(y)\n",
      "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    if hasattr(y, \"__array__\") or is_array_api:\n        # Handle pandas nullable dtypes that get converted to object dtype\n        y_array = xp.asarray(y)\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name') and y.dtype.name in ['Int64', 'Float64', 'boolean']:\n            # For pandas nullable dtypes, extract the non-null values for unique computation\n            if hasattr(y, 'dropna'):\n                return xp.unique_values(xp.asarray(y.dropna()))\n            else:\n                # Fallback: filter out None/NaN values manually\n                valid_mask = y_array != None\n                if xp.__name__ == 'numpy':\n                    valid_mask = valid_mask & ~np.isnan(y_array.astype(float, errors='ignore'))\n                return xp.unique_values(y_array[valid_mask])\n        return xp.unique_values(y_array)\n    else:\n        return set(y)\n",
      "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    if hasattr(y, \"__array__\") or is_array_api:\n        # Handle pandas nullable dtypes that get converted to object arrays\n        y_array = xp.asarray(y)\n        if hasattr(y, 'dtype') and str(y.dtype) in ['Int64', 'Float64', 'boolean']:\n            # For pandas nullable dtypes, convert to non-nullable equivalent\n            if str(y.dtype) == 'boolean':\n                y_array = y_array.astype(bool)\n            elif str(y.dtype) == 'Int64':\n                y_array = y_array.astype(int)\n            elif str(y.dtype) == 'Float64':\n                y_array = y_array.astype(float)\n        elif y_array.dtype == object and hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n            # Check if object array came from nullable dtype conversion\n            try:\n                # Try to convert back to numeric if possible\n                if all(isinstance(x, (int, np.integer)) or (x is not None and not np.isnan(x)) for x in y_array if x is not None):\n                    y_array = y_array.astype(int)\n                elif all(isinstance(x, (float, np.floating)) or x is None or np.isnan(x) for x in y_array):\n                    y_array = y_array.astype(float)\n            except (ValueError, TypeError):\n                pass\n        return xp.unique_values(y_array)\n    else:\n        return set(y)\n",
      "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    if hasattr(y, \"__array__\") or is_array_api:\n        # Handle pandas nullable dtypes that get converted to object arrays\n        y_array = xp.asarray(y)\n        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name') and y.dtype.name in ('Int64', 'Float64', 'boolean'):\n            # For pandas nullable dtypes, convert to non-nullable equivalent\n            if y.dtype.name == 'boolean':\n                y_array = y_array.astype(bool)\n            elif y.dtype.name == 'Int64':\n                y_array = y_array.astype(int)\n            elif y.dtype.name == 'Float64':\n                y_array = y_array.astype(float)\n        return xp.unique_values(y_array)\n    else:\n        return set(y)\n",
      "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    if hasattr(y, \"__array__\") or is_array_api:\n        # Handle pandas nullable dtypes that get converted to object arrays\n        y_array = xp.asarray(y)\n        if hasattr(y, 'dtype') and str(y.dtype) in ('Int64', 'Float64', 'boolean'):\n            # For pandas nullable dtypes, extract the non-null values for unique computation\n            if hasattr(y, 'dropna'):\n                return xp.unique_values(xp.asarray(y.dropna()))\n            else:\n                # Fallback: filter out None/NaN values manually\n                mask = y_array != None\n                if xp.any(mask):\n                    return xp.unique_values(y_array[mask])\n                else:\n                    return xp.asarray([])\n        return xp.unique_values(y_array)\n    else:\n        return set(y)\n",
      "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    if hasattr(y, \"__array__\") or is_array_api:\n        # Handle pandas nullable dtypes that get converted to object arrays\n        y_array = xp.asarray(y)\n        if hasattr(y, 'dtype') and str(y.dtype) in ('Int64', 'Float64', 'boolean'):\n            # For pandas nullable dtypes, use the underlying non-null values\n            if hasattr(y, 'array') and hasattr(y.array, '_ndarray'):\n                # Extract the underlying numpy array from pandas nullable dtype\n                underlying_array = y.array._ndarray\n                mask = ~y.array._mask if hasattr(y.array, '_mask') else slice(None)\n                return xp.unique_values(underlying_array[mask])\n        return xp.unique_values(y_array)\n    else:\n        return set(y)\n",
      "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    if hasattr(y, \"__array__\") or is_array_api:\n        # Handle pandas nullable dtypes that get converted to object arrays\n        y_array = xp.asarray(y)\n        if hasattr(y, 'dtype') and str(y.dtype) in ('Int64', 'Float64', 'boolean'):\n            # For pandas nullable dtypes, extract the underlying values\n            if hasattr(y, 'array') and hasattr(y.array, '_ndarray'):\n                # Use the underlying numpy array from pandas nullable dtype\n                y_array = y.array._ndarray[~y.array.isna()]\n            elif hasattr(y, 'to_numpy'):\n                # Fallback to to_numpy with na_value handling\n                y_array = y.to_numpy(dtype=y.dtype.numpy_dtype, na_value=np.nan)\n                y_array = y_array[~np.isnan(y_array)] if np.issubdtype(y_array.dtype, np.floating) else y_array\n        return xp.unique_values(y_array)\n    else:\n        return set(y)\n",
      "\ndef _unique_multiclass(y):\n    xp, is_array_api = get_namespace(y)\n    if hasattr(y, \"__array__\") or is_array_api:\n        # Handle pandas nullable dtypes that get converted to object arrays\n        y_array = xp.asarray(y)\n        if hasattr(y, 'dtype') and str(y.dtype).lower() in ['int64', 'float64', 'boolean']:\n            # Original pandas nullable dtype, convert to non-nullable equivalent\n            if str(y.dtype).lower() == 'boolean':\n                y_array = y_array.astype(bool)\n            elif str(y.dtype).lower() == 'int64':\n                y_array = y_array.astype(np.int64)\n            elif str(y.dtype).lower() == 'float64':\n                y_array = y_array.astype(np.float64)\n        return xp.unique_values(y_array)\n    else:\n        return set(y)\n"
    ],
    "Location 5 (/root/hy/projects_4/scikit-learn/sklearn/utils/multiclass.py lines 81-85)": [
      "\n    ys_types = set(type_of_target(x) for x in ys)\n    # Handle pandas nullable dtypes that get misclassified as 'unknown'\n    # Convert 'unknown' back to proper type if it contains valid numeric data\n    if 'unknown' in ys_types:\n        corrected_types = set()\n        for x in ys:\n            target_type = type_of_target(x)\n            if target_type == 'unknown':\n                # Check if this is actually numeric data that was converted to object dtype\n                x_array = check_array(x, ensure_2d=False, dtype=None, force_all_finite=False)\n                if x_array.dtype == object and len(x_array) > 0:\n                    # Try to determine if it's really binary/multiclass numeric data\n                    try:\n                        # Convert to numeric to see if it's actually numeric data\n                        numeric_vals = []\n                        for val in x_array.ravel():\n                            if val is not None and not (isinstance(val, float) and np.isnan(val)):\n                                numeric_vals.append(val)\n                        \n                        if numeric_vals:\n                            unique_vals = np.unique(numeric_vals)\n                            if len(unique_vals) == 2:\n                                corrected_types.add('binary')\n                            elif len(unique_vals) > 2:\n                                corrected_types.add('multiclass')\n                            else:\n                                corrected_types.add('unknown')\n                        else:\n                            corrected_types.add('unknown')\n                    except (ValueError, TypeError):\n                        corrected_types.add('unknown')\n                else:\n                    corrected_types.add('unknown')\n            else:\n                corrected_types.add(target_type)\n        ys_types = corrected_types\n    \n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n",
      "\n    ys_types = set(type_of_target(x) for x in ys)\n    # Handle pandas nullable dtypes that get misclassified as 'unknown'\n    # when they should be 'binary' or 'multiclass'\n    if 'unknown' in ys_types and len(ys_types) > 1:\n        # Check if 'unknown' types are actually pandas nullable dtypes\n        corrected_types = set()\n        for x in ys:\n            x_type = type_of_target(x)\n            if x_type == 'unknown':\n                # Try to get the actual type by checking the underlying data\n                try:\n                    # Convert to numpy array and check if it's numeric\n                    x_array = np.asarray(x)\n                    if x_array.dtype == object:\n                        # Check if all non-null values are numeric\n                        non_null_mask = x_array != None\n                        if np.any(non_null_mask):\n                            non_null_values = x_array[non_null_mask]\n                            if all(isinstance(val, (int, float, np.integer, np.floating)) for val in non_null_values):\n                                # Determine if binary or multiclass based on unique values\n                                unique_vals = np.unique(non_null_values)\n                                if len(unique_vals) <= 2:\n                                    corrected_types.add('binary')\n                                else:\n                                    corrected_types.add('multiclass')\n                            else:\n                                corrected_types.add('unknown')\n                        else:\n                            corrected_types.add('unknown')\n                    else:\n                        corrected_types.add('unknown')\n                except:\n                    corrected_types.add('unknown')\n            else:\n                corrected_types.add(x_type)\n        ys_types = corrected_types\n    \n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n",
      "\n    ys_types = set(type_of_target(x) for x in ys)\n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n    # Handle pandas nullable dtypes that get misclassified as 'unknown'\n    if \"unknown\" in ys_types and len(ys_types) > 1:\n        # Check if 'unknown' types are actually pandas nullable dtypes\n        filtered_types = set()\n        for x in ys:\n            target_type = type_of_target(x)\n            if target_type == \"unknown\":\n                # Try to determine the actual type for object arrays from nullable dtypes\n                xp, _ = get_namespace(x)\n                x_array = xp.asarray(x)\n                if hasattr(x_array, 'dtype') and x_array.dtype == object:\n                    # Check if this is numeric data in object array (from nullable dtype)\n                    try:\n                        # Convert to numeric and check unique values\n                        numeric_vals = [val for val in x_array.ravel() if val is not None]\n                        if numeric_vals and all(isinstance(val, (int, float, np.integer, np.floating)) for val in numeric_vals):\n                            unique_vals = len(set(numeric_vals))\n                            if unique_vals <= 2:\n                                filtered_types.add(\"binary\")\n                            else:\n                                filtered_types.add(\"multiclass\")\n                        else:\n                            filtered_types.add(\"unknown\")\n                    except:\n                        filtered_types.add(\"unknown\")\n                else:\n                    filtered_types.add(\"unknown\")\n            else:\n                filtered_types.add(target_type)\n        ys_types = filtered_types\n        if ys_types == {\"binary\", \"multiclass\"}:\n            ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n",
      "\n    ys_types = set(type_of_target(x) for x in ys)\n    # Handle pandas nullable dtypes that get misclassified as 'unknown'\n    # If we have 'unknown' types, check if they're actually pandas nullable arrays\n    if 'unknown' in ys_types:\n        corrected_types = set()\n        for x in ys:\n            target_type = type_of_target(x)\n            if target_type == 'unknown':\n                # Check if this is a pandas nullable dtype converted to object\n                xp, _ = get_namespace(x)\n                x_array = xp.asarray(x)\n                if hasattr(x, 'dtype') and str(x.dtype) in ('Int64', 'Float64', 'boolean'):\n                    # Re-classify based on the actual values\n                    if x_array.dtype == object:\n                        # Convert to proper numpy array for classification\n                        try:\n                            # Handle nullable integers/floats\n                            if str(x.dtype) in ('Int64', 'Float64'):\n                                # Check for binary vs multiclass based on unique values\n                                unique_vals = np.unique(x_array[x_array != None])\n                                if len(unique_vals) == 2:\n                                    corrected_types.add('binary')\n                                else:\n                                    corrected_types.add('multiclass')\n                            # Handle nullable boolean\n                            elif str(x.dtype) == 'boolean':\n                                corrected_types.add('binary')\n                        except:\n                            corrected_types.add('unknown')\n                    else:\n                        corrected_types.add('unknown')\n                else:\n                    corrected_types.add('unknown')\n            else:\n                corrected_types.add(target_type)\n        ys_types = corrected_types\n    \n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n",
      "\n    ys_types = set()\n    for x in ys:\n        # Check if x is a pandas array with nullable dtype before type_of_target conversion\n        if hasattr(x, 'dtype') and hasattr(x.dtype, 'name') and x.dtype.name in ('Int64', 'Float64', 'boolean'):\n            # Convert nullable pandas dtype to regular numpy array for type detection\n            if x.dtype.name == 'boolean':\n                converted_x = np.asarray(x, dtype=bool)\n            elif x.dtype.name == 'Int64':\n                converted_x = np.asarray(x, dtype=int)\n            elif x.dtype.name == 'Float64':\n                converted_x = np.asarray(x, dtype=float)\n            ys_types.add(type_of_target(converted_x))\n        else:\n            ys_types.add(type_of_target(x))\n    \n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n",
      "\n    ys_types = set(type_of_target(x) for x in ys)\n    # Handle pandas nullable dtypes that get misclassified as 'unknown'\n    if 'unknown' in ys_types and len(ys_types) > 1:\n        # Check if 'unknown' types are actually pandas nullable dtypes\n        corrected_types = set()\n        for x in ys:\n            y_type = type_of_target(x)\n            if y_type == 'unknown':\n                # Try to determine the actual type for pandas nullable dtypes\n                try:\n                    import pandas as pd\n                    if hasattr(x, 'dtype') and hasattr(x.dtype, 'name'):\n                        # Check if it's a pandas nullable dtype\n                        if x.dtype.name in ('Int64', 'Float64', 'boolean', 'string'):\n                            # Convert to non-nullable equivalent to get proper type\n                            temp_array = x.to_numpy(dtype=None, na_value=np.nan)\n                            corrected_type = type_of_target(temp_array)\n                            corrected_types.add(corrected_type)\n                        else:\n                            corrected_types.add(y_type)\n                    else:\n                        corrected_types.add(y_type)\n                except ImportError:\n                    corrected_types.add(y_type)\n            else:\n                corrected_types.add(y_type)\n        ys_types = corrected_types\n    \n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n",
      "\n    ys_types = set(type_of_target(x) for x in ys)\n    # Handle pandas nullable dtypes that get misclassified as 'unknown'\n    # Convert 'unknown' back to proper type if the data is actually numeric\n    if 'unknown' in ys_types:\n        corrected_types = set()\n        for x in ys:\n            y_type = type_of_target(x)\n            if y_type == 'unknown':\n                # Check if this is a pandas nullable dtype converted to object\n                x_array = check_array(x, ensure_2d=False, dtype=None, force_all_finite=False)\n                if x_array.dtype == object and x_array.size > 0:\n                    # Try to determine the actual type by examining the data\n                    try:\n                        # Remove None/nan values for type checking\n                        non_null_mask = x_array != None\n                        if hasattr(x_array, 'notna'):\n                            non_null_mask = x_array.notna()\n                        elif hasattr(np, 'isnan'):\n                            try:\n                                non_null_mask = ~np.isnan(x_array.astype(float))\n                            except (ValueError, TypeError):\n                                pass\n                        \n                        if np.any(non_null_mask):\n                            non_null_values = x_array[non_null_mask]\n                            unique_vals = np.unique(non_null_values)\n                            if len(unique_vals) <= 2:\n                                corrected_types.add('binary')\n                            else:\n                                corrected_types.add('multiclass')\n                        else:\n                            corrected_types.add('binary')  # Default for empty/all-null\n                    except:\n                        corrected_types.add('unknown')\n                else:\n                    corrected_types.add('unknown')\n            else:\n                corrected_types.add(y_type)\n        ys_types = corrected_types\n    \n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n",
      "\n    ys_types = set(type_of_target(x) for x in ys)\n    # Handle pandas nullable dtypes that get misclassified as 'unknown'\n    if \"unknown\" in ys_types and len(ys_types) > 1:\n        # Check if 'unknown' types are actually pandas nullable dtypes\n        refined_types = set()\n        for x in ys:\n            target_type = type_of_target(x)\n            if target_type == \"unknown\":\n                # Try to determine the actual type for pandas nullable dtypes\n                try:\n                    # Convert to array and check if it's numeric\n                    xp_local, _ = get_namespace(x)\n                    x_array = xp_local.asarray(x)\n                    if x_array.dtype == object:\n                        # Check if all non-null values are numeric\n                        non_null_vals = [v for v in x_array.flat if v is not None and not (hasattr(v, '__class__') and v.__class__.__name__ == 'NAType')]\n                        if non_null_vals and all(isinstance(v, (int, float, np.integer, np.floating)) for v in non_null_vals):\n                            unique_vals = set(non_null_vals)\n                            if len(unique_vals) <= 2:\n                                refined_types.add(\"binary\")\n                            else:\n                                refined_types.add(\"multiclass\")\n                        else:\n                            refined_types.add(\"unknown\")\n                    else:\n                        refined_types.add(\"unknown\")\n                except:\n                    refined_types.add(\"unknown\")\n            else:\n                refined_types.add(target_type)\n        ys_types = refined_types\n    \n    if ys_types == {\"binary\", \"multiclass\"}:\n        ys_types = {\"multiclass\"}\n\n    if len(ys_types) > 1:\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..78d014730 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,6 +20,7 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n     if hasattr(y, \"__array__\") or is_array_api:\n@@ -78,6 +79,7 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n@@ -302,6 +304,13 @@ def type_of_target(y, input_name=\"\"):\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n+\n+    # Check if y is a pandas Series with nullable dtype before conversion\n+    pandas_nullable_dtype = None\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        if y.dtype.name in ('Int64', 'Float64', 'boolean'):\n+            pandas_nullable_dtype = y.dtype.name\n+    \n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n         if not issparse(y):\n@@ -311,7 +320,6 @@ def type_of_target(y, input_name=\"\"):\n                 # dtype=object should be provided explicitly for ragged arrays,\n                 # see NEP 34\n                 y = xp.asarray(y, dtype=object)\n-\n     # The old sequence of sequences format\n     try:\n         if (\n@@ -340,9 +348,17 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n+\n     if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+        # Check if this object array contains numeric data from pandas nullable dtypes\n+        # by examining the first element's type\n+        first_elem = y.flat[0]\n+        if isinstance(first_elem, (int, float, bool, np.integer, np.floating, np.bool_)):\n+            # This is likely from a pandas nullable dtype, continue to proper classification\n+            pass\n+        else:\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -358,6 +374,7 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n     if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n",
    "variant_0": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..080973665 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,10 +20,24 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n     if hasattr(y, \"__array__\") or is_array_api:\n-        return xp.unique_values(xp.asarray(y))\n+        # Handle pandas nullable dtypes that get converted to object arrays\n+        y_array = xp.asarray(y)\n+        if hasattr(y, 'dtype') and str(y.dtype) in ['Int64', 'Float64', 'boolean']:\n+            # For pandas nullable dtypes, convert to regular numpy array\n+            y_array = np.asarray(y.to_numpy(dtype=y.dtype.numpy_dtype, na_value=np.nan))\n+        elif y_array.dtype == object and hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+            # Check if this is a converted pandas nullable dtype\n+            if str(y.dtype).endswith('64') or str(y.dtype) == 'boolean':\n+                try:\n+                    # Try to convert back to numeric if possible\n+                    y_array = np.asarray(y.to_numpy(na_value=np.nan))\n+                except:\n+                    pass\n+        return xp.unique_values(y_array)\n     else:\n         return set(y)\n \n@@ -78,7 +92,39 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n+    # Handle pandas nullable dtypes that get misclassified as 'unknown'\n+    if 'unknown' in ys_types and len(ys_types) > 1:\n+        # Check if 'unknown' types are actually pandas nullable dtypes\n+        refined_types = set()\n+        for x in ys:\n+            target_type = type_of_target(x)\n+            if target_type == 'unknown':\n+                # Try to infer the actual type for pandas nullable dtypes\n+                try:\n+                    # Convert to numpy array and check if it's actually numeric\n+                    arr = np.asarray(x)\n+                    if arr.dtype == object and len(arr) > 0:\n+                        # Check if all non-null values are numeric\n+                        non_null_vals = [v for v in arr if v is not None and not (isinstance(v, float) and np.isnan(v))]\n+                        if non_null_vals and all(isinstance(v, (int, float, np.integer, np.floating)) for v in non_null_vals):\n+                            # Determine if binary or multiclass based on unique values\n+                            unique_vals = np.unique([v for v in non_null_vals])\n+                            if len(unique_vals) <= 2:\n+                                refined_types.add('binary')\n+                            else:\n+                                refined_types.add('multiclass')\n+                        else:\n+                            refined_types.add('unknown')\n+                    else:\n+                        refined_types.add('unknown')\n+                except:\n+                    refined_types.add('unknown')\n+            else:\n+                refined_types.add(target_type)\n+        ys_types = refined_types\n+    \n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n \n@@ -302,16 +348,32 @@ def type_of_target(y, input_name=\"\"):\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n+\n+    # DeprecationWarning will be replaced by ValueError, see NEP 34\n+    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n+    # We therefore catch both deprecation (NumPy < 1.24) warning and\n+    # value error (NumPy >= 1.24).\n+    \n+    # Check if y is a pandas nullable dtype before conversion\n+    pandas_nullable_dtype = False\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        nullable_dtypes = {'Int8', 'Int16', 'Int32', 'Int64', 'UInt8', 'UInt16', 'UInt32', 'UInt64', 'Float32', 'Float64', 'boolean'}\n+        if y.dtype.name in nullable_dtypes:\n+            pandas_nullable_dtype = True\n+    \n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n         if not issparse(y):\n             try:\n-                y = xp.asarray(y)\n+                if pandas_nullable_dtype:\n+                    # Convert pandas nullable dtype to regular numpy dtype to preserve semantics\n+                    y = y.to_numpy(dtype=y.dtype.numpy_dtype, na_value=np.nan)\n+                else:\n+                    y = xp.asarray(y)\n             except (np.VisibleDeprecationWarning, ValueError):\n                 # dtype=object should be provided explicitly for ragged arrays,\n                 # see NEP 34\n                 y = xp.asarray(y, dtype=object)\n-\n     # The old sequence of sequences format\n     try:\n         if (\n@@ -340,9 +402,29 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+\n+    if not issparse(y) and y.dtype == object:\n+        # Check if this is a pandas nullable dtype converted to object\n+        if hasattr(y, '__array_function__') and len(y) > 0:\n+            # Try to determine if object array contains numeric data from nullable dtypes\n+            first_val = y.flat[0]\n+            if first_val is not None and not isinstance(first_val, str):\n+                # Check if all non-null values are numeric\n+                try:\n+                    non_null_vals = [val for val in y.flat if val is not None]\n+                    if non_null_vals and all(isinstance(val, (int, float, np.integer, np.floating)) for val in non_null_vals):\n+                        # This appears to be numeric data, continue with normal classification\n+                        pass\n+                    else:\n+                        return \"unknown\"\n+                except (TypeError, ValueError):\n+                    return \"unknown\"\n+            elif not isinstance(first_val, str):\n+                # [obj_1] and not [\"label_1\"]\n+                return \"unknown\"\n+        elif not isinstance(y.flat[0], str):\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -358,6 +440,178 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+\n+def type_of_target(y, input_name=\"\"):\n+    \"\"\"Determine the type of data indicated by the target.\n+\n+    Note that this type is the most specific type that can be inferred.\n+    For example:\n+\n+        * ``binary`` is more specific but compatible with ``multiclass``.\n+        * ``multiclass`` is more specific but compatible with ``continuous``.\n+        * ``multilabel-indicator`` is more specific but compatible with\n+          ``multiclass-multioutput``.\n+\n+    Parameters\n+    ----------\n+    y : {array-like, sparse matrix}\n+        Target values. If a sparse matrix, a CSR matrix is expected.\n+\n+    input_name : str, default=\"\"\n+        The data name used to construct the error message.\n+\n+        .. versionadded:: 1.1.0\n+\n+    Returns\n+    -------\n+    target_type : str\n+        One of:\n+\n+        * 'continuous': `y` is an array-like of floats that are not all\n+          integers, and is 1d or a column vector.\n+        * 'continuous-multioutput': `y` is a 2d array of floats that are\n+          not all integers, and both dimensions are of size > 1.\n+        * 'binary': `y` contains <= 2 discrete values and is 1d or a column\n+          vector.\n+        * 'multiclass': `y` contains more than two discrete values, is not a\n+          sequence of sequences, and is 1d or a column vector.\n+        * 'multiclass-multioutput': `y` is a 2d array that contains more\n+          than two discrete values, is not a sequence of sequences, and both\n+          dimensions are of size > 1.\n+        * 'multilabel-indicator': `y` is a label indicator matrix, an array\n+          of two dimensions with at least two columns, and at most 2 unique\n+          values.\n+        * 'unknown': `y` is array-like but none of the above, such as a 3d\n+          array, or an array of non-sequence objects.\n+\n+    Examples\n+    --------\n+    >>> from sklearn.utils.multiclass import type_of_target\n+    >>> import numpy as np\n+    >>> type_of_target([0.1, 0.6])\n+    'continuous'\n+    >>> type_of_target([1, -1, -1, 1])\n+    'binary'\n+    >>> type_of_target(['a', 'b', 'a'])\n+    'binary'\n+    >>> type_of_target([1.0, 2.0])\n+    'binary'\n+    >>> type_of_target([1, 0, 2])\n+    'multiclass'\n+    >>> type_of_target([1.0, 0.0, 3.0])\n+    'multiclass'\n+    >>> type_of_target(['a', 'b', 'c'])\n+    'multiclass'\n+    >>> type_of_target(np.array([[1, 2], [3, 1]]))\n+    'multiclass-multioutput'\n+    >>> type_of_target([[1, 2]])\n+    'multilabel-indicator'\n+    >>> type_of_target(np.array([[1.5, 2.0], [3.0, 1.6]]))\n+    'continuous-multioutput'\n+    >>> type_of_target(np.array([[0, 1], [1, 1]]))\n+    'multilabel-indicator'\n+    \"\"\"\n+    xp, is_array_api_compliant = get_namespace(y)\n+    \n+    # Store original pandas nullable dtype info if present\n+    original_pandas_dtype = None\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        if y.dtype.name in ['Int8', 'Int16', 'Int32', 'Int64', 'UInt8', 'UInt16', 'UInt32', 'UInt64', 'Float32', 'Float64', 'boolean']:\n+            original_pandas_dtype = y.dtype.name\n+\n+    if is_array_api_compliant:\n+        y = xp.asarray(y)\n+    else:\n+        y = check_array(y, accept_sparse=True, ensure_2d=False, dtype=None)\n+\n+    # Check if sparse matrix\n+    if issparse(y):\n+        if y.format not in [\"csr\", \"csc\", \"coo\"]:\n+            raise ValueError(\n+                \"Sparse matrix in format {} is not supported\".format(y.format)\n+            )\n+\n+    # The targets are empty, consider them as binary.\n+    if y.size == 0:\n+        return \"binary\"\n+\n+    # The targets are of a valid type?\n+    valid = (\n+        (issparse(y) or hasattr(y, \"__array__\"))\n+        and hasattr(y, \"shape\")\n+        and hasattr(y, \"dtype\")\n+    )\n+\n+    if not valid:\n+        return \"unknown\"\n+\n+    # Check if y is a string array\n+    if y.dtype.kind in \"SUVO\":\n+        # Check if y is a sequence of sequences\n+        if y.ndim == 2 and y.shape[1] > 1:\n+            suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n+        else:\n+            suffix = \"\"  # [1, 2, 3] or [[1], [2], [3]]\n+\n+        # Special handling for object dtype that might be from pandas nullable types\n+        if y.dtype == object and original_pandas_dtype:\n+            # For converted pandas nullable types, treat as numeric\n+            if original_pandas_dtype in ['Int8', 'Int16', 'Int32', 'Int64', 'UInt8', 'UInt16', 'UInt32', 'UInt64']:\n+                # Integer nullable types - check for binary vs multiclass\n+                try:\n+                    unique_vals = xp.unique_values(y)\n+                    if unique_vals.shape[0] > 2 or (y.ndim == 2 and y.shape[1] > 1):\n+                        return \"multiclass\" + suffix\n+                    else:\n+                        return \"binary\"\n+                except:\n+                    # Fallback to checking first few elements\n+                    first_row = y[0] if not issparse(y) else y.getrow(0).data\n+                    if y.ndim == 2 and len(first_row) > 1:\n+                        return \"multiclass\" + suffix\n+                    else:\n+                        return \"binary\"\n+            elif original_pandas_dtype in ['Float32', 'Float64']:\n+                # Float nullable types - check if they're all integers\n+                try:\n+                    data = y.data if issparse(y) else y\n+                    # Convert to float for comparison\n+                    float_data = data.astype(float)\n+                    if xp.any(float_data != float_data.astype(int)):\n+                        return \"continuous\" + suffix\n+                    else:\n+                        # All floats are integers, treat as discrete\n+                        unique_vals = xp.unique_values(y)\n+                        if unique_vals.shape[0] > 2 or (y.ndim == 2 and y.shape[1] > 1):\n+                            return \"multiclass\" + suffix\n+                        else:\n+                            return \"binary\"\n+                except:\n+                    return \"continuous\" + suffix\n+            elif original_pandas_dtype == 'boolean':\n+                return \"binary\"\n+        \n+        # Original string/object logic for non-pandas cases\n+        if y.dtype != object:\n+            # [1, 2, 3] or [[1], [2], [3]] or [[1, 2], [1, 2]]\n+            return \"multiclass\" + suffix\n+        else:\n+            return \"unknown\"\n+\n+    # Check if y is a sequence of sequences\n+    if y.ndim == 2 and y.shape[1] > 1:\n+        suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n+    else:\n+        suffix = \"\"  # [1, 2, 3] or [[1], [2], [3]]\n+\n+    # Check float and contains non-integer float values\n+    if y.dtype.kind == \"f\":\n+        # [.1, .2, 3] or [[.1, .2, 3]] or [[1., .2]] and not [1., 2., 3.]\n+        data = y.data if issparse(y) else y\n+        if xp.any(data != data.astype(int)):\n+            _assert_all_finite(data, input_name=input_name)\n+            return \"continuous\" + suffix\n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n     if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n",
    "variant_1": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..6fab77af8 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,10 +20,22 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n     if hasattr(y, \"__array__\") or is_array_api:\n-        return xp.unique_values(xp.asarray(y))\n+        # Handle pandas nullable dtypes that get converted to object dtype\n+        y_array = xp.asarray(y)\n+        if hasattr(y, 'dtype') and str(y.dtype) in ['Int64', 'Float64', 'boolean']:\n+            # Convert pandas nullable dtype to regular numpy array\n+            y_array = y_array.astype(y.dtype.numpy_dtype)\n+        elif y_array.dtype == object and hasattr(y, 'dtype') and hasattr(y.dtype, 'numpy_dtype'):\n+            # Handle case where pandas nullable dtype was already converted to object\n+            try:\n+                y_array = y_array.astype(y.dtype.numpy_dtype)\n+            except (AttributeError, TypeError):\n+                pass\n+        return xp.unique_values(y_array)\n     else:\n         return set(y)\n \n@@ -78,7 +90,44 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n+    # Handle pandas nullable dtypes that get misclassified as 'unknown'\n+    # Convert 'unknown' back to proper type if it contains valid numeric data\n+    if 'unknown' in ys_types:\n+        corrected_types = set()\n+        for x in ys:\n+            target_type = type_of_target(x)\n+            if target_type == 'unknown':\n+                # Check if this is actually numeric data that was converted to object dtype\n+                x_array = check_array(x, ensure_2d=False, dtype=None, force_all_finite=False)\n+                if x_array.dtype == object and len(x_array) > 0:\n+                    # Try to determine if it's really binary/multiclass numeric data\n+                    try:\n+                        # Convert to numeric to see if it's actually numeric data\n+                        numeric_vals = []\n+                        for val in x_array.ravel():\n+                            if val is not None and not (isinstance(val, float) and np.isnan(val)):\n+                                numeric_vals.append(val)\n+                        \n+                        if numeric_vals:\n+                            unique_vals = np.unique(numeric_vals)\n+                            if len(unique_vals) == 2:\n+                                corrected_types.add('binary')\n+                            elif len(unique_vals) > 2:\n+                                corrected_types.add('multiclass')\n+                            else:\n+                                corrected_types.add('unknown')\n+                        else:\n+                            corrected_types.add('unknown')\n+                    except (ValueError, TypeError):\n+                        corrected_types.add('unknown')\n+                else:\n+                    corrected_types.add('unknown')\n+            else:\n+                corrected_types.add(target_type)\n+        ys_types = corrected_types\n+    \n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n \n@@ -302,16 +351,26 @@ def type_of_target(y, input_name=\"\"):\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n+\n+    # Check for pandas nullable dtypes before conversion\n+    pandas_nullable_dtype = False\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        pandas_nullable_dtype = y.dtype.name in {'Int64', 'Float64', 'boolean'}\n+    \n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n         if not issparse(y):\n             try:\n-                y = xp.asarray(y)\n+                if pandas_nullable_dtype:\n+                    # Convert pandas nullable dtypes to their non-nullable equivalents\n+                    # to preserve semantic meaning and avoid object dtype\n+                    y = xp.asarray(y.astype(y.dtype.name.lower()))\n+                else:\n+                    y = xp.asarray(y)\n             except (np.VisibleDeprecationWarning, ValueError):\n                 # dtype=object should be provided explicitly for ragged arrays,\n                 # see NEP 34\n                 y = xp.asarray(y, dtype=object)\n-\n     # The old sequence of sequences format\n     try:\n         if (\n@@ -340,7 +399,26 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n+\n+if not issparse(y) and y.dtype == object:\n+    # Check if this is a pandas nullable dtype converted to object\n+    if hasattr(y, '__array_function__') and len(y) > 0:\n+        # Try to detect if object array contains numeric data from nullable dtypes\n+        first_val = y.flat[0]\n+        if first_val is not None and not isinstance(first_val, str):\n+            # Check if all non-None values are numeric\n+            try:\n+                non_none_vals = [val for val in y.flat if val is not None]\n+                if non_none_vals and all(isinstance(val, (int, float, np.integer, np.floating)) for val in non_none_vals):\n+                    # This appears to be numeric data, continue with normal classification\n+                    pass\n+                else:\n+                    return \"unknown\"\n+            except:\n+                return \"unknown\"\n+        elif not isinstance(first_val, str):\n+            return \"unknown\"\n+    elif len(y) > 0 and not isinstance(y.flat[0], str):\n         # [obj_1] and not [\"label_1\"]\n         return \"unknown\"\n \n@@ -358,6 +436,160 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+\n+def type_of_target(y, input_name=\"\"):\n+    \"\"\"Determine the type of data indicated by the target.\n+\n+    Note that this type is the most specific type that can be inferred.\n+    For example:\n+\n+        * ``binary`` is more specific but compatible with ``multiclass``.\n+        * ``multiclass`` is more specific but compatible with ``continuous``.\n+        * ``multilabel-indicator`` is more specific but compatible with\n+          ``multiclass-multioutput``.\n+\n+    Parameters\n+    ----------\n+    y : {array-like, sparse matrix}\n+        Target values. If a sparse matrix, ``y`` is expected to be a\n+        CSR/CSC matrix.\n+\n+    input_name : str, default=\"\"\n+        The data name used to construct the error message.\n+\n+        .. versionadded:: 1.1.0\n+\n+    Returns\n+    -------\n+    target_type : str\n+        One of:\n+\n+        * 'continuous': `y` is an array-like of floats that are not all\n+          integers, and is 1d or a column vector.\n+        * 'continuous-multioutput': `y` is a 2d array of floats that are\n+          not all integers, and both dimensions are of size > 1.\n+        * 'binary': `y` contains <= 2 discrete values and is 1d or a column\n+          vector.\n+        * 'multiclass': `y` contains more than two discrete values, is not a\n+          sequence of sequences, and is 1d or a column vector.\n+        * 'multiclass-multioutput': `y` is a 2d array that contains more\n+          than two discrete values, is not a sequence of sequences, and both\n+          dimensions are of size > 1.\n+        * 'multilabel-indicator': `y` is a label indicator matrix, an array\n+          of two dimensions with at least two columns, and at most 2 unique\n+          values.\n+        * 'unknown': `y` is array-like but none of the above, such as a 3d\n+          array, or an array of non-sequence objects.\n+\n+    Examples\n+    --------\n+    >>> from sklearn.utils.multiclass import type_of_target\n+    >>> import numpy as np\n+    >>> type_of_target([0.1, 0.6])\n+    'continuous'\n+    >>> type_of_target([1, -1, -1, 1])\n+    'binary'\n+    >>> type_of_target(['a', 'b', 'a'])\n+    'binary'\n+    >>> type_of_target([1.0, 2.0])\n+    'binary'\n+    >>> type_of_target([1, 0, 2])\n+    'multiclass'\n+    >>> type_of_target([1.0, 0.0, 3.0])\n+    'multiclass'\n+    >>> type_of_target(['a', 'b', 'c'])\n+    'multiclass'\n+    >>> type_of_target(np.array([[1, 2], [3, 1]]))\n+    'multiclass-multioutput'\n+    >>> type_of_target([[1, 2]])\n+    'multilabel-indicator'\n+    >>> type_of_target(np.array([[1.5, 2.0], [3.0, 1.6]]))\n+    'continuous-multioutput'\n+    >>> type_of_target(np.array([[0, 1], [1, 1]]))\n+    'multilabel-indicator'\n+    \"\"\"\n+    xp, is_array_api_compliant = get_namespace(y)\n+    \n+    # Store original pandas nullable dtype info if present\n+    pandas_nullable_dtype = None\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        dtype_name = y.dtype.name\n+        if dtype_name in ['Int8', 'Int16', 'Int32', 'Int64', 'UInt8', 'UInt16', 'UInt32', 'UInt64', 'Float32', 'Float64', 'boolean']:\n+            pandas_nullable_dtype = dtype_name\n+\n+    y = xp.asarray(y)\n+\n+    # The old sequence of sequences format\n+    try:\n+        if (\n+            not hasattr(y, \"shape\")\n+            and isinstance(y, Sequence)\n+            and not isinstance(y, str)\n+        ):\n+            raise ValueError(\n+                \"You appear to be using a legacy multi-label data\"\n+                \" representation. Sequence of sequences are no\"\n+                \" longer supported; use a binary array or sparse\"\n+                \" matrix instead - the MultiLabelBinarizer\"\n+                \" transformer can convert to this format.\"\n+            )\n+    except ValueError:\n+        # This is a sparse matrix, do nothing\n+        pass\n+\n+    # Invalid inputs\n+    if y.ndim not in (1, 2):\n+        # Number of dimension greater than 2: [[[1, 2]]]\n+        return \"unknown\"\n+\n+    # The multilabel-indicator case\n+    if y.ndim == 2 and y.shape[1] > 1:\n+        suffix = \"-multioutput\"  # [[1, 2], [1, 2]]\n+    else:\n+        suffix = \"\"  # [1, 2, 3] or [[1], [2], [3]]\n+\n+    # Check float and contains non-integer float values\n+    if y.dtype.kind == \"f\":\n+        # [.1, .2, 3] or [[.1, .2, 3]] or [[1., .2]] and not [1., 2., 3.]\n+        data = y.data if issparse(y) else y\n+        if xp.any(data != data.astype(int)):\n+            _assert_all_finite(data, input_name=input_name)\n+            return \"continuous\" + suffix\n+\n+    # Check if this is an object array from pandas nullable dtype\n+    if y.dtype == object and pandas_nullable_dtype is not None:\n+        # Handle pandas nullable dtypes that were converted to object arrays\n+        # Convert to appropriate numpy dtype for further processing\n+        if pandas_nullable_dtype == 'boolean':\n+            # Convert to bool, handling pd.NA as False for type determination\n+            try:\n+                y_converted = np.array([bool(x) if x is not None and str(x).lower() != 'nan' else False for x in y.flat]).reshape(y.shape)\n+                y = xp.asarray(y_converted)\n+            except (ValueError, TypeError):\n+                return \"unknown\"\n+        elif pandas_nullable_dtype.startswith(('Int', 'UInt')):\n+            # Convert to int, handling pd.NA as 0 for type determination\n+            try:\n+                y_converted = np.array([int(x) if x is not None and str(x).lower() != 'nan' else 0 for x in y.flat]).reshape(y.shape)\n+                y = xp.asarray(y_converted)\n+            except (ValueError, TypeError):\n+                return \"unknown\"\n+        elif pandas_nullable_dtype.startswith('Float'):\n+            # Convert to float, handling pd.NA as 0.0 for type determination\n+            try:\n+                y_converted = np.array([float(x) if x is not None and str(x).lower() != 'nan' else 0.0 for x in y.flat]).reshape(y.shape)\n+                y = xp.asarray(y_converted)\n+            except (ValueError, TypeError):\n+                return \"unknown\"\n+    elif y.dtype == object:\n+        # Check if the object array contains strings\n+        if len(y) and isinstance(y.flat[0], str):\n+            # [[\"a\"], [\"b\"]] or [\"a\", \"b\"]\n+            pass\n+        else:\n+            # [array([1]), array([2])] or [1, 2, 3] but y.dtype == object\n+            return \"unknown\"\n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n     if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n",
    "variant_2": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..f57acb8f2 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,10 +20,23 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n     if hasattr(y, \"__array__\") or is_array_api:\n-        return xp.unique_values(xp.asarray(y))\n+        # Handle pandas nullable dtypes that get converted to object dtype\n+        y_array = xp.asarray(y)\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name') and y.dtype.name in ['Int64', 'Float64', 'boolean']:\n+            # For pandas nullable dtypes, extract the non-null values for unique computation\n+            if hasattr(y, 'dropna'):\n+                return xp.unique_values(xp.asarray(y.dropna()))\n+            else:\n+                # Fallback: filter out None/NaN values manually\n+                valid_mask = y_array != None\n+                if xp.__name__ == 'numpy':\n+                    valid_mask = valid_mask & ~np.isnan(y_array.astype(float, errors='ignore'))\n+                return xp.unique_values(y_array[valid_mask])\n+        return xp.unique_values(y_array)\n     else:\n         return set(y)\n \n@@ -78,7 +91,44 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n+    # Handle pandas nullable dtypes that get misclassified as 'unknown'\n+    # when they should be 'binary' or 'multiclass'\n+    if 'unknown' in ys_types and len(ys_types) > 1:\n+        # Check if 'unknown' types are actually pandas nullable dtypes\n+        corrected_types = set()\n+        for x in ys:\n+            x_type = type_of_target(x)\n+            if x_type == 'unknown':\n+                # Try to get the actual type by checking the underlying data\n+                try:\n+                    # Convert to numpy array and check if it's numeric\n+                    x_array = np.asarray(x)\n+                    if x_array.dtype == object:\n+                        # Check if all non-null values are numeric\n+                        non_null_mask = x_array != None\n+                        if np.any(non_null_mask):\n+                            non_null_values = x_array[non_null_mask]\n+                            if all(isinstance(val, (int, float, np.integer, np.floating)) for val in non_null_values):\n+                                # Determine if binary or multiclass based on unique values\n+                                unique_vals = np.unique(non_null_values)\n+                                if len(unique_vals) <= 2:\n+                                    corrected_types.add('binary')\n+                                else:\n+                                    corrected_types.add('multiclass')\n+                            else:\n+                                corrected_types.add('unknown')\n+                        else:\n+                            corrected_types.add('unknown')\n+                    else:\n+                        corrected_types.add('unknown')\n+                except:\n+                    corrected_types.add('unknown')\n+            else:\n+                corrected_types.add(x_type)\n+        ys_types = corrected_types\n+    \n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n \n@@ -302,16 +352,30 @@ def type_of_target(y, input_name=\"\"):\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n+\n+    # Check for pandas nullable dtypes before conversion\n+    pandas_nullable_dtype = False\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        pandas_nullable_dtype = y.dtype.name in ('Int8', 'Int16', 'Int32', 'Int64', \n+                                                 'Float32', 'Float64', 'boolean')\n+    \n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n         if not issparse(y):\n             try:\n-                y = xp.asarray(y)\n+                # For pandas nullable dtypes, convert to non-nullable equivalent\n+                if pandas_nullable_dtype:\n+                    if y.dtype.name == 'boolean':\n+                        y = xp.asarray(y.astype('bool'))\n+                    else:\n+                        # Convert nullable numeric types to their non-nullable equivalents\n+                        y = xp.asarray(y.astype(y.dtype.name.lower()))\n+                else:\n+                    y = xp.asarray(y)\n             except (np.VisibleDeprecationWarning, ValueError):\n                 # dtype=object should be provided explicitly for ragged arrays,\n                 # see NEP 34\n                 y = xp.asarray(y, dtype=object)\n-\n     # The old sequence of sequences format\n     try:\n         if (\n@@ -340,9 +404,21 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n+\n     if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+        # Check if this is a converted pandas nullable dtype containing numeric data\n+        try:\n+            # Try to get a sample of non-null values to check if they're numeric\n+            sample_values = [val for val in y.flat[:min(10, len(y.flat))] if val is not None and not np.isnan(val) if isinstance(val, (int, float, np.integer, np.floating)) else False]\n+            if sample_values and all(isinstance(val, (int, float, np.integer, np.floating)) for val in sample_values):\n+                # This appears to be numeric data in object dtype, continue with normal classification\n+                pass\n+            else:\n+                # [obj_1] and not [\"label_1\"] - truly non-numeric objects\n+                return \"unknown\"\n+        except (TypeError, ValueError):\n+            # [obj_1] and not [\"label_1\"] - objects that can't be processed\n+            return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -358,8 +434,33 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n+    \n+    # For object dtype arrays that may have come from pandas nullable dtypes,\n+    # check if they contain numeric data that should be treated as multiclass/binary\n+    if y.dtype == object and not issparse(y):\n+        # Try to determine if this is numeric data in object array\n+        try:\n+            # Check if all non-null values can be converted to numeric\n+            flat_y = y.ravel() if y.ndim > 1 else y\n+            non_null_mask = flat_y != None\n+            if xp.any(non_null_mask):\n+                non_null_values = flat_y[non_null_mask]\n+                # Check if values are numeric (int, float, or convertible)\n+                if all(isinstance(val, (int, float, np.integer, np.floating)) or \n+                       (hasattr(val, 'dtype') and val.dtype.kind in 'iuf') for val in non_null_values):\n+                    # This appears to be numeric data, check unique count\n+                    unique_vals = xp.unique_values(non_null_values)\n+                    if unique_vals.shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n+                        return \"multiclass\" + suffix\n+                    else:\n+                        return \"binary\" + suffix\n+        except (TypeError, ValueError):\n+            # If we can't determine it's numeric, fall through to normal logic\n+            pass\n+    \n     if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n         # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n         return \"multiclass\" + suffix\n",
    "variant_3": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..453e6cda5 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,10 +20,31 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n     if hasattr(y, \"__array__\") or is_array_api:\n-        return xp.unique_values(xp.asarray(y))\n+        # Handle pandas nullable dtypes that get converted to object arrays\n+        y_array = xp.asarray(y)\n+        if hasattr(y, 'dtype') and str(y.dtype) in ['Int64', 'Float64', 'boolean']:\n+            # For pandas nullable dtypes, convert to non-nullable equivalent\n+            if str(y.dtype) == 'boolean':\n+                y_array = y_array.astype(bool)\n+            elif str(y.dtype) == 'Int64':\n+                y_array = y_array.astype(int)\n+            elif str(y.dtype) == 'Float64':\n+                y_array = y_array.astype(float)\n+        elif y_array.dtype == object and hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+            # Check if object array came from nullable dtype conversion\n+            try:\n+                # Try to convert back to numeric if possible\n+                if all(isinstance(x, (int, np.integer)) or (x is not None and not np.isnan(x)) for x in y_array if x is not None):\n+                    y_array = y_array.astype(int)\n+                elif all(isinstance(x, (float, np.floating)) or x is None or np.isnan(x) for x in y_array):\n+                    y_array = y_array.astype(float)\n+            except (ValueError, TypeError):\n+                pass\n+        return xp.unique_values(y_array)\n     else:\n         return set(y)\n \n@@ -78,9 +99,42 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n+    # Handle pandas nullable dtypes that get misclassified as 'unknown'\n+    if \"unknown\" in ys_types and len(ys_types) > 1:\n+        # Check if 'unknown' types are actually pandas nullable dtypes\n+        filtered_types = set()\n+        for x in ys:\n+            target_type = type_of_target(x)\n+            if target_type == \"unknown\":\n+                # Try to determine the actual type for object arrays from nullable dtypes\n+                xp, _ = get_namespace(x)\n+                x_array = xp.asarray(x)\n+                if hasattr(x_array, 'dtype') and x_array.dtype == object:\n+                    # Check if this is numeric data in object array (from nullable dtype)\n+                    try:\n+                        # Convert to numeric and check unique values\n+                        numeric_vals = [val for val in x_array.ravel() if val is not None]\n+                        if numeric_vals and all(isinstance(val, (int, float, np.integer, np.floating)) for val in numeric_vals):\n+                            unique_vals = len(set(numeric_vals))\n+                            if unique_vals <= 2:\n+                                filtered_types.add(\"binary\")\n+                            else:\n+                                filtered_types.add(\"multiclass\")\n+                        else:\n+                            filtered_types.add(\"unknown\")\n+                    except:\n+                        filtered_types.add(\"unknown\")\n+                else:\n+                    filtered_types.add(\"unknown\")\n+            else:\n+                filtered_types.add(target_type)\n+        ys_types = filtered_types\n+        if ys_types == {\"binary\", \"multiclass\"}:\n+            ys_types = {\"multiclass\"}\n \n     if len(ys_types) > 1:\n         raise ValueError(\"Mix type of y not allowed, got types %s\" % ys_types)\n@@ -302,16 +356,26 @@ def type_of_target(y, input_name=\"\"):\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n+\n+    # Check for pandas nullable dtypes before conversion\n+    pandas_nullable_dtype = False\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        pandas_nullable_dtype = y.dtype.name in ('Int64', 'Float64', 'boolean')\n+    \n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n         if not issparse(y):\n             try:\n-                y = xp.asarray(y)\n+                if pandas_nullable_dtype:\n+                    # Convert pandas nullable dtypes to their non-nullable equivalents\n+                    # to preserve semantic meaning and avoid object dtype\n+                    y = xp.asarray(y.astype(str(y.dtype).lower()))\n+                else:\n+                    y = xp.asarray(y)\n             except (np.VisibleDeprecationWarning, ValueError):\n                 # dtype=object should be provided explicitly for ragged arrays,\n                 # see NEP 34\n                 y = xp.asarray(y, dtype=object)\n-\n     # The old sequence of sequences format\n     try:\n         if (\n@@ -340,9 +404,27 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+\n+    if not issparse(y) and y.dtype == object:\n+        # Check if this is a pandas nullable dtype converted to object\n+        if hasattr(y, '__array__') and len(y) > 0:\n+            # Try to get a sample value to check if it's numeric\n+            sample_val = None\n+            for val in y.flat:\n+                if val is not None and not (isinstance(val, str) and val != val):  # Skip NaN strings\n+                    sample_val = val\n+                    break\n+            \n+            # If we found a numeric sample, this likely came from a nullable dtype\n+            if sample_val is not None and not isinstance(sample_val, str):\n+                # Continue with normal classification instead of returning \"unknown\"\n+                pass\n+            else:\n+                # [obj_1] and not [\"label_1\"]\n+                return \"unknown\"\n+        elif not isinstance(y.flat[0], str):\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -358,9 +440,27 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n-    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n+    \n+    # For object dtype arrays that may contain numeric data from pandas nullable dtypes,\n+    # check if all values are numeric and can be treated as binary/multiclass\n+    if y.dtype == object and not issparse(y):\n+        try:\n+            # Try to convert to numeric to check if this is a converted nullable dtype\n+            numeric_y = xp.asarray(y, dtype=float)\n+            if xp.all(xp.isfinite(numeric_y)):\n+                # Use numeric version for unique value counting\n+                unique_count = xp.unique_values(numeric_y).shape[0]\n+            else:\n+                unique_count = xp.unique_values(y).shape[0]\n+        except (ValueError, TypeError):\n+            unique_count = xp.unique_values(y).shape[0]\n+    else:\n+        unique_count = xp.unique_values(y).shape[0]\n+    \n+    if unique_count > 2 or (y.ndim == 2 and len(first_row) > 1):\n         # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n         return \"multiclass\" + suffix\n     else:\n",
    "variant_4": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..ba270b364 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,10 +20,21 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n     if hasattr(y, \"__array__\") or is_array_api:\n-        return xp.unique_values(xp.asarray(y))\n+        # Handle pandas nullable dtypes that get converted to object arrays\n+        y_array = xp.asarray(y)\n+        if hasattr(y, 'dtype') and hasattr(y.dtype, 'name') and y.dtype.name in ('Int64', 'Float64', 'boolean'):\n+            # For pandas nullable dtypes, convert to non-nullable equivalent\n+            if y.dtype.name == 'boolean':\n+                y_array = y_array.astype(bool)\n+            elif y.dtype.name == 'Int64':\n+                y_array = y_array.astype(int)\n+            elif y.dtype.name == 'Float64':\n+                y_array = y_array.astype(float)\n+        return xp.unique_values(y_array)\n     else:\n         return set(y)\n \n@@ -78,7 +89,44 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n+    # Handle pandas nullable dtypes that get misclassified as 'unknown'\n+    # If we have 'unknown' types, check if they're actually pandas nullable arrays\n+    if 'unknown' in ys_types:\n+        corrected_types = set()\n+        for x in ys:\n+            target_type = type_of_target(x)\n+            if target_type == 'unknown':\n+                # Check if this is a pandas nullable dtype converted to object\n+                xp, _ = get_namespace(x)\n+                x_array = xp.asarray(x)\n+                if hasattr(x, 'dtype') and str(x.dtype) in ('Int64', 'Float64', 'boolean'):\n+                    # Re-classify based on the actual values\n+                    if x_array.dtype == object:\n+                        # Convert to proper numpy array for classification\n+                        try:\n+                            # Handle nullable integers/floats\n+                            if str(x.dtype) in ('Int64', 'Float64'):\n+                                # Check for binary vs multiclass based on unique values\n+                                unique_vals = np.unique(x_array[x_array != None])\n+                                if len(unique_vals) == 2:\n+                                    corrected_types.add('binary')\n+                                else:\n+                                    corrected_types.add('multiclass')\n+                            # Handle nullable boolean\n+                            elif str(x.dtype) == 'boolean':\n+                                corrected_types.add('binary')\n+                        except:\n+                            corrected_types.add('unknown')\n+                    else:\n+                        corrected_types.add('unknown')\n+                else:\n+                    corrected_types.add('unknown')\n+            else:\n+                corrected_types.add(target_type)\n+        ys_types = corrected_types\n+    \n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n \n@@ -302,16 +350,37 @@ def type_of_target(y, input_name=\"\"):\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n+\n+    # DeprecationWarning will be replaced by ValueError, see NEP 34\n+    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n+    # We therefore catch both deprecation (NumPy < 1.24) warning and\n+    # value error (NumPy >= 1.24).\n+    \n+    # Check for pandas nullable dtypes before conversion\n+    pandas_nullable_dtype = False\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        pandas_nullable_dtype = y.dtype.name in ('Int64', 'Float64', 'boolean', 'string')\n+    \n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n         if not issparse(y):\n             try:\n-                y = xp.asarray(y)\n+                # For pandas nullable dtypes, convert to non-nullable equivalent\n+                if pandas_nullable_dtype:\n+                    if y.dtype.name == 'boolean':\n+                        y = xp.asarray(y.astype('bool'))\n+                    elif y.dtype.name in ('Int64', 'Float64'):\n+                        y = xp.asarray(y.astype(y.dtype.name.lower()))\n+                    elif y.dtype.name == 'string':\n+                        y = xp.asarray(y.astype('object'))\n+                    else:\n+                        y = xp.asarray(y)\n+                else:\n+                    y = xp.asarray(y)\n             except (np.VisibleDeprecationWarning, ValueError):\n                 # dtype=object should be provided explicitly for ragged arrays,\n                 # see NEP 34\n                 y = xp.asarray(y, dtype=object)\n-\n     # The old sequence of sequences format\n     try:\n         if (\n@@ -340,9 +409,26 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+\n+    if not issparse(y) and y.dtype == object:\n+        # Check if this is a pandas nullable dtype converted to object\n+        if hasattr(y, '__array__') and len(y) > 0:\n+            # Try to get a sample value to check if it's numeric\n+            sample_val = None\n+            for val in y.flat:\n+                if val is not None and not pd.isna(val) if 'pd' in globals() else val is not None:\n+                    sample_val = val\n+                    break\n+            \n+            # If we found a numeric sample, treat as numeric array\n+            if sample_val is not None and isinstance(sample_val, (int, float, np.integer, np.floating)):\n+                pass  # Continue with normal numeric processing\n+            elif not isinstance(y.flat[0], str):\n+                # [obj_1] and not [\"label_1\"] - original object array logic\n+                return \"unknown\"\n+        elif not isinstance(y.flat[0], str):\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -358,8 +444,33 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n+    \n+    # For object dtype arrays that may come from pandas nullable dtypes,\n+    # check if they contain numeric data that should be treated as multiclass/binary\n+    if y.dtype == object and not issparse(y):\n+        # Try to determine if this is numeric data in object array\n+        try:\n+            # Flatten the array to check all values\n+            flat_y = y.ravel() if y.ndim > 1 else y\n+            # Check if all non-null values can be converted to numeric\n+            non_null_mask = flat_y != np.array(None)\n+            if non_null_mask.any():\n+                non_null_values = flat_y[non_null_mask]\n+                # Try to convert to float to check if numeric\n+                numeric_values = np.asarray(non_null_values, dtype=float)\n+                # If successful, use numeric logic for classification\n+                unique_vals = xp.unique_values(numeric_values)\n+                if unique_vals.shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n+                    return \"multiclass\" + suffix\n+                else:\n+                    return \"binary\" + suffix\n+        except (ValueError, TypeError):\n+            # If conversion fails, fall through to original logic\n+            pass\n+    \n     if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n         # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n         return \"multiclass\" + suffix\n",
    "variant_5": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..8d548927a 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,10 +20,24 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n     if hasattr(y, \"__array__\") or is_array_api:\n-        return xp.unique_values(xp.asarray(y))\n+        # Handle pandas nullable dtypes that get converted to object arrays\n+        y_array = xp.asarray(y)\n+        if hasattr(y, 'dtype') and str(y.dtype) in ('Int64', 'Float64', 'boolean'):\n+            # For pandas nullable dtypes, extract the non-null values for unique computation\n+            if hasattr(y, 'dropna'):\n+                return xp.unique_values(xp.asarray(y.dropna()))\n+            else:\n+                # Fallback: filter out None/NaN values manually\n+                mask = y_array != None\n+                if xp.any(mask):\n+                    return xp.unique_values(y_array[mask])\n+                else:\n+                    return xp.asarray([])\n+        return xp.unique_values(y_array)\n     else:\n         return set(y)\n \n@@ -78,7 +92,22 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n-    ys_types = set(type_of_target(x) for x in ys)\n+\n+    ys_types = set()\n+    for x in ys:\n+        # Check if x is a pandas array with nullable dtype before type_of_target conversion\n+        if hasattr(x, 'dtype') and hasattr(x.dtype, 'name') and x.dtype.name in ('Int64', 'Float64', 'boolean'):\n+            # Convert nullable pandas dtype to regular numpy array for type detection\n+            if x.dtype.name == 'boolean':\n+                converted_x = np.asarray(x, dtype=bool)\n+            elif x.dtype.name == 'Int64':\n+                converted_x = np.asarray(x, dtype=int)\n+            elif x.dtype.name == 'Float64':\n+                converted_x = np.asarray(x, dtype=float)\n+            ys_types.add(type_of_target(converted_x))\n+        else:\n+            ys_types.add(type_of_target(x))\n+    \n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n \n@@ -302,16 +331,28 @@ def type_of_target(y, input_name=\"\"):\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n+\n+    # Check for pandas nullable dtypes before conversion\n+    pandas_nullable_dtype = False\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        pandas_nullable_dtype = y.dtype.name in ['Int64', 'Float64', 'boolean']\n+    \n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n         if not issparse(y):\n             try:\n-                y = xp.asarray(y)\n+                # For pandas nullable dtypes, convert to non-nullable equivalent\n+                if pandas_nullable_dtype:\n+                    if y.dtype.name == 'boolean':\n+                        y = xp.asarray(y.astype('bool'))\n+                    elif y.dtype.name in ['Int64', 'Float64']:\n+                        y = xp.asarray(y.astype(y.dtype.name.lower()))\n+                else:\n+                    y = xp.asarray(y)\n             except (np.VisibleDeprecationWarning, ValueError):\n                 # dtype=object should be provided explicitly for ragged arrays,\n                 # see NEP 34\n                 y = xp.asarray(y, dtype=object)\n-\n     # The old sequence of sequences format\n     try:\n         if (\n@@ -340,9 +381,36 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+\n+    if not issparse(y) and y.dtype == object:\n+        # Check if this is a pandas nullable dtype converted to object\n+        if hasattr(y, '__array_function__') or (\n+            len(y) > 0 and hasattr(y.flat[0], '__class__') and \n+            y.flat[0].__class__.__module__ in ('pandas._libs.missing', 'numpy')\n+        ):\n+            # Handle pandas nullable dtypes that became object arrays\n+            # Try to extract the actual values, skipping pandas NA/None\n+            non_null_values = []\n+            for val in y.flat:\n+                if val is not None and not (hasattr(val, '__class__') and \n+                                          val.__class__.__name__ in ('NAType', 'NaTType')):\n+                    non_null_values.append(val)\n+            \n+            # If we have non-null values, determine type based on them\n+            if non_null_values:\n+                # Check if all values are numeric (int/float/bool)\n+                if all(isinstance(val, (int, float, bool, np.integer, np.floating, np.bool_)) \n+                       for val in non_null_values):\n+                    # Continue with normal classification logic instead of returning \"unknown\"\n+                    pass\n+                else:\n+                    return \"unknown\"\n+            else:\n+                # All values are null, treat as binary for empty case\n+                return \"binary\"\n+        elif not isinstance(y.flat[0], str):\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -358,8 +426,34 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n+    \n+    # For object arrays that might come from pandas nullable dtypes,\n+    # check if all values are numeric and can be safely converted\n+    if y.dtype == object and not issparse(y):\n+        try:\n+            # Try to convert to numeric to check if it's actually numeric data\n+            flat_y = y.ravel()\n+            if len(flat_y) > 0:\n+                # Check if all non-null values are numeric\n+                non_null_mask = flat_y != None\n+                if xp.any(non_null_mask):\n+                    non_null_values = flat_y[non_null_mask]\n+                    # Try converting first non-null value to see if it's numeric\n+                    test_val = non_null_values[0]\n+                    if isinstance(test_val, (int, float, np.integer, np.floating)):\n+                        # All values appear to be numeric, treat as numeric array\n+                        unique_vals = xp.unique_values(flat_y[non_null_mask])\n+                        if len(unique_vals) > 2:\n+                            return \"multiclass\" + suffix\n+                        else:\n+                            return \"binary\" + suffix\n+        except (TypeError, ValueError):\n+            # Not numeric, continue with original logic\n+            pass\n+    \n     if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n         # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n         return \"multiclass\" + suffix\n",
    "variant_6": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..85b7c9bba 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,10 +20,20 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n     if hasattr(y, \"__array__\") or is_array_api:\n-        return xp.unique_values(xp.asarray(y))\n+        # Handle pandas nullable dtypes that get converted to object arrays\n+        y_array = xp.asarray(y)\n+        if hasattr(y, 'dtype') and str(y.dtype) in ('Int64', 'Float64', 'boolean'):\n+            # For pandas nullable dtypes, use the underlying non-null values\n+            if hasattr(y, 'array') and hasattr(y.array, '_ndarray'):\n+                # Extract the underlying numpy array from pandas nullable dtype\n+                underlying_array = y.array._ndarray\n+                mask = ~y.array._mask if hasattr(y.array, '_mask') else slice(None)\n+                return xp.unique_values(underlying_array[mask])\n+        return xp.unique_values(y_array)\n     else:\n         return set(y)\n \n@@ -78,7 +88,35 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n+    # Handle pandas nullable dtypes that get misclassified as 'unknown'\n+    if 'unknown' in ys_types and len(ys_types) > 1:\n+        # Check if 'unknown' types are actually pandas nullable dtypes\n+        corrected_types = set()\n+        for x in ys:\n+            y_type = type_of_target(x)\n+            if y_type == 'unknown':\n+                # Try to determine the actual type for pandas nullable dtypes\n+                try:\n+                    import pandas as pd\n+                    if hasattr(x, 'dtype') and hasattr(x.dtype, 'name'):\n+                        # Check if it's a pandas nullable dtype\n+                        if x.dtype.name in ('Int64', 'Float64', 'boolean', 'string'):\n+                            # Convert to non-nullable equivalent to get proper type\n+                            temp_array = x.to_numpy(dtype=None, na_value=np.nan)\n+                            corrected_type = type_of_target(temp_array)\n+                            corrected_types.add(corrected_type)\n+                        else:\n+                            corrected_types.add(y_type)\n+                    else:\n+                        corrected_types.add(y_type)\n+                except ImportError:\n+                    corrected_types.add(y_type)\n+            else:\n+                corrected_types.add(y_type)\n+        ys_types = corrected_types\n+    \n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n \n@@ -302,16 +340,32 @@ def type_of_target(y, input_name=\"\"):\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n+\n+    # DeprecationWarning will be replaced by ValueError, see NEP 34\n+    # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n+    # We therefore catch both deprecation (NumPy < 1.24) warning and\n+    # value error (NumPy >= 1.24).\n+    \n+    # Check for pandas nullable dtypes before conversion\n+    pandas_nullable_dtype = False\n+    if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+        nullable_dtypes = {'Int8', 'Int16', 'Int32', 'Int64', \n+                          'Float32', 'Float64', 'boolean'}\n+        if y.dtype.name in nullable_dtypes:\n+            pandas_nullable_dtype = True\n+    \n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n         if not issparse(y):\n             try:\n+                # Convert pandas nullable dtypes to their non-nullable equivalents\n+                if pandas_nullable_dtype:\n+                    y = y.astype(str(y.dtype).lower())\n                 y = xp.asarray(y)\n             except (np.VisibleDeprecationWarning, ValueError):\n                 # dtype=object should be provided explicitly for ragged arrays,\n                 # see NEP 34\n                 y = xp.asarray(y, dtype=object)\n-\n     # The old sequence of sequences format\n     try:\n         if (\n@@ -340,9 +394,26 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+\n+    if not issparse(y) and y.dtype == object:\n+        # Check if this is a pandas nullable dtype converted to object\n+        if hasattr(y, '__array_function__') or str(type(y)).startswith('<class \\'pandas.'):\n+            # Handle pandas nullable dtypes that got converted to object\n+            try:\n+                # Try to convert to numeric to see if it's actually numeric data\n+                numeric_y = np.asarray(y, dtype=float)\n+                if not np.isnan(numeric_y).all():\n+                    # This is numeric data, treat it as such\n+                    pass\n+                else:\n+                    return \"unknown\"\n+            except (ValueError, TypeError):\n+                # Not numeric, check if string-like\n+                if not isinstance(y.flat[0], str):\n+                    return \"unknown\"\n+        elif not isinstance(y.flat[0], str):\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -358,9 +429,24 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n-    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n+    \n+    # For object arrays that might contain numeric data from pandas nullable dtypes,\n+    # try to get unique values more carefully\n+    if y.dtype == object and not issparse(y):\n+        try:\n+            # Convert to numeric if possible to get proper unique count\n+            numeric_y = xp.asarray(y, dtype=float)\n+            n_unique = xp.unique_values(numeric_y).shape[0]\n+        except (ValueError, TypeError):\n+            # Fall back to regular unique if conversion fails\n+            n_unique = xp.unique_values(y).shape[0]\n+    else:\n+        n_unique = xp.unique_values(y).shape[0]\n+    \n+    if n_unique > 2 or (y.ndim == 2 and len(first_row) > 1):\n         # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n         return \"multiclass\" + suffix\n     else:\n",
    "variant_7": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..ed7a517f3 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,10 +20,22 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n     if hasattr(y, \"__array__\") or is_array_api:\n-        return xp.unique_values(xp.asarray(y))\n+        # Handle pandas nullable dtypes that get converted to object arrays\n+        y_array = xp.asarray(y)\n+        if hasattr(y, 'dtype') and str(y.dtype) in ('Int64', 'Float64', 'boolean'):\n+            # For pandas nullable dtypes, extract the underlying values\n+            if hasattr(y, 'array') and hasattr(y.array, '_ndarray'):\n+                # Use the underlying numpy array from pandas nullable dtype\n+                y_array = y.array._ndarray[~y.array.isna()]\n+            elif hasattr(y, 'to_numpy'):\n+                # Fallback to to_numpy with na_value handling\n+                y_array = y.to_numpy(dtype=y.dtype.numpy_dtype, na_value=np.nan)\n+                y_array = y_array[~np.isnan(y_array)] if np.issubdtype(y_array.dtype, np.floating) else y_array\n+        return xp.unique_values(y_array)\n     else:\n         return set(y)\n \n@@ -78,7 +90,47 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n+    # Handle pandas nullable dtypes that get misclassified as 'unknown'\n+    # Convert 'unknown' back to proper type if the data is actually numeric\n+    if 'unknown' in ys_types:\n+        corrected_types = set()\n+        for x in ys:\n+            y_type = type_of_target(x)\n+            if y_type == 'unknown':\n+                # Check if this is a pandas nullable dtype converted to object\n+                x_array = check_array(x, ensure_2d=False, dtype=None, force_all_finite=False)\n+                if x_array.dtype == object and x_array.size > 0:\n+                    # Try to determine the actual type by examining the data\n+                    try:\n+                        # Remove None/nan values for type checking\n+                        non_null_mask = x_array != None\n+                        if hasattr(x_array, 'notna'):\n+                            non_null_mask = x_array.notna()\n+                        elif hasattr(np, 'isnan'):\n+                            try:\n+                                non_null_mask = ~np.isnan(x_array.astype(float))\n+                            except (ValueError, TypeError):\n+                                pass\n+                        \n+                        if np.any(non_null_mask):\n+                            non_null_values = x_array[non_null_mask]\n+                            unique_vals = np.unique(non_null_values)\n+                            if len(unique_vals) <= 2:\n+                                corrected_types.add('binary')\n+                            else:\n+                                corrected_types.add('multiclass')\n+                        else:\n+                            corrected_types.add('binary')  # Default for empty/all-null\n+                    except:\n+                        corrected_types.add('unknown')\n+                else:\n+                    corrected_types.add('unknown')\n+            else:\n+                corrected_types.add(y_type)\n+        ys_types = corrected_types\n+    \n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n \n@@ -302,16 +354,38 @@ def type_of_target(y, input_name=\"\"):\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n+\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n         if not issparse(y):\n-            try:\n+            # Check if y is a pandas nullable dtype before conversion\n+            pandas_nullable_dtype = False\n+            if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+                # Check for pandas nullable dtypes\n+                nullable_dtypes = {'Int8', 'Int16', 'Int32', 'Int64', \n+                                 'UInt8', 'UInt16', 'UInt32', 'UInt64',\n+                                 'Float32', 'Float64', 'boolean', 'string'}\n+                if y.dtype.name in nullable_dtypes:\n+                    pandas_nullable_dtype = True\n+                    # Convert to non-nullable equivalent to preserve numeric nature\n+                    if y.dtype.name in {'Int8', 'Int16', 'Int32', 'Int64', \n+                                       'UInt8', 'UInt16', 'UInt32', 'UInt64'}:\n+                        y = y.astype('int64')\n+                    elif y.dtype.name in {'Float32', 'Float64'}:\n+                        y = y.astype('float64')\n+                    elif y.dtype.name == 'boolean':\n+                        y = y.astype('bool')\n+                    # For string dtype, let it convert to object as intended\n+            \n+            if not pandas_nullable_dtype:\n+                try:\n+                    y = xp.asarray(y)\n+                except (np.VisibleDeprecationWarning, ValueError):\n+                    # dtype=object should be provided explicitly for ragged arrays,\n+                    # see NEP 34\n+                    y = xp.asarray(y, dtype=object)\n+            else:\n                 y = xp.asarray(y)\n-            except (np.VisibleDeprecationWarning, ValueError):\n-                # dtype=object should be provided explicitly for ragged arrays,\n-                # see NEP 34\n-                y = xp.asarray(y, dtype=object)\n-\n     # The old sequence of sequences format\n     try:\n         if (\n@@ -340,9 +414,38 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+\n+    if not issparse(y) and y.dtype == object:\n+        # Check if this is a pandas nullable dtype converted to object\n+        try:\n+            # Try to convert back to numeric to see if it's actually numeric data\n+            import pandas as pd\n+            if hasattr(y, '__array__') and len(y) > 0:\n+                # Check if all non-null values are numeric\n+                flat_y = y.flat\n+                first_val = next(iter(flat_y), None)\n+                if first_val is not None and not isinstance(first_val, str):\n+                    # Try to determine if this came from a pandas nullable dtype\n+                    try:\n+                        # Attempt to convert to float to check if numeric\n+                        numeric_vals = []\n+                        for val in y.flat:\n+                            if val is not None and not pd.isna(val):\n+                                numeric_vals.append(float(val))\n+                        if numeric_vals:  # If we have numeric values, continue processing\n+                            pass\n+                        else:\n+                            return \"unknown\"\n+                    except (ValueError, TypeError):\n+                        return \"unknown\"\n+                else:\n+                    return \"unknown\"\n+            else:\n+                return \"unknown\"\n+        except ImportError:\n+            # pandas not available, fall back to original logic\n+            if not isinstance(y.flat[0], str):\n+                return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -358,8 +461,44 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n+    \n+    # For object arrays that might contain numeric data from pandas nullable dtypes,\n+    # check if all values are numeric before determining multiclass vs binary\n+    if y.dtype == object and not issparse(y):\n+        # Check if this is a numeric object array (e.g., from pandas nullable types)\n+        try:\n+            # Try to convert to numeric - if successful, it's numeric data in object array\n+            flat_y = y.ravel()\n+            # Check if all non-null values are numeric\n+            numeric_mask = []\n+            for val in flat_y:\n+                if val is None or (hasattr(val, '__class__') and val.__class__.__name__ == 'NAType'):\n+                    continue  # Skip pandas NA values\n+                try:\n+                    float(val)\n+                    numeric_mask.append(True)\n+                except (ValueError, TypeError):\n+                    numeric_mask.append(False)\n+            \n+            if numeric_mask and all(numeric_mask):\n+                # This is numeric data in object array, proceed with normal logic\n+                pass\n+            else:\n+                # Non-numeric object array, use original logic\n+                if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n+                    return \"multiclass\" + suffix\n+                else:\n+                    return \"binary\"\n+        except:\n+            # If any error occurs, fall back to original logic\n+            if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n+                return \"multiclass\" + suffix\n+            else:\n+                return \"binary\"\n+    \n     if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n         # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n         return \"multiclass\" + suffix\n",
    "variant_8": "diff --git a/sklearn/utils/multiclass.py b/sklearn/utils/multiclass.py\nindex 5eaef2fde..45b71372e 100644\n--- a/sklearn/utils/multiclass.py\n+++ b/sklearn/utils/multiclass.py\n@@ -20,10 +20,21 @@ from .validation import check_array, _assert_all_finite\n from ..utils._array_api import get_namespace\n \n \n+\n def _unique_multiclass(y):\n     xp, is_array_api = get_namespace(y)\n     if hasattr(y, \"__array__\") or is_array_api:\n-        return xp.unique_values(xp.asarray(y))\n+        # Handle pandas nullable dtypes that get converted to object arrays\n+        y_array = xp.asarray(y)\n+        if hasattr(y, 'dtype') and str(y.dtype).lower() in ['int64', 'float64', 'boolean']:\n+            # Original pandas nullable dtype, convert to non-nullable equivalent\n+            if str(y.dtype).lower() == 'boolean':\n+                y_array = y_array.astype(bool)\n+            elif str(y.dtype).lower() == 'int64':\n+                y_array = y_array.astype(np.int64)\n+            elif str(y.dtype).lower() == 'float64':\n+                y_array = y_array.astype(np.float64)\n+        return xp.unique_values(y_array)\n     else:\n         return set(y)\n \n@@ -78,7 +89,39 @@ def unique_labels(*ys):\n         raise ValueError(\"No argument has been passed.\")\n     # Check that we don't mix label format\n \n+\n     ys_types = set(type_of_target(x) for x in ys)\n+    # Handle pandas nullable dtypes that get misclassified as 'unknown'\n+    if \"unknown\" in ys_types and len(ys_types) > 1:\n+        # Check if 'unknown' types are actually pandas nullable dtypes\n+        refined_types = set()\n+        for x in ys:\n+            target_type = type_of_target(x)\n+            if target_type == \"unknown\":\n+                # Try to determine the actual type for pandas nullable dtypes\n+                try:\n+                    # Convert to array and check if it's numeric\n+                    xp_local, _ = get_namespace(x)\n+                    x_array = xp_local.asarray(x)\n+                    if x_array.dtype == object:\n+                        # Check if all non-null values are numeric\n+                        non_null_vals = [v for v in x_array.flat if v is not None and not (hasattr(v, '__class__') and v.__class__.__name__ == 'NAType')]\n+                        if non_null_vals and all(isinstance(v, (int, float, np.integer, np.floating)) for v in non_null_vals):\n+                            unique_vals = set(non_null_vals)\n+                            if len(unique_vals) <= 2:\n+                                refined_types.add(\"binary\")\n+                            else:\n+                                refined_types.add(\"multiclass\")\n+                        else:\n+                            refined_types.add(\"unknown\")\n+                    else:\n+                        refined_types.add(\"unknown\")\n+                except:\n+                    refined_types.add(\"unknown\")\n+            else:\n+                refined_types.add(target_type)\n+        ys_types = refined_types\n+    \n     if ys_types == {\"binary\", \"multiclass\"}:\n         ys_types = {\"multiclass\"}\n \n@@ -302,16 +345,25 @@ def type_of_target(y, input_name=\"\"):\n     # https://numpy.org/neps/nep-0034-infer-dtype-is-object.html\n     # We therefore catch both deprecation (NumPy < 1.24) warning and\n     # value error (NumPy >= 1.24).\n+\n     with warnings.catch_warnings():\n         warnings.simplefilter(\"error\", np.VisibleDeprecationWarning)\n         if not issparse(y):\n+            # Check if y has pandas nullable dtype before conversion\n+            pandas_nullable_dtype = False\n+            if hasattr(y, 'dtype') and hasattr(y.dtype, 'name'):\n+                pandas_nullable_dtype = y.dtype.name in ('Int64', 'Float64', 'boolean')\n+            \n             try:\n-                y = xp.asarray(y)\n+                if pandas_nullable_dtype:\n+                    # Convert pandas nullable dtype to regular numpy dtype to avoid object conversion\n+                    y = xp.asarray(y.to_numpy(dtype=y.dtype.numpy_dtype, na_value=np.nan))\n+                else:\n+                    y = xp.asarray(y)\n             except (np.VisibleDeprecationWarning, ValueError):\n                 # dtype=object should be provided explicitly for ragged arrays,\n                 # see NEP 34\n                 y = xp.asarray(y, dtype=object)\n-\n     # The old sequence of sequences format\n     try:\n         if (\n@@ -340,9 +392,38 @@ def type_of_target(y, input_name=\"\"):\n             return \"binary\"  # []\n         # 2-D empty array: [[]]\n         return \"unknown\"\n-    if not issparse(y) and y.dtype == object and not isinstance(y.flat[0], str):\n-        # [obj_1] and not [\"label_1\"]\n-        return \"unknown\"\n+\n+    if not issparse(y) and y.dtype == object:\n+        # Check if this is a pandas nullable dtype converted to object\n+        if hasattr(y, '__array__') and len(y) > 0:\n+            # Try to get a sample value to check if it's numeric\n+            sample_val = None\n+            for val in y.flat:\n+                if val is not None and not pd.isna(val):\n+                    sample_val = val\n+                    break\n+            \n+            # If we found a numeric sample, treat as numeric array\n+            if sample_val is not None and not isinstance(sample_val, str):\n+                # Convert to appropriate numeric type for further processing\n+                try:\n+                    # Try to convert to float to handle both int and float nullable types\n+                    y_converted = np.asarray(y, dtype=float)\n+                    # Check if all values are integers (for Int64 nullable type)\n+                    if np.all(np.isnan(y_converted) | (y_converted == np.asarray(y_converted, dtype=int))):\n+                        y = np.asarray(y, dtype=float)  # Keep as float to handle NaN\n+                    else:\n+                        y = y_converted\n+                except (ValueError, TypeError):\n+                    # If conversion fails, fall back to original object handling\n+                    if not isinstance(y.flat[0], str):\n+                        return \"unknown\"\n+            elif not isinstance(y.flat[0], str):\n+                # [obj_1] and not [\"label_1\"]\n+                return \"unknown\"\n+        elif not isinstance(y.flat[0], str):\n+            # [obj_1] and not [\"label_1\"]\n+            return \"unknown\"\n \n     # Check if multioutput\n     if y.ndim == 2 and y.shape[1] > 1:\n@@ -358,9 +439,28 @@ def type_of_target(y, input_name=\"\"):\n             _assert_all_finite(data, input_name=input_name)\n             return \"continuous\" + suffix\n \n+\n     # Check multiclass\n     first_row = y[0] if not issparse(y) else y.getrow(0).data\n-    if xp.unique_values(y).shape[0] > 2 or (y.ndim == 2 and len(first_row) > 1):\n+    \n+    # Handle object dtype arrays that may contain numeric data from nullable dtypes\n+    if y.dtype == object and not issparse(y):\n+        # Check if all elements are numeric (int or float)\n+        try:\n+            # Convert to numeric array to check unique values properly\n+            numeric_y = xp.asarray([float(val) if val is not None else xp.nan for val in y.ravel()])\n+            if not xp.any(xp.isnan(numeric_y)):\n+                # All values are numeric, use numeric array for unique check\n+                unique_count = xp.unique_values(numeric_y).shape[0]\n+            else:\n+                unique_count = xp.unique_values(y).shape[0]\n+        except (ValueError, TypeError):\n+            # Not all numeric, use original array\n+            unique_count = xp.unique_values(y).shape[0]\n+    else:\n+        unique_count = xp.unique_values(y).shape[0]\n+    \n+    if unique_count > 2 or (y.ndim == 2 and len(first_row) > 1):\n         # [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]\n         return \"multiclass\" + suffix\n     else:\n"
  }
}