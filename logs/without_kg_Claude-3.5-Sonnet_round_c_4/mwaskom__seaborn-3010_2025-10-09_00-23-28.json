{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/seaborn/seaborn/_stats/regression.py lines 22-34)": "\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        \n        # Filter out rows with missing values in either x or y\n        valid_mask = x.notna() & y.notna()\n        x_valid = x[valid_mask]\n        y_valid = y[valid_mask]\n        \n        if x_valid.nunique() <= self.order or len(x_valid) <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x_valid, y_valid, self.order)\n            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/seaborn/seaborn/_stats/regression.py lines 22-34)": [
      "\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        \n        # Filter out rows with missing values in either x or y\n        valid_mask = x.notna() & y.notna()\n        x_valid = x[valid_mask]\n        y_valid = y[valid_mask]\n        \n        if x_valid.nunique() <= self.order or len(x_valid) <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x_valid, y_valid, self.order)\n            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        \n        # Filter out rows with missing values in either x or y\n        valid_mask = x.notna() & y.notna()\n        x_valid = x[valid_mask]\n        y_valid = y[valid_mask]\n        \n        if x_valid.nunique() <= self.order or len(x_valid) <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x_valid, y_valid, self.order)\n            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\ndef _fit_predict(self, data):\n\n    x = data[\"x\"]\n    y = data[\"y\"]\n    \n    # Filter out rows with missing values in either x or y\n    valid_mask = x.notna() & y.notna()\n    x_valid = x[valid_mask]\n    y_valid = y[valid_mask]\n    \n    if x_valid.nunique() <= self.order or len(x_valid) <= self.order:\n        # TODO warn?\n        xx = yy = []\n    else:\n        p = np.polyfit(x_valid, y_valid, self.order)\n        xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n        yy = np.polyval(p, xx)\n\n    return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        \n        # Filter out rows with missing values in either x or y\n        valid_mask = x.notna() & y.notna()\n        x_valid = x[valid_mask]\n        y_valid = y[valid_mask]\n        \n        if x_valid.nunique() <= self.order or len(x_valid) <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x_valid, y_valid, self.order)\n            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        \n        # Filter out rows with missing values in x or y\n        valid_mask = x.notna() & y.notna()\n        x_valid = x[valid_mask]\n        y_valid = y[valid_mask]\n        \n        if x_valid.nunique() <= self.order or len(x_valid) == 0:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x_valid, y_valid, self.order)\n            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        \n        # Filter out rows with missing values in either x or y\n        valid_mask = pd.notna(x) & pd.notna(y)\n        x_valid = x[valid_mask]\n        y_valid = y[valid_mask]\n        \n        if x_valid.nunique() <= self.order or len(x_valid) <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x_valid, y_valid, self.order)\n            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        \n        # Filter out rows with missing values in either x or y\n        valid_mask = x.notna() & y.notna()\n        x_valid = x[valid_mask]\n        y_valid = y[valid_mask]\n        \n        if x_valid.nunique() <= self.order or len(x_valid) == 0:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x_valid, y_valid, self.order)\n            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n",
      "\n    def _fit_predict(self, data):\n\n        x = data[\"x\"]\n        y = data[\"y\"]\n        \n        # Filter out rows with missing values in either x or y\n        valid_mask = pd.notna(x) & pd.notna(y)\n        x_valid = x[valid_mask]\n        y_valid = y[valid_mask]\n        \n        if x_valid.nunique() <= self.order or len(x_valid) <= self.order:\n            # TODO warn?\n            xx = yy = []\n        else:\n            p = np.polyfit(x_valid, y_valid, self.order)\n            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n            yy = np.polyval(p, xx)\n\n        return pd.DataFrame(dict(x=xx, y=yy))\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..a78e0857 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,16 +19,23 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out rows with missing values in either x or y\n+        valid_mask = pd.notna(x) & pd.notna(y)\n+        x_valid = x[valid_mask]\n+        y_valid = y[valid_mask]\n+        \n+        if x_valid.nunique() <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_valid, y_valid, self.order)\n+            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n",
    "variant_0": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..2a98a51f 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,16 +19,23 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out rows with missing values in either x or y\n+        valid_mask = x.notna() & y.notna()\n+        x_valid = x[valid_mask]\n+        y_valid = y[valid_mask]\n+        \n+        if x_valid.nunique() <= self.order or len(x_valid) <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_valid, y_valid, self.order)\n+            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n",
    "variant_1": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..2a98a51f 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,16 +19,23 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out rows with missing values in either x or y\n+        valid_mask = x.notna() & y.notna()\n+        x_valid = x[valid_mask]\n+        y_valid = y[valid_mask]\n+        \n+        if x_valid.nunique() <= self.order or len(x_valid) <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_valid, y_valid, self.order)\n+            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n",
    "variant_2": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..2a98a51f 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,16 +19,23 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out rows with missing values in either x or y\n+        valid_mask = x.notna() & y.notna()\n+        x_valid = x[valid_mask]\n+        y_valid = y[valid_mask]\n+        \n+        if x_valid.nunique() <= self.order or len(x_valid) <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_valid, y_valid, self.order)\n+            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n",
    "variant_3": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..26e8c4d8 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,19 +19,26 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n-    def _fit_predict(self, data):\n-\n-        x = data[\"x\"]\n-        y = data[\"y\"]\n-        if x.nunique() <= self.order:\n-            # TODO warn?\n-            xx = yy = []\n-        else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n-            yy = np.polyval(p, xx)\n-\n-        return pd.DataFrame(dict(x=xx, y=yy))\n+\n+def _fit_predict(self, data):\n+\n+    x = data[\"x\"]\n+    y = data[\"y\"]\n+    \n+    # Filter out rows with missing values in either x or y\n+    valid_mask = x.notna() & y.notna()\n+    x_valid = x[valid_mask]\n+    y_valid = y[valid_mask]\n+    \n+    if x_valid.nunique() <= self.order or len(x_valid) <= self.order:\n+        # TODO warn?\n+        xx = yy = []\n+    else:\n+        p = np.polyfit(x_valid, y_valid, self.order)\n+        xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n+        yy = np.polyval(p, xx)\n+\n+    return pd.DataFrame(dict(x=xx, y=yy))\n \n     # TODO we should have a way of identifying the method that will be applied\n     # and then only define __call__ on a base-class of stats with this pattern\n",
    "variant_4": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..2a98a51f 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,16 +19,23 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out rows with missing values in either x or y\n+        valid_mask = x.notna() & y.notna()\n+        x_valid = x[valid_mask]\n+        y_valid = y[valid_mask]\n+        \n+        if x_valid.nunique() <= self.order or len(x_valid) <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_valid, y_valid, self.order)\n+            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n",
    "variant_5": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..eacd7553 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,16 +19,23 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out rows with missing values in x or y\n+        valid_mask = x.notna() & y.notna()\n+        x_valid = x[valid_mask]\n+        y_valid = y[valid_mask]\n+        \n+        if x_valid.nunique() <= self.order or len(x_valid) == 0:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_valid, y_valid, self.order)\n+            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n",
    "variant_6": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..958387e1 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,16 +19,23 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out rows with missing values in either x or y\n+        valid_mask = pd.notna(x) & pd.notna(y)\n+        x_valid = x[valid_mask]\n+        y_valid = y[valid_mask]\n+        \n+        if x_valid.nunique() <= self.order or len(x_valid) <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_valid, y_valid, self.order)\n+            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n",
    "variant_7": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..af9794c7 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,16 +19,23 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out rows with missing values in either x or y\n+        valid_mask = x.notna() & y.notna()\n+        x_valid = x[valid_mask]\n+        y_valid = y[valid_mask]\n+        \n+        if x_valid.nunique() <= self.order or len(x_valid) == 0:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_valid, y_valid, self.order)\n+            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n",
    "variant_8": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..958387e1 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -19,16 +19,23 @@ class PolyFit(Stat):\n     order: int = 2\n     gridsize: int = 100\n \n+\n     def _fit_predict(self, data):\n \n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n+        \n+        # Filter out rows with missing values in either x or y\n+        valid_mask = pd.notna(x) & pd.notna(y)\n+        x_valid = x[valid_mask]\n+        y_valid = y[valid_mask]\n+        \n+        if x_valid.nunique() <= self.order or len(x_valid) <= self.order:\n             # TODO warn?\n             xx = yy = []\n         else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n+            p = np.polyfit(x_valid, y_valid, self.order)\n+            xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n             yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n"
  }
}