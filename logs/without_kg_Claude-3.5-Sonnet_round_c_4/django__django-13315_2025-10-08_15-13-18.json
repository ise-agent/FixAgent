{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/forms/models.py lines 1154-1162)": "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            from django.db.models.query_utils import Q\n            from django.db.models.sql.query import Query\n            \n            # Apply limit_choices_to filter using complex_filter like other parts of Django\n            if hasattr(queryset, 'complex_filter'):\n                queryset = queryset.complex_filter(self.field.limit_choices_to)\n            else:\n                # Fallback for custom querysets\n                if isinstance(self.field.limit_choices_to, Q):\n                    queryset = queryset.filter(self.field.limit_choices_to)\n                else:\n                    queryset = queryset.filter(**self.field.limit_choices_to)\n            \n            # Add distinct() to eliminate duplicates from joins\n            queryset = queryset.distinct()\n        \n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        for obj in queryset:\n            yield self.choice(obj)\n",
    "Location 2 (/root/hy/projects_4/django/django/forms/models.py lines 1164-1168)": "\n    def __len__(self):\n        # count() adds a query but uses less memory since the QuerySet results\n        # won't be cached. In most cases, the choices will only be iterated on,\n        # and __len__() won't be called.\n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            queryset = queryset.complex_filter(self.field.limit_choices_to).distinct()\n        return queryset.count() + (1 if self.field.empty_label is not None else 0)\n",
    "Location 3 (/root/hy/projects_4/django/django/forms/models.py lines 1170-1171)": "\n    def __bool__(self):\n        from django.db.models.query_utils import Q\n        from django.db.models.sql.query import Query\n        \n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            queryset = queryset.complex_filter(self.field.limit_choices_to)\n            # Add distinct() to handle potential duplicates from joins\n            if isinstance(self.field.limit_choices_to, Q):\n                # Check if Q object might involve joins by examining its children\n                query = Query(queryset.model)\n                query.add_q(self.field.limit_choices_to)\n                if query.alias_refcount:\n                    queryset = queryset.distinct()\n        return self.field.empty_label is not None or queryset.exists()\n",
    "Location 4 (/root/hy/projects_4/django/django/forms/models.py lines 1232-1233)": "\n    def _set_queryset(self, queryset):\n        self._queryset = None if queryset is None else queryset.all()\n        self.widget.choices = self.choices\n",
    "Location 5 (/root/hy/projects_4/django/django/forms/models.py lines 1207-1208)": "\n        self.queryset = queryset\n        self.limit_choices_to = limit_choices_to\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/forms/models.py lines 1154-1162)": [
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            from django.db.models.query_utils import Q\n            from django.db.models.sql.query import Query\n            \n            def complex_filter(queryset, filter_obj):\n                if isinstance(filter_obj, Q):\n                    return queryset.filter(filter_obj)\n                elif isinstance(filter_obj, dict):\n                    return queryset.filter(**filter_obj)\n                else:\n                    return queryset.filter(filter_obj)\n            \n            queryset = complex_filter(queryset, self.field.limit_choices_to).distinct()\n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            from django.db.models.query_utils import Q\n            from django.db.models.sql.query import Query\n            \n            def complex_filter(queryset, filter_obj):\n                if isinstance(filter_obj, Q):\n                    return queryset.filter(filter_obj)\n                elif isinstance(filter_obj, dict):\n                    return queryset.filter(**filter_obj)\n                else:\n                    return queryset.filter(filter_obj)\n            \n            queryset = complex_filter(queryset, self.field.limit_choices_to).distinct()\n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            from django.db.models.sql.query import Query\n            queryset = queryset.complex_filter(self.field.limit_choices_to)\n        queryset = queryset.distinct()\n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            from django.db.models.query_utils import Q\n            from django.db.models.utils import resolve_callables\n            from django.db.models.sql.query import Query\n            \n            # Apply limit_choices_to filter using Django's complex_filter\n            limit_choices_to = resolve_callables(self.field.limit_choices_to)\n            queryset = queryset.complex_filter(limit_choices_to)\n        \n        # Add distinct() to eliminate duplicates from joins\n        queryset = queryset.distinct()\n        \n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            from django.db.models.sql.query import Query\n            queryset = queryset.complex_filter(self.field.limit_choices_to)\n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        # Add distinct() to prevent duplicates from joins in limit_choices_to Q objects\n        if self.field.limit_choices_to:\n            if hasattr(queryset, 'distinct'):\n                queryset = queryset.distinct()\n            else:\n                # For iterator() case, we need to get distinct values manually\n                seen_pks = set()\n                filtered_queryset = []\n                for obj in queryset:\n                    if obj.pk not in seen_pks:\n                        seen_pks.add(obj.pk)\n                        filtered_queryset.append(obj)\n                queryset = filtered_queryset\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        \n        # Apply limit_choices_to filter if present\n        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n            from django.db.models.sql.query import Query\n            queryset = queryset.complex_filter(self.field.limit_choices_to)\n        \n        # Add distinct() to eliminate duplicates from joins\n        queryset = queryset.distinct()\n        \n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            from django.db.models.query_utils import Q\n            from django.db.models.sql.query import Query\n            \n            def complex_filter(queryset, filter_obj):\n                if isinstance(filter_obj, Q):\n                    return queryset.filter(filter_obj)\n                else:\n                    return queryset.filter(**filter_obj)\n            \n            queryset = complex_filter(queryset, self.field.limit_choices_to).distinct()\n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        for obj in queryset:\n            yield self.choice(obj)\n",
      "\n    def __iter__(self):\n        if self.field.empty_label is not None:\n            yield (\"\", self.field.empty_label)\n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            from django.db.models.query_utils import Q\n            from django.db.models.sql.query import Query\n            \n            def complex_filter(queryset, filter_obj):\n                \"\"\"Apply a complex filter (Q object or dict) to a queryset.\"\"\"\n                if isinstance(filter_obj, Q):\n                    return queryset.filter(filter_obj)\n                else:\n                    return queryset.filter(**filter_obj)\n            \n            queryset = complex_filter(queryset, self.field.limit_choices_to).distinct()\n        # Can't use iterator() when queryset uses prefetch_related()\n        if not queryset._prefetch_related_lookups:\n            queryset = queryset.iterator()\n        for obj in queryset:\n            yield self.choice(obj)\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/forms/models.py lines 1164-1168)": [
      "\n    def __len__(self):\n        # Apply limit_choices_to filter and use distinct() to handle joins\n        filtered_queryset = self.queryset\n        if self.field.limit_choices_to:\n            from django.db.models.query_utils import Q\n            from django.db.models.sql.query import Query\n            \n            # Use complex_filter to handle both dict and Q object formats\n            filtered_queryset = filtered_queryset.complex_filter(self.field.limit_choices_to).distinct()\n        \n        # count() adds a query but uses less memory since the QuerySet results\n        # won't be cached. In most cases, the choices will only be iterated on,\n        # and __len__() won't be called.\n        return filtered_queryset.count() + (1 if self.field.empty_label is not None else 0)\n",
      "\n    def __len__(self):\n        # count() adds a query but uses less memory since the QuerySet results\n        # won't be cached. In most cases, the choices will only be iterated on,\n        # and __len__() won't be called.\n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            from django.db.models.query_utils import Q\n            from django.db.models.sql.query import Query\n            \n            def complex_filter(queryset, filter_expr):\n                if isinstance(filter_expr, Q):\n                    return queryset.filter(filter_expr)\n                elif isinstance(filter_expr, dict):\n                    return queryset.filter(**filter_expr)\n                else:\n                    return queryset.filter(filter_expr)\n            \n            queryset = complex_filter(queryset, self.field.limit_choices_to).distinct()\n        return queryset.count() + (1 if self.field.empty_label is not None else 0)\n",
      "\n    def __len__(self):\n        # count() adds a query but uses less memory since the QuerySet results\n        # won't be cached. In most cases, the choices will only be iterated on,\n        # and __len__() won't be called.\n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            from django.db.models.query_utils import Q\n            from django.db.models.sql.query import Query\n            \n            def complex_filter(queryset, filter_arg):\n                if isinstance(filter_arg, Q) or hasattr(filter_arg, 'add_to_query'):\n                    return queryset.filter(filter_arg)\n                else:\n                    return queryset.filter(**filter_arg)\n            \n            queryset = complex_filter(queryset, self.field.limit_choices_to).distinct()\n        return queryset.count() + (1 if self.field.empty_label is not None else 0)\n",
      "\n    def __len__(self):\n        # count() adds a query but uses less memory since the QuerySet results\n        # won't be cached. In most cases, the choices will only be iterated on,\n        # and __len__() won't be called.\n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            queryset = queryset.complex_filter(self.field.limit_choices_to).distinct()\n        return queryset.count() + (1 if self.field.empty_label is not None else 0)\n",
      "\n    def __len__(self):\n        # count() adds a query but uses less memory since the QuerySet results\n        # won't be cached. In most cases, the choices will only be iterated on,\n        # and __len__() won't be called.\n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            from django.db.models.query_utils import Q\n            from django.db.models.sql.query import Query\n            \n            def complex_filter(queryset, filter_obj):\n                if isinstance(filter_obj, Q):\n                    return queryset.filter(filter_obj)\n                elif isinstance(filter_obj, dict):\n                    return queryset.filter(**filter_obj)\n                else:\n                    return queryset.filter(filter_obj)\n            \n            queryset = complex_filter(queryset, self.field.limit_choices_to).distinct()\n        return queryset.count() + (1 if self.field.empty_label is not None else 0)\n",
      "\n    def __len__(self):\n        # count() adds a query but uses less memory since the QuerySet results\n        # won't be cached. In most cases, the choices will only be iterated on,\n        # and __len__() won't be called.\n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            queryset = queryset.complex_filter(self.field.limit_choices_to).distinct()\n        return queryset.count() + (1 if self.field.empty_label is not None else 0)\n",
      "\n    def __len__(self):\n        # count() adds a query but uses less memory since the QuerySet results\n        # won't be cached. In most cases, the choices will only be iterated on,\n        # and __len__() won't be called.\n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            from django.db.models.query_utils import Q\n            from django.db.models.sql.query import Query\n            limit_choices_to = self.field.limit_choices_to\n            if callable(limit_choices_to):\n                limit_choices_to = limit_choices_to()\n            queryset = queryset.complex_filter(limit_choices_to).distinct()\n        return queryset.count() + (1 if self.field.empty_label is not None else 0)\n",
      "\n    def __len__(self):\n        # count() adds a query but uses less memory since the QuerySet results\n        # won't be cached. In most cases, the choices will only be iterated on,\n        # and __len__() won't be called.\n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            queryset = queryset.complex_filter(self.field.limit_choices_to)\n        return queryset.count() + (1 if self.field.empty_label is not None else 0)\n"
    ],
    "Location 3 (/root/hy/projects_4/django/django/forms/models.py lines 1170-1171)": [
      "\n    def __bool__(self):\n        from django.db.models.query_utils import Q\n        from django.db.models.sql.query import Query\n        \n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            queryset = queryset.complex_filter(self.field.limit_choices_to)\n            \n        # Check if limit_choices_to involves joins by examining the filter\n        needs_distinct = False\n        if self.field.limit_choices_to:\n            if isinstance(self.field.limit_choices_to, Q):\n                # For Q objects, check if any condition involves field lookups with '__'\n                def has_joins(q_obj):\n                    if hasattr(q_obj, 'children'):\n                        for child in q_obj.children:\n                            if isinstance(child, tuple) and len(child) == 2:\n                                field_name, _ = child\n                                if '__' in str(field_name):\n                                    return True\n                            elif hasattr(child, 'children') and has_joins(child):\n                                return True\n                    return False\n                needs_distinct = has_joins(self.field.limit_choices_to)\n            elif isinstance(self.field.limit_choices_to, dict):\n                # For dict filters, check if any key involves field lookups with '__'\n                needs_distinct = any('__' in str(key) for key in self.field.limit_choices_to.keys())\n                \n        if needs_distinct:\n            queryset = queryset.distinct()\n            \n        return self.field.empty_label is not None or queryset.exists()\n",
      "\n    def __bool__(self):\n        from django.db.models.sql.query import Query\n        \n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            queryset = queryset.complex_filter(self.field.limit_choices_to)\n        \n        # Add distinct() to handle potential duplicates from joins\n        if hasattr(queryset.query, 'select_related') and (queryset.query.select_related or queryset.query.prefetch_related_lookups):\n            queryset = queryset.distinct()\n        \n        return self.field.empty_label is not None or queryset.exists()\n",
      "\n    def __bool__(self):\n        # Apply limit_choices_to filter if present\n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            queryset = queryset.complex_filter(self.field.limit_choices_to).distinct()\n        return self.field.empty_label is not None or queryset.exists()\n",
      "\n    def __bool__(self):\n        from django.db.models.query_utils import Q\n        from django.db.models.sql.query import Query\n        \n        queryset = self.queryset\n        if self.field.limit_choices_to:\n            # Apply limit_choices_to filter using complex_filter\n            queryset = queryset.complex_filter(self.field.limit_choices_to)\n            # Add distinct() to eliminate duplicates from joins in Q objects\n            queryset = queryset.distinct()\n        \n        return self.field.empty_label is not None or queryset.exists()\n",
      "\n    def __bool__(self):\n        queryset = self.queryset\n        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n            from django.db.models.query_utils import Q\n            from django.db.models.sql.query import Query\n            \n            def complex_filter(queryset, filter_arg):\n                if isinstance(filter_arg, Q):\n                    return queryset.filter(filter_arg)\n                elif isinstance(filter_arg, dict):\n                    return queryset.filter(**filter_arg)\n                else:\n                    return queryset.filter(filter_arg)\n            \n            queryset = complex_filter(queryset, self.field.limit_choices_to).distinct()\n        \n        return self.field.empty_label is not None or queryset.exists()\n",
      "\n    def __bool__(self):\n        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n            from django.db.models.query_utils import Q\n            from django.db.models.sql.query import Query\n            \n            def complex_filter(queryset, filter_arg):\n                if isinstance(filter_arg, Q):\n                    return queryset.filter(filter_arg)\n                elif isinstance(filter_arg, dict):\n                    return queryset.filter(**filter_arg)\n                else:\n                    return queryset.filter(filter_arg)\n            \n            filtered_queryset = complex_filter(self.queryset, self.field.limit_choices_to).distinct()\n            return self.field.empty_label is not None or filtered_queryset.exists()\n        return self.field.empty_label is not None or self.queryset.exists()\n",
      "\n    def __bool__(self):\n        # Apply limit_choices_to filter and use distinct() to handle join-induced duplicates\n        filtered_queryset = self.queryset\n        if self.field.limit_choices_to:\n            from django.db.models.sql.query import Query\n            filtered_queryset = filtered_queryset.complex_filter(self.field.limit_choices_to).distinct()\n        return self.field.empty_label is not None or filtered_queryset.exists()\n",
      "\n    def __bool__(self):\n        from django.db.models.sql.query import Query\n        \n        queryset = self.queryset\n        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n            # Apply limit_choices_to filter\n            if hasattr(Query, 'complex_filter'):\n                # Django 3.0+\n                queryset = queryset.complex_filter(self.field.limit_choices_to)\n            else:\n                # Django < 3.0\n                from django.db.models.sql.query import Query as BaseQuery\n                temp_query = BaseQuery(queryset.model)\n                temp_query.add_q(self.field.limit_choices_to)\n                queryset = queryset.filter(temp_query.where)\n            # Add distinct() to handle potential duplicates from joins\n            queryset = queryset.distinct()\n        \n        return self.field.empty_label is not None or queryset.exists()\n"
    ],
    "Location 4 (/root/hy/projects_4/django/django/forms/models.py lines 1232-1233)": [
      "\n    def _set_queryset(self, queryset):\n        self._queryset = None if queryset is None else queryset.all()\n        self.widget.choices = self.choices\n",
      "\n    def _set_queryset(self, queryset):\n        self._queryset = None if queryset is None else queryset.all()\n        self.widget.choices = self.choices\n",
      "\n    def _set_queryset(self, queryset):\n        self._queryset = None if queryset is None else queryset.all()\n        self.widget.choices = self.choices\n",
      "\n    def _set_queryset(self, queryset):\n        self._queryset = None if queryset is None else queryset.all()\n        self.widget.choices = self.choices\n",
      "\n    def _set_queryset(self, queryset):\n        self._queryset = None if queryset is None else queryset.all()\n        self.widget.choices = self.choices\n",
      "\n    def _set_queryset(self, queryset):\n        from django.db.models.query_utils import Q\n        from django.db.models.sql.query import Query\n        \n        if queryset is None:\n            self._queryset = None\n        else:\n            # Apply limit_choices_to filter if present\n            filtered_queryset = queryset.all()\n            if hasattr(self, 'limit_choices_to') and self.limit_choices_to:\n                if hasattr(self.limit_choices_to, 'resolve_expression'):\n                    # It's a Q object or similar - use complex_filter\n                    filtered_queryset = filtered_queryset.complex_filter(self.limit_choices_to)\n                else:\n                    # It's a dict - use filter\n                    filtered_queryset = filtered_queryset.filter(self.limit_choices_to)\n                \n                # Add distinct() to eliminate duplicates from joins\n                filtered_queryset = filtered_queryset.distinct()\n            \n            self._queryset = filtered_queryset\n        self.widget.choices = self.choices\n",
      "\n    def _set_queryset(self, queryset):\n        self._queryset = None if queryset is None else queryset.all()\n        self.widget.choices = self.choices\n",
      "\n    def _set_queryset(self, queryset):\n        self._queryset = None if queryset is None else queryset.all()\n        self.widget.choices = self.choices\n"
    ],
    "Location 5 (/root/hy/projects_4/django/django/forms/models.py lines 1207-1208)": [
      "\n        self.queryset = queryset\n        self.limit_choices_to = limit_choices_to\n",
      "\n        self.queryset = queryset\n        self.limit_choices_to = limit_choices_to\n",
      "\n    def __init__(self, queryset, empty_label=\"---------\", required=True,\n                 widget=None, label=None, initial=None, help_text='',\n                 to_field_name=None, limit_choices_to=None, blank=False,\n                 **kwargs):\n        # Call Field, not ChoiceField __init__, because we don't need\n        # ChoiceField.__init__.\n        Field.__init__(\n            self, required=required, widget=widget, label=label,\n            initial=initial, help_text=help_text, **kwargs\n        )\n        if (\n            (required and initial is not None) or\n            (isinstance(self.widget, RadioSelect) and not blank)\n        ):\n            self.empty_label = None\n        else:\n            self.empty_label = empty_label\n        self.queryset = queryset\n        self.limit_choices_to = limit_choices_to\n        self.to_field_name = to_field_name\n",
      "\n        self.queryset = queryset\n        self.limit_choices_to = limit_choices_to\n",
      "\n    def __init__(self, queryset, empty_label=\"---------\", required=True,\n                 widget=None, label=None, initial=None,\n                 help_text='', to_field_name=None, limit_choices_to=None,\n                 blank=False, **kwargs):\n        # Call Field, not ChoiceField __init__, because we don't need\n        # ChoiceField.__init__.\n        Field.__init__(\n            self, required=required, widget=widget, label=label,\n            initial=initial, help_text=help_text, **kwargs\n        )\n        if (\n            (required and initial is not None) or\n            (isinstance(self.widget, RadioSelect) and not blank)\n        ):\n            self.empty_label = None\n        else:\n            self.empty_label = empty_label\n        self.queryset = queryset\n        self.limit_choices_to = limit_choices_to or {}\n        self.to_field_name = to_field_name\n",
      "\n    def __init__(\n        self, queryset, empty_label=\"---------\", required=True, widget=None,\n        label=None, initial=None, help_text='', to_field_name=None,\n        limit_choices_to=None, blank=False, **kwargs\n    ):\n        # Call Field's init first because it calls _set_queryset.\n        if required and (initial is not None):\n            self.empty_label = None\n        else:\n            self.empty_label = empty_label\n        Field.__init__(\n            self, required=required, widget=widget, label=label,\n            initial=initial, help_text=help_text, **kwargs\n        )\n        if (\n            (required and initial is not None) or\n            (isinstance(self.widget, RadioSelect) and not blank)\n        ):\n            self.empty_label = None\n        else:\n            self.empty_label = empty_label\n        self.limit_choices_to = limit_choices_to\n        self.queryset = queryset\n        self.to_field_name = to_field_name\n",
      "\n    def __init__(self, queryset, empty_label=\"---------\", required=True,\n                 widget=None, label=None, initial=None,\n                 help_text='', to_field_name=None, limit_choices_to=None,\n                 blank=False, **kwargs):\n        if required and (initial is not None):\n            self.empty_label = None\n        elif isinstance(widget, RadioSelect):\n            # RadioSelect widgets need a choice with an empty value.\n            self.empty_label = empty_label\n        else:\n            self.empty_label = empty_label\n        super().__init__(\n            required=required, widget=widget, label=label,\n            initial=initial, help_text=help_text, **kwargs\n        )\n        if (\n            (required and initial is not None) or\n            (isinstance(self.widget, RadioSelect) and not blank)\n        ):\n            self.empty_label = None\n        else:\n            self.empty_label = empty_label\n        self.queryset = queryset\n        self.limit_choices_to = limit_choices_to\n",
      "\n        self.queryset = queryset\n        self.limit_choices_to = limit_choices_to\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..4cbc20b71e 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1151,24 +1151,41 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        # Apply limit_choices_to filter if it exists\n+        limit_choices_to = self.field.get_limit_choices_to()\n+        if limit_choices_to is not None:\n+            queryset = queryset.complex_filter(limit_choices_to).distinct()\n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n         for obj in queryset:\n             yield self.choice(obj)\n \n+\n     def __len__(self):\n         # count() adds a query but uses less memory since the QuerySet results\n         # won't be cached. In most cases, the choices will only be iterated on,\n         # and __len__() won't be called.\n-        return self.queryset.count() + (1 if self.field.empty_label is not None else 0)\n+        queryset = self.queryset\n+        # Apply limit_choices_to filter for consistency with __iter__()\n+        limit_choices_to = self.field.get_limit_choices_to()\n+        if limit_choices_to is not None:\n+            queryset = queryset.complex_filter(limit_choices_to).distinct()\n+        return queryset.count() + (1 if self.field.empty_label is not None else 0)\n+\n \n     def __bool__(self):\n-        return self.field.empty_label is not None or self.queryset.exists()\n+        queryset = self.queryset\n+        # Apply limit_choices_to filter for consistency with __iter__()\n+        limit_choices_to = self.field.get_limit_choices_to()\n+        if limit_choices_to is not None:\n+            queryset = queryset.complex_filter(limit_choices_to).distinct()\n+        return self.field.empty_label is not None or queryset.exists()\n \n     def choice(self, obj):\n         return (\n@@ -1204,6 +1221,7 @@ class ModelChoiceField(ChoiceField):\n             self.empty_label = None\n         else:\n             self.empty_label = empty_label\n+\n         self.queryset = queryset\n         self.limit_choices_to = limit_choices_to   # limit the queryset later.\n         self.to_field_name = to_field_name\n@@ -1229,6 +1247,7 @@ class ModelChoiceField(ChoiceField):\n         return self._queryset\n \n     def _set_queryset(self, queryset):\n+\n         self._queryset = None if queryset is None else queryset.all()\n         self.widget.choices = self.choices\n \n",
    "variant_0": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..37f623960f 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1151,24 +1151,60 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            from django.db.models.query_utils import Q\n+            from django.db.models.sql.query import Query\n+            \n+            # Apply limit_choices_to filter using complex_filter like other parts of Django\n+            if hasattr(queryset, 'complex_filter'):\n+                queryset = queryset.complex_filter(self.field.limit_choices_to)\n+            else:\n+                # Fallback for custom querysets\n+                if isinstance(self.field.limit_choices_to, Q):\n+                    queryset = queryset.filter(self.field.limit_choices_to)\n+                else:\n+                    queryset = queryset.filter(**self.field.limit_choices_to)\n+            \n+            # Add distinct() to eliminate duplicates from joins\n+            queryset = queryset.distinct()\n+        \n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n         for obj in queryset:\n             yield self.choice(obj)\n \n+\n     def __len__(self):\n         # count() adds a query but uses less memory since the QuerySet results\n         # won't be cached. In most cases, the choices will only be iterated on,\n         # and __len__() won't be called.\n-        return self.queryset.count() + (1 if self.field.empty_label is not None else 0)\n+        queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            queryset = queryset.complex_filter(self.field.limit_choices_to).distinct()\n+        return queryset.count() + (1 if self.field.empty_label is not None else 0)\n+\n \n     def __bool__(self):\n-        return self.field.empty_label is not None or self.queryset.exists()\n+        from django.db.models.query_utils import Q\n+        from django.db.models.sql.query import Query\n+        \n+        queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            queryset = queryset.complex_filter(self.field.limit_choices_to)\n+            # Add distinct() to handle potential duplicates from joins\n+            if isinstance(self.field.limit_choices_to, Q):\n+                # Check if Q object might involve joins by examining its children\n+                query = Query(queryset.model)\n+                query.add_q(self.field.limit_choices_to)\n+                if query.alias_refcount:\n+                    queryset = queryset.distinct()\n+        return self.field.empty_label is not None or queryset.exists()\n \n     def choice(self, obj):\n         return (\n@@ -1204,8 +1240,9 @@ class ModelChoiceField(ChoiceField):\n             self.empty_label = None\n         else:\n             self.empty_label = empty_label\n+\n         self.queryset = queryset\n-        self.limit_choices_to = limit_choices_to   # limit the queryset later.\n+        self.limit_choices_to = limit_choices_to\n         self.to_field_name = to_field_name\n \n     def get_limit_choices_to(self):\n@@ -1228,6 +1265,8 @@ class ModelChoiceField(ChoiceField):\n     def _get_queryset(self):\n         return self._queryset\n \n+    def _set_queryset(self, queryset):\n+\n     def _set_queryset(self, queryset):\n         self._queryset = None if queryset is None else queryset.all()\n         self.widget.choices = self.choices\n",
    "variant_1": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..3dd57e664b 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1151,24 +1151,79 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            from django.db.models.query_utils import Q\n+            from django.db.models.sql.query import Query\n+            \n+            def complex_filter(queryset, filter_obj):\n+                if isinstance(filter_obj, Q):\n+                    return queryset.filter(filter_obj)\n+                elif isinstance(filter_obj, dict):\n+                    return queryset.filter(**filter_obj)\n+                else:\n+                    return queryset.filter(filter_obj)\n+            \n+            queryset = complex_filter(queryset, self.field.limit_choices_to).distinct()\n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n         for obj in queryset:\n             yield self.choice(obj)\n \n+\n     def __len__(self):\n+        # Apply limit_choices_to filter and use distinct() to handle joins\n+        filtered_queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            from django.db.models.query_utils import Q\n+            from django.db.models.sql.query import Query\n+            \n+            # Use complex_filter to handle both dict and Q object formats\n+            filtered_queryset = filtered_queryset.complex_filter(self.field.limit_choices_to).distinct()\n+        \n         # count() adds a query but uses less memory since the QuerySet results\n         # won't be cached. In most cases, the choices will only be iterated on,\n         # and __len__() won't be called.\n-        return self.queryset.count() + (1 if self.field.empty_label is not None else 0)\n+        return filtered_queryset.count() + (1 if self.field.empty_label is not None else 0)\n+\n \n     def __bool__(self):\n-        return self.field.empty_label is not None or self.queryset.exists()\n+        from django.db.models.query_utils import Q\n+        from django.db.models.sql.query import Query\n+        \n+        queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            queryset = queryset.complex_filter(self.field.limit_choices_to)\n+            \n+        # Check if limit_choices_to involves joins by examining the filter\n+        needs_distinct = False\n+        if self.field.limit_choices_to:\n+            if isinstance(self.field.limit_choices_to, Q):\n+                # For Q objects, check if any condition involves field lookups with '__'\n+                def has_joins(q_obj):\n+                    if hasattr(q_obj, 'children'):\n+                        for child in q_obj.children:\n+                            if isinstance(child, tuple) and len(child) == 2:\n+                                field_name, _ = child\n+                                if '__' in str(field_name):\n+                                    return True\n+                            elif hasattr(child, 'children') and has_joins(child):\n+                                return True\n+                    return False\n+                needs_distinct = has_joins(self.field.limit_choices_to)\n+            elif isinstance(self.field.limit_choices_to, dict):\n+                # For dict filters, check if any key involves field lookups with '__'\n+                needs_distinct = any('__' in str(key) for key in self.field.limit_choices_to.keys())\n+                \n+        if needs_distinct:\n+            queryset = queryset.distinct()\n+            \n+        return self.field.empty_label is not None or queryset.exists()\n \n     def choice(self, obj):\n         return (\n@@ -1204,8 +1259,9 @@ class ModelChoiceField(ChoiceField):\n             self.empty_label = None\n         else:\n             self.empty_label = empty_label\n+\n         self.queryset = queryset\n-        self.limit_choices_to = limit_choices_to   # limit the queryset later.\n+        self.limit_choices_to = limit_choices_to\n         self.to_field_name = to_field_name\n \n     def get_limit_choices_to(self):\n@@ -1228,6 +1284,8 @@ class ModelChoiceField(ChoiceField):\n     def _get_queryset(self):\n         return self._queryset\n \n+    def _set_queryset(self, queryset):\n+\n     def _set_queryset(self, queryset):\n         self._queryset = None if queryset is None else queryset.all()\n         self.widget.choices = self.choices\n",
    "variant_2": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..eb499c26a4 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1151,24 +1151,64 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            from django.db.models.query_utils import Q\n+            from django.db.models.sql.query import Query\n+            \n+            def complex_filter(queryset, filter_obj):\n+                if isinstance(filter_obj, Q):\n+                    return queryset.filter(filter_obj)\n+                elif isinstance(filter_obj, dict):\n+                    return queryset.filter(**filter_obj)\n+                else:\n+                    return queryset.filter(filter_obj)\n+            \n+            queryset = complex_filter(queryset, self.field.limit_choices_to).distinct()\n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n         for obj in queryset:\n             yield self.choice(obj)\n \n+\n     def __len__(self):\n         # count() adds a query but uses less memory since the QuerySet results\n         # won't be cached. In most cases, the choices will only be iterated on,\n         # and __len__() won't be called.\n-        return self.queryset.count() + (1 if self.field.empty_label is not None else 0)\n+        queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            from django.db.models.query_utils import Q\n+            from django.db.models.sql.query import Query\n+            \n+            def complex_filter(queryset, filter_expr):\n+                if isinstance(filter_expr, Q):\n+                    return queryset.filter(filter_expr)\n+                elif isinstance(filter_expr, dict):\n+                    return queryset.filter(**filter_expr)\n+                else:\n+                    return queryset.filter(filter_expr)\n+            \n+            queryset = complex_filter(queryset, self.field.limit_choices_to).distinct()\n+        return queryset.count() + (1 if self.field.empty_label is not None else 0)\n+\n \n     def __bool__(self):\n-        return self.field.empty_label is not None or self.queryset.exists()\n+        from django.db.models.sql.query import Query\n+        \n+        queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            queryset = queryset.complex_filter(self.field.limit_choices_to)\n+        \n+        # Add distinct() to handle potential duplicates from joins\n+        if hasattr(queryset.query, 'select_related') and (queryset.query.select_related or queryset.query.prefetch_related_lookups):\n+            queryset = queryset.distinct()\n+        \n+        return self.field.empty_label is not None or queryset.exists()\n \n     def choice(self, obj):\n         return (\n@@ -1204,8 +1244,9 @@ class ModelChoiceField(ChoiceField):\n             self.empty_label = None\n         else:\n             self.empty_label = empty_label\n+\n         self.queryset = queryset\n-        self.limit_choices_to = limit_choices_to   # limit the queryset later.\n+        self.limit_choices_to = limit_choices_to\n         self.to_field_name = to_field_name\n \n     def get_limit_choices_to(self):\n@@ -1228,6 +1269,8 @@ class ModelChoiceField(ChoiceField):\n     def _get_queryset(self):\n         return self._queryset\n \n+    def _set_queryset(self, queryset):\n+\n     def _set_queryset(self, queryset):\n         self._queryset = None if queryset is None else queryset.all()\n         self.widget.choices = self.choices\n",
    "variant_3": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..5bcdf7709a 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1151,24 +1151,47 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            from django.db.models.sql.query import Query\n+            queryset = queryset.complex_filter(self.field.limit_choices_to)\n+        queryset = queryset.distinct()\n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n         for obj in queryset:\n             yield self.choice(obj)\n \n+\n     def __len__(self):\n         # count() adds a query but uses less memory since the QuerySet results\n         # won't be cached. In most cases, the choices will only be iterated on,\n         # and __len__() won't be called.\n-        return self.queryset.count() + (1 if self.field.empty_label is not None else 0)\n+        queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            from django.db.models.query_utils import Q\n+            from django.db.models.sql.query import Query\n+            \n+            def complex_filter(queryset, filter_arg):\n+                if isinstance(filter_arg, Q) or hasattr(filter_arg, 'add_to_query'):\n+                    return queryset.filter(filter_arg)\n+                else:\n+                    return queryset.filter(**filter_arg)\n+            \n+            queryset = complex_filter(queryset, self.field.limit_choices_to).distinct()\n+        return queryset.count() + (1 if self.field.empty_label is not None else 0)\n+\n \n     def __bool__(self):\n-        return self.field.empty_label is not None or self.queryset.exists()\n+        # Apply limit_choices_to filter if present\n+        queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            queryset = queryset.complex_filter(self.field.limit_choices_to).distinct()\n+        return self.field.empty_label is not None or queryset.exists()\n \n     def choice(self, obj):\n         return (\n@@ -1204,8 +1227,27 @@ class ModelChoiceField(ChoiceField):\n             self.empty_label = None\n         else:\n             self.empty_label = empty_label\n+\n+    def __init__(self, queryset, empty_label=\"---------\", required=True,\n+                 widget=None, label=None, initial=None, help_text='',\n+                 to_field_name=None, limit_choices_to=None, blank=False,\n+                 **kwargs):\n+        # Call Field, not ChoiceField __init__, because we don't need\n+        # ChoiceField.__init__.\n+        Field.__init__(\n+            self, required=required, widget=widget, label=label,\n+            initial=initial, help_text=help_text, **kwargs\n+        )\n+        if (\n+            (required and initial is not None) or\n+            (isinstance(self.widget, RadioSelect) and not blank)\n+        ):\n+            self.empty_label = None\n+        else:\n+            self.empty_label = empty_label\n         self.queryset = queryset\n-        self.limit_choices_to = limit_choices_to   # limit the queryset later.\n+        self.limit_choices_to = limit_choices_to\n+        self.to_field_name = to_field_name\n         self.to_field_name = to_field_name\n \n     def get_limit_choices_to(self):\n@@ -1228,6 +1270,8 @@ class ModelChoiceField(ChoiceField):\n     def _get_queryset(self):\n         return self._queryset\n \n+    def _set_queryset(self, queryset):\n+\n     def _set_queryset(self, queryset):\n         self._queryset = None if queryset is None else queryset.all()\n         self.widget.choices = self.choices\n",
    "variant_4": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..16c51e1006 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1151,24 +1151,52 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            from django.db.models.query_utils import Q\n+            from django.db.models.utils import resolve_callables\n+            from django.db.models.sql.query import Query\n+            \n+            # Apply limit_choices_to filter using Django's complex_filter\n+            limit_choices_to = resolve_callables(self.field.limit_choices_to)\n+            queryset = queryset.complex_filter(limit_choices_to)\n+        \n+        # Add distinct() to eliminate duplicates from joins\n+        queryset = queryset.distinct()\n+        \n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n         for obj in queryset:\n             yield self.choice(obj)\n \n+\n     def __len__(self):\n         # count() adds a query but uses less memory since the QuerySet results\n         # won't be cached. In most cases, the choices will only be iterated on,\n         # and __len__() won't be called.\n-        return self.queryset.count() + (1 if self.field.empty_label is not None else 0)\n+        queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            queryset = queryset.complex_filter(self.field.limit_choices_to).distinct()\n+        return queryset.count() + (1 if self.field.empty_label is not None else 0)\n+\n \n     def __bool__(self):\n-        return self.field.empty_label is not None or self.queryset.exists()\n+        from django.db.models.query_utils import Q\n+        from django.db.models.sql.query import Query\n+        \n+        queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            # Apply limit_choices_to filter using complex_filter\n+            queryset = queryset.complex_filter(self.field.limit_choices_to)\n+            # Add distinct() to eliminate duplicates from joins in Q objects\n+            queryset = queryset.distinct()\n+        \n+        return self.field.empty_label is not None or queryset.exists()\n \n     def choice(self, obj):\n         return (\n@@ -1204,8 +1232,9 @@ class ModelChoiceField(ChoiceField):\n             self.empty_label = None\n         else:\n             self.empty_label = empty_label\n+\n         self.queryset = queryset\n-        self.limit_choices_to = limit_choices_to   # limit the queryset later.\n+        self.limit_choices_to = limit_choices_to\n         self.to_field_name = to_field_name\n \n     def get_limit_choices_to(self):\n@@ -1228,6 +1257,8 @@ class ModelChoiceField(ChoiceField):\n     def _get_queryset(self):\n         return self._queryset\n \n+    def _set_queryset(self, queryset):\n+\n     def _set_queryset(self, queryset):\n         self._queryset = None if queryset is None else queryset.all()\n         self.widget.choices = self.choices\n",
    "variant_5": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..ea8cecfb10 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1151,24 +1151,72 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            from django.db.models.sql.query import Query\n+            queryset = queryset.complex_filter(self.field.limit_choices_to)\n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n+        # Add distinct() to prevent duplicates from joins in limit_choices_to Q objects\n+        if self.field.limit_choices_to:\n+            if hasattr(queryset, 'distinct'):\n+                queryset = queryset.distinct()\n+            else:\n+                # For iterator() case, we need to get distinct values manually\n+                seen_pks = set()\n+                filtered_queryset = []\n+                for obj in queryset:\n+                    if obj.pk not in seen_pks:\n+                        seen_pks.add(obj.pk)\n+                        filtered_queryset.append(obj)\n+                queryset = filtered_queryset\n         for obj in queryset:\n             yield self.choice(obj)\n \n+\n     def __len__(self):\n         # count() adds a query but uses less memory since the QuerySet results\n         # won't be cached. In most cases, the choices will only be iterated on,\n         # and __len__() won't be called.\n-        return self.queryset.count() + (1 if self.field.empty_label is not None else 0)\n+        queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            from django.db.models.query_utils import Q\n+            from django.db.models.sql.query import Query\n+            \n+            def complex_filter(queryset, filter_obj):\n+                if isinstance(filter_obj, Q):\n+                    return queryset.filter(filter_obj)\n+                elif isinstance(filter_obj, dict):\n+                    return queryset.filter(**filter_obj)\n+                else:\n+                    return queryset.filter(filter_obj)\n+            \n+            queryset = complex_filter(queryset, self.field.limit_choices_to).distinct()\n+        return queryset.count() + (1 if self.field.empty_label is not None else 0)\n+\n \n     def __bool__(self):\n-        return self.field.empty_label is not None or self.queryset.exists()\n+        queryset = self.queryset\n+        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n+            from django.db.models.query_utils import Q\n+            from django.db.models.sql.query import Query\n+            \n+            def complex_filter(queryset, filter_arg):\n+                if isinstance(filter_arg, Q):\n+                    return queryset.filter(filter_arg)\n+                elif isinstance(filter_arg, dict):\n+                    return queryset.filter(**filter_arg)\n+                else:\n+                    return queryset.filter(filter_arg)\n+            \n+            queryset = complex_filter(queryset, self.field.limit_choices_to).distinct()\n+        \n+        return self.field.empty_label is not None or queryset.exists()\n \n     def choice(self, obj):\n         return (\n@@ -1204,8 +1252,27 @@ class ModelChoiceField(ChoiceField):\n             self.empty_label = None\n         else:\n             self.empty_label = empty_label\n+\n+    def __init__(self, queryset, empty_label=\"---------\", required=True,\n+                 widget=None, label=None, initial=None,\n+                 help_text='', to_field_name=None, limit_choices_to=None,\n+                 blank=False, **kwargs):\n+        # Call Field, not ChoiceField __init__, because we don't need\n+        # ChoiceField.__init__.\n+        Field.__init__(\n+            self, required=required, widget=widget, label=label,\n+            initial=initial, help_text=help_text, **kwargs\n+        )\n+        if (\n+            (required and initial is not None) or\n+            (isinstance(self.widget, RadioSelect) and not blank)\n+        ):\n+            self.empty_label = None\n+        else:\n+            self.empty_label = empty_label\n         self.queryset = queryset\n-        self.limit_choices_to = limit_choices_to   # limit the queryset later.\n+        self.limit_choices_to = limit_choices_to or {}\n+        self.to_field_name = to_field_name\n         self.to_field_name = to_field_name\n \n     def get_limit_choices_to(self):\n@@ -1228,6 +1295,8 @@ class ModelChoiceField(ChoiceField):\n     def _get_queryset(self):\n         return self._queryset\n \n+    def _set_queryset(self, queryset):\n+\n     def _set_queryset(self, queryset):\n         self._queryset = None if queryset is None else queryset.all()\n         self.widget.choices = self.choices\n",
    "variant_6": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..ce7a71d0f9 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1151,23 +1151,52 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        \n+        # Apply limit_choices_to filter if present\n+        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n+            from django.db.models.sql.query import Query\n+            queryset = queryset.complex_filter(self.field.limit_choices_to)\n+        \n+        # Add distinct() to eliminate duplicates from joins\n+        queryset = queryset.distinct()\n+        \n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n         for obj in queryset:\n             yield self.choice(obj)\n \n+\n     def __len__(self):\n         # count() adds a query but uses less memory since the QuerySet results\n         # won't be cached. In most cases, the choices will only be iterated on,\n         # and __len__() won't be called.\n-        return self.queryset.count() + (1 if self.field.empty_label is not None else 0)\n+        queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            queryset = queryset.complex_filter(self.field.limit_choices_to).distinct()\n+        return queryset.count() + (1 if self.field.empty_label is not None else 0)\n+\n \n     def __bool__(self):\n+        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n+            from django.db.models.query_utils import Q\n+            from django.db.models.sql.query import Query\n+            \n+            def complex_filter(queryset, filter_arg):\n+                if isinstance(filter_arg, Q):\n+                    return queryset.filter(filter_arg)\n+                elif isinstance(filter_arg, dict):\n+                    return queryset.filter(**filter_arg)\n+                else:\n+                    return queryset.filter(filter_arg)\n+            \n+            filtered_queryset = complex_filter(self.queryset, self.field.limit_choices_to).distinct()\n+            return self.field.empty_label is not None or filtered_queryset.exists()\n         return self.field.empty_label is not None or self.queryset.exists()\n \n     def choice(self, obj):\n@@ -1204,8 +1233,31 @@ class ModelChoiceField(ChoiceField):\n             self.empty_label = None\n         else:\n             self.empty_label = empty_label\n+\n+    def __init__(\n+        self, queryset, empty_label=\"---------\", required=True, widget=None,\n+        label=None, initial=None, help_text='', to_field_name=None,\n+        limit_choices_to=None, blank=False, **kwargs\n+    ):\n+        # Call Field's init first because it calls _set_queryset.\n+        if required and (initial is not None):\n+            self.empty_label = None\n+        else:\n+            self.empty_label = empty_label\n+        Field.__init__(\n+            self, required=required, widget=widget, label=label,\n+            initial=initial, help_text=help_text, **kwargs\n+        )\n+        if (\n+            (required and initial is not None) or\n+            (isinstance(self.widget, RadioSelect) and not blank)\n+        ):\n+            self.empty_label = None\n+        else:\n+            self.empty_label = empty_label\n+        self.limit_choices_to = limit_choices_to\n         self.queryset = queryset\n-        self.limit_choices_to = limit_choices_to   # limit the queryset later.\n+        self.to_field_name = to_field_name\n         self.to_field_name = to_field_name\n \n     def get_limit_choices_to(self):\n@@ -1229,7 +1281,28 @@ class ModelChoiceField(ChoiceField):\n         return self._queryset\n \n     def _set_queryset(self, queryset):\n-        self._queryset = None if queryset is None else queryset.all()\n+\n+    def _set_queryset(self, queryset):\n+        from django.db.models.query_utils import Q\n+        from django.db.models.sql.query import Query\n+        \n+        if queryset is None:\n+            self._queryset = None\n+        else:\n+            # Apply limit_choices_to filter if present\n+            filtered_queryset = queryset.all()\n+            if hasattr(self, 'limit_choices_to') and self.limit_choices_to:\n+                if hasattr(self.limit_choices_to, 'resolve_expression'):\n+                    # It's a Q object or similar - use complex_filter\n+                    filtered_queryset = filtered_queryset.complex_filter(self.limit_choices_to)\n+                else:\n+                    # It's a dict - use filter\n+                    filtered_queryset = filtered_queryset.filter(self.limit_choices_to)\n+                \n+                # Add distinct() to eliminate duplicates from joins\n+                filtered_queryset = filtered_queryset.distinct()\n+            \n+            self._queryset = filtered_queryset\n         self.widget.choices = self.choices\n \n     queryset = property(_get_queryset, _set_queryset)\n",
    "variant_7": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..b4c936d6f1 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1151,24 +1151,51 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            from django.db.models.query_utils import Q\n+            from django.db.models.sql.query import Query\n+            \n+            def complex_filter(queryset, filter_obj):\n+                if isinstance(filter_obj, Q):\n+                    return queryset.filter(filter_obj)\n+                else:\n+                    return queryset.filter(**filter_obj)\n+            \n+            queryset = complex_filter(queryset, self.field.limit_choices_to).distinct()\n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n         for obj in queryset:\n             yield self.choice(obj)\n \n+\n     def __len__(self):\n         # count() adds a query but uses less memory since the QuerySet results\n         # won't be cached. In most cases, the choices will only be iterated on,\n         # and __len__() won't be called.\n-        return self.queryset.count() + (1 if self.field.empty_label is not None else 0)\n+        queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            from django.db.models.query_utils import Q\n+            from django.db.models.sql.query import Query\n+            limit_choices_to = self.field.limit_choices_to\n+            if callable(limit_choices_to):\n+                limit_choices_to = limit_choices_to()\n+            queryset = queryset.complex_filter(limit_choices_to).distinct()\n+        return queryset.count() + (1 if self.field.empty_label is not None else 0)\n+\n \n     def __bool__(self):\n-        return self.field.empty_label is not None or self.queryset.exists()\n+        # Apply limit_choices_to filter and use distinct() to handle join-induced duplicates\n+        filtered_queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            from django.db.models.sql.query import Query\n+            filtered_queryset = filtered_queryset.complex_filter(self.field.limit_choices_to).distinct()\n+        return self.field.empty_label is not None or filtered_queryset.exists()\n \n     def choice(self, obj):\n         return (\n@@ -1204,8 +1231,31 @@ class ModelChoiceField(ChoiceField):\n             self.empty_label = None\n         else:\n             self.empty_label = empty_label\n+\n+    def __init__(self, queryset, empty_label=\"---------\", required=True,\n+                 widget=None, label=None, initial=None,\n+                 help_text='', to_field_name=None, limit_choices_to=None,\n+                 blank=False, **kwargs):\n+        if required and (initial is not None):\n+            self.empty_label = None\n+        elif isinstance(widget, RadioSelect):\n+            # RadioSelect widgets need a choice with an empty value.\n+            self.empty_label = empty_label\n+        else:\n+            self.empty_label = empty_label\n+        super().__init__(\n+            required=required, widget=widget, label=label,\n+            initial=initial, help_text=help_text, **kwargs\n+        )\n+        if (\n+            (required and initial is not None) or\n+            (isinstance(self.widget, RadioSelect) and not blank)\n+        ):\n+            self.empty_label = None\n+        else:\n+            self.empty_label = empty_label\n         self.queryset = queryset\n-        self.limit_choices_to = limit_choices_to   # limit the queryset later.\n+        self.limit_choices_to = limit_choices_to\n         self.to_field_name = to_field_name\n \n     def get_limit_choices_to(self):\n@@ -1228,6 +1278,8 @@ class ModelChoiceField(ChoiceField):\n     def _get_queryset(self):\n         return self._queryset\n \n+    def _set_queryset(self, queryset):\n+\n     def _set_queryset(self, queryset):\n         self._queryset = None if queryset is None else queryset.all()\n         self.widget.choices = self.choices\n",
    "variant_8": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..aec86d58d4 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -1151,24 +1151,59 @@ class ModelChoiceIterator:\n         self.field = field\n         self.queryset = field.queryset\n \n+\n     def __iter__(self):\n         if self.field.empty_label is not None:\n             yield (\"\", self.field.empty_label)\n         queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            from django.db.models.query_utils import Q\n+            from django.db.models.sql.query import Query\n+            \n+            def complex_filter(queryset, filter_obj):\n+                \"\"\"Apply a complex filter (Q object or dict) to a queryset.\"\"\"\n+                if isinstance(filter_obj, Q):\n+                    return queryset.filter(filter_obj)\n+                else:\n+                    return queryset.filter(**filter_obj)\n+            \n+            queryset = complex_filter(queryset, self.field.limit_choices_to).distinct()\n         # Can't use iterator() when queryset uses prefetch_related()\n         if not queryset._prefetch_related_lookups:\n             queryset = queryset.iterator()\n         for obj in queryset:\n             yield self.choice(obj)\n \n+\n     def __len__(self):\n         # count() adds a query but uses less memory since the QuerySet results\n         # won't be cached. In most cases, the choices will only be iterated on,\n         # and __len__() won't be called.\n-        return self.queryset.count() + (1 if self.field.empty_label is not None else 0)\n+        queryset = self.queryset\n+        if self.field.limit_choices_to:\n+            queryset = queryset.complex_filter(self.field.limit_choices_to)\n+        return queryset.count() + (1 if self.field.empty_label is not None else 0)\n+\n \n     def __bool__(self):\n-        return self.field.empty_label is not None or self.queryset.exists()\n+        from django.db.models.sql.query import Query\n+        \n+        queryset = self.queryset\n+        if hasattr(self.field, 'limit_choices_to') and self.field.limit_choices_to:\n+            # Apply limit_choices_to filter\n+            if hasattr(Query, 'complex_filter'):\n+                # Django 3.0+\n+                queryset = queryset.complex_filter(self.field.limit_choices_to)\n+            else:\n+                # Django < 3.0\n+                from django.db.models.sql.query import Query as BaseQuery\n+                temp_query = BaseQuery(queryset.model)\n+                temp_query.add_q(self.field.limit_choices_to)\n+                queryset = queryset.filter(temp_query.where)\n+            # Add distinct() to handle potential duplicates from joins\n+            queryset = queryset.distinct()\n+        \n+        return self.field.empty_label is not None or queryset.exists()\n \n     def choice(self, obj):\n         return (\n@@ -1204,8 +1239,9 @@ class ModelChoiceField(ChoiceField):\n             self.empty_label = None\n         else:\n             self.empty_label = empty_label\n+\n         self.queryset = queryset\n-        self.limit_choices_to = limit_choices_to   # limit the queryset later.\n+        self.limit_choices_to = limit_choices_to\n         self.to_field_name = to_field_name\n \n     def get_limit_choices_to(self):\n@@ -1228,6 +1264,8 @@ class ModelChoiceField(ChoiceField):\n     def _get_queryset(self):\n         return self._queryset\n \n+    def _set_queryset(self, queryset):\n+\n     def _set_queryset(self, queryset):\n         self._queryset = None if queryset is None else queryset.all()\n         self.widget.choices = self.choices\n"
  }
}