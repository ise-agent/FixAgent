{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/forms/boundfield.py lines 141-151)": "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For fields with callable defaults (like default=list), always use\n            # self.initial to ensure the default is properly re-evaluated\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
    "Location 2 (/root/hy/projects_4/django/django/forms/forms.py lines 515-530)": "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always check initial data via self.initial for consistency\n        # with get_initial_for_field() and proper callable evaluation\n        if self.field.show_hidden_initial:\n            # For fields with callable defaults (like default=list), we need to\n            # use self.initial which properly evaluates callables, rather than\n            # the serialized data from hidden fields which becomes stale\n            if callable(self.field.initial):\n                initial_value = self.initial\n            else:\n                initial_value = self.field.widget.value_from_datadict(\n                    self.form.data, self.form.files, self.html_initial_name\n                )\n        else:\n            initial_value = initial\n        return self.field.widget.value_omitted_from_data(\n            self.form.data, self.form.files, self.html_name\n        ) or self.field.widget._has_changed(initial_value, data)\n",
    "Location 3 (/root/hy/projects_4/django/django/forms/boundfield.py lines 253-255)": "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always compare against the current data.\n        data = self.to_python(data)\n        if self.field.show_hidden_initial:\n            # For fields with callable defaults (like default=list), we need to use\n            # self.initial which properly evaluates the callable, rather than using\n            # the serialized value from hidden form data which becomes stale\n            if callable(self.field.initial):\n                initial_value = self.initial\n            else:\n                initial_value = self._widget_data_value(self.field.hidden_widget(), initial)\n        else:\n            initial_value = initial\n        return self.field.has_changed(initial_value, data)\n",
    "Location 4 (/root/hy/projects_4/django/django/forms/boundfield.py lines 152-154)": "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For fields with callable defaults (like default=list), we should\n            # use self.initial to get the freshly evaluated default rather than\n            # the serialized value from hidden widget data\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
    "Location 5 (/root/hy/projects_4/django/django/forms/boundfield.py lines 139-140)": "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults, use self.initial to re-evaluate the callable\n            # instead of using stale serialized data from hidden fields\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/forms/boundfield.py lines 141-151)": [
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For fields with callable defaults (like default=list), use self.initial\n            # to ensure the default is re-evaluated rather than using stale serialized data\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # Check if the field has a callable default - if so, use self.initial\n            # to ensure the callable is re-evaluated rather than using stale data\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults like default=list, use self.initial to ensure\n            # the callable is re-evaluated instead of using stale serialized data\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like default=list), use self.initial instead of\n            # hidden widget data to ensure the default is re-evaluated each time\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults, use self.initial instead of hidden widget data\n            # to ensure the default is re-evaluated on each form processing\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # If the field has a callable default, use self.initial which properly\n            # evaluates the callable instead of using stale serialized data\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # Check if field has a callable default that should be re-evaluated\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like default=list), use self.initial which properly\n            # evaluates the callable, rather than using stale serialized data from hidden fields\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/forms/forms.py lines 515-530)": [
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always check the field's show_hidden_initial attribute if it's a\n        # BoundField.\n        if self.field.show_hidden_initial:\n            # Check if the field has a callable default and use self.initial\n            # to ensure callable defaults are properly re-evaluated\n            if callable(self.field.initial):\n                initial_value = self.initial\n            else:\n                initial_value = self._widget_data_value(\n                    self.field.widget, self.html_initial_name, self.html_initial_id\n                )\n        else:\n            initial_value = self.initial\n        try:\n            data = self.field.to_python(data)\n        except ValidationError:\n            return True\n        return self.field.has_changed(initial_value, data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For fields with callable initial values (like default=list),\n            # use the properly evaluated initial value instead of hidden field data\n            # to avoid using stale serialized data\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                initial_value = self._widget_data_value(field.hidden_widget())\n        else:\n            initial_value = self.initial\n        return field.widget.value_omitted_from_data(self.data, self.files, self.html_name) or field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always check the field's show_hidden_initial attribute if it's a\n        # BoundField.\n        if self.field.show_hidden_initial:\n            # Check if the field has a callable default that should be re-evaluated\n            if callable(self.field.initial):\n                initial_value = self.initial\n            else:\n                initial_value = self.field.widget.value_from_datadict(\n                    self.form.data, self.form.files, self.form.add_initial_prefix(self.name)\n                )\n        else:\n            initial_value = initial\n        try:\n            data = self.field.to_python(data)\n        except ValidationError:\n            return True\n        # For purposes of seeing whether something has changed, None is\n        # the same as an empty string, if the data or initial value we get\n        # is None, replace it with ''.\n        initial_value = self.field.bound_data(initial_value, initial_value)\n        return self.field.has_changed(initial_value, data)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always return False if the field is disabled since self.bound_data\n        # always uses the initial value in this case.\n        if self.field.disabled:\n            return False\n        try:\n            data = self.field.to_python(data)\n            if hasattr(self.field, '_coerce'):\n                return self.field._coerce(data) != self.field._coerce(initial)\n        except ValidationError:\n            return True\n        # For purposes of seeing whether something has changed, None is\n        # the same as an empty string, if the data or initial value we get\n        # is None, replace it with ''.\n        initial_value = initial if initial is not None else ''\n        data_value = data if data is not None else ''\n        return initial_value != data_value\n\n    def _widget_data_value(self):\n        \"\"\"\n        Returns the data value for this BoundField's widget. Subclasses\n        should not need to override this.\n        \"\"\"\n        if self.field.show_hidden_initial:\n            # For fields with callable defaults, use self.initial which properly\n            # evaluates the callable, rather than hidden field data which may be stale\n            if callable(self.field.initial):\n                return self.initial\n            return self._widget_data_value_from_datadict()\n        else:\n            return self.initial\n",
      "\ndef _has_changed(self, initial, data):\n    \"\"\"Return True if data differs from initial.\"\"\"\n    # Always check if the field has a callable default when using hidden initial\n    if self.field.show_hidden_initial:\n        # For callable defaults, use self.initial to get fresh evaluation\n        # instead of stale serialized data from hidden fields\n        if callable(self.field.initial):\n            initial_value = self.initial\n        else:\n            initial_value = self._widget_data_value(self.form.add_initial_prefix(self.name))\n    else:\n        initial_value = initial\n    return self.field.widget.value_changed(initial_value, data)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always check for changes if show_hidden_initial is False\n        if self.field.show_hidden_initial:\n            # For callable defaults, use self.initial which properly evaluates them\n            # instead of using stale serialized data from hidden fields\n            if callable(self.field.initial):\n                initial_value = self.initial\n            else:\n                initial_value = self._widget_data_value(self.field.widget, self.html_initial_name)\n        else:\n            initial_value = self.initial\n        try:\n            data = self.field.to_python(data)\n        except ValidationError:\n            return True\n        return self.field.has_changed(initial_value, data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # If the field has a callable initial value (like default=list),\n            # use self.initial which properly evaluates callables instead of\n            # the serialized hidden field data which becomes stale\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                initial_value = self._widget_data_value(field.hidden_widget())\n        else:\n            initial_value = self.initial\n        return field.widget.value_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always check the field's show_hidden_initial attribute if it's a\n        # BoundField.\n        if self.field.show_hidden_initial:\n            # For callable defaults, use self.initial to ensure proper re-evaluation\n            # instead of stale serialized data from hidden fields\n            if callable(self.field.initial):\n                initial_value = self.initial\n            else:\n                initial_value = self._widget_data_value(self.field.widget, self.html_initial_name)\n        else:\n            initial_value = initial\n        try:\n            data = self.field.to_python(data)\n        except ValidationError:\n            return True\n        return self.field.has_changed(initial_value, data)\n"
    ],
    "Location 3 (/root/hy/projects_4/django/django/forms/boundfield.py lines 253-255)": [
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always assume data has changed if it's a callable that isn't a type.\n        if initial is self.field.initial and callable(initial) and not isinstance(initial, type):\n            initial = initial()\n        # For purposes of seeing whether something has changed, None is\n        # the same as an empty string, if the data or initial value we get\n        # is None, replace it with ''.\n        initial_value = initial if initial is not None else ''\n        data_value = data if data is not None else ''\n        if self.field.show_hidden_initial:\n            # For fields with show_hidden_initial=True and callable defaults,\n            # use self.initial to ensure callable defaults are re-evaluated\n            if callable(self.field.initial):\n                initial_value = self.initial if self.initial is not None else ''\n            else:\n                initial_value = self._widget_data_value(self.field.hidden_widget(), initial)\n        return initial_value != data_value\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always compare against the current initial value.\n        if self.field.show_hidden_initial:\n            # For fields with callable defaults, we need to use the properly\n            # evaluated initial value rather than the serialized hidden data\n            if callable(self.field.initial):\n                initial_value = self.initial\n            else:\n                initial_value = self.field.widget.value_from_datadict(\n                    self.form.data, self.form.files, self.form.add_initial_prefix(self.name)\n                )\n        else:\n            initial_value = initial\n        try:\n            data = self.field.to_python(data)\n        except ValidationError:\n            return True\n        # We need to be careful here because we can receive a data that's not\n        # valid for the field (for example, a date string for a DateTimeField),\n        # so we need to catch the exception.\n        return self.field.has_changed(initial_value, data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like default=list), we need to compare against\n            # the freshly evaluated default rather than the serialized hidden value\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                initial_value = self._widget_data_value(self.form.initial.get(self.name, field.initial))\n        else:\n            initial_value = self.initial\n        try:\n            data = field.to_python(self._value())\n        except ValidationError:\n            return True\n        # For purposes of seeing whether something has changed, None is\n        # the same as an empty string, if the data or initial value we get\n        # is None, replace it with ''.\n        initial_value = initial_value if initial_value is not None else ''\n        data = data if data is not None else ''\n        return field.has_changed(initial_value, data)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always check for changes using self.initial for callable defaults\n        # to ensure they are re-evaluated on each form processing\n        if self.field.show_hidden_initial:\n            # For callable defaults (like default=list), use self.initial which\n            # properly re-evaluates the callable instead of using stale hidden data\n            if callable(self.field.initial):\n                initial_value = self.initial\n            else:\n                initial_value = self._widget_data_value(self.field.hidden_widget(), initial)\n        else:\n            initial_value = self.initial\n        return self.field.widget.value_changed(initial_value, data)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always compare against the current data.\n        field = self.field\n        if field.show_hidden_initial:\n            # Check if field has a callable default that needs re-evaluation\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                initial_value = self._widget_data_value(field.hidden_widget(), self.html_initial_name)\n        else:\n            initial_value = self.initial\n        return field.widget.value_has_changed(initial_value, data)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always compare against the current data.\n        if data is None:\n            data_value = ''\n        else:\n            data_value = self.field.to_python(data)\n            if hasattr(self.field, 'to_python'):\n                try:\n                    data_value = self.field.to_python(data)\n                except ValidationError:\n                    return True\n\n        if self.field.show_hidden_initial:\n            # For callable defaults (like default=list), use self.initial which \n            # properly re-evaluates the callable instead of using stale hidden data\n            if callable(self.field.initial):\n                initial_value = self.initial\n            else:\n                initial_prefixed_name = self.form.add_initial_prefix(self.name)\n                hidden_widget = self.field.hidden_widget()\n                try:\n                    initial_value = hidden_widget.value_from_datadict(\n                        self.form.data, self.form.files, initial_prefixed_name,\n                    )\n                except AttributeError:\n                    # hidden_widget doesn't define value_from_datadict.\n                    initial_value = self.form.initial.get(self.name, self.field.initial)\n        else:\n            initial_value = self.initial\n        return self.field.has_changed(initial_value, data_value)\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always return False if the field is disabled since self.bound_data\n        # always uses the initial value in this case.\n        if self.field.disabled:\n            return False\n        try:\n            data = self.field.to_python(data)\n            if hasattr(self.field, '_coerce'):\n                return self.field._coerce(data) != self.field._coerce(initial)\n        except ValidationError:\n            return True\n        # For purposes of seeing whether something has changed, None is\n        # the same as an empty string, if the data or initial value we get\n        # is None, replace it with ''.\n        initial_value = initial if initial is not None else ''\n        data_value = data if data is not None else ''\n        return initial_value != data_value\n",
      "\n    def _has_changed(self, initial, data):\n        \"\"\"Return True if data differs from initial.\"\"\"\n        # Always compare against the current data.\n        if data is None:\n            data_value = ''\n        else:\n            data_value = self.field.to_python(data)\n            if hasattr(self.field, 'to_python'):\n                try:\n                    data_value = self.field.to_python(data)\n                except ValidationError:\n                    return True\n\n        if self.field.show_hidden_initial:\n            # For fields with callable defaults, use self.initial to get fresh evaluation\n            if callable(self.field.initial):\n                initial_value = self.initial\n            else:\n                initial_value = self._widget_data_value(self.field.widget, initial)\n        else:\n            initial_value = self.initial\n        return self.field.has_changed(initial_value, data_value)\n"
    ],
    "Location 4 (/root/hy/projects_4/django/django/forms/boundfield.py lines 152-154)": [
      "\n        if field.show_hidden_initial:\n            hidden_widget = field.hidden_widget()\n            initial_value = self.form._widget_data_value(\n                hidden_widget,\n                self.html_initial_name,\n            )\n            try:\n                initial_value = field.to_python(initial_value)\n            except ValidationError:\n                # Always assume data has changed if validation fails.\n                return True\n            # For callable defaults, use self.initial instead of hidden field data\n            # to ensure the default is re-evaluated on each form processing\n            if callable(field.initial):\n                initial_value = self.initial\n        else:\n            initial_value = self.initial\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # Check if the field has a callable default that should be re-evaluated\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like default=list), we should use self.initial\n            # which properly evaluates the callable, rather than using stale data\n            # from hidden form fields\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            hidden_widget = field.hidden_widget()\n            initial_value = self.form._widget_data_value(\n                hidden_widget,\n                self.html_initial_name,\n            )\n            try:\n                initial_value = field.to_python(initial_value)\n            except ValidationError:\n                # Always assume data has changed if validation fails.\n                return True\n            # For callable defaults, use self.initial instead of hidden field data\n            # to ensure the default is re-evaluated on each form processing\n            if callable(field.initial):\n                initial_value = self.initial\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # Check if the field has a callable default that should be re-evaluated\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n        if field.show_hidden_initial:\n            hidden_widget = field.hidden_widget()\n            initial_value = self.form._widget_data_value(\n                hidden_widget,\n                self.html_initial_name,\n            )\n            try:\n                initial_value = field.to_python(initial_value)\n            except ValidationError:\n                # Always assume data has changed if validation fails.\n                return True\n            # If the field has a callable default, use self.initial instead\n            # of the serialized hidden field value to ensure callable defaults\n            # are properly re-evaluated on each form processing\n            if callable(field.initial):\n                initial_value = self.initial\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like default=list), we should use self.initial\n            # instead of hidden field data to ensure the default is re-evaluated\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like default=list), we should use self.initial\n            # which properly evaluates the callable, rather than the serialized\n            # hidden field data which becomes stale\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n"
    ],
    "Location 5 (/root/hy/projects_4/django/django/forms/boundfield.py lines 139-140)": [
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # Check if field has a callable default and use self.initial instead of hidden data\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults, use self.initial to ensure proper re-evaluation\n            # instead of stale serialized data from hidden fields\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like default=list), use self.initial which properly\n            # evaluates the callable, rather than using stale serialized data from hidden fields\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like default=list), use self.initial instead of\n            # hidden field data to ensure the default is properly re-evaluated\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # Check if field has a callable default that should be re-evaluated\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults, use self.initial to ensure proper re-evaluation\n            # instead of using potentially stale serialized data from hidden fields\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like default=list), use self.initial to ensure\n            # the default is re-evaluated rather than using stale serialized data\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n",
      "\n    def _has_changed(self):\n        field = self.field\n        if field.show_hidden_initial:\n            # For callable defaults (like default=list), use self.initial to ensure\n            # the default is re-evaluated rather than using stale serialized data\n            if callable(field.initial):\n                initial_value = self.initial\n            else:\n                hidden_widget = field.hidden_widget()\n                initial_value = self.form._widget_data_value(\n                    hidden_widget,\n                    self.html_initial_name,\n                )\n                try:\n                    initial_value = field.to_python(initial_value)\n                except ValidationError:\n                    # Always assume data has changed if validation fails.\n                    return True\n        else:\n            initial_value = self.initial\n        return field.has_changed(initial_value, self.data)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..a1c4e1260d 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,19 +136,27 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+\n     def _has_changed(self):\n         field = self.field\n+\n         if field.show_hidden_initial:\n-            hidden_widget = field.hidden_widget()\n-            initial_value = self.form._widget_data_value(\n-                hidden_widget,\n-                self.html_initial_name,\n-            )\n-            try:\n-                initial_value = field.to_python(initial_value)\n-            except ValidationError:\n-                # Always assume data has changed if validation fails.\n-                return True\n+            # Check if field has a callable default - if so, use self.initial\n+            # which properly evaluates callable defaults via get_initial_for_field()\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n@@ -250,6 +258,7 @@ class BoundField:\n         id_ = widget.attrs.get(\"id\") or self.auto_id\n         return widget.id_for_label(id_)\n \n+\n     @cached_property\n     def initial(self):\n         return self.form.get_initial_for_field(self.field, self.name)\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..e2e4f2aed1 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -512,6 +512,7 @@ class BaseForm(RenderableFormMixin):\n         \"\"\"\n         return [field for field in self if not field.is_hidden]\n \n+\n     def get_initial_for_field(self, field, field_name):\n         \"\"\"\n         Return initial data for field on form. Use initial data from the form\n",
    "variant_0": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..54352ee99a 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,19 +136,70 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+\n     def _has_changed(self):\n         field = self.field\n         if field.show_hidden_initial:\n-            hidden_widget = field.hidden_widget()\n-            initial_value = self.form._widget_data_value(\n-                hidden_widget,\n-                self.html_initial_name,\n-            )\n-            try:\n-                initial_value = field.to_python(initial_value)\n-            except ValidationError:\n-                # Always assume data has changed if validation fails.\n-                return True\n+            # For callable defaults, use self.initial to re-evaluate the callable\n+            # instead of using stale serialized data from hidden fields\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # For fields with callable defaults (like default=list), always use\n+            # self.initial to ensure the default is properly re-evaluated\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # For fields with callable defaults (like default=list), we should\n+            # use self.initial to get the freshly evaluated default rather than\n+            # the serialized value from hidden widget data\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n@@ -250,9 +301,22 @@ class BoundField:\n         id_ = widget.attrs.get(\"id\") or self.auto_id\n         return widget.id_for_label(id_)\n \n-    @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always compare against the current data.\n+        data = self.to_python(data)\n+        if self.field.show_hidden_initial:\n+            # For fields with callable defaults (like default=list), we need to use\n+            # self.initial which properly evaluates the callable, rather than using\n+            # the serialized value from hidden form data which becomes stale\n+            if callable(self.field.initial):\n+                initial_value = self.initial\n+            else:\n+                initial_value = self._widget_data_value(self.field.hidden_widget(), initial)\n+        else:\n+            initial_value = initial\n+        return self.field.has_changed(initial_value, data)\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..1fcda4f0da 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -512,22 +512,26 @@ class BaseForm(RenderableFormMixin):\n         \"\"\"\n         return [field for field in self if not field.is_hidden]\n \n-    def get_initial_for_field(self, field, field_name):\n-        \"\"\"\n-        Return initial data for field on form. Use initial data from the form\n-        or the field, in that order. Evaluate callable values.\n-        \"\"\"\n-        value = self.initial.get(field_name, field.initial)\n-        if callable(value):\n-            value = value()\n-        # If this is an auto-generated default date, nix the microseconds\n-        # for standardized handling. See #22502.\n-        if (\n-            isinstance(value, (datetime.datetime, datetime.time))\n-            and not field.widget.supports_microseconds\n-        ):\n-            value = value.replace(microsecond=0)\n-        return value\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always check initial data via self.initial for consistency\n+        # with get_initial_for_field() and proper callable evaluation\n+        if self.field.show_hidden_initial:\n+            # For fields with callable defaults (like default=list), we need to\n+            # use self.initial which properly evaluates callables, rather than\n+            # the serialized data from hidden fields which becomes stale\n+            if callable(self.field.initial):\n+                initial_value = self.initial\n+            else:\n+                initial_value = self.field.widget.value_from_datadict(\n+                    self.form.data, self.form.files, self.html_initial_name\n+                )\n+        else:\n+            initial_value = initial\n+        return self.field.widget.value_omitted_from_data(\n+            self.form.data, self.form.files, self.html_name\n+        ) or self.field.widget._has_changed(initial_value, data)\n \n \n class Form(BaseForm, metaclass=DeclarativeFieldsMetaclass):\n",
    "variant_1": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..b3b82d0199 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,8 +136,50 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # Check if field has a callable default and use self.initial instead of hidden data\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n     def _has_changed(self):\n         field = self.field\n+        if field.show_hidden_initial:\n+            # For fields with callable defaults (like default=list), use self.initial\n+            # to ensure the default is re-evaluated rather than using stale serialized data\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n         if field.show_hidden_initial:\n             hidden_widget = field.hidden_widget()\n             initial_value = self.form._widget_data_value(\n@@ -149,9 +191,12 @@ class BoundField:\n             except ValidationError:\n                 # Always assume data has changed if validation fails.\n                 return True\n+            # For callable defaults, use self.initial instead of hidden field data\n+            # to ensure the default is re-evaluated on each form processing\n+            if callable(field.initial):\n+                initial_value = self.initial\n         else:\n             initial_value = self.initial\n-        return field.has_changed(initial_value, self.data)\n \n     def label_tag(self, contents=None, attrs=None, label_suffix=None, tag=None):\n         \"\"\"\n@@ -250,9 +295,25 @@ class BoundField:\n         id_ = widget.attrs.get(\"id\") or self.auto_id\n         return widget.id_for_label(id_)\n \n-    @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always assume data has changed if it's a callable that isn't a type.\n+        if initial is self.field.initial and callable(initial) and not isinstance(initial, type):\n+            initial = initial()\n+        # For purposes of seeing whether something has changed, None is\n+        # the same as an empty string, if the data or initial value we get\n+        # is None, replace it with ''.\n+        initial_value = initial if initial is not None else ''\n+        data_value = data if data is not None else ''\n+        if self.field.show_hidden_initial:\n+            # For fields with show_hidden_initial=True and callable defaults,\n+            # use self.initial to ensure callable defaults are re-evaluated\n+            if callable(self.field.initial):\n+                initial_value = self.initial if self.initial is not None else ''\n+            else:\n+                initial_value = self._widget_data_value(self.field.hidden_widget(), initial)\n+        return initial_value != data_value\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..5899139587 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -512,22 +512,27 @@ class BaseForm(RenderableFormMixin):\n         \"\"\"\n         return [field for field in self if not field.is_hidden]\n \n-    def get_initial_for_field(self, field, field_name):\n-        \"\"\"\n-        Return initial data for field on form. Use initial data from the form\n-        or the field, in that order. Evaluate callable values.\n-        \"\"\"\n-        value = self.initial.get(field_name, field.initial)\n-        if callable(value):\n-            value = value()\n-        # If this is an auto-generated default date, nix the microseconds\n-        # for standardized handling. See #22502.\n-        if (\n-            isinstance(value, (datetime.datetime, datetime.time))\n-            and not field.widget.supports_microseconds\n-        ):\n-            value = value.replace(microsecond=0)\n-        return value\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always check the field's show_hidden_initial attribute if it's a\n+        # BoundField.\n+        if self.field.show_hidden_initial:\n+            # Check if the field has a callable default and use self.initial\n+            # to ensure callable defaults are properly re-evaluated\n+            if callable(self.field.initial):\n+                initial_value = self.initial\n+            else:\n+                initial_value = self._widget_data_value(\n+                    self.field.widget, self.html_initial_name, self.html_initial_id\n+                )\n+        else:\n+            initial_value = self.initial\n+        try:\n+            data = self.field.to_python(data)\n+        except ValidationError:\n+            return True\n+        return self.field.has_changed(initial_value, data)\n \n \n class Form(BaseForm, metaclass=DeclarativeFieldsMetaclass):\n",
    "variant_2": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..756ba0b064 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,19 +136,68 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+\n     def _has_changed(self):\n         field = self.field\n         if field.show_hidden_initial:\n-            hidden_widget = field.hidden_widget()\n-            initial_value = self.form._widget_data_value(\n-                hidden_widget,\n-                self.html_initial_name,\n-            )\n-            try:\n-                initial_value = field.to_python(initial_value)\n-            except ValidationError:\n-                # Always assume data has changed if validation fails.\n-                return True\n+            # For callable defaults, use self.initial to ensure proper re-evaluation\n+            # instead of stale serialized data from hidden fields\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # Check if the field has a callable default - if so, use self.initial\n+            # to ensure the callable is re-evaluated rather than using stale data\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # Check if the field has a callable default that should be re-evaluated\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n@@ -250,9 +299,29 @@ class BoundField:\n         id_ = widget.attrs.get(\"id\") or self.auto_id\n         return widget.id_for_label(id_)\n \n-    @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always compare against the current initial value.\n+        if self.field.show_hidden_initial:\n+            # For fields with callable defaults, we need to use the properly\n+            # evaluated initial value rather than the serialized hidden data\n+            if callable(self.field.initial):\n+                initial_value = self.initial\n+            else:\n+                initial_value = self.field.widget.value_from_datadict(\n+                    self.form.data, self.form.files, self.form.add_initial_prefix(self.name)\n+                )\n+        else:\n+            initial_value = initial\n+        try:\n+            data = self.field.to_python(data)\n+        except ValidationError:\n+            return True\n+        # We need to be careful here because we can receive a data that's not\n+        # valid for the field (for example, a date string for a DateTimeField),\n+        # so we need to catch the exception.\n+        return self.field.has_changed(initial_value, data)\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..4be0f2cd12 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -512,22 +512,20 @@ class BaseForm(RenderableFormMixin):\n         \"\"\"\n         return [field for field in self if not field.is_hidden]\n \n-    def get_initial_for_field(self, field, field_name):\n-        \"\"\"\n-        Return initial data for field on form. Use initial data from the form\n-        or the field, in that order. Evaluate callable values.\n-        \"\"\"\n-        value = self.initial.get(field_name, field.initial)\n-        if callable(value):\n-            value = value()\n-        # If this is an auto-generated default date, nix the microseconds\n-        # for standardized handling. See #22502.\n-        if (\n-            isinstance(value, (datetime.datetime, datetime.time))\n-            and not field.widget.supports_microseconds\n-        ):\n-            value = value.replace(microsecond=0)\n-        return value\n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # For fields with callable initial values (like default=list),\n+            # use the properly evaluated initial value instead of hidden field data\n+            # to avoid using stale serialized data\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                initial_value = self._widget_data_value(field.hidden_widget())\n+        else:\n+            initial_value = self.initial\n+        return field.widget.value_omitted_from_data(self.data, self.files, self.html_name) or field.has_changed(initial_value, self.data)\n \n \n class Form(BaseForm, metaclass=DeclarativeFieldsMetaclass):\n",
    "variant_3": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..2533eb2b68 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,19 +136,70 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+\n     def _has_changed(self):\n         field = self.field\n         if field.show_hidden_initial:\n-            hidden_widget = field.hidden_widget()\n-            initial_value = self.form._widget_data_value(\n-                hidden_widget,\n-                self.html_initial_name,\n-            )\n-            try:\n-                initial_value = field.to_python(initial_value)\n-            except ValidationError:\n-                # Always assume data has changed if validation fails.\n-                return True\n+            # For callable defaults (like default=list), use self.initial which properly\n+            # evaluates the callable, rather than using stale serialized data from hidden fields\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # For callable defaults like default=list, use self.initial to ensure\n+            # the callable is re-evaluated instead of using stale serialized data\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # For callable defaults (like default=list), we should use self.initial\n+            # which properly evaluates the callable, rather than using stale data\n+            # from hidden form fields\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n@@ -250,9 +301,28 @@ class BoundField:\n         id_ = widget.attrs.get(\"id\") or self.auto_id\n         return widget.id_for_label(id_)\n \n-    @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # For callable defaults (like default=list), we need to compare against\n+            # the freshly evaluated default rather than the serialized hidden value\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                initial_value = self._widget_data_value(self.form.initial.get(self.name, field.initial))\n+        else:\n+            initial_value = self.initial\n+        try:\n+            data = field.to_python(self._value())\n+        except ValidationError:\n+            return True\n+        # For purposes of seeing whether something has changed, None is\n+        # the same as an empty string, if the data or initial value we get\n+        # is None, replace it with ''.\n+        initial_value = initial_value if initial_value is not None else ''\n+        data = data if data is not None else ''\n+        return field.has_changed(initial_value, data)\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..f2e1fb3118 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -512,22 +512,30 @@ class BaseForm(RenderableFormMixin):\n         \"\"\"\n         return [field for field in self if not field.is_hidden]\n \n-    def get_initial_for_field(self, field, field_name):\n-        \"\"\"\n-        Return initial data for field on form. Use initial data from the form\n-        or the field, in that order. Evaluate callable values.\n-        \"\"\"\n-        value = self.initial.get(field_name, field.initial)\n-        if callable(value):\n-            value = value()\n-        # If this is an auto-generated default date, nix the microseconds\n-        # for standardized handling. See #22502.\n-        if (\n-            isinstance(value, (datetime.datetime, datetime.time))\n-            and not field.widget.supports_microseconds\n-        ):\n-            value = value.replace(microsecond=0)\n-        return value\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always check the field's show_hidden_initial attribute if it's a\n+        # BoundField.\n+        if self.field.show_hidden_initial:\n+            # Check if the field has a callable default that should be re-evaluated\n+            if callable(self.field.initial):\n+                initial_value = self.initial\n+            else:\n+                initial_value = self.field.widget.value_from_datadict(\n+                    self.form.data, self.form.files, self.form.add_initial_prefix(self.name)\n+                )\n+        else:\n+            initial_value = initial\n+        try:\n+            data = self.field.to_python(data)\n+        except ValidationError:\n+            return True\n+        # For purposes of seeing whether something has changed, None is\n+        # the same as an empty string, if the data or initial value we get\n+        # is None, replace it with ''.\n+        initial_value = self.field.bound_data(initial_value, initial_value)\n+        return self.field.has_changed(initial_value, data)\n \n \n class Form(BaseForm, metaclass=DeclarativeFieldsMetaclass):\n",
    "variant_4": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..2f8c989c16 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,6 +136,51 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # For callable defaults (like default=list), use self.initial instead of\n+            # hidden field data to ensure the default is properly re-evaluated\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # For callable defaults (like default=list), use self.initial instead of\n+            # hidden widget data to ensure the default is re-evaluated each time\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n     def _has_changed(self):\n         field = self.field\n         if field.show_hidden_initial:\n@@ -149,6 +194,10 @@ class BoundField:\n             except ValidationError:\n                 # Always assume data has changed if validation fails.\n                 return True\n+            # For callable defaults, use self.initial instead of hidden field data\n+            # to ensure the default is re-evaluated on each form processing\n+            if callable(field.initial):\n+                initial_value = self.initial\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n@@ -250,9 +299,21 @@ class BoundField:\n         id_ = widget.attrs.get(\"id\") or self.auto_id\n         return widget.id_for_label(id_)\n \n-    @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always check for changes using self.initial for callable defaults\n+        # to ensure they are re-evaluated on each form processing\n+        if self.field.show_hidden_initial:\n+            # For callable defaults (like default=list), use self.initial which\n+            # properly re-evaluates the callable instead of using stale hidden data\n+            if callable(self.field.initial):\n+                initial_value = self.initial\n+            else:\n+                initial_value = self._widget_data_value(self.field.hidden_widget(), initial)\n+        else:\n+            initial_value = self.initial\n+        return self.field.widget.value_changed(initial_value, data)\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..88d835808b 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -512,22 +512,39 @@ class BaseForm(RenderableFormMixin):\n         \"\"\"\n         return [field for field in self if not field.is_hidden]\n \n-    def get_initial_for_field(self, field, field_name):\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always return False if the field is disabled since self.bound_data\n+        # always uses the initial value in this case.\n+        if self.field.disabled:\n+            return False\n+        try:\n+            data = self.field.to_python(data)\n+            if hasattr(self.field, '_coerce'):\n+                return self.field._coerce(data) != self.field._coerce(initial)\n+        except ValidationError:\n+            return True\n+        # For purposes of seeing whether something has changed, None is\n+        # the same as an empty string, if the data or initial value we get\n+        # is None, replace it with ''.\n+        initial_value = initial if initial is not None else ''\n+        data_value = data if data is not None else ''\n+        return initial_value != data_value\n+\n+    def _widget_data_value(self):\n         \"\"\"\n-        Return initial data for field on form. Use initial data from the form\n-        or the field, in that order. Evaluate callable values.\n+        Returns the data value for this BoundField's widget. Subclasses\n+        should not need to override this.\n         \"\"\"\n-        value = self.initial.get(field_name, field.initial)\n-        if callable(value):\n-            value = value()\n-        # If this is an auto-generated default date, nix the microseconds\n-        # for standardized handling. See #22502.\n-        if (\n-            isinstance(value, (datetime.datetime, datetime.time))\n-            and not field.widget.supports_microseconds\n-        ):\n-            value = value.replace(microsecond=0)\n-        return value\n+        if self.field.show_hidden_initial:\n+            # For fields with callable defaults, use self.initial which properly\n+            # evaluates the callable, rather than hidden field data which may be stale\n+            if callable(self.field.initial):\n+                return self.initial\n+            return self._widget_data_value_from_datadict()\n+        else:\n+            return self.initial\n \n \n class Form(BaseForm, metaclass=DeclarativeFieldsMetaclass):\n",
    "variant_5": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..3c34704093 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,19 +136,67 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+\n     def _has_changed(self):\n         field = self.field\n         if field.show_hidden_initial:\n-            hidden_widget = field.hidden_widget()\n-            initial_value = self.form._widget_data_value(\n-                hidden_widget,\n-                self.html_initial_name,\n-            )\n-            try:\n-                initial_value = field.to_python(initial_value)\n-            except ValidationError:\n-                # Always assume data has changed if validation fails.\n-                return True\n+            # Check if field has a callable default that should be re-evaluated\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # For callable defaults, use self.initial instead of hidden widget data\n+            # to ensure the default is re-evaluated on each form processing\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # Check if the field has a callable default that should be re-evaluated\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n@@ -250,9 +298,20 @@ class BoundField:\n         id_ = widget.attrs.get(\"id\") or self.auto_id\n         return widget.id_for_label(id_)\n \n-    @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always compare against the current data.\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # Check if field has a callable default that needs re-evaluation\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                initial_value = self._widget_data_value(field.hidden_widget(), self.html_initial_name)\n+        else:\n+            initial_value = self.initial\n+        return field.widget.value_has_changed(initial_value, data)\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..b9d32ba582 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -512,22 +512,20 @@ class BaseForm(RenderableFormMixin):\n         \"\"\"\n         return [field for field in self if not field.is_hidden]\n \n-    def get_initial_for_field(self, field, field_name):\n-        \"\"\"\n-        Return initial data for field on form. Use initial data from the form\n-        or the field, in that order. Evaluate callable values.\n-        \"\"\"\n-        value = self.initial.get(field_name, field.initial)\n-        if callable(value):\n-            value = value()\n-        # If this is an auto-generated default date, nix the microseconds\n-        # for standardized handling. See #22502.\n-        if (\n-            isinstance(value, (datetime.datetime, datetime.time))\n-            and not field.widget.supports_microseconds\n-        ):\n-            value = value.replace(microsecond=0)\n-        return value\n+\n+def _has_changed(self, initial, data):\n+    \"\"\"Return True if data differs from initial.\"\"\"\n+    # Always check if the field has a callable default when using hidden initial\n+    if self.field.show_hidden_initial:\n+        # For callable defaults, use self.initial to get fresh evaluation\n+        # instead of stale serialized data from hidden fields\n+        if callable(self.field.initial):\n+            initial_value = self.initial\n+        else:\n+            initial_value = self._widget_data_value(self.form.add_initial_prefix(self.name))\n+    else:\n+        initial_value = initial\n+    return self.field.widget.value_changed(initial_value, data)\n \n \n class Form(BaseForm, metaclass=DeclarativeFieldsMetaclass):\n",
    "variant_6": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..5eed984ae6 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,8 +136,51 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # For callable defaults, use self.initial to ensure proper re-evaluation\n+            # instead of using potentially stale serialized data from hidden fields\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n     def _has_changed(self):\n         field = self.field\n+        if field.show_hidden_initial:\n+            # If the field has a callable default, use self.initial which properly\n+            # evaluates the callable instead of using stale serialized data\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n         if field.show_hidden_initial:\n             hidden_widget = field.hidden_widget()\n             initial_value = self.form._widget_data_value(\n@@ -149,6 +192,11 @@ class BoundField:\n             except ValidationError:\n                 # Always assume data has changed if validation fails.\n                 return True\n+            # If the field has a callable default, use self.initial instead\n+            # of the serialized hidden field value to ensure callable defaults\n+            # are properly re-evaluated on each form processing\n+            if callable(field.initial):\n+                initial_value = self.initial\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n@@ -250,9 +298,38 @@ class BoundField:\n         id_ = widget.attrs.get(\"id\") or self.auto_id\n         return widget.id_for_label(id_)\n \n-    @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always compare against the current data.\n+        if data is None:\n+            data_value = ''\n+        else:\n+            data_value = self.field.to_python(data)\n+            if hasattr(self.field, 'to_python'):\n+                try:\n+                    data_value = self.field.to_python(data)\n+                except ValidationError:\n+                    return True\n+\n+        if self.field.show_hidden_initial:\n+            # For callable defaults (like default=list), use self.initial which \n+            # properly re-evaluates the callable instead of using stale hidden data\n+            if callable(self.field.initial):\n+                initial_value = self.initial\n+            else:\n+                initial_prefixed_name = self.form.add_initial_prefix(self.name)\n+                hidden_widget = self.field.hidden_widget()\n+                try:\n+                    initial_value = hidden_widget.value_from_datadict(\n+                        self.form.data, self.form.files, initial_prefixed_name,\n+                    )\n+                except AttributeError:\n+                    # hidden_widget doesn't define value_from_datadict.\n+                    initial_value = self.form.initial.get(self.name, self.field.initial)\n+        else:\n+            initial_value = self.initial\n+        return self.field.has_changed(initial_value, data_value)\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..b5ec4e2916 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -512,22 +512,24 @@ class BaseForm(RenderableFormMixin):\n         \"\"\"\n         return [field for field in self if not field.is_hidden]\n \n-    def get_initial_for_field(self, field, field_name):\n-        \"\"\"\n-        Return initial data for field on form. Use initial data from the form\n-        or the field, in that order. Evaluate callable values.\n-        \"\"\"\n-        value = self.initial.get(field_name, field.initial)\n-        if callable(value):\n-            value = value()\n-        # If this is an auto-generated default date, nix the microseconds\n-        # for standardized handling. See #22502.\n-        if (\n-            isinstance(value, (datetime.datetime, datetime.time))\n-            and not field.widget.supports_microseconds\n-        ):\n-            value = value.replace(microsecond=0)\n-        return value\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always check for changes if show_hidden_initial is False\n+        if self.field.show_hidden_initial:\n+            # For callable defaults, use self.initial which properly evaluates them\n+            # instead of using stale serialized data from hidden fields\n+            if callable(self.field.initial):\n+                initial_value = self.initial\n+            else:\n+                initial_value = self._widget_data_value(self.field.widget, self.html_initial_name)\n+        else:\n+            initial_value = self.initial\n+        try:\n+            data = self.field.to_python(data)\n+        except ValidationError:\n+            return True\n+        return self.field.has_changed(initial_value, data)\n \n \n class Form(BaseForm, metaclass=DeclarativeFieldsMetaclass):\n",
    "variant_7": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..fd397b8be8 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,19 +136,68 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+\n     def _has_changed(self):\n         field = self.field\n         if field.show_hidden_initial:\n-            hidden_widget = field.hidden_widget()\n-            initial_value = self.form._widget_data_value(\n-                hidden_widget,\n-                self.html_initial_name,\n-            )\n-            try:\n-                initial_value = field.to_python(initial_value)\n-            except ValidationError:\n-                # Always assume data has changed if validation fails.\n-                return True\n+            # For callable defaults (like default=list), use self.initial to ensure\n+            # the default is re-evaluated rather than using stale serialized data\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # Check if field has a callable default that should be re-evaluated\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # For callable defaults (like default=list), we should use self.initial\n+            # instead of hidden field data to ensure the default is re-evaluated\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n@@ -250,9 +299,25 @@ class BoundField:\n         id_ = widget.attrs.get(\"id\") or self.auto_id\n         return widget.id_for_label(id_)\n \n-    @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always return False if the field is disabled since self.bound_data\n+        # always uses the initial value in this case.\n+        if self.field.disabled:\n+            return False\n+        try:\n+            data = self.field.to_python(data)\n+            if hasattr(self.field, '_coerce'):\n+                return self.field._coerce(data) != self.field._coerce(initial)\n+        except ValidationError:\n+            return True\n+        # For purposes of seeing whether something has changed, None is\n+        # the same as an empty string, if the data or initial value we get\n+        # is None, replace it with ''.\n+        initial_value = initial if initial is not None else ''\n+        data_value = data if data is not None else ''\n+        return initial_value != data_value\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..4329b215d3 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -512,22 +512,20 @@ class BaseForm(RenderableFormMixin):\n         \"\"\"\n         return [field for field in self if not field.is_hidden]\n \n-    def get_initial_for_field(self, field, field_name):\n-        \"\"\"\n-        Return initial data for field on form. Use initial data from the form\n-        or the field, in that order. Evaluate callable values.\n-        \"\"\"\n-        value = self.initial.get(field_name, field.initial)\n-        if callable(value):\n-            value = value()\n-        # If this is an auto-generated default date, nix the microseconds\n-        # for standardized handling. See #22502.\n-        if (\n-            isinstance(value, (datetime.datetime, datetime.time))\n-            and not field.widget.supports_microseconds\n-        ):\n-            value = value.replace(microsecond=0)\n-        return value\n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # If the field has a callable initial value (like default=list),\n+            # use self.initial which properly evaluates callables instead of\n+            # the serialized hidden field data which becomes stale\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                initial_value = self._widget_data_value(field.hidden_widget())\n+        else:\n+            initial_value = self.initial\n+        return field.widget.value_changed(initial_value, self.data)\n \n \n class Form(BaseForm, metaclass=DeclarativeFieldsMetaclass):\n",
    "variant_8": "diff --git a/django/forms/boundfield.py b/django/forms/boundfield.py\nindex 9f2ae59ab4..9ea62d5731 100644\n--- a/django/forms/boundfield.py\n+++ b/django/forms/boundfield.py\n@@ -136,19 +136,70 @@ class BoundField:\n             data = self.field.bound_data(self.data, data)\n         return self.field.prepare_value(data)\n \n+\n     def _has_changed(self):\n         field = self.field\n         if field.show_hidden_initial:\n-            hidden_widget = field.hidden_widget()\n-            initial_value = self.form._widget_data_value(\n-                hidden_widget,\n-                self.html_initial_name,\n-            )\n-            try:\n-                initial_value = field.to_python(initial_value)\n-            except ValidationError:\n-                # Always assume data has changed if validation fails.\n-                return True\n+            # For callable defaults (like default=list), use self.initial to ensure\n+            # the default is re-evaluated rather than using stale serialized data\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # For callable defaults (like default=list), use self.initial which properly\n+            # evaluates the callable, rather than using stale serialized data from hidden fields\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n+        else:\n+            initial_value = self.initial\n+        return field.has_changed(initial_value, self.data)\n+\n+    def _has_changed(self):\n+        field = self.field\n+        if field.show_hidden_initial:\n+            # For callable defaults (like default=list), we should use self.initial\n+            # which properly evaluates the callable, rather than the serialized\n+            # hidden field data which becomes stale\n+            if callable(field.initial):\n+                initial_value = self.initial\n+            else:\n+                hidden_widget = field.hidden_widget()\n+                initial_value = self.form._widget_data_value(\n+                    hidden_widget,\n+                    self.html_initial_name,\n+                )\n+                try:\n+                    initial_value = field.to_python(initial_value)\n+                except ValidationError:\n+                    # Always assume data has changed if validation fails.\n+                    return True\n         else:\n             initial_value = self.initial\n         return field.has_changed(initial_value, self.data)\n@@ -250,9 +301,29 @@ class BoundField:\n         id_ = widget.attrs.get(\"id\") or self.auto_id\n         return widget.id_for_label(id_)\n \n-    @cached_property\n-    def initial(self):\n-        return self.form.get_initial_for_field(self.field, self.name)\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always compare against the current data.\n+        if data is None:\n+            data_value = ''\n+        else:\n+            data_value = self.field.to_python(data)\n+            if hasattr(self.field, 'to_python'):\n+                try:\n+                    data_value = self.field.to_python(data)\n+                except ValidationError:\n+                    return True\n+\n+        if self.field.show_hidden_initial:\n+            # For fields with callable defaults, use self.initial to get fresh evaluation\n+            if callable(self.field.initial):\n+                initial_value = self.initial\n+            else:\n+                initial_value = self._widget_data_value(self.field.widget, initial)\n+        else:\n+            initial_value = self.initial\n+        return self.field.has_changed(initial_value, data_value)\n \n     def build_widget_attrs(self, attrs, widget=None):\n         widget = widget or self.field.widget\ndiff --git a/django/forms/forms.py b/django/forms/forms.py\nindex 6884e6e724..67231c6548 100644\n--- a/django/forms/forms.py\n+++ b/django/forms/forms.py\n@@ -512,22 +512,25 @@ class BaseForm(RenderableFormMixin):\n         \"\"\"\n         return [field for field in self if not field.is_hidden]\n \n-    def get_initial_for_field(self, field, field_name):\n-        \"\"\"\n-        Return initial data for field on form. Use initial data from the form\n-        or the field, in that order. Evaluate callable values.\n-        \"\"\"\n-        value = self.initial.get(field_name, field.initial)\n-        if callable(value):\n-            value = value()\n-        # If this is an auto-generated default date, nix the microseconds\n-        # for standardized handling. See #22502.\n-        if (\n-            isinstance(value, (datetime.datetime, datetime.time))\n-            and not field.widget.supports_microseconds\n-        ):\n-            value = value.replace(microsecond=0)\n-        return value\n+\n+    def _has_changed(self, initial, data):\n+        \"\"\"Return True if data differs from initial.\"\"\"\n+        # Always check the field's show_hidden_initial attribute if it's a\n+        # BoundField.\n+        if self.field.show_hidden_initial:\n+            # For callable defaults, use self.initial to ensure proper re-evaluation\n+            # instead of stale serialized data from hidden fields\n+            if callable(self.field.initial):\n+                initial_value = self.initial\n+            else:\n+                initial_value = self._widget_data_value(self.field.widget, self.html_initial_name)\n+        else:\n+            initial_value = initial\n+        try:\n+            data = self.field.to_python(data)\n+        except ValidationError:\n+            return True\n+        return self.field.has_changed(initial_value, data)\n \n \n class Form(BaseForm, metaclass=DeclarativeFieldsMetaclass):\n"
  }
}