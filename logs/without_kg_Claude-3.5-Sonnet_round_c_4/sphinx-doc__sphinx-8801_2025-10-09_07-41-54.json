{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/sphinx/sphinx/util/inspect.py lines 892-918)": "\ndef getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n           allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n    \"\"\"Get the docstring for the object.\n\n    This tries to obtain the docstring for some kind of objects additionally:\n\n    * partial functions\n    * inherited docstring\n    * inherited decorated methods\n    \"\"\"\n    doc = attrgetter(obj, '__doc__', None)\n    if ispartial(obj) and doc == obj.__class__.__doc__:\n        return getdoc(obj.func)\n    elif doc is None and allow_inherited:\n        doc = inspect.getdoc(obj)\n\n        if doc is None and cls and name:\n            # inspect.getdoc() does not support some kind of inherited and decorated methods.\n            # This tries to obtain the docstring from super classes.\n            for basecls in getattr(cls, '__mro__', []):\n                meth = safe_getattr(basecls, name, None)\n                if meth is not None:\n                    doc = inspect.getdoc(meth)\n                    if doc:\n                        break\n            \n            # If still no doc found, check for annotation comments in superclasses\n            if doc is None:\n                for basecls in getattr(cls, '__mro__', []):\n                    # Skip the current class to only check inherited members\n                    if basecls is cls:\n                        continue\n                    \n                    # Check if the attribute exists in this base class\n                    if hasattr(basecls, '__annotations__') and name in basecls.__annotations__:\n                        # Try to get annotation comment from the base class module\n                        try:\n                            from sphinx.pycode import ModuleAnalyzer\n                            analyzer = ModuleAnalyzer.for_module(basecls.__module__)\n                            analyzer.analyze()\n                            if hasattr(analyzer, 'attr_docs') and analyzer.attr_docs:\n                                # Look for annotation comment in the base class\n                                qualified_name = f\"{basecls.__qualname__}.{name}\"\n                                if qualified_name in analyzer.attr_docs:\n                                    doc = '\\n'.join(analyzer.attr_docs[qualified_name])\n                                    break\n                        except Exception:\n                            # If ModuleAnalyzer fails, continue to next base class\n                            continue\n\n    return doc\n",
    "Location 2 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/__init__.py lines 713-714)": "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name)\n            \n            # For inherited annotation-only members, try to get annotation comment documentation\n            if not doc and member is INSTANCEATTR and self.parent:\n                # Check if this is an annotation-only member from a superclass\n                for cls in inspect.getmro(self.parent):\n                    if cls is self.parent:\n                        continue\n                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n                        # Try to get annotation comment from the defining class's module\n                        try:\n                            analyzer = ModuleAnalyzer.for_module(cls.__module__)\n                            analyzer.analyze()\n                            attr_docs = analyzer.find_attr_docs()\n                            if (cls.__name__, membername) in attr_docs:\n                                doc = '\\n'.join(attr_docs[(cls.__name__, membername)])\n                                break\n                        except (PycodeError, AttributeError):\n                            pass\n",
    "Location 3 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/__init__.py lines 731-731)": "\n            # Enhanced logic to handle annotation comment documentation for inherited members\n            has_doc = bool(doc)\n            \n            # If no doc found and this is an annotation-only member, check for annotation comments\n            if not has_doc and isinstance(obj, ObjectMember) and not obj.value:\n                # This is likely an annotation-only member, try to get annotation comment doc\n                try:\n                    # Get the class that actually defines this member\n                    defining_class = None\n                    for cls in inspect.getmro(self.object):\n                        if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n                            defining_class = cls\n                            break\n                    \n                    if defining_class and defining_class != self.object:\n                        # This is an inherited annotation, check for annotation comment in the defining module\n                        defining_module = inspect.getmodule(defining_class)\n                        if defining_module:\n                            try:\n                                analyzer = ModuleAnalyzer.for_module(defining_module.__name__)\n                                analyzer.analyze()\n                                # Look for annotation comment documentation\n                                qualname = f\"{defining_class.__qualname__}.{membername}\"\n                                if qualname in analyzer.attr_docs:\n                                    doc = '\\n'.join(analyzer.attr_docs[qualname])\n                                    has_doc = bool(doc)\n                            except (PycodeError, AttributeError):\n                                pass\n                except Exception:\n                    # If anything goes wrong, fall back to the original behavior\n                    pass\n",
    "Location 4 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/__init__.py lines 787-787)": "\n                    keep = has_doc or self.options.undoc_members\n                    \n                    # Special handling for annotation-only inherited members\n                    if not keep and not has_doc and isinstance(obj, ObjectMember):\n                        # Check if this is an annotation-only member from a superclass\n                        # that might have annotation comment documentation\n                        if (hasattr(self.object, '__mro__') and \n                            hasattr(obj, 'class_') and obj.class_ != self.object):\n                            # This is an inherited member, try to get annotation comment doc\n                            try:\n                                from sphinx.pycode import ModuleAnalyzer\n                                analyzer = ModuleAnalyzer.for_module(obj.class_.__module__)\n                                analyzer.analyze()\n                                if analyzer.annotations.get(membername):\n                                    # Has annotation comment documentation\n                                    keep = True\n                            except (PycodeError, AttributeError):\n                                pass\n",
    "Location 5 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/importer.py lines 228-233)": "\n    # annotation only member (ex. attr: int)\n    for i, cls in enumerate(getmro(subject)):\n        for name in getannotations(cls):\n            name = unmangle(cls, name)\n            if name and name not in members:\n                # Store additional metadata about the defining class and module\n                # to help with annotation comment lookup for inherited members\n                attr_value = INSTANCEATTR\n                if hasattr(attr_value, '__dict__'):\n                    # If INSTANCEATTR is mutable, we can't modify it directly\n                    # Create a simple container for the metadata\n                    class AnnotationMember:\n                        def __init__(self, value, defining_class, defining_module):\n                            self.value = value\n                            self.defining_class = defining_class\n                            self.defining_module = defining_module\n                        \n                        def __repr__(self):\n                            return repr(self.value)\n                    \n                    attr_value = AnnotationMember(INSTANCEATTR, cls, getattr(cls, '__module__', None))\n                \n                members[name] = Attribute(name, i == 0, attr_value)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/sphinx/sphinx/util/inspect.py lines 892-918)": [
      "\ndef getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n           allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n    \"\"\"Get the docstring for the object.\n\n    This tries to obtain the docstring for some kind of objects additionally:\n\n    * partial functions\n    * inherited docstring\n    * inherited decorated methods\n    \"\"\"\n    doc = attrgetter(obj, '__doc__', None)\n    if ispartial(obj) and doc == obj.__class__.__doc__:\n        return getdoc(obj.func)\n    elif doc is None and allow_inherited:\n        doc = inspect.getdoc(obj)\n\n        if doc is None and cls and name:\n            # inspect.getdoc() does not support some kind of inherited and decorated methods.\n            # This tries to obtain the docstring from super classes.\n            for basecls in getattr(cls, '__mro__', []):\n                meth = safe_getattr(basecls, name, None)\n                if meth is not None:\n                    doc = inspect.getdoc(meth)\n                    if doc:\n                        break\n            \n            # If still no doc found, check for annotation comments in superclasses\n            if doc is None:\n                from sphinx.pycode import ModuleAnalyzer\n                for basecls in getattr(cls, '__mro__', []):\n                    # Check if the attribute exists as an annotation in this base class\n                    if (hasattr(basecls, '__annotations__') and \n                        name in basecls.__annotations__ and\n                        hasattr(basecls, '__module__')):\n                        try:\n                            analyzer = ModuleAnalyzer.for_module(basecls.__module__)\n                            analyzer.parse()\n                            if hasattr(analyzer, 'attr_docs') and analyzer.attr_docs:\n                                # Look for annotation comment for this attribute\n                                qualname = f\"{basecls.__qualname__}.{name}\"\n                                if qualname in analyzer.attr_docs:\n                                    doc = '\\n'.join(analyzer.attr_docs[qualname])\n                                    break\n                        except Exception:\n                            # If we can't analyze the module, continue to next base class\n                            continue\n\n    return doc\n",
      "\ndef getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n           allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n    \"\"\"Get the docstring for the object.\n\n    This tries to obtain the docstring for some kind of objects additionally:\n\n    * partial functions\n    * inherited docstring\n    * inherited decorated methods\n    \"\"\"\n    doc = attrgetter(obj, '__doc__', None)\n    if ispartial(obj) and doc == obj.__class__.__doc__:\n        return getdoc(obj.func)\n    elif doc is None and allow_inherited:\n        doc = inspect.getdoc(obj)\n\n        if doc is None and cls and name:\n            # inspect.getdoc() does not support some kind of inherited and decorated methods.\n            # This tries to obtain the docstring from super classes.\n            for basecls in getattr(cls, '__mro__', []):\n                meth = safe_getattr(basecls, name, None)\n                if meth is not None:\n                    doc = inspect.getdoc(meth)\n                    if doc:\n                        break\n            \n            # If still no doc found, check for annotation comments in superclasses\n            if doc is None:\n                for basecls in getattr(cls, '__mro__', []):\n                    if hasattr(basecls, '__annotations__') and name in basecls.__annotations__:\n                        # Found annotation in this class, try to get comment doc\n                        try:\n                            from sphinx.pycode import ModuleAnalyzer\n                            module = inspect.getmodule(basecls)\n                            if module and hasattr(module, '__file__') and module.__file__:\n                                analyzer = ModuleAnalyzer.for_module(module.__name__)\n                                analyzer.analyze()\n                                attr_docs = analyzer.find_attr_docs()\n                                if (basecls.__name__, name) in attr_docs:\n                                    doc = '\\n'.join(attr_docs[(basecls.__name__, name)])\n                                    if doc:\n                                        break\n                        except Exception:\n                            # If analyzer fails, continue searching\n                            pass\n\n    return doc\n",
      "\ndef getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n           allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n    \"\"\"Get the docstring for the object.\n\n    This tries to obtain the docstring for some kind of objects additionally:\n\n    * partial functions\n    * inherited docstring\n    * inherited decorated methods\n    \"\"\"\n    doc = attrgetter(obj, '__doc__', None)\n    if ispartial(obj) and doc == obj.__class__.__doc__:\n        return getdoc(obj.func)\n    elif doc is None and allow_inherited:\n        doc = inspect.getdoc(obj)\n\n        if doc is None and cls and name:\n            # inspect.getdoc() does not support some kind of inherited and decorated methods.\n            # This tries to obtain the docstring from super classes.\n            for basecls in getattr(cls, '__mro__', []):\n                meth = safe_getattr(basecls, name, None)\n                if meth is not None:\n                    doc = inspect.getdoc(meth)\n                    if doc:\n                        break\n            \n            # If still no doc found, check for annotation comments in superclasses\n            if doc is None:\n                from sphinx.pycode import ModuleAnalyzer\n                for basecls in getattr(cls, '__mro__', []):\n                    if hasattr(basecls, '__module__') and hasattr(basecls, '__annotations__'):\n                        if name in basecls.__annotations__:\n                            try:\n                                analyzer = ModuleAnalyzer.for_module(basecls.__module__)\n                                analyzer.analyze()\n                                if hasattr(analyzer, 'attr_docs') and analyzer.attr_docs:\n                                    attr_docs = analyzer.attr_docs\n                                    if (basecls.__name__, name) in attr_docs:\n                                        doc = '\\n'.join(attr_docs[(basecls.__name__, name)])\n                                        break\n                            except Exception:\n                                # If analysis fails, continue to next base class\n                                continue\n\n    return doc\n",
      "\ndef getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n           allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n    \"\"\"Get the docstring for the object.\n\n    This tries to obtain the docstring for some kind of objects additionally:\n\n    * partial functions\n    * inherited docstring\n    * inherited decorated methods\n    * annotation comments for inherited members\n    \"\"\"\n    doc = attrgetter(obj, '__doc__', None)\n    if ispartial(obj) and doc == obj.__class__.__doc__:\n        return getdoc(obj.func)\n    elif doc is None and allow_inherited:\n        doc = inspect.getdoc(obj)\n\n        if doc is None and cls and name:\n            # inspect.getdoc() does not support some kind of inherited and decorated methods.\n            # This tries to obtain the docstring from super classes.\n            for basecls in getattr(cls, '__mro__', []):\n                meth = safe_getattr(basecls, name, None)\n                if meth is not None:\n                    doc = inspect.getdoc(meth)\n                    if doc:\n                        break\n            \n            # If still no doc found, try to get annotation comment from superclass modules\n            if doc is None:\n                from sphinx.pycode import ModuleAnalyzer\n                for basecls in getattr(cls, '__mro__', []):\n                    if hasattr(basecls, name):\n                        try:\n                            module = inspect.getmodule(basecls)\n                            if module and hasattr(module, '__file__') and module.__file__:\n                                analyzer = ModuleAnalyzer.for_module(module.__name__)\n                                analyzer.parse()\n                                qualname = f\"{basecls.__name__}.{name}\"\n                                if qualname in analyzer.attr_docs:\n                                    doc = '\\n'.join(analyzer.attr_docs[qualname])\n                                    if doc:\n                                        break\n                        except Exception:\n                            # If analysis fails, continue to next base class\n                            continue\n\n    return doc or ''\n",
      "\ndef getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n           allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n    \"\"\"Get the docstring for the object.\n\n    This tries to obtain the docstring for some kind of objects additionally:\n\n    * partial functions\n    * inherited docstring\n    * inherited decorated methods\n    \"\"\"\n    doc = attrgetter(obj, '__doc__', None)\n    if ispartial(obj) and doc == obj.__class__.__doc__:\n        return getdoc(obj.func)\n    elif doc is None and allow_inherited:\n        doc = inspect.getdoc(obj)\n\n        if doc is None and cls:\n            # inspect.getdoc() does not support some kind of inherited and decorated methods.\n            # This tries to obtain the docstring from super classes.\n            for basecls in getattr(cls, '__mro__', []):\n                meth = safe_getattr(basecls, name, None)\n                if meth is not None:\n                    doc = inspect.getdoc(meth)\n                    if doc:\n                        break\n            \n            # If still no doc found, try to get annotation comment documentation\n            # from the class where the attribute is defined\n            if doc is None and name:\n                for basecls in getattr(cls, '__mro__', []):\n                    if hasattr(basecls, '__annotations__') and name in basecls.__annotations__:\n                        # Found the class that defines this annotation\n                        try:\n                            from sphinx.pycode import ModuleAnalyzer\n                            modname = getattr(basecls, '__module__', None)\n                            if modname:\n                                analyzer = ModuleAnalyzer.for_module(modname)\n                                analyzer.analyze()\n                                attr_docs = analyzer.find_attr_docs()\n                                # Look for annotation comment in the defining class\n                                qualname = getattr(basecls, '__qualname__', basecls.__name__)\n                                if (qualname, name) in attr_docs:\n                                    doc = '\\n'.join(attr_docs[(qualname, name)])\n                                    break\n                        except Exception:\n                            # If analysis fails, continue without annotation comment doc\n                            pass\n\n    return doc\n",
      "\ndef getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n           allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n    \"\"\"Get the docstring for the object.\n\n    This tries to obtain the docstring for some kind of objects additionally:\n\n    * partial functions\n    * inherited docstring\n    * inherited decorated methods\n    \"\"\"\n    doc = attrgetter(obj, '__doc__', None)\n    if ispartial(obj) and doc == obj.__class__.__doc__:\n        return getdoc(obj.func)\n    elif doc is None and allow_inherited:\n        doc = inspect.getdoc(obj)\n\n        if doc is None and cls and name:\n            # inspect.getdoc() does not support some kind of inherited and decorated methods.\n            # This tries to obtain the docstring from super classes.\n            for basecls in getattr(cls, '__mro__', []):\n                meth = safe_getattr(basecls, name, None)\n                if meth is not None:\n                    doc = inspect.getdoc(meth)\n                    if doc:\n                        break\n            \n            # If still no doc, try to get annotation comment from superclass modules\n            if doc is None:\n                from sphinx.pycode import ModuleAnalyzer\n                for basecls in getattr(cls, '__mro__', []):\n                    if hasattr(basecls, '__annotations__') and name in basecls.__annotations__:\n                        try:\n                            module = inspect.getmodule(basecls)\n                            if module and hasattr(module, '__file__') and module.__file__:\n                                analyzer = ModuleAnalyzer.for_module(module.__name__)\n                                analyzer.analyze()\n                                qualname = f\"{basecls.__name__}.{name}\"\n                                if qualname in analyzer.attr_docs:\n                                    doc = '\\n'.join(analyzer.attr_docs[qualname])\n                                    break\n                        except Exception:\n                            # If we can't analyze the module, continue to next base class\n                            continue\n\n    return doc\n",
      "\ndef getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n           allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n    \"\"\"Get the docstring for the object.\n\n    This tries to obtain the docstring for some kind of objects additionally:\n\n    * partial functions\n    * inherited docstring\n    * inherited decorated methods\n    \"\"\"\n    doc = attrgetter(obj, '__doc__', None)\n    if ispartial(obj) and doc == obj.__class__.__doc__:\n        return getdoc(obj.func)\n    elif doc is None and allow_inherited:\n        doc = inspect.getdoc(obj)\n\n        if doc is None and cls and name:\n            # inspect.getdoc() does not support some kind of inherited and decorated methods.\n            # This tries to obtain the docstring from super classes.\n            for basecls in getattr(cls, '__mro__', []):\n                meth = safe_getattr(basecls, name, None)\n                if meth is not None:\n                    doc = inspect.getdoc(meth)\n                    if doc:\n                        break\n            \n            # If still no doc found, check for annotation comments in superclass modules\n            if doc is None:\n                try:\n                    from sphinx.pycode import ModuleAnalyzer\n                    for basecls in getattr(cls, '__mro__', []):\n                        if hasattr(basecls, '__module__') and hasattr(basecls, '__annotations__'):\n                            if name in basecls.__annotations__:\n                                try:\n                                    analyzer = ModuleAnalyzer.for_module(basecls.__module__)\n                                    analyzer.analyze()\n                                    # Get annotation comments for the class\n                                    attr_docs = analyzer.find_attr_docs()\n                                    # Look for the attribute in this class\n                                    class_name = basecls.__name__\n                                    attr_key = (class_name, name)\n                                    if attr_key in attr_docs:\n                                        doc = attr_docs[attr_key]\n                                        break\n                                except Exception:\n                                    # If analysis fails, continue to next class\n                                    continue\n                except ImportError:\n                    # ModuleAnalyzer not available, skip annotation comment lookup\n                    pass\n\n    return doc\n",
      "\ndef getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n           allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n    \"\"\"Get the docstring for the object.\n\n    This tries to obtain the docstring for some kind of objects additionally:\n\n    * partial functions\n    * inherited docstring\n    * inherited decorated methods\n    \"\"\"\n    doc = attrgetter(obj, '__doc__', None)\n    if ispartial(obj) and doc == obj.__class__.__doc__:\n        return getdoc(obj.func)\n    elif doc is None and allow_inherited:\n        doc = inspect.getdoc(obj)\n\n        if doc is None and cls and name:\n            # inspect.getdoc() does not support some kind of inherited and decorated methods.\n            # This tries to obtain the docstring from super classes.\n            for basecls in getattr(cls, '__mro__', []):\n                meth = safe_getattr(basecls, name, None)\n                if meth is not None:\n                    doc = inspect.getdoc(meth)\n                    if doc:\n                        break\n            \n            # If still no doc found, try to get annotation comment from superclass modules\n            if doc is None:\n                for basecls in getattr(cls, '__mro__', []):\n                    if hasattr(basecls, '__annotations__') and name in basecls.__annotations__:\n                        try:\n                            from sphinx.pycode import ModuleAnalyzer\n                            module = inspect.getmodule(basecls)\n                            if module and hasattr(module, '__file__') and module.__file__:\n                                analyzer = ModuleAnalyzer.for_module(module.__name__)\n                                analyzer.analyze()\n                                # Get annotation comment for the attribute\n                                attr_doc = analyzer.attr_docs.get((basecls.__name__, name))\n                                if attr_doc:\n                                    doc = '\\n'.join(attr_doc)\n                                    break\n                        except Exception:\n                            # If ModuleAnalyzer fails, continue to next base class\n                            continue\n\n    return doc\n"
    ],
    "Location 2 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/__init__.py lines 713-714)": [
      "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name)\n            if not isinstance(doc, str):\n                # Ignore non-string __doc__\n                doc = None\n            \n            # For inherited annotation-only members, try to get annotation comment documentation\n            if doc is None and member is INSTANCEATTR and self.parent:\n                try:\n                    # Find which class this annotation comes from\n                    for cls in inspect.getmro(self.parent):\n                        if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n                            # Try to get annotation comment from the defining class's module\n                            cls_module = safe_getattr(cls, '__module__', None)\n                            if cls_module:\n                                try:\n                                    from sphinx.pycode import ModuleAnalyzer\n                                    analyzer = ModuleAnalyzer.for_module(cls_module)\n                                    analyzer.analyze()\n                                    # Get annotation comment for this member\n                                    if hasattr(analyzer, 'attr_docs') and cls.__name__ in analyzer.attr_docs:\n                                        attr_docs = analyzer.attr_docs[cls.__name__]\n                                        if membername in attr_docs:\n                                            doc = '\\n'.join(attr_docs[membername])\n                                            break\n                                except (PycodeError, ImportError, AttributeError):\n                                    continue\n                            break\n                except Exception:\n                    # Fallback to original behavior if anything goes wrong\n                    pass\n",
      "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name, self.analyzer)\n",
      "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name)\n            if not isinstance(doc, str):\n                # Ignore non-string __doc__\n                doc = None\n            \n            # For inherited annotation-only members, try to get annotation comment documentation\n            if doc is None and member is INSTANCEATTR and self.parent:\n                # Try to find annotation comment documentation from the defining class\n                for base in inspect.getmro(self.parent):\n                    if hasattr(base, '__annotations__') and membername in base.__annotations__:\n                        try:\n                            from sphinx.pycode import ModuleAnalyzer\n                            analyzer = ModuleAnalyzer.for_module(base.__module__)\n                            analyzer.find_attr_docs()\n                            if hasattr(analyzer, 'attr_docs') and (base.__name__, membername) in analyzer.attr_docs:\n                                doc = '\\n'.join(analyzer.attr_docs[(base.__name__, membername)])\n                                break\n                        except (ImportError, PycodeError, AttributeError):\n                            continue\n",
      "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name, membername)\n",
      "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name)\n            \n            # If no doc found and member is an annotation-only attribute, try to get\n            # annotation comment from the defining class\n            if not doc and member is INSTANCEATTR:\n                # Try to find annotation comment for inherited annotation-only members\n                from sphinx.pycode import ModuleAnalyzer, PycodeError\n                \n                # Look through the MRO to find where this annotation is defined\n                for cls in inspect.getmro(self.object):\n                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n                        try:\n                            # Get the module where this class is defined\n                            cls_module = inspect.getmodule(cls)\n                            if cls_module and hasattr(cls_module, '__file__') and cls_module.__file__:\n                                analyzer = ModuleAnalyzer.for_module(cls_module.__name__)\n                                analyzer.find_attr_docs()\n                                # Look for annotation comment in the defining class\n                                qualname = f\"{cls.__name__}.{membername}\"\n                                if qualname in analyzer.attr_docs:\n                                    doc = '\\n'.join(analyzer.attr_docs[qualname])\n                                    break\n                        except (PycodeError, AttributeError):\n                            continue\n",
      "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name)\n            \n            # For inherited annotation-only members, try to get annotation comment documentation\n            if not doc and member is INSTANCEATTR and self.parent:\n                # Try to find annotation comment documentation from the defining class\n                for cls in inspect.getmro(self.parent):\n                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n                        try:\n                            analyzer = ModuleAnalyzer.for_module(cls.__module__)\n                            analyzer.find_attr_docs()\n                            if cls.__name__ in analyzer.attr_docs:\n                                cls_attr_docs = analyzer.attr_docs[cls.__name__]\n                                if membername in cls_attr_docs:\n                                    doc = '\\n'.join(cls_attr_docs[membername])\n                                    break\n                        except (PycodeError, AttributeError):\n                            continue\n",
      "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name)\n            \n            # For inherited annotation-only members, try to get annotation comment documentation\n            if not isinstance(doc, str) and member is INSTANCEATTR:\n                # Check if this is an inherited annotation-only member\n                for cls in inspect.getmro(self.object):\n                    if cls is self.object:\n                        continue\n                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n                        # Try to get annotation comment from the defining class's module\n                        try:\n                            analyzer = ModuleAnalyzer.for_module(cls.__module__)\n                            analyzer.find_attr_docs()\n                            qualname = f\"{cls.__qualname__}.{membername}\"\n                            if qualname in analyzer.attr_docs:\n                                doc = '\\n'.join(analyzer.attr_docs[qualname])\n                                break\n                        except (PycodeError, AttributeError):\n                            continue\n",
      "\n            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                         self.parent, self.object_name)\n            if not isinstance(doc, str):\n                # Ignore non-string __doc__\n                doc = None\n            \n            # For inherited annotation-only members, try to get annotation comment documentation\n            if doc is None and member is INSTANCEATTR and self.parent:\n                try:\n                    # Find which class this annotation comes from\n                    for cls in inspect.getmro(self.parent):\n                        if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n                            # Try to get annotation comment from the defining class's module\n                            cls_module = safe_getattr(cls, '__module__', None)\n                            if cls_module:\n                                try:\n                                    from sphinx.pycode import ModuleAnalyzer\n                                    analyzer = ModuleAnalyzer.for_module(cls_module)\n                                    analyzer.analyze()\n                                    # Look for annotation comment in the defining class\n                                    qualname = getattr(cls, '__qualname__', cls.__name__)\n                                    attr_key = f\"{qualname}.{membername}\"\n                                    if attr_key in analyzer.attr_docs:\n                                        doc = '\\n'.join(analyzer.attr_docs[attr_key])\n                                        break\n                                except (PycodeError, ImportError):\n                                    continue\n                            break\n                except Exception:\n                    # If anything fails, continue with doc = None\n                    pass\n"
    ],
    "Location 3 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/__init__.py lines 731-731)": [
      "\n            has_doc = bool(doc)\n            \n            # For inherited annotation-only members, check for annotation comment documentation\n            if not has_doc and isinstance(obj, ObjectMember) and obj.skipped:\n                # This is likely an annotation-only member from a superclass\n                # Try to find annotation comment documentation from the defining class\n                for cls in inspect.getmro(self.object):\n                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n                        try:\n                            analyzer = ModuleAnalyzer.for_module(cls.__module__)\n                            attr_docs = analyzer.find_attr_docs()\n                            if (cls.__name__, membername) in attr_docs:\n                                doc = '\\n'.join(attr_docs[(cls.__name__, membername)])\n                                has_doc = bool(doc)\n                                break\n                        except (PycodeError, AttributeError):\n                            continue\n",
      "\n            has_doc = bool(doc)\n\n            # Check for annotation comment documentation for inherited members\n            if not has_doc and isinstance(obj, ObjectMember) and obj.object is INSTANCEATTR:\n                # Try to find annotation comment documentation from the defining class\n                for cls in inspect.getmro(self.object):\n                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n                        try:\n                            analyzer = ModuleAnalyzer.for_module(cls.__module__)\n                            analyzer.analyze()\n                            if membername in analyzer.attr_docs:\n                                doc = '\\n'.join(analyzer.attr_docs[membername])\n                                has_doc = bool(doc)\n                                break\n                        except (PycodeError, AttributeError):\n                            continue\n",
      "\n            # Check for annotation comment documentation for inherited members\n            if not doc and isinstance(obj, ObjectMember):\n                # Try to get annotation comment from the defining class\n                try:\n                    from sphinx.pycode import ModuleAnalyzer\n                    defining_class = getattr(obj, 'class', None)\n                    if defining_class and hasattr(defining_class, '__module__'):\n                        analyzer = ModuleAnalyzer.for_module(defining_class.__module__)\n                        analyzer.analyze()\n                        if membername in analyzer.attr_docs:\n                            doc = '\\n'.join(analyzer.attr_docs[membername])\n                except (PycodeError, ImportError, AttributeError):\n                    pass\n\n            has_doc = bool(doc)\n",
      "\n            has_doc = bool(doc)\n            \n            # For inherited annotation-only members, check for annotation comments in the source class\n            if not has_doc and isinstance(obj, ObjectMember) and obj.class_ is not None:\n                try:\n                    # Get the module where the annotation was defined\n                    source_module = inspect.getmodule(obj.class_)\n                    if source_module:\n                        from sphinx.pycode import ModuleAnalyzer\n                        analyzer = ModuleAnalyzer.for_module(source_module.__name__)\n                        analyzer.analyze()\n                        \n                        # Look for annotation comment in the source class\n                        qualname = f\"{obj.class_.__name__}.{membername}\"\n                        if qualname in analyzer.annotations:\n                            annotation_doc = analyzer.annotations[qualname]\n                            if annotation_doc:\n                                doc = annotation_doc\n                                has_doc = True\n                except (PycodeError, ImportError, AttributeError):\n                    # If we can't analyze the source module, continue without doc\n                    pass\n",
      "\n            has_doc = bool(doc)\n            \n            # For inherited annotation-only members, check for annotation comments\n            if not has_doc and isinstance(obj, ObjectMember) and obj.class_ != self.object:\n                # This is an inherited annotation-only member, try to get annotation comment doc\n                try:\n                    from sphinx.pycode import ModuleAnalyzer\n                    defining_class = obj.class_\n                    if defining_class and hasattr(defining_class, '__module__'):\n                        analyzer = ModuleAnalyzer.for_module(defining_class.__module__)\n                        analyzer.find_attr_docs()\n                        qualname = f\"{defining_class.__qualname__}.{membername}\"\n                        if qualname in analyzer.attr_docs:\n                            doc = '\\n'.join(analyzer.attr_docs[qualname])\n                            has_doc = bool(doc)\n                except (PycodeError, AttributeError, ImportError):\n                    pass\n",
      "\n            has_doc = bool(doc)\n\n            # For inherited annotation-only members, check for annotation comment documentation\n            if not has_doc and isinstance(obj, ObjectMember) and obj.class_ and obj.class_ != self.object:\n                # This is an inherited annotation-only member\n                try:\n                    from sphinx.pycode import ModuleAnalyzer\n                    analyzer = ModuleAnalyzer.for_module(obj.class_.__module__)\n                    analyzer.find_attr_docs()\n                    qualname = f\"{obj.class_.__qualname__}.{membername}\"\n                    if qualname in analyzer.attr_docs:\n                        has_doc = True\n                except (PycodeError, AttributeError):\n                    pass\n",
      "\n            has_doc = bool(doc)\n            \n            # For inherited annotation-only members, check for annotation comment documentation\n            if not has_doc and isinstance(obj, ObjectMember) and not obj.docstring:\n                # Try to find annotation comment documentation from the defining class\n                for cls in inspect.getmro(self.object):\n                    if cls is self.object:\n                        continue\n                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n                        try:\n                            analyzer = ModuleAnalyzer.for_module(cls.__module__)\n                            analyzer.find_attr_docs()\n                            if (cls.__name__, membername) in analyzer.attr_docs:\n                                doc = '\\n'.join(analyzer.attr_docs[(cls.__name__, membername)])\n                                has_doc = bool(doc)\n                                break\n                        except (PycodeError, AttributeError):\n                            continue\n",
      "\n            has_doc = bool(doc)\n            \n            # Check for annotation comment documentation for inherited members\n            if not has_doc and isinstance(obj, ObjectMember) and obj.class_doc is None:\n                # Try to get annotation comment from the defining class\n                try:\n                    if hasattr(self, 'analyzer') and self.analyzer:\n                        # Check if this is an annotation-only member from a superclass\n                        for cls in inspect.getmro(self.object):\n                            if cls is self.object:\n                                continue\n                            if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n                                # Found the defining class, try to get annotation comment\n                                try:\n                                    cls_analyzer = ModuleAnalyzer.for_module(cls.__module__)\n                                    cls_analyzer.analyze()\n                                    if hasattr(cls_analyzer, 'attr_docs') and cls_analyzer.attr_docs:\n                                        attr_doc = cls_analyzer.attr_docs.get((cls.__name__, membername))\n                                        if attr_doc:\n                                            doc = '\\n'.join(attr_doc)\n                                            has_doc = True\n                                            break\n                                except (PycodeError, AttributeError):\n                                    pass\n                                break\n                except (AttributeError, TypeError):\n                    pass\n"
    ],
    "Location 4 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/__init__.py lines 787-787)": [
      "\n                    keep = has_doc or self.options.undoc_members\n",
      "\n                    # ignore undocumented members if :undoc-members: is not given\n                    keep = has_doc or self.options.undoc_members\n                    \n                    # Special handling for inherited annotation-only members\n                    if not keep and not has_doc and isinstance(obj, ObjectMember):\n                        # Check if this is an annotation-only member from a superclass\n                        # that might have annotation comment documentation\n                        if hasattr(obj, 'class_') and obj.class_ != self.object:\n                            try:\n                                analyzer = ModuleAnalyzer.for_module(obj.class_.__module__)\n                                analyzer.find_attr_docs()\n                                qualname = f\"{obj.class_.__qualname__}.{name}\"\n                                if qualname in analyzer.attr_docs:\n                                    keep = True\n                            except (PycodeError, AttributeError):\n                                pass\n",
      "\n                    keep = has_doc or self.options.undoc_members\n                    \n                    # Special handling for annotation-only inherited members\n                    if not keep and not has_doc and isinstance(obj, ObjectMember):\n                        # Check if this is an annotation-only member from a superclass\n                        # that might have annotation comment documentation\n                        if (hasattr(self.object, '__mro__') and \n                            hasattr(obj.object, '__annotations__')):\n                            for base_cls in self.object.__mro__[1:]:  # Skip self\n                                if (hasattr(base_cls, '__annotations__') and \n                                    membername in base_cls.__annotations__):\n                                    try:\n                                        analyzer = ModuleAnalyzer.for_module(base_cls.__module__)\n                                        analyzer.find_attr_docs()\n                                        qualname = f\"{base_cls.__qualname__}.{membername}\"\n                                        if qualname in analyzer.attr_docs:\n                                            keep = True\n                                            break\n                                    except (PycodeError, AttributeError):\n                                        continue\n",
      "\n                    doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,\n                                self.parent, self.object_name)\n",
      "\n                    keep = has_doc or self.options.undoc_members\n                    \n                    # Check for annotation comment documentation for inherited members\n                    if not keep and not has_doc and isinstance(obj, ObjectMember):\n                        # Try to get annotation comment doc from the defining class\n                        if hasattr(obj, 'class_') and obj.class_ != self.object:\n                            try:\n                                analyzer = ModuleAnalyzer.for_module(obj.class_.__module__)\n                                qualname = f\"{obj.class_.__qualname__}.{membername}\"\n                                attr_docs = analyzer.find_attr_docs()\n                                if qualname in attr_docs:\n                                    keep = True\n                            except (PycodeError, AttributeError):\n                                pass\n",
      "\n                    keep = has_doc or self.options.undoc_members\n                    \n                    # Special case for annotation-only inherited members with annotation comments\n                    if not keep and not has_doc and isinstance(obj, ObjectMember):\n                        if (hasattr(obj.object, '__annotations__') and \n                            membername in getattr(obj.object, '__annotations__', {})):\n                            # Check if this annotation-only member has annotation comment documentation\n                            # in the defining class by looking up the MRO\n                            for base_cls in getattr(obj.object, '__mro__', []):\n                                if hasattr(base_cls, '__annotations__') and membername in base_cls.__annotations__:\n                                    try:\n                                        analyzer = ModuleAnalyzer.for_module(base_cls.__module__)\n                                        analyzer.find_attr_docs()\n                                        if (base_cls.__name__, membername) in analyzer.attr_docs:\n                                            keep = True\n                                            break\n                                    except (ImportError, PycodeError, AttributeError):\n                                        continue\n",
      "\n                    keep = has_doc or self.options.undoc_members\n                    \n                    # For annotation-only inherited members, check for annotation comments\n                    if not keep and isinstance(obj, ObjectMember) and obj.class_ != self.object:\n                        # This is an inherited annotation-only member\n                        try:\n                            from sphinx.pycode import ModuleAnalyzer\n                            analyzer = ModuleAnalyzer.for_module(obj.class_.__module__)\n                            analyzer.find_attr_docs()\n                            qualname = f\"{obj.class_.__qualname__}.{membername}\"\n                            if qualname in analyzer.attr_docs:\n                                keep = True\n                        except (PycodeError, AttributeError, ImportError):\n                            pass\n",
      "\n                    keep = has_doc or self.options.undoc_members\n                    \n                    # Special handling for annotation-only inherited members\n                    if not keep and not has_doc and isinstance(obj, ObjectMember):\n                        # Check if this is an annotation-only member from a superclass\n                        # that might have annotation comment documentation\n                        if hasattr(obj, 'class_') and obj.class_ != self.object:\n                            try:\n                                analyzer = ModuleAnalyzer.for_module(obj.class_.__module__)\n                                analyzer.analyze()\n                                qualname = f\"{obj.class_.__qualname__}.{membername}\"\n                                if qualname in analyzer.annotations:\n                                    attr_docs = analyzer.find_attr_docs()\n                                    if (obj.class_.__name__, membername) in attr_docs:\n                                        keep = True\n                            except (PycodeError, AttributeError):\n                                pass\n"
    ],
    "Location 5 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/importer.py lines 228-233)": [
      "\n    # annotation only member (ex. attr: int)\n    for i, cls in enumerate(getmro(subject)):\n        for name in getannotations(cls):\n            name = unmangle(cls, name)\n            if name and name not in members:\n                # Store additional metadata about the defining class and module\n                # to help with documentation lookup for inherited annotations\n                attr_value = INSTANCEATTR\n                if hasattr(attr_value, '__dict__'):\n                    # If INSTANCEATTR is mutable, store metadata\n                    attr_with_meta = type('AnnotationAttribute', (), {\n                        '__name__': 'INSTANCEATTR',\n                        '__defining_class__': cls,\n                        '__defining_module__': getattr(cls, '__module__', None)\n                    })()\n                    members[name] = Attribute(name, i == 0, attr_with_meta)\n                else:\n                    # For immutable INSTANCEATTR, we'll rely on the class info in getdoc\n                    members[name] = Attribute(name, i == 0, INSTANCEATTR)\n",
      "\n    # annotation only member (ex. attr: int)\n    for i, cls in enumerate(getmro(subject)):\n        for name in getannotations(cls):\n            name = unmangle(cls, name)\n            if name and name not in members:\n                # Store the defining class as additional metadata for annotation comment lookup\n                members[name] = Attribute(name, i == 0, INSTANCEATTR, cls)\n",
      "\n    # annotation only member (ex. attr: int)\n    for i, cls in enumerate(getmro(subject)):\n        for name in getannotations(cls):\n            name = unmangle(cls, name)\n            if name and name not in members:\n                # Store additional metadata about the defining class and module\n                # to help with annotation comment lookup for inherited members\n                attr_value = INSTANCEATTR\n                if hasattr(attr_value, '__dict__'):\n                    # If INSTANCEATTR is mutable, store metadata\n                    setattr(attr_value, '_defining_class', cls)\n                    setattr(attr_value, '_defining_module', getattr(cls, '__module__', None))\n                members[name] = Attribute(name, i == 0, attr_value)\n",
      "\n    # annotation only member (ex. attr: int)\n    for i, cls in enumerate(getmro(subject)):\n        for name in getannotations(cls):\n            name = unmangle(cls, name)\n            if name and name not in members:\n                # Store additional metadata about the source class and module\n                # to help with documentation lookup for inherited annotation-only members\n                value = getattr(cls, '__module__', None)\n                if value and hasattr(cls, '__name__'):\n                    # Create a special marker that includes source class info\n                    source_info = f\"{value}.{cls.__name__}\"\n                    members[name] = Attribute(name, i == 0, INSTANCEATTR, source_info)\n                else:\n                    members[name] = Attribute(name, i == 0, INSTANCEATTR)\n",
      "\n    # annotation only member (ex. attr: int)\n    for i, cls in enumerate(getmro(subject)):\n        for name in getannotations(cls):\n            name = unmangle(cls, name)\n            if name and name not in members:\n                # Store additional metadata about the defining class and module\n                # to help with annotation comment documentation lookup\n                attr_value = INSTANCEATTR\n                if hasattr(attr_value, '__dict__'):\n                    # If INSTANCEATTR is mutable, store metadata\n                    attr_with_meta = type('InstanceAttrWithMeta', (), {\n                        '__defining_class__': cls,\n                        '__defining_module__': getattr(cls, '__module__', None)\n                    })()\n                else:\n                    # INSTANCEATTR is likely a constant, use as-is\n                    attr_with_meta = INSTANCEATTR\n                members[name] = Attribute(name, i == 0, attr_with_meta)\n",
      "\n    # annotation only member (ex. attr: int)\n    for i, cls in enumerate(getmro(subject)):\n        for name in getannotations(cls):\n            name = unmangle(cls, name)\n            if name and name not in members:\n                # Store additional metadata about the defining class and module\n                # to help with documentation lookup for inherited annotations\n                attr_value = getattr(cls, '__annotations__', {}).get(name, INSTANCEATTR)\n                if attr_value is INSTANCEATTR or not hasattr(attr_value, '__module__'):\n                    # For annotation-only attributes, create a special marker that includes\n                    # information about the defining class to aid documentation lookup\n                    class AnnotationAttribute:\n                        def __init__(self, defining_class):\n                            self.defining_class = defining_class\n                            self.__module__ = getattr(defining_class, '__module__', None)\n                    \n                    members[name] = Attribute(name, i == 0, AnnotationAttribute(cls))\n                else:\n                    members[name] = Attribute(name, i == 0, INSTANCEATTR)\n",
      "\n    # annotation only member (ex. attr: int)\n    for i, cls in enumerate(getmro(subject)):\n        for name in getannotations(cls):\n            name = unmangle(cls, name)\n            if name and name not in members:\n                # Store additional metadata about the defining class for annotation comment lookup\n                attr_value = INSTANCEATTR\n                # Add metadata about the defining class and module for cross-module doc lookup\n                if hasattr(attr_value, '__dict__'):\n                    attr_value.__defining_class__ = cls\n                    attr_value.__defining_module__ = getattr(cls, '__module__', None)\n                else:\n                    # Create a wrapper object to store metadata\n                    class AnnotationAttribute:\n                        def __init__(self, value, defining_class, defining_module):\n                            self.value = value\n                            self.__defining_class__ = defining_class\n                            self.__defining_module__ = defining_module\n                        \n                        def __repr__(self):\n                            return repr(self.value)\n                    \n                    attr_value = AnnotationAttribute(INSTANCEATTR, cls, getattr(cls, '__module__', None))\n                \n                members[name] = Attribute(name, i == 0, attr_value)\n",
      "\n    # annotation only member (ex. attr: int)\n    for i, cls in enumerate(getmro(subject)):\n        for name in getannotations(cls):\n            name = unmangle(cls, name)\n            if name and name not in members:\n                # Store additional metadata about the source class for annotation comment lookup\n                attr_value = INSTANCEATTR\n                # If this is an inherited annotation (i > 0), store the source class info\n                if hasattr(attr_value, '__class__'):\n                    # Create a wrapper that stores source class information\n                    class AnnotationAttribute:\n                        def __init__(self, value, source_cls):\n                            self.value = value\n                            self.source_cls = source_cls\n                        def __repr__(self):\n                            return repr(self.value)\n                    attr_value = AnnotationAttribute(INSTANCEATTR, cls)\n                members[name] = Attribute(name, i == 0, attr_value)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..109f60efd 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -710,6 +710,7 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n             if not isinstance(doc, str):\n@@ -728,6 +729,7 @@ class Documenter:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n \n+\n             has_doc = bool(doc)\n \n             metadata = extract_metadata(doc)\n@@ -784,6 +786,7 @@ class Documenter:\n                     keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n+\n                     keep = has_doc or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\ndiff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py\nindex 477aae247..566d50390 100644\n--- a/sphinx/ext/autodoc/importer.py\n+++ b/sphinx/ext/autodoc/importer.py\n@@ -225,6 +225,7 @@ def get_object_members(subject: Any, objpath: List[str], attrgetter: Callable,\n         except AttributeError:\n             continue\n \n+\n     # annotation only member (ex. attr: int)\n     for i, cls in enumerate(getmro(subject)):\n         for name in getannotations(cls):\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 5477e64f7..e2f479f10 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -889,6 +889,7 @@ class Signature:\n         return stringify_annotation(annotation)\n \n \n+\n def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n            allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n     \"\"\"Get the docstring for the object.\n@@ -898,6 +899,7 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n     * partial functions\n     * inherited docstring\n     * inherited decorated methods\n+    * annotation comments for inherited members\n     \"\"\"\n     doc = attrgetter(obj, '__doc__', None)\n     if ispartial(obj) and doc == obj.__class__.__doc__:\n@@ -914,5 +916,30 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n                     doc = inspect.getdoc(meth)\n                     if doc:\n                         break\n+            \n+            # If still no doc found, try to get annotation comment documentation\n+            # from superclass modules for annotation-only members\n+            if doc is None and name:\n+                from sphinx.pycode import ModuleAnalyzer, PycodeError\n+                for basecls in getattr(cls, '__mro__', []):\n+                    # Check if this class has the annotation\n+                    if hasattr(basecls, '__annotations__') and name in basecls.__annotations__:\n+                        try:\n+                            # Get the module where this class is defined\n+                            module = inspect.getmodule(basecls)\n+                            if module and hasattr(module, '__name__'):\n+                                analyzer = ModuleAnalyzer.for_module(module.__name__)\n+                                attr_docs = analyzer.find_attr_docs()\n+                                # Look for annotation comment documentation\n+                                class_name = basecls.__qualname__\n+                                key = (class_name, name)\n+                                if key in attr_docs:\n+                                    doc_lines = attr_docs[key]\n+                                    if doc_lines:\n+                                        doc = '\\n'.join(doc_lines).strip()\n+                                        break\n+                        except (PycodeError, ImportError, AttributeError):\n+                            # If we can't analyze the module, continue to next class\n+                            continue\n \n     return doc\n",
    "variant_0": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..c99c6920c 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -710,8 +710,27 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n+            \n+            # For inherited annotation-only members, try to get annotation comment documentation\n+            if not doc and member is INSTANCEATTR and self.parent:\n+                # Check if this is an annotation-only member from a superclass\n+                for cls in inspect.getmro(self.parent):\n+                    if cls is self.parent:\n+                        continue\n+                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n+                        # Try to get annotation comment from the defining class's module\n+                        try:\n+                            analyzer = ModuleAnalyzer.for_module(cls.__module__)\n+                            analyzer.analyze()\n+                            attr_docs = analyzer.find_attr_docs()\n+                            if (cls.__name__, membername) in attr_docs:\n+                                doc = '\\n'.join(attr_docs[(cls.__name__, membername)])\n+                                break\n+                        except (PycodeError, AttributeError):\n+                            pass\n             if not isinstance(doc, str):\n                 # Ignore non-string __doc__\n                 doc = None\n@@ -728,7 +747,38 @@ class Documenter:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n \n+\n+            # Enhanced logic to handle annotation comment documentation for inherited members\n             has_doc = bool(doc)\n+            \n+            # If no doc found and this is an annotation-only member, check for annotation comments\n+            if not has_doc and isinstance(obj, ObjectMember) and not obj.value:\n+                # This is likely an annotation-only member, try to get annotation comment doc\n+                try:\n+                    # Get the class that actually defines this member\n+                    defining_class = None\n+                    for cls in inspect.getmro(self.object):\n+                        if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n+                            defining_class = cls\n+                            break\n+                    \n+                    if defining_class and defining_class != self.object:\n+                        # This is an inherited annotation, check for annotation comment in the defining module\n+                        defining_module = inspect.getmodule(defining_class)\n+                        if defining_module:\n+                            try:\n+                                analyzer = ModuleAnalyzer.for_module(defining_module.__name__)\n+                                analyzer.analyze()\n+                                # Look for annotation comment documentation\n+                                qualname = f\"{defining_class.__qualname__}.{membername}\"\n+                                if qualname in analyzer.attr_docs:\n+                                    doc = '\\n'.join(analyzer.attr_docs[qualname])\n+                                    has_doc = bool(doc)\n+                            except (PycodeError, AttributeError):\n+                                pass\n+                except Exception:\n+                    # If anything goes wrong, fall back to the original behavior\n+                    pass\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -784,7 +834,25 @@ class Documenter:\n                     keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n+\n                     keep = has_doc or self.options.undoc_members\n+                    \n+                    # Special handling for annotation-only inherited members\n+                    if not keep and not has_doc and isinstance(obj, ObjectMember):\n+                        # Check if this is an annotation-only member from a superclass\n+                        # that might have annotation comment documentation\n+                        if (hasattr(self.object, '__mro__') and \n+                            hasattr(obj, 'class_') and obj.class_ != self.object):\n+                            # This is an inherited member, try to get annotation comment doc\n+                            try:\n+                                from sphinx.pycode import ModuleAnalyzer\n+                                analyzer = ModuleAnalyzer.for_module(obj.class_.__module__)\n+                                analyzer.analyze()\n+                                if analyzer.annotations.get(membername):\n+                                    # Has annotation comment documentation\n+                                    keep = True\n+                            except (PycodeError, AttributeError):\n+                                pass\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\ndiff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py\nindex 477aae247..120bcde3f 100644\n--- a/sphinx/ext/autodoc/importer.py\n+++ b/sphinx/ext/autodoc/importer.py\n@@ -225,12 +225,30 @@ def get_object_members(subject: Any, objpath: List[str], attrgetter: Callable,\n         except AttributeError:\n             continue\n \n+\n     # annotation only member (ex. attr: int)\n     for i, cls in enumerate(getmro(subject)):\n         for name in getannotations(cls):\n             name = unmangle(cls, name)\n             if name and name not in members:\n-                members[name] = Attribute(name, i == 0, INSTANCEATTR)\n+                # Store additional metadata about the defining class and module\n+                # to help with annotation comment lookup for inherited members\n+                attr_value = INSTANCEATTR\n+                if hasattr(attr_value, '__dict__'):\n+                    # If INSTANCEATTR is mutable, we can't modify it directly\n+                    # Create a simple container for the metadata\n+                    class AnnotationMember:\n+                        def __init__(self, value, defining_class, defining_module):\n+                            self.value = value\n+                            self.defining_class = defining_class\n+                            self.defining_module = defining_module\n+                        \n+                        def __repr__(self):\n+                            return repr(self.value)\n+                    \n+                    attr_value = AnnotationMember(INSTANCEATTR, cls, getattr(cls, '__module__', None))\n+                \n+                members[name] = Attribute(name, i == 0, attr_value)\n \n     if analyzer:\n         # append instance attributes (cf. self.attr1) if analyzer knows\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 5477e64f7..c8bfc66b3 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -889,6 +889,7 @@ class Signature:\n         return stringify_annotation(annotation)\n \n \n+\n def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n            allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n     \"\"\"Get the docstring for the object.\n@@ -905,7 +906,7 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n     elif doc is None and allow_inherited:\n         doc = inspect.getdoc(obj)\n \n-        if doc is None and cls:\n+        if doc is None and cls and name:\n             # inspect.getdoc() does not support some kind of inherited and decorated methods.\n             # This tries to obtain the docstring from super classes.\n             for basecls in getattr(cls, '__mro__', []):\n@@ -914,5 +915,29 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n                     doc = inspect.getdoc(meth)\n                     if doc:\n                         break\n+            \n+            # If still no doc found, check for annotation comments in superclasses\n+            if doc is None:\n+                for basecls in getattr(cls, '__mro__', []):\n+                    # Skip the current class to only check inherited members\n+                    if basecls is cls:\n+                        continue\n+                    \n+                    # Check if the attribute exists in this base class\n+                    if hasattr(basecls, '__annotations__') and name in basecls.__annotations__:\n+                        # Try to get annotation comment from the base class module\n+                        try:\n+                            from sphinx.pycode import ModuleAnalyzer\n+                            analyzer = ModuleAnalyzer.for_module(basecls.__module__)\n+                            analyzer.analyze()\n+                            if hasattr(analyzer, 'attr_docs') and analyzer.attr_docs:\n+                                # Look for annotation comment in the base class\n+                                qualified_name = f\"{basecls.__qualname__}.{name}\"\n+                                if qualified_name in analyzer.attr_docs:\n+                                    doc = '\\n'.join(analyzer.attr_docs[qualified_name])\n+                                    break\n+                        except Exception:\n+                            # If ModuleAnalyzer fails, continue to next base class\n+                            continue\n \n     return doc\n",
    "variant_1": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..366398e28 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -710,11 +710,41 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n             if not isinstance(doc, str):\n                 # Ignore non-string __doc__\n                 doc = None\n+            \n+            # For inherited annotation-only members, try to get annotation comment documentation\n+            if doc is None and member is INSTANCEATTR and self.parent:\n+                try:\n+                    # Find which class this annotation comes from\n+                    for cls in inspect.getmro(self.parent):\n+                        if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n+                            # Try to get annotation comment from the defining class's module\n+                            cls_module = safe_getattr(cls, '__module__', None)\n+                            if cls_module:\n+                                try:\n+                                    from sphinx.pycode import ModuleAnalyzer\n+                                    analyzer = ModuleAnalyzer.for_module(cls_module)\n+                                    analyzer.analyze()\n+                                    # Get annotation comment for this member\n+                                    if hasattr(analyzer, 'attr_docs') and cls.__name__ in analyzer.attr_docs:\n+                                        attr_docs = analyzer.attr_docs[cls.__name__]\n+                                        if membername in attr_docs:\n+                                            doc = '\\n'.join(attr_docs[membername])\n+                                            break\n+                                except (PycodeError, ImportError, AttributeError):\n+                                    continue\n+                            break\n+                except Exception:\n+                    # Fallback to original behavior if anything goes wrong\n+                    pass\n+            if not isinstance(doc, str):\n+                # Ignore non-string __doc__\n+                doc = None\n \n             # if the member __doc__ is the same as self's __doc__, it's just\n             # inherited and therefore not the member's doc\n@@ -728,7 +758,24 @@ class Documenter:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n \n+\n             has_doc = bool(doc)\n+            \n+            # For inherited annotation-only members, check for annotation comment documentation\n+            if not has_doc and isinstance(obj, ObjectMember) and obj.skipped:\n+                # This is likely an annotation-only member from a superclass\n+                # Try to find annotation comment documentation from the defining class\n+                for cls in inspect.getmro(self.object):\n+                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n+                        try:\n+                            analyzer = ModuleAnalyzer.for_module(cls.__module__)\n+                            attr_docs = analyzer.find_attr_docs()\n+                            if (cls.__name__, membername) in attr_docs:\n+                                doc = '\\n'.join(attr_docs[(cls.__name__, membername)])\n+                                has_doc = bool(doc)\n+                                break\n+                        except (PycodeError, AttributeError):\n+                            continue\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -784,6 +831,7 @@ class Documenter:\n                     keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n+\n                     keep = has_doc or self.options.undoc_members\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\ndiff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py\nindex 477aae247..dcffe2ac4 100644\n--- a/sphinx/ext/autodoc/importer.py\n+++ b/sphinx/ext/autodoc/importer.py\n@@ -225,12 +225,26 @@ def get_object_members(subject: Any, objpath: List[str], attrgetter: Callable,\n         except AttributeError:\n             continue\n \n+\n     # annotation only member (ex. attr: int)\n     for i, cls in enumerate(getmro(subject)):\n         for name in getannotations(cls):\n             name = unmangle(cls, name)\n             if name and name not in members:\n-                members[name] = Attribute(name, i == 0, INSTANCEATTR)\n+                # Store additional metadata about the defining class and module\n+                # to help with documentation lookup for inherited annotations\n+                attr_value = INSTANCEATTR\n+                if hasattr(attr_value, '__dict__'):\n+                    # If INSTANCEATTR is mutable, store metadata\n+                    attr_with_meta = type('AnnotationAttribute', (), {\n+                        '__name__': 'INSTANCEATTR',\n+                        '__defining_class__': cls,\n+                        '__defining_module__': getattr(cls, '__module__', None)\n+                    })()\n+                    members[name] = Attribute(name, i == 0, attr_with_meta)\n+                else:\n+                    # For immutable INSTANCEATTR, we'll rely on the class info in getdoc\n+                    members[name] = Attribute(name, i == 0, INSTANCEATTR)\n \n     if analyzer:\n         # append instance attributes (cf. self.attr1) if analyzer knows\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 5477e64f7..bcef3caa8 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -889,6 +889,7 @@ class Signature:\n         return stringify_annotation(annotation)\n \n \n+\n def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n            allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n     \"\"\"Get the docstring for the object.\n@@ -905,7 +906,7 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n     elif doc is None and allow_inherited:\n         doc = inspect.getdoc(obj)\n \n-        if doc is None and cls:\n+        if doc is None and cls and name:\n             # inspect.getdoc() does not support some kind of inherited and decorated methods.\n             # This tries to obtain the docstring from super classes.\n             for basecls in getattr(cls, '__mro__', []):\n@@ -914,5 +915,26 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n                     doc = inspect.getdoc(meth)\n                     if doc:\n                         break\n+            \n+            # If still no doc found, check for annotation comments in superclasses\n+            if doc is None:\n+                from sphinx.pycode import ModuleAnalyzer\n+                for basecls in getattr(cls, '__mro__', []):\n+                    # Check if the attribute exists as an annotation in this base class\n+                    if (hasattr(basecls, '__annotations__') and \n+                        name in basecls.__annotations__ and\n+                        hasattr(basecls, '__module__')):\n+                        try:\n+                            analyzer = ModuleAnalyzer.for_module(basecls.__module__)\n+                            analyzer.parse()\n+                            if hasattr(analyzer, 'attr_docs') and analyzer.attr_docs:\n+                                # Look for annotation comment for this attribute\n+                                qualname = f\"{basecls.__qualname__}.{name}\"\n+                                if qualname in analyzer.attr_docs:\n+                                    doc = '\\n'.join(analyzer.attr_docs[qualname])\n+                                    break\n+                        except Exception:\n+                            # If we can't analyze the module, continue to next base class\n+                            continue\n \n     return doc\n",
    "variant_2": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..7a7d6fa0d 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -710,8 +710,9 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n-                         self.parent, self.object_name)\n+                         self.parent, self.object_name, self.analyzer)\n             if not isinstance(doc, str):\n                 # Ignore non-string __doc__\n                 doc = None\n@@ -728,8 +729,24 @@ class Documenter:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n \n+\n             has_doc = bool(doc)\n \n+            # Check for annotation comment documentation for inherited members\n+            if not has_doc and isinstance(obj, ObjectMember) and obj.object is INSTANCEATTR:\n+                # Try to find annotation comment documentation from the defining class\n+                for cls in inspect.getmro(self.object):\n+                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n+                        try:\n+                            analyzer = ModuleAnalyzer.for_module(cls.__module__)\n+                            analyzer.analyze()\n+                            if membername in analyzer.attr_docs:\n+                                doc = '\\n'.join(analyzer.attr_docs[membername])\n+                                has_doc = bool(doc)\n+                                break\n+                        except (PycodeError, AttributeError):\n+                            continue\n+\n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n                 # consider a member private if docstring has \"private\" metadata\n@@ -783,8 +800,24 @@ class Documenter:\n                         is_filtered_inherited_member(membername, obj)):\n                     keep = False\n                 else:\n+                    # ignore undocumented members if :undoc-members: is not given\n+\n                     # ignore undocumented members if :undoc-members: is not given\n                     keep = has_doc or self.options.undoc_members\n+                    \n+                    # Special handling for inherited annotation-only members\n+                    if not keep and not has_doc and isinstance(obj, ObjectMember):\n+                        # Check if this is an annotation-only member from a superclass\n+                        # that might have annotation comment documentation\n+                        if hasattr(obj, 'class_') and obj.class_ != self.object:\n+                            try:\n+                                analyzer = ModuleAnalyzer.for_module(obj.class_.__module__)\n+                                analyzer.find_attr_docs()\n+                                qualname = f\"{obj.class_.__qualname__}.{name}\"\n+                                if qualname in analyzer.attr_docs:\n+                                    keep = True\n+                            except (PycodeError, AttributeError):\n+                                pass\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\ndiff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py\nindex 477aae247..2ce50a371 100644\n--- a/sphinx/ext/autodoc/importer.py\n+++ b/sphinx/ext/autodoc/importer.py\n@@ -225,12 +225,14 @@ def get_object_members(subject: Any, objpath: List[str], attrgetter: Callable,\n         except AttributeError:\n             continue\n \n+\n     # annotation only member (ex. attr: int)\n     for i, cls in enumerate(getmro(subject)):\n         for name in getannotations(cls):\n             name = unmangle(cls, name)\n             if name and name not in members:\n-                members[name] = Attribute(name, i == 0, INSTANCEATTR)\n+                # Store the defining class as additional metadata for annotation comment lookup\n+                members[name] = Attribute(name, i == 0, INSTANCEATTR, cls)\n \n     if analyzer:\n         # append instance attributes (cf. self.attr1) if analyzer knows\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 5477e64f7..559c56e07 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -889,6 +889,7 @@ class Signature:\n         return stringify_annotation(annotation)\n \n \n+\n def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n            allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n     \"\"\"Get the docstring for the object.\n@@ -905,7 +906,7 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n     elif doc is None and allow_inherited:\n         doc = inspect.getdoc(obj)\n \n-        if doc is None and cls:\n+        if doc is None and cls and name:\n             # inspect.getdoc() does not support some kind of inherited and decorated methods.\n             # This tries to obtain the docstring from super classes.\n             for basecls in getattr(cls, '__mro__', []):\n@@ -914,5 +915,25 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n                     doc = inspect.getdoc(meth)\n                     if doc:\n                         break\n+            \n+            # If still no doc found, check for annotation comments in superclasses\n+            if doc is None:\n+                for basecls in getattr(cls, '__mro__', []):\n+                    if hasattr(basecls, '__annotations__') and name in basecls.__annotations__:\n+                        # Found annotation in this class, try to get comment doc\n+                        try:\n+                            from sphinx.pycode import ModuleAnalyzer\n+                            module = inspect.getmodule(basecls)\n+                            if module and hasattr(module, '__file__') and module.__file__:\n+                                analyzer = ModuleAnalyzer.for_module(module.__name__)\n+                                analyzer.analyze()\n+                                attr_docs = analyzer.find_attr_docs()\n+                                if (basecls.__name__, name) in attr_docs:\n+                                    doc = '\\n'.join(attr_docs[(basecls.__name__, name)])\n+                                    if doc:\n+                                        break\n+                        except Exception:\n+                            # If analyzer fails, continue searching\n+                            pass\n \n     return doc\n",
    "variant_3": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..8f780a61e 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -710,11 +710,30 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n             if not isinstance(doc, str):\n                 # Ignore non-string __doc__\n                 doc = None\n+            \n+            # For inherited annotation-only members, try to get annotation comment documentation\n+            if doc is None and member is INSTANCEATTR and self.parent:\n+                # Try to find annotation comment documentation from the defining class\n+                for base in inspect.getmro(self.parent):\n+                    if hasattr(base, '__annotations__') and membername in base.__annotations__:\n+                        try:\n+                            from sphinx.pycode import ModuleAnalyzer\n+                            analyzer = ModuleAnalyzer.for_module(base.__module__)\n+                            analyzer.find_attr_docs()\n+                            if hasattr(analyzer, 'attr_docs') and (base.__name__, membername) in analyzer.attr_docs:\n+                                doc = '\\n'.join(analyzer.attr_docs[(base.__name__, membername)])\n+                                break\n+                        except (ImportError, PycodeError, AttributeError):\n+                            continue\n+            if not isinstance(doc, str):\n+                # Ignore non-string __doc__\n+                doc = None\n \n             # if the member __doc__ is the same as self's __doc__, it's just\n             # inherited and therefore not the member's doc\n@@ -728,6 +747,21 @@ class Documenter:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n \n+\n+            # Check for annotation comment documentation for inherited members\n+            if not doc and isinstance(obj, ObjectMember):\n+                # Try to get annotation comment from the defining class\n+                try:\n+                    from sphinx.pycode import ModuleAnalyzer\n+                    defining_class = getattr(obj, 'class', None)\n+                    if defining_class and hasattr(defining_class, '__module__'):\n+                        analyzer = ModuleAnalyzer.for_module(defining_class.__module__)\n+                        analyzer.analyze()\n+                        if membername in analyzer.attr_docs:\n+                            doc = '\\n'.join(analyzer.attr_docs[membername])\n+                except (PycodeError, ImportError, AttributeError):\n+                    pass\n+\n             has_doc = bool(doc)\n \n             metadata = extract_metadata(doc)\n@@ -784,7 +818,27 @@ class Documenter:\n                     keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n+\n                     keep = has_doc or self.options.undoc_members\n+                    \n+                    # Special handling for annotation-only inherited members\n+                    if not keep and not has_doc and isinstance(obj, ObjectMember):\n+                        # Check if this is an annotation-only member from a superclass\n+                        # that might have annotation comment documentation\n+                        if (hasattr(self.object, '__mro__') and \n+                            hasattr(obj.object, '__annotations__')):\n+                            for base_cls in self.object.__mro__[1:]:  # Skip self\n+                                if (hasattr(base_cls, '__annotations__') and \n+                                    membername in base_cls.__annotations__):\n+                                    try:\n+                                        analyzer = ModuleAnalyzer.for_module(base_cls.__module__)\n+                                        analyzer.find_attr_docs()\n+                                        qualname = f\"{base_cls.__qualname__}.{membername}\"\n+                                        if qualname in analyzer.attr_docs:\n+                                            keep = True\n+                                            break\n+                                    except (PycodeError, AttributeError):\n+                                        continue\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\ndiff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py\nindex 477aae247..bf733f30d 100644\n--- a/sphinx/ext/autodoc/importer.py\n+++ b/sphinx/ext/autodoc/importer.py\n@@ -225,12 +225,20 @@ def get_object_members(subject: Any, objpath: List[str], attrgetter: Callable,\n         except AttributeError:\n             continue\n \n+\n     # annotation only member (ex. attr: int)\n     for i, cls in enumerate(getmro(subject)):\n         for name in getannotations(cls):\n             name = unmangle(cls, name)\n             if name and name not in members:\n-                members[name] = Attribute(name, i == 0, INSTANCEATTR)\n+                # Store additional metadata about the defining class and module\n+                # to help with annotation comment lookup for inherited members\n+                attr_value = INSTANCEATTR\n+                if hasattr(attr_value, '__dict__'):\n+                    # If INSTANCEATTR is mutable, store metadata\n+                    setattr(attr_value, '_defining_class', cls)\n+                    setattr(attr_value, '_defining_module', getattr(cls, '__module__', None))\n+                members[name] = Attribute(name, i == 0, attr_value)\n \n     if analyzer:\n         # append instance attributes (cf. self.attr1) if analyzer knows\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 5477e64f7..e934b22ab 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -889,6 +889,7 @@ class Signature:\n         return stringify_annotation(annotation)\n \n \n+\n def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n            allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n     \"\"\"Get the docstring for the object.\n@@ -905,7 +906,7 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n     elif doc is None and allow_inherited:\n         doc = inspect.getdoc(obj)\n \n-        if doc is None and cls:\n+        if doc is None and cls and name:\n             # inspect.getdoc() does not support some kind of inherited and decorated methods.\n             # This tries to obtain the docstring from super classes.\n             for basecls in getattr(cls, '__mro__', []):\n@@ -914,5 +915,23 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n                     doc = inspect.getdoc(meth)\n                     if doc:\n                         break\n+            \n+            # If still no doc found, check for annotation comments in superclasses\n+            if doc is None:\n+                from sphinx.pycode import ModuleAnalyzer\n+                for basecls in getattr(cls, '__mro__', []):\n+                    if hasattr(basecls, '__module__') and hasattr(basecls, '__annotations__'):\n+                        if name in basecls.__annotations__:\n+                            try:\n+                                analyzer = ModuleAnalyzer.for_module(basecls.__module__)\n+                                analyzer.analyze()\n+                                if hasattr(analyzer, 'attr_docs') and analyzer.attr_docs:\n+                                    attr_docs = analyzer.attr_docs\n+                                    if (basecls.__name__, name) in attr_docs:\n+                                        doc = '\\n'.join(attr_docs[(basecls.__name__, name)])\n+                                        break\n+                            except Exception:\n+                                # If analysis fails, continue to next base class\n+                                continue\n \n     return doc\n",
    "variant_4": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..5bd9b6a29 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -710,8 +710,9 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n-                         self.parent, self.object_name)\n+                         self.parent, self.object_name, membername)\n             if not isinstance(doc, str):\n                 # Ignore non-string __doc__\n                 doc = None\n@@ -728,7 +729,29 @@ class Documenter:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n \n+\n             has_doc = bool(doc)\n+            \n+            # For inherited annotation-only members, check for annotation comments in the source class\n+            if not has_doc and isinstance(obj, ObjectMember) and obj.class_ is not None:\n+                try:\n+                    # Get the module where the annotation was defined\n+                    source_module = inspect.getmodule(obj.class_)\n+                    if source_module:\n+                        from sphinx.pycode import ModuleAnalyzer\n+                        analyzer = ModuleAnalyzer.for_module(source_module.__name__)\n+                        analyzer.analyze()\n+                        \n+                        # Look for annotation comment in the source class\n+                        qualname = f\"{obj.class_.__name__}.{membername}\"\n+                        if qualname in analyzer.annotations:\n+                            annotation_doc = analyzer.annotations[qualname]\n+                            if annotation_doc:\n+                                doc = annotation_doc\n+                                has_doc = True\n+                except (PycodeError, ImportError, AttributeError):\n+                    # If we can't analyze the source module, continue without doc\n+                    pass\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -784,7 +807,9 @@ class Documenter:\n                     keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n-                    keep = has_doc or self.options.undoc_members\n+\n+                    doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,\n+                                self.parent, self.object_name)\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\ndiff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py\nindex 477aae247..7f355c2f4 100644\n--- a/sphinx/ext/autodoc/importer.py\n+++ b/sphinx/ext/autodoc/importer.py\n@@ -225,12 +225,21 @@ def get_object_members(subject: Any, objpath: List[str], attrgetter: Callable,\n         except AttributeError:\n             continue\n \n+\n     # annotation only member (ex. attr: int)\n     for i, cls in enumerate(getmro(subject)):\n         for name in getannotations(cls):\n             name = unmangle(cls, name)\n             if name and name not in members:\n-                members[name] = Attribute(name, i == 0, INSTANCEATTR)\n+                # Store additional metadata about the source class and module\n+                # to help with documentation lookup for inherited annotation-only members\n+                value = getattr(cls, '__module__', None)\n+                if value and hasattr(cls, '__name__'):\n+                    # Create a special marker that includes source class info\n+                    source_info = f\"{value}.{cls.__name__}\"\n+                    members[name] = Attribute(name, i == 0, INSTANCEATTR, source_info)\n+                else:\n+                    members[name] = Attribute(name, i == 0, INSTANCEATTR)\n \n     if analyzer:\n         # append instance attributes (cf. self.attr1) if analyzer knows\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 5477e64f7..1e87f4b18 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -889,6 +889,7 @@ class Signature:\n         return stringify_annotation(annotation)\n \n \n+\n def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n            allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n     \"\"\"Get the docstring for the object.\n@@ -898,6 +899,7 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n     * partial functions\n     * inherited docstring\n     * inherited decorated methods\n+    * annotation comments for inherited members\n     \"\"\"\n     doc = attrgetter(obj, '__doc__', None)\n     if ispartial(obj) and doc == obj.__class__.__doc__:\n@@ -905,7 +907,7 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n     elif doc is None and allow_inherited:\n         doc = inspect.getdoc(obj)\n \n-        if doc is None and cls:\n+        if doc is None and cls and name:\n             # inspect.getdoc() does not support some kind of inherited and decorated methods.\n             # This tries to obtain the docstring from super classes.\n             for basecls in getattr(cls, '__mro__', []):\n@@ -914,5 +916,24 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n                     doc = inspect.getdoc(meth)\n                     if doc:\n                         break\n-\n-    return doc\n+            \n+            # If still no doc found, try to get annotation comment from superclass modules\n+            if doc is None:\n+                from sphinx.pycode import ModuleAnalyzer\n+                for basecls in getattr(cls, '__mro__', []):\n+                    if hasattr(basecls, name):\n+                        try:\n+                            module = inspect.getmodule(basecls)\n+                            if module and hasattr(module, '__file__') and module.__file__:\n+                                analyzer = ModuleAnalyzer.for_module(module.__name__)\n+                                analyzer.parse()\n+                                qualname = f\"{basecls.__name__}.{name}\"\n+                                if qualname in analyzer.attr_docs:\n+                                    doc = '\\n'.join(analyzer.attr_docs[qualname])\n+                                    if doc:\n+                                        break\n+                        except Exception:\n+                            # If analysis fails, continue to next base class\n+                            continue\n+\n+    return doc or ''\n",
    "variant_5": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..abbb47cd6 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -710,8 +710,32 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n+            \n+            # If no doc found and member is an annotation-only attribute, try to get\n+            # annotation comment from the defining class\n+            if not doc and member is INSTANCEATTR:\n+                # Try to find annotation comment for inherited annotation-only members\n+                from sphinx.pycode import ModuleAnalyzer, PycodeError\n+                \n+                # Look through the MRO to find where this annotation is defined\n+                for cls in inspect.getmro(self.object):\n+                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n+                        try:\n+                            # Get the module where this class is defined\n+                            cls_module = inspect.getmodule(cls)\n+                            if cls_module and hasattr(cls_module, '__file__') and cls_module.__file__:\n+                                analyzer = ModuleAnalyzer.for_module(cls_module.__name__)\n+                                analyzer.find_attr_docs()\n+                                # Look for annotation comment in the defining class\n+                                qualname = f\"{cls.__name__}.{membername}\"\n+                                if qualname in analyzer.attr_docs:\n+                                    doc = '\\n'.join(analyzer.attr_docs[qualname])\n+                                    break\n+                        except (PycodeError, AttributeError):\n+                            continue\n             if not isinstance(doc, str):\n                 # Ignore non-string __doc__\n                 doc = None\n@@ -728,7 +752,24 @@ class Documenter:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n \n+\n             has_doc = bool(doc)\n+            \n+            # For inherited annotation-only members, check for annotation comments\n+            if not has_doc and isinstance(obj, ObjectMember) and obj.class_ != self.object:\n+                # This is an inherited annotation-only member, try to get annotation comment doc\n+                try:\n+                    from sphinx.pycode import ModuleAnalyzer\n+                    defining_class = obj.class_\n+                    if defining_class and hasattr(defining_class, '__module__'):\n+                        analyzer = ModuleAnalyzer.for_module(defining_class.__module__)\n+                        analyzer.find_attr_docs()\n+                        qualname = f\"{defining_class.__qualname__}.{membername}\"\n+                        if qualname in analyzer.attr_docs:\n+                            doc = '\\n'.join(analyzer.attr_docs[qualname])\n+                            has_doc = bool(doc)\n+                except (PycodeError, AttributeError, ImportError):\n+                    pass\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -784,7 +825,21 @@ class Documenter:\n                     keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n+\n                     keep = has_doc or self.options.undoc_members\n+                    \n+                    # Check for annotation comment documentation for inherited members\n+                    if not keep and not has_doc and isinstance(obj, ObjectMember):\n+                        # Try to get annotation comment doc from the defining class\n+                        if hasattr(obj, 'class_') and obj.class_ != self.object:\n+                            try:\n+                                analyzer = ModuleAnalyzer.for_module(obj.class_.__module__)\n+                                qualname = f\"{obj.class_.__qualname__}.{membername}\"\n+                                attr_docs = analyzer.find_attr_docs()\n+                                if qualname in attr_docs:\n+                                    keep = True\n+                            except (PycodeError, AttributeError):\n+                                pass\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\ndiff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py\nindex 477aae247..80e7d5927 100644\n--- a/sphinx/ext/autodoc/importer.py\n+++ b/sphinx/ext/autodoc/importer.py\n@@ -225,12 +225,25 @@ def get_object_members(subject: Any, objpath: List[str], attrgetter: Callable,\n         except AttributeError:\n             continue\n \n+\n     # annotation only member (ex. attr: int)\n     for i, cls in enumerate(getmro(subject)):\n         for name in getannotations(cls):\n             name = unmangle(cls, name)\n             if name and name not in members:\n-                members[name] = Attribute(name, i == 0, INSTANCEATTR)\n+                # Store additional metadata about the defining class and module\n+                # to help with annotation comment documentation lookup\n+                attr_value = INSTANCEATTR\n+                if hasattr(attr_value, '__dict__'):\n+                    # If INSTANCEATTR is mutable, store metadata\n+                    attr_with_meta = type('InstanceAttrWithMeta', (), {\n+                        '__defining_class__': cls,\n+                        '__defining_module__': getattr(cls, '__module__', None)\n+                    })()\n+                else:\n+                    # INSTANCEATTR is likely a constant, use as-is\n+                    attr_with_meta = INSTANCEATTR\n+                members[name] = Attribute(name, i == 0, attr_with_meta)\n \n     if analyzer:\n         # append instance attributes (cf. self.attr1) if analyzer knows\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 5477e64f7..c533c547f 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -889,6 +889,7 @@ class Signature:\n         return stringify_annotation(annotation)\n \n \n+\n def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n            allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n     \"\"\"Get the docstring for the object.\n@@ -914,5 +915,27 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n                     doc = inspect.getdoc(meth)\n                     if doc:\n                         break\n+            \n+            # If still no doc found, try to get annotation comment documentation\n+            # from the class where the attribute is defined\n+            if doc is None and name:\n+                for basecls in getattr(cls, '__mro__', []):\n+                    if hasattr(basecls, '__annotations__') and name in basecls.__annotations__:\n+                        # Found the class that defines this annotation\n+                        try:\n+                            from sphinx.pycode import ModuleAnalyzer\n+                            modname = getattr(basecls, '__module__', None)\n+                            if modname:\n+                                analyzer = ModuleAnalyzer.for_module(modname)\n+                                analyzer.analyze()\n+                                attr_docs = analyzer.find_attr_docs()\n+                                # Look for annotation comment in the defining class\n+                                qualname = getattr(basecls, '__qualname__', basecls.__name__)\n+                                if (qualname, name) in attr_docs:\n+                                    doc = '\\n'.join(attr_docs[(qualname, name)])\n+                                    break\n+                        except Exception:\n+                            # If analysis fails, continue without annotation comment doc\n+                            pass\n \n     return doc\n",
    "variant_6": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..d8a5aa80e 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -710,8 +710,25 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n+            \n+            # For inherited annotation-only members, try to get annotation comment documentation\n+            if not doc and member is INSTANCEATTR and self.parent:\n+                # Try to find annotation comment documentation from the defining class\n+                for cls in inspect.getmro(self.parent):\n+                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n+                        try:\n+                            analyzer = ModuleAnalyzer.for_module(cls.__module__)\n+                            analyzer.find_attr_docs()\n+                            if cls.__name__ in analyzer.attr_docs:\n+                                cls_attr_docs = analyzer.attr_docs[cls.__name__]\n+                                if membername in cls_attr_docs:\n+                                    doc = '\\n'.join(cls_attr_docs[membername])\n+                                    break\n+                        except (PycodeError, AttributeError):\n+                            continue\n             if not isinstance(doc, str):\n                 # Ignore non-string __doc__\n                 doc = None\n@@ -728,8 +745,22 @@ class Documenter:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n \n+\n             has_doc = bool(doc)\n \n+            # For inherited annotation-only members, check for annotation comment documentation\n+            if not has_doc and isinstance(obj, ObjectMember) and obj.class_ and obj.class_ != self.object:\n+                # This is an inherited annotation-only member\n+                try:\n+                    from sphinx.pycode import ModuleAnalyzer\n+                    analyzer = ModuleAnalyzer.for_module(obj.class_.__module__)\n+                    analyzer.find_attr_docs()\n+                    qualname = f\"{obj.class_.__qualname__}.{membername}\"\n+                    if qualname in analyzer.attr_docs:\n+                        has_doc = True\n+                except (PycodeError, AttributeError):\n+                    pass\n+\n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n                 # consider a member private if docstring has \"private\" metadata\n@@ -784,7 +815,25 @@ class Documenter:\n                     keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n+\n                     keep = has_doc or self.options.undoc_members\n+                    \n+                    # Special case for annotation-only inherited members with annotation comments\n+                    if not keep and not has_doc and isinstance(obj, ObjectMember):\n+                        if (hasattr(obj.object, '__annotations__') and \n+                            membername in getattr(obj.object, '__annotations__', {})):\n+                            # Check if this annotation-only member has annotation comment documentation\n+                            # in the defining class by looking up the MRO\n+                            for base_cls in getattr(obj.object, '__mro__', []):\n+                                if hasattr(base_cls, '__annotations__') and membername in base_cls.__annotations__:\n+                                    try:\n+                                        analyzer = ModuleAnalyzer.for_module(base_cls.__module__)\n+                                        analyzer.find_attr_docs()\n+                                        if (base_cls.__name__, membername) in analyzer.attr_docs:\n+                                            keep = True\n+                                            break\n+                                    except (ImportError, PycodeError, AttributeError):\n+                                        continue\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\ndiff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py\nindex 477aae247..16e6a5ac6 100644\n--- a/sphinx/ext/autodoc/importer.py\n+++ b/sphinx/ext/autodoc/importer.py\n@@ -225,12 +225,26 @@ def get_object_members(subject: Any, objpath: List[str], attrgetter: Callable,\n         except AttributeError:\n             continue\n \n+\n     # annotation only member (ex. attr: int)\n     for i, cls in enumerate(getmro(subject)):\n         for name in getannotations(cls):\n             name = unmangle(cls, name)\n             if name and name not in members:\n-                members[name] = Attribute(name, i == 0, INSTANCEATTR)\n+                # Store additional metadata about the defining class and module\n+                # to help with documentation lookup for inherited annotations\n+                attr_value = getattr(cls, '__annotations__', {}).get(name, INSTANCEATTR)\n+                if attr_value is INSTANCEATTR or not hasattr(attr_value, '__module__'):\n+                    # For annotation-only attributes, create a special marker that includes\n+                    # information about the defining class to aid documentation lookup\n+                    class AnnotationAttribute:\n+                        def __init__(self, defining_class):\n+                            self.defining_class = defining_class\n+                            self.__module__ = getattr(defining_class, '__module__', None)\n+                    \n+                    members[name] = Attribute(name, i == 0, AnnotationAttribute(cls))\n+                else:\n+                    members[name] = Attribute(name, i == 0, INSTANCEATTR)\n \n     if analyzer:\n         # append instance attributes (cf. self.attr1) if analyzer knows\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 5477e64f7..3cc89829b 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -889,6 +889,7 @@ class Signature:\n         return stringify_annotation(annotation)\n \n \n+\n def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n            allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n     \"\"\"Get the docstring for the object.\n@@ -905,7 +906,7 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n     elif doc is None and allow_inherited:\n         doc = inspect.getdoc(obj)\n \n-        if doc is None and cls:\n+        if doc is None and cls and name:\n             # inspect.getdoc() does not support some kind of inherited and decorated methods.\n             # This tries to obtain the docstring from super classes.\n             for basecls in getattr(cls, '__mro__', []):\n@@ -914,5 +915,23 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n                     doc = inspect.getdoc(meth)\n                     if doc:\n                         break\n+            \n+            # If still no doc, try to get annotation comment from superclass modules\n+            if doc is None:\n+                from sphinx.pycode import ModuleAnalyzer\n+                for basecls in getattr(cls, '__mro__', []):\n+                    if hasattr(basecls, '__annotations__') and name in basecls.__annotations__:\n+                        try:\n+                            module = inspect.getmodule(basecls)\n+                            if module and hasattr(module, '__file__') and module.__file__:\n+                                analyzer = ModuleAnalyzer.for_module(module.__name__)\n+                                analyzer.analyze()\n+                                qualname = f\"{basecls.__name__}.{name}\"\n+                                if qualname in analyzer.attr_docs:\n+                                    doc = '\\n'.join(analyzer.attr_docs[qualname])\n+                                    break\n+                        except Exception:\n+                            # If we can't analyze the module, continue to next base class\n+                            continue\n \n     return doc\n",
    "variant_7": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..5fad15932 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -710,8 +710,27 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n+            \n+            # For inherited annotation-only members, try to get annotation comment documentation\n+            if not isinstance(doc, str) and member is INSTANCEATTR:\n+                # Check if this is an inherited annotation-only member\n+                for cls in inspect.getmro(self.object):\n+                    if cls is self.object:\n+                        continue\n+                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n+                        # Try to get annotation comment from the defining class's module\n+                        try:\n+                            analyzer = ModuleAnalyzer.for_module(cls.__module__)\n+                            analyzer.find_attr_docs()\n+                            qualname = f\"{cls.__qualname__}.{membername}\"\n+                            if qualname in analyzer.attr_docs:\n+                                doc = '\\n'.join(analyzer.attr_docs[qualname])\n+                                break\n+                        except (PycodeError, AttributeError):\n+                            continue\n             if not isinstance(doc, str):\n                 # Ignore non-string __doc__\n                 doc = None\n@@ -728,7 +747,25 @@ class Documenter:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n \n+\n             has_doc = bool(doc)\n+            \n+            # For inherited annotation-only members, check for annotation comment documentation\n+            if not has_doc and isinstance(obj, ObjectMember) and not obj.docstring:\n+                # Try to find annotation comment documentation from the defining class\n+                for cls in inspect.getmro(self.object):\n+                    if cls is self.object:\n+                        continue\n+                    if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n+                        try:\n+                            analyzer = ModuleAnalyzer.for_module(cls.__module__)\n+                            analyzer.find_attr_docs()\n+                            if (cls.__name__, membername) in analyzer.attr_docs:\n+                                doc = '\\n'.join(analyzer.attr_docs[(cls.__name__, membername)])\n+                                has_doc = bool(doc)\n+                                break\n+                        except (PycodeError, AttributeError):\n+                            continue\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -784,7 +821,21 @@ class Documenter:\n                     keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n+\n                     keep = has_doc or self.options.undoc_members\n+                    \n+                    # For annotation-only inherited members, check for annotation comments\n+                    if not keep and isinstance(obj, ObjectMember) and obj.class_ != self.object:\n+                        # This is an inherited annotation-only member\n+                        try:\n+                            from sphinx.pycode import ModuleAnalyzer\n+                            analyzer = ModuleAnalyzer.for_module(obj.class_.__module__)\n+                            analyzer.find_attr_docs()\n+                            qualname = f\"{obj.class_.__qualname__}.{membername}\"\n+                            if qualname in analyzer.attr_docs:\n+                                keep = True\n+                        except (PycodeError, AttributeError, ImportError):\n+                            pass\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\ndiff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py\nindex 477aae247..3aee92be2 100644\n--- a/sphinx/ext/autodoc/importer.py\n+++ b/sphinx/ext/autodoc/importer.py\n@@ -225,12 +225,32 @@ def get_object_members(subject: Any, objpath: List[str], attrgetter: Callable,\n         except AttributeError:\n             continue\n \n+\n     # annotation only member (ex. attr: int)\n     for i, cls in enumerate(getmro(subject)):\n         for name in getannotations(cls):\n             name = unmangle(cls, name)\n             if name and name not in members:\n-                members[name] = Attribute(name, i == 0, INSTANCEATTR)\n+                # Store additional metadata about the defining class for annotation comment lookup\n+                attr_value = INSTANCEATTR\n+                # Add metadata about the defining class and module for cross-module doc lookup\n+                if hasattr(attr_value, '__dict__'):\n+                    attr_value.__defining_class__ = cls\n+                    attr_value.__defining_module__ = getattr(cls, '__module__', None)\n+                else:\n+                    # Create a wrapper object to store metadata\n+                    class AnnotationAttribute:\n+                        def __init__(self, value, defining_class, defining_module):\n+                            self.value = value\n+                            self.__defining_class__ = defining_class\n+                            self.__defining_module__ = defining_module\n+                        \n+                        def __repr__(self):\n+                            return repr(self.value)\n+                    \n+                    attr_value = AnnotationAttribute(INSTANCEATTR, cls, getattr(cls, '__module__', None))\n+                \n+                members[name] = Attribute(name, i == 0, attr_value)\n \n     if analyzer:\n         # append instance attributes (cf. self.attr1) if analyzer knows\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 5477e64f7..9974d76e2 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -889,6 +889,7 @@ class Signature:\n         return stringify_annotation(annotation)\n \n \n+\n def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n            allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n     \"\"\"Get the docstring for the object.\n@@ -905,7 +906,7 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n     elif doc is None and allow_inherited:\n         doc = inspect.getdoc(obj)\n \n-        if doc is None and cls:\n+        if doc is None and cls and name:\n             # inspect.getdoc() does not support some kind of inherited and decorated methods.\n             # This tries to obtain the docstring from super classes.\n             for basecls in getattr(cls, '__mro__', []):\n@@ -914,5 +915,30 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n                     doc = inspect.getdoc(meth)\n                     if doc:\n                         break\n+            \n+            # If still no doc found, check for annotation comments in superclass modules\n+            if doc is None:\n+                try:\n+                    from sphinx.pycode import ModuleAnalyzer\n+                    for basecls in getattr(cls, '__mro__', []):\n+                        if hasattr(basecls, '__module__') and hasattr(basecls, '__annotations__'):\n+                            if name in basecls.__annotations__:\n+                                try:\n+                                    analyzer = ModuleAnalyzer.for_module(basecls.__module__)\n+                                    analyzer.analyze()\n+                                    # Get annotation comments for the class\n+                                    attr_docs = analyzer.find_attr_docs()\n+                                    # Look for the attribute in this class\n+                                    class_name = basecls.__name__\n+                                    attr_key = (class_name, name)\n+                                    if attr_key in attr_docs:\n+                                        doc = attr_docs[attr_key]\n+                                        break\n+                                except Exception:\n+                                    # If analysis fails, continue to next class\n+                                    continue\n+                except ImportError:\n+                    # ModuleAnalyzer not available, skip annotation comment lookup\n+                    pass\n \n     return doc\n",
    "variant_8": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex dc413b5c2..89ff70445 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -710,11 +710,41 @@ class Documenter:\n             else:\n                 isattr = False\n \n+\n             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n                          self.parent, self.object_name)\n             if not isinstance(doc, str):\n                 # Ignore non-string __doc__\n                 doc = None\n+            \n+            # For inherited annotation-only members, try to get annotation comment documentation\n+            if doc is None and member is INSTANCEATTR and self.parent:\n+                try:\n+                    # Find which class this annotation comes from\n+                    for cls in inspect.getmro(self.parent):\n+                        if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n+                            # Try to get annotation comment from the defining class's module\n+                            cls_module = safe_getattr(cls, '__module__', None)\n+                            if cls_module:\n+                                try:\n+                                    from sphinx.pycode import ModuleAnalyzer\n+                                    analyzer = ModuleAnalyzer.for_module(cls_module)\n+                                    analyzer.analyze()\n+                                    # Look for annotation comment in the defining class\n+                                    qualname = getattr(cls, '__qualname__', cls.__name__)\n+                                    attr_key = f\"{qualname}.{membername}\"\n+                                    if attr_key in analyzer.attr_docs:\n+                                        doc = '\\n'.join(analyzer.attr_docs[attr_key])\n+                                        break\n+                                except (PycodeError, ImportError):\n+                                    continue\n+                            break\n+                except Exception:\n+                    # If anything fails, continue with doc = None\n+                    pass\n+            if not isinstance(doc, str):\n+                # Ignore non-string __doc__\n+                doc = None\n \n             # if the member __doc__ is the same as self's __doc__, it's just\n             # inherited and therefore not the member's doc\n@@ -728,7 +758,34 @@ class Documenter:\n                 # hack for ClassDocumenter to inject docstring via ObjectMember\n                 doc = obj.docstring\n \n+\n             has_doc = bool(doc)\n+            \n+            # Check for annotation comment documentation for inherited members\n+            if not has_doc and isinstance(obj, ObjectMember) and obj.class_doc is None:\n+                # Try to get annotation comment from the defining class\n+                try:\n+                    if hasattr(self, 'analyzer') and self.analyzer:\n+                        # Check if this is an annotation-only member from a superclass\n+                        for cls in inspect.getmro(self.object):\n+                            if cls is self.object:\n+                                continue\n+                            if hasattr(cls, '__annotations__') and membername in cls.__annotations__:\n+                                # Found the defining class, try to get annotation comment\n+                                try:\n+                                    cls_analyzer = ModuleAnalyzer.for_module(cls.__module__)\n+                                    cls_analyzer.analyze()\n+                                    if hasattr(cls_analyzer, 'attr_docs') and cls_analyzer.attr_docs:\n+                                        attr_doc = cls_analyzer.attr_docs.get((cls.__name__, membername))\n+                                        if attr_doc:\n+                                            doc = '\\n'.join(attr_doc)\n+                                            has_doc = True\n+                                            break\n+                                except (PycodeError, AttributeError):\n+                                    pass\n+                                break\n+                except (AttributeError, TypeError):\n+                    pass\n \n             metadata = extract_metadata(doc)\n             if 'private' in metadata:\n@@ -784,7 +841,24 @@ class Documenter:\n                     keep = False\n                 else:\n                     # ignore undocumented members if :undoc-members: is not given\n+\n                     keep = has_doc or self.options.undoc_members\n+                    \n+                    # Special handling for annotation-only inherited members\n+                    if not keep and not has_doc and isinstance(obj, ObjectMember):\n+                        # Check if this is an annotation-only member from a superclass\n+                        # that might have annotation comment documentation\n+                        if hasattr(obj, 'class_') and obj.class_ != self.object:\n+                            try:\n+                                analyzer = ModuleAnalyzer.for_module(obj.class_.__module__)\n+                                analyzer.analyze()\n+                                qualname = f\"{obj.class_.__qualname__}.{membername}\"\n+                                if qualname in analyzer.annotations:\n+                                    attr_docs = analyzer.find_attr_docs()\n+                                    if (obj.class_.__name__, membername) in attr_docs:\n+                                        keep = True\n+                            except (PycodeError, AttributeError):\n+                                pass\n \n             if isinstance(obj, ObjectMember) and obj.skipped:\n                 # forcedly skipped member (ex. a module attribute not defined in __all__)\ndiff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py\nindex 477aae247..58b5b8b3d 100644\n--- a/sphinx/ext/autodoc/importer.py\n+++ b/sphinx/ext/autodoc/importer.py\n@@ -225,12 +225,25 @@ def get_object_members(subject: Any, objpath: List[str], attrgetter: Callable,\n         except AttributeError:\n             continue\n \n+\n     # annotation only member (ex. attr: int)\n     for i, cls in enumerate(getmro(subject)):\n         for name in getannotations(cls):\n             name = unmangle(cls, name)\n             if name and name not in members:\n-                members[name] = Attribute(name, i == 0, INSTANCEATTR)\n+                # Store additional metadata about the source class for annotation comment lookup\n+                attr_value = INSTANCEATTR\n+                # If this is an inherited annotation (i > 0), store the source class info\n+                if hasattr(attr_value, '__class__'):\n+                    # Create a wrapper that stores source class information\n+                    class AnnotationAttribute:\n+                        def __init__(self, value, source_cls):\n+                            self.value = value\n+                            self.source_cls = source_cls\n+                        def __repr__(self):\n+                            return repr(self.value)\n+                    attr_value = AnnotationAttribute(INSTANCEATTR, cls)\n+                members[name] = Attribute(name, i == 0, attr_value)\n \n     if analyzer:\n         # append instance attributes (cf. self.attr1) if analyzer knows\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex 5477e64f7..acfebdbd1 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -889,6 +889,7 @@ class Signature:\n         return stringify_annotation(annotation)\n \n \n+\n def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n            allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\n     \"\"\"Get the docstring for the object.\n@@ -905,7 +906,7 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n     elif doc is None and allow_inherited:\n         doc = inspect.getdoc(obj)\n \n-        if doc is None and cls:\n+        if doc is None and cls and name:\n             # inspect.getdoc() does not support some kind of inherited and decorated methods.\n             # This tries to obtain the docstring from super classes.\n             for basecls in getattr(cls, '__mro__', []):\n@@ -914,5 +915,24 @@ def getdoc(obj: Any, attrgetter: Callable = safe_getattr,\n                     doc = inspect.getdoc(meth)\n                     if doc:\n                         break\n+            \n+            # If still no doc found, try to get annotation comment from superclass modules\n+            if doc is None:\n+                for basecls in getattr(cls, '__mro__', []):\n+                    if hasattr(basecls, '__annotations__') and name in basecls.__annotations__:\n+                        try:\n+                            from sphinx.pycode import ModuleAnalyzer\n+                            module = inspect.getmodule(basecls)\n+                            if module and hasattr(module, '__file__') and module.__file__:\n+                                analyzer = ModuleAnalyzer.for_module(module.__name__)\n+                                analyzer.analyze()\n+                                # Get annotation comment for the attribute\n+                                attr_doc = analyzer.attr_docs.get((basecls.__name__, name))\n+                                if attr_doc:\n+                                    doc = '\\n'.join(attr_doc)\n+                                    break\n+                        except Exception:\n+                            # If ModuleAnalyzer fails, continue to next base class\n+                            continue\n \n     return doc\n"
  }
}