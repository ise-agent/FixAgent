{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/matplotlib/lib/matplotlib/colorbar.py lines 1104-1111)": "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            # Handle LogNorm compatibility - prevent division by zero\n            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n                # Use a small positive value or inherit from mappable if available\n                if hasattr(self, 'mappable') and self.mappable is not None:\n                    data = self.mappable.get_array()\n                    if data is not None:\n                        positive_data = data[data > 0]\n                        if len(positive_data) > 0:\n                            self.norm.vmin = np.min(positive_data)\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n                else:\n                    self.norm.vmin = 1e-10\n            b = self.norm.inverse(b)\n",
    "Location 2 (/root/hy/projects_4/matplotlib/lib/matplotlib/colorbar.py lines 510-514)": "\n        if mappable.norm != self.norm:\n            self.norm = mappable.norm\n            # Ensure colorbar boundaries are compatible with the new norm\n            if hasattr(mappable.norm, 'vmin') and hasattr(mappable.norm, 'vmax'):\n                # For norms like LogNorm that have specific requirements\n                if isinstance(mappable.norm, colors.LogNorm):\n                    # LogNorm requires positive vmin/vmax\n                    if mappable.norm.vmin is not None and mappable.norm.vmin > 0:\n                        self._boundaries = None  # Reset boundaries to force recalculation\n                    if mappable.norm.vmax is not None and mappable.norm.vmax > 0:\n                        self._boundaries = None  # Reset boundaries to force recalculation\n            self._reset_locator_formatter_scale()\n\n        self._draw_all()\n",
    "Location 3 (/root/hy/projects_4/matplotlib/lib/matplotlib/colorbar.py lines 1167-1173)": "\n    def _reset_locator_formatter_scale(self):\n        \"\"\"\n        Reset the locator et al to defaults.  Any user-hardcoded changes\n        need to be re-entered if this gets called (either at init, or when\n        the mappable normal gets changed: Colorbar.update_normal)\n        \"\"\"\n        # Ensure norm compatibility before processing values\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, ensure vmin and vmax are positive\n            if hasattr(self.mappable, 'get_array'):\n                array = self.mappable.get_array()\n                if array is not None and array.size > 0:\n                    array_min = np.ma.masked_invalid(array).compressed()\n                    if array_min.size > 0:\n                        array_min = array_min[array_min > 0].min() if (array_min > 0).any() else 1e-10\n                        if self.norm.vmin <= 0:\n                            self.norm.vmin = array_min\n                        if self.norm.vmax <= 0:\n                            self.norm.vmax = max(array_min * 10, 1.0)\n            else:\n                # Fallback if no array data available\n                if self.norm.vmin <= 0:\n                    self.norm.vmin = 1e-10\n                if self.norm.vmax <= 0:\n                    self.norm.vmax = 1.0\n        \n        self._process_values()\n",
    "Location 4 (/root/hy/projects_4/matplotlib/lib/matplotlib/colorbar.py lines 1065-1070)": "\ndef _process_values(self):\n    \"\"\"\n    Set `_boundaries` and `_values` based on the self.boundaries and\n    self.values if not None, or based on the size of the colormap and\n    the vmin/vmax of the norm.\n    \"\"\"\n    # Handle LogNorm compatibility - ensure vmin > 0 to prevent ZeroDivisionError\n    if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            if hasattr(self, 'mappable') and self.mappable is not None:\n                # Try to get positive vmin from mappable data\n                try:\n                    data = self.mappable.get_array()\n                    if data is not None:\n                        positive_data = data[data > 0]\n                        if len(positive_data) > 0:\n                            self.norm.vmin = positive_data.min()\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n                except (AttributeError, IndexError):\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n",
    "Location 5 (/root/hy/projects_4/matplotlib/lib/matplotlib/colorbar.py lines 493-520)": "\ndef update_normal(self, mappable):\n    \"\"\"\n    Update solid patches, lines, etc.\n\n    This is meant to be called when the norm of the image or contour plot\n    to which this colorbar belongs changes.\n\n    If the norm on the mappable is different than before, this resets the\n    locator and formatter for the axis, so if these have been customized,\n    they will need to be customized again.  However, if the norm only\n    changes values of *vmin*, *vmax* or *cmap* then the old formatter\n    and locator will be preserved.\n    \"\"\"\n    _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n    self.mappable = mappable\n    self.set_alpha(mappable.get_alpha())\n    self.cmap = mappable.cmap\n    if mappable.norm != self.norm:\n        self.norm = mappable.norm\n        # Ensure colorbar vmin/vmax are compatible with the new norm\n        if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n            # For LogNorm and similar norms, inherit vmin/vmax from mappable's norm\n            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n                # Use mappable's actual data range for LogNorm compatibility\n                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n                    data = mappable.get_array()\n                    data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                    if self.norm.vmin <= 0:\n                        self.norm.vmin = data_min\n        self._reset_locator_formatter_scale()\n\n    self._draw_all()\n    if isinstance(self.mappable, contour.ContourSet):\n        CS = self.mappable\n        if not CS.filled:\n            self.add_lines(CS)\n    self.stale = True\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/matplotlib/lib/matplotlib/colorbar.py lines 1104-1111)": [
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            # Handle LogNorm compatibility - ensure vmin > 0 to avoid division by zero\n            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n                if hasattr(self, 'mappable') and self.mappable is not None:\n                    # Try to get a reasonable vmin from the mappable's data\n                    try:\n                        data = self.mappable.get_array()\n                        if data is not None and len(data) > 0:\n                            data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                            self.norm.vmin = max(data_min, 1e-10)\n                        else:\n                            self.norm.vmin = 1e-10\n                    except (AttributeError, ValueError):\n                        self.norm.vmin = 1e-10\n                else:\n                    self.norm.vmin = 1e-10\n            b = self.norm.inverse(b)\n",
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            # Handle LogNorm case to prevent division by zero\n            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n                # Use mappable's data range if available, otherwise use small positive value\n                if hasattr(self, 'mappable') and self.mappable is not None:\n                    data = getattr(self.mappable, '_A', None)\n                    if data is not None:\n                        data_min = np.ma.masked_invalid(data).min()\n                        if data_min > 0:\n                            self.norm.vmin = data_min\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n                else:\n                    self.norm.vmin = 1e-10\n            b = self.norm.inverse(b)\n",
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            # Handle LogNorm compatibility - ensure vmin > 0 to avoid division by zero\n            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n                # Use mappable's actual data range if available, otherwise use small positive value\n                if hasattr(self, 'mappable') and self.mappable is not None:\n                    try:\n                        array = self.mappable.get_array()\n                        if array is not None and array.size > 0:\n                            data_min = np.nanmin(array[array > 0]) if np.any(array > 0) else 1e-10\n                            self.norm.vmin = max(data_min, 1e-10)\n                    except (AttributeError, TypeError):\n                        self.norm.vmin = 1e-10\n                else:\n                    self.norm.vmin = 1e-10\n            b = self.norm.inverse(b)\n",
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            # Handle LogNorm compatibility - ensure vmin > 0 to avoid division by zero\n            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n                if hasattr(self, 'mappable') and self.mappable is not None:\n                    # Try to get positive vmin from mappable's data\n                    data = getattr(self.mappable, 'get_array', lambda: None)()\n                    if data is not None:\n                        data_min = np.ma.min(data[data > 0]) if np.ma.is_masked(data) else np.min(data[data > 0])\n                        if np.isfinite(data_min) and data_min > 0:\n                            self.norm.vmin = data_min\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n                else:\n                    self.norm.vmin = 1e-10\n            b = self.norm.inverse(b)\n",
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            # For LogNorm, ensure vmin > 0 to avoid division by zero\n            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n                if hasattr(self, 'mappable') and self.mappable is not None:\n                    # Try to get a positive minimum from the mappable's data\n                    data = self.mappable.get_array()\n                    if data is not None and len(data) > 0:\n                        positive_data = data[data > 0]\n                        if len(positive_data) > 0:\n                            self.norm.vmin = float(np.min(positive_data))\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n                else:\n                    self.norm.vmin = 1e-10\n            b = self.norm.inverse(b)\n",
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        \n        # Handle LogNorm compatibility - ensure vmin > 0 to prevent division by zero\n        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n            if hasattr(self, 'mappable') and self.mappable is not None:\n                # Try to get a reasonable vmin from the mappable's data\n                try:\n                    data = self.mappable.get_array()\n                    if data is not None:\n                        data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                        self.norm.vmin = max(data_min, 1e-10)\n                    else:\n                        self.norm.vmin = 1e-10\n                except (AttributeError, ValueError):\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n        \n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            b = self.norm.inverse(b)\n",
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            # Handle LogNorm compatibility - ensure vmin > 0 to avoid division by zero\n            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n                # Use mappable's actual data range or fallback to small positive value\n                if hasattr(self, 'mappable') and self.mappable is not None:\n                    array = self.mappable.get_array()\n                    if array is not None and array.size > 0:\n                        data_min = np.ma.masked_invalid(array).min()\n                        if np.ma.is_masked(data_min) or data_min <= 0:\n                            self.norm.vmin = 1e-10\n                        else:\n                            self.norm.vmin = float(data_min)\n                    else:\n                        self.norm.vmin = 1e-10\n                else:\n                    self.norm.vmin = 1e-10\n            b = self.norm.inverse(b)\n",
      "\n        # transform from 0-1 to vmin-vmax:\n        if not self.norm.scaled():\n            self.norm.vmin = 0\n            self.norm.vmax = 1\n        self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n            self.norm.vmin, self.norm.vmax, expander=0.1)\n        if (not isinstance(self.norm, colors.BoundaryNorm) and\n                (self.boundaries is None)):\n            # Handle LogNorm compatibility - ensure vmin > 0 to avoid division by zero\n            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n                # Use mappable's data range or fallback to small positive value\n                if hasattr(self, 'mappable') and self.mappable is not None:\n                    try:\n                        data = self.mappable.get_array()\n                        if data is not None and len(data) > 0:\n                            data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                            self.norm.vmin = max(data_min, 1e-10)\n                    except (AttributeError, ValueError):\n                        self.norm.vmin = 1e-10\n                else:\n                    self.norm.vmin = 1e-10\n            b = self.norm.inverse(b)\n"
    ],
    "Location 2 (/root/hy/projects_4/matplotlib/lib/matplotlib/colorbar.py lines 510-514)": [
      "\n        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n        self.mappable = mappable\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        if mappable.norm != self.norm:\n            self.norm = mappable.norm\n            # Ensure vmin/vmax compatibility for LogNorm\n            if isinstance(self.norm, colors.LogNorm):\n                # Copy vmin/vmax from mappable to ensure compatibility\n                self.norm.vmin = mappable.norm.vmin\n                self.norm.vmax = mappable.norm.vmax\n            self._reset_locator_formatter_scale()\n\n        self._draw_all()\n",
      "\n        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n        self.mappable = mappable\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        if mappable.norm != self.norm:\n            self.norm = mappable.norm\n            # Ensure norm compatibility, especially for LogNorm\n            if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n                if isinstance(self.norm, colors.LogNorm):\n                    # For LogNorm, ensure vmin > 0 to avoid division by zero\n                    if self.norm.vmin <= 0:\n                        # Get valid range from mappable data if available\n                        if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n                            data = mappable.get_array()\n                            valid_data = data[data > 0] if np.ma.is_masked(data) else data[data > 0]\n                            if len(valid_data) > 0:\n                                self.norm.vmin = np.min(valid_data)\n                            else:\n                                self.norm.vmin = 1e-10\n                        else:\n                            self.norm.vmin = 1e-10\n            self._reset_locator_formatter_scale()\n\n        self._draw_all()\n",
      "\n        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n        self.mappable = mappable\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        if mappable.norm != self.norm:\n            self.norm = mappable.norm\n            # Ensure norm compatibility, especially for LogNorm\n            if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n                # For LogNorm, ensure vmin > 0 to prevent division by zero\n                if isinstance(self.norm, colors.LogNorm):\n                    if self.norm.vmin <= 0:\n                        # Use mappable's data to determine appropriate vmin\n                        if hasattr(mappable, 'get_array'):\n                            array = mappable.get_array()\n                            if array is not None:\n                                pos_data = array[array > 0]\n                                if len(pos_data) > 0:\n                                    self.norm.vmin = float(np.min(pos_data))\n                                else:\n                                    self.norm.vmin = 1e-10\n                            else:\n                                self.norm.vmin = 1e-10\n                        else:\n                            self.norm.vmin = 1e-10\n            self._reset_locator_formatter_scale()\n\n        self._draw_all()\n",
      "\n        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n        self.mappable = mappable\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        if mappable.norm != self.norm:\n            self.norm = mappable.norm\n            # Ensure vmin/vmax compatibility with new norm, especially LogNorm\n            if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n                # For LogNorm, ensure vmin > 0 to prevent ZeroDivisionError\n                if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n                    # Use mappable's actual data range or a small positive value\n                    if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n                        data = mappable.get_array()\n                        data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                        self.norm.vmin = data_min\n                    else:\n                        self.norm.vmin = 1e-10\n            self._reset_locator_formatter_scale()\n\n        self._draw_all()\n",
      "\n    def update_normal(self, mappable):\n        \"\"\"\n        Update this colorbar to match the mappable's properties.\n\n        Typically this is automatically called by the colorbar's associated\n        mappable's :meth:`~.ScalarMappable.callbacksSM` at draw time by\n        :meth:`~.Figure.draw`.\n\n        Parameters\n        ----------\n        mappable : `.ScalarMappable`\n            The mappable whose properties are to be reflected in this colorbar.\n\n        Notes\n        -----\n        If the norm on the mappable is different than before, this resets the\n        locator and formatter for the axis, so if these have been customized,\n        they will need to be customized again.  However, if the norm only\n        changes values of *vmin*, *vmax* or *cmap* then the old formatter\n        and locator will be preserved.\n        \"\"\"\n        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n        self.mappable = mappable\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        if mappable.norm != self.norm:\n            self.norm = mappable.norm\n            # Ensure colorbar vmin/vmax are compatible with the new norm\n            if hasattr(mappable.norm, 'vmin') and hasattr(mappable.norm, 'vmax'):\n                self.vmin = mappable.norm.vmin\n                self.vmax = mappable.norm.vmax\n            self._reset_locator_formatter_scale()\n\n        self._draw_all()\n",
      "\n        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n        self.mappable = mappable\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        if mappable.norm != self.norm:\n            self.norm = mappable.norm\n            # Ensure colorbar bounds are compatible with the new norm\n            if isinstance(self.norm, colors.LogNorm):\n                # For LogNorm, ensure vmin > 0 to avoid division by zero\n                mappable_vmin, mappable_vmax = mappable.get_clim()\n                if mappable_vmin <= 0:\n                    # Use a small positive value or the actual data minimum\n                    if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n                        data = mappable.get_array()\n                        positive_data = data[data > 0]\n                        if len(positive_data) > 0:\n                            mappable_vmin = positive_data.min()\n                        else:\n                            mappable_vmin = 1e-10\n                    else:\n                        mappable_vmin = 1e-10\n                # Update norm bounds\n                self.norm.vmin = mappable_vmin\n                self.norm.vmax = mappable_vmax\n            _reset_locator_formatter_scale()\n\n        self._draw_all()\n",
      "\n        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n        self.mappable = mappable\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        if mappable.norm != self.norm:\n            self.norm = mappable.norm\n            # For LogNorm, ensure vmin/vmax compatibility\n            if isinstance(self.norm, colors.LogNorm):\n                # Copy vmin/vmax from mappable to ensure compatibility\n                if hasattr(mappable, 'get_clim'):\n                    vmin, vmax = mappable.get_clim()\n                    if vmin is not None and vmax is not None:\n                        self.norm.vmin = vmin\n                        self.norm.vmax = vmax\n            self._reset_locator_formatter_scale()\n\n        self._draw_all()\n",
      "\n        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n        self.mappable = mappable\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        if mappable.norm != self.norm:\n            self.norm = mappable.norm\n            # For LogNorm, ensure vmin/vmax compatibility\n            if isinstance(self.norm, colors.LogNorm):\n                if hasattr(mappable, 'get_clim'):\n                    vmin, vmax = mappable.get_clim()\n                    if vmin is not None and vmax is not None:\n                        self.norm.vmin = max(vmin, 1e-10) if vmin <= 0 else vmin\n                        self.norm.vmax = vmax\n            self._reset_locator_formatter_scale()\n\n        self._draw_all()\n"
    ],
    "Location 3 (/root/hy/projects_4/matplotlib/lib/matplotlib/colorbar.py lines 1167-1173)": [
      "\n    def _reset_locator_formatter_scale(self):\n        \"\"\"\n        Reset the locator et al to defaults.  Any user-hardcoded changes\n        need to be re-entered if this gets called (either at init, or when\n        the mappable normal gets changed: Colorbar.update_normal)\n        \"\"\"\n        # Ensure norm compatibility before processing values\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, ensure vmin and vmax are positive\n            if hasattr(self.mappable, 'get_array') and self.mappable.get_array() is not None:\n                data = self.mappable.get_array()\n                if data.size > 0:\n                    data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                    if self.norm.vmin <= 0:\n                        self.norm.vmin = data_min\n                    if self.norm.vmax <= 0:\n                        self.norm.vmax = max(np.max(data), self.norm.vmin * 10)\n            else:\n                # Fallback if no data available\n                if self.norm.vmin <= 0:\n                    self.norm.vmin = 1e-10\n                if self.norm.vmax <= self.norm.vmin:\n                    self.norm.vmax = self.norm.vmin * 10\n        \n        self._process_values()\n",
      "\n    def _reset_locator_formatter_scale(self):\n        \"\"\"\n        Reset the locator et al to defaults.  Any user-hardcoded changes\n        need to be re-entered if this gets called (either at init, or when\n        the mappable normal gets changed: Colorbar.update_normal)\n        \"\"\"\n        # Ensure norm compatibility before processing values\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, ensure vmin > 0 to avoid division by zero\n            if hasattr(self, 'vmin') and self.vmin is not None and self.vmin <= 0:\n                # Try to get a reasonable vmin from the mappable's data\n                if hasattr(self.mappable, 'get_array'):\n                    array = self.mappable.get_array()\n                    if array is not None and len(array) > 0:\n                        positive_data = array[array > 0]\n                        if len(positive_data) > 0:\n                            self.vmin = np.min(positive_data)\n                        else:\n                            self.vmin = 1e-10\n                    else:\n                        self.vmin = 1e-10\n                else:\n                    self.vmin = 1e-10\n        \n        self._process_values()\n",
      "\n    def _reset_locator_formatter_scale(self):\n        \"\"\"\n        Reset the locator et al to defaults.  Any user-hardcoded changes\n        need to be re-entered if this gets called (either at init, or when\n        the mappable normal gets changed: Colorbar.update_normal)\n        \"\"\"\n        # Ensure norm compatibility before processing values\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, ensure vmin > 0 to avoid ZeroDivisionError\n            if hasattr(self.mappable, 'get_clim'):\n                mappable_vmin, mappable_vmax = self.mappable.get_clim()\n                if mappable_vmin > 0:\n                    self.norm.vmin = max(self.norm.vmin or mappable_vmin, mappable_vmin)\n                    self.norm.vmax = self.norm.vmax or mappable_vmax\n                elif self.norm.vmin <= 0:\n                    # Set a small positive value if vmin is non-positive\n                    self.norm.vmin = 1e-10\n        \n        self._process_values()\n",
      "\n    def _reset_locator_formatter_scale(self):\n        \"\"\"\n        Reset the locator et al to defaults.  Any user-hardcoded changes\n        need to be re-entered if this gets called (either at init, or when\n        the mappable normal gets changed: Colorbar.update_normal)\n        \"\"\"\n        # Ensure norm compatibility before processing values\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, ensure vmin > 0 to avoid division by zero\n            if hasattr(self.mappable, 'get_array') and self.mappable.get_array() is not None:\n                data = self.mappable.get_array()\n                if data.size > 0:\n                    data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                    if self.norm.vmin <= 0:\n                        self.norm.vmin = max(data_min, 1e-10)\n                    if self.norm.vmax <= 0:\n                        self.norm.vmax = max(self.norm.vmin * 10, 1.0)\n            else:\n                # Fallback if no data available\n                if self.norm.vmin <= 0:\n                    self.norm.vmin = 1e-10\n                if self.norm.vmax <= self.norm.vmin:\n                    self.norm.vmax = self.norm.vmin * 10\n        \n        self._process_values()\n",
      "\n    def _reset_locator_formatter_scale(self):\n        \"\"\"\n        Reset the locator et al to defaults.  Any user-hardcoded changes\n        need to be re-entered if this gets called (either at init, or when\n        the mappable normal gets changed: Colorbar.update_normal)\n        \"\"\"\n        # Ensure norm compatibility before processing values\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, ensure vmin/vmax are positive\n            if hasattr(self.mappable, 'get_array'):\n                array = self.mappable.get_array()\n                if array is not None and len(array) > 0:\n                    array_min = np.ma.min(array[array > 0]) if np.ma.is_masked(array) else np.min(array[array > 0])\n                    if len(array[array > 0]) > 0:\n                        if self.norm.vmin <= 0:\n                            self.norm.vmin = float(array_min)\n                        if self.norm.vmax <= 0:\n                            self.norm.vmax = float(np.ma.max(array) if np.ma.is_masked(array) else np.max(array))\n        \n        self._process_values()\n",
      "\n    def _reset_locator_formatter_scale(self):\n        \"\"\"\n        Reset the locator et al to defaults.  Any user-hardcoded changes\n        need to be re-entered if this gets called (either at init, or when\n        the mappable normal gets changed: Colorbar.update_normal)\n        \"\"\"\n        # Ensure norm compatibility before processing values\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, ensure vmin > 0 to avoid division by zero\n            if self.vmin <= 0:\n                if hasattr(self.mappable, 'get_array'):\n                    array = self.mappable.get_array()\n                    if array is not None and array.size > 0:\n                        positive_data = array[array > 0]\n                        if positive_data.size > 0:\n                            self.vmin = float(positive_data.min())\n                        else:\n                            self.vmin = 1e-10\n                    else:\n                        self.vmin = 1e-10\n                else:\n                    self.vmin = 1e-10\n        \n        self._process_values()\n",
      "\n    def _reset_locator_formatter_scale(self):\n        \"\"\"\n        Reset the locator et al to defaults.  Any user-hardcoded changes\n        need to be re-entered if this gets called (either at init, or when\n        the mappable normal gets changed: Colorbar.update_normal)\n        \"\"\"\n        # Ensure norm compatibility before processing values\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, ensure vmin > 0\n            if hasattr(self, 'vmin') and self.vmin is not None and self.vmin <= 0:\n                if hasattr(self.mappable, 'get_array'):\n                    array = self.mappable.get_array()\n                    if array is not None and len(array) > 0:\n                        positive_values = array[array > 0]\n                        if len(positive_values) > 0:\n                            self.vmin = positive_values.min()\n                        else:\n                            self.vmin = 1e-10\n                    else:\n                        self.vmin = 1e-10\n                else:\n                    self.vmin = 1e-10\n        \n        self._process_values()\n",
      "\n    def _reset_locator_formatter_scale(self):\n        \"\"\"\n        Reset the locator et al to defaults.  Any user-hardcoded changes\n        need to be re-entered if this gets called (either at init, or when\n        the mappable normal gets changed: Colorbar.update_normal)\n        \"\"\"\n        # Ensure norm compatibility before processing values\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, ensure vmin and vmax are positive\n            if hasattr(self.mappable, 'get_array'):\n                array = self.mappable.get_array()\n                if array is not None:\n                    array_min = np.nanmin(array[array > 0]) if np.any(array > 0) else 1e-10\n                    if self.vmin <= 0:\n                        self.vmin = array_min\n                    if self.vmax <= 0:\n                        self.vmax = max(np.nanmax(array), self.vmin * 10)\n            else:\n                # Fallback if no array available\n                if self.vmin <= 0:\n                    self.vmin = 1e-10\n                if self.vmax <= self.vmin:\n                    self.vmax = self.vmin * 10\n        \n        self._process_values()\n"
    ],
    "Location 4 (/root/hy/projects_4/matplotlib/lib/matplotlib/colorbar.py lines 1065-1070)": [
      "\ndef _process_values(self):\n    \"\"\"\n    Set `_boundaries` and `_values` based on the self.boundaries and\n    self.values if not None, or based on the size of the colormap and\n    the vmin/vmax of the norm.\n    \"\"\"\n    # Handle LogNorm compatibility - ensure vmin > 0 to prevent division by zero\n    if isinstance(self.norm, colors.LogNorm):\n        if self.norm.vmin is None or self.norm.vmin <= 0:\n            # Try to get a reasonable positive minimum from the mappable\n            if hasattr(self.mappable, 'get_array'):\n                array = self.mappable.get_array()\n                if array is not None and len(array) > 0:\n                    positive_data = array[array > 0]\n                    if len(positive_data) > 0:\n                        self.norm.vmin = positive_data.min()\n                    else:\n                        self.norm.vmin = 1e-10\n                else:\n                    self.norm.vmin = 1e-10\n            else:\n                self.norm.vmin = 1e-10\n        \n        if self.norm.vmax is None or self.norm.vmax <= self.norm.vmin:\n            if hasattr(self.mappable, 'get_array'):\n                array = self.mappable.get_array()\n                if array is not None and len(array) > 0:\n                    self.norm.vmax = array.max()\n                else:\n                    self.norm.vmax = max(self.norm.vmin * 10, 1.0)\n            else:\n                self.norm.vmax = max(self.norm.vmin * 10, 1.0)\n",
      "\n    def _process_values(self):\n        \"\"\"\n        Set `_boundaries` and `_values` based on the self.boundaries and\n        self.values if not None, or based on the size of the colormap and\n        the vmin/vmax of the norm.\n        \"\"\"\n        # Handle LogNorm compatibility - ensure vmin > 0 for LogNorm\n        if isinstance(self.norm, colors.LogNorm):\n            if self.norm.vmin is not None and self.norm.vmin <= 0:\n                # Get actual data range from mappable if available\n                if hasattr(self, 'mappable') and self.mappable is not None:\n                    try:\n                        data = self.mappable.get_array()\n                        if data is not None:\n                            data_min = np.ma.masked_invalid(data).min()\n                            if data_min > 0:\n                                self.norm.vmin = data_min\n                            else:\n                                self.norm.vmin = max(1e-10, self.norm.vmax * 1e-10 if self.norm.vmax else 1e-10)\n                    except (AttributeError, ValueError):\n                        self.norm.vmin = max(1e-10, self.norm.vmax * 1e-10 if self.norm.vmax else 1e-10)\n                else:\n                    self.norm.vmin = max(1e-10, self.norm.vmax * 1e-10 if self.norm.vmax else 1e-10)\n",
      "\n    def _process_values(self):\n        \"\"\"\n        Set `_boundaries` and `_values` based on the self.boundaries and\n        self.values if not None, or based on the size of the colormap and\n        the vmin/vmax of the norm.\n        \"\"\"\n        # Handle LogNorm compatibility - ensure vmin > 0 for LogNorm\n        if isinstance(self.norm, colors.LogNorm):\n            if self.norm.vmin is None or self.norm.vmin <= 0:\n                # Get valid vmin from mappable data if available\n                if hasattr(self, 'mappable') and self.mappable is not None:\n                    data = self.mappable.get_array()\n                    if data is not None and len(data) > 0:\n                        valid_data = data[data > 0]\n                        if len(valid_data) > 0:\n                            self.norm.vmin = valid_data.min()\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n                else:\n                    self.norm.vmin = 1e-10\n            \n            if self.norm.vmax is None or self.norm.vmax <= self.norm.vmin:\n                if hasattr(self, 'mappable') and self.mappable is not None:\n                    data = self.mappable.get_array()\n                    if data is not None and len(data) > 0:\n                        self.norm.vmax = data.max()\n                    else:\n                        self.norm.vmax = max(self.norm.vmin * 10, 1.0)\n                else:\n                    self.norm.vmax = max(self.norm.vmin * 10, 1.0)\n",
      "\n    def _process_values(self):\n        \"\"\"\n        Set `_boundaries` and `_values` based on the self.boundaries and\n        self.values if not None, or based on the size of the colormap and\n        the vmin/vmax of the norm.\n        \"\"\"\n        # Handle LogNorm compatibility early to prevent ZeroDivisionError\n        if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n                # For LogNorm, vmin must be positive. Use mappable's data range if available.\n                if hasattr(self, 'mappable') and self.mappable is not None:\n                    try:\n                        data = self.mappable.get_array()\n                        if data is not None and len(data) > 0:\n                            data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                            self.norm.vmin = max(data_min, 1e-10)\n                        else:\n                            self.norm.vmin = 1e-10\n                    except (AttributeError, ValueError):\n                        self.norm.vmin = 1e-10\n                else:\n                    self.norm.vmin = 1e-10\n",
      "\ndef _process_values(self):\n    \"\"\"\n    Set `_boundaries` and `_values` based on the self.boundaries and\n    self.values if not None, or based on the size of the colormap and\n    the vmin/vmax of the norm.\n    \"\"\"\n    # Handle LogNorm compatibility early - ensure vmin > 0 for LogNorm\n    if isinstance(self.norm, colors.LogNorm):\n        if self.norm.vmin is not None and self.norm.vmin <= 0:\n            # Try to get a reasonable vmin from the mappable's data\n            if hasattr(self.mappable, 'get_array') and self.mappable.get_array() is not None:\n                data = self.mappable.get_array()\n                data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                self.norm.vmin = max(data_min, 1e-10)\n            else:\n                self.norm.vmin = 1e-10\n        elif self.norm.vmin is None:\n            self.norm.vmin = 1e-10\n            \n    if self.values is not None:\n        # set self._boundaries from the values...\n        self._values = np.array(self.values)\n        if self.boundaries is None:\n            # bracket values by 1/2 dv:\n            b = np.zeros(len(self.values) + 1)\n            b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])\n            b[0] = 2.0 * b[1] - b[2]\n            b[-1] = 2.0 * b[-2] - b[-3]\n            self._boundaries = b\n",
      "\n    def _process_values(self):\n        \"\"\"\n        Set `_boundaries` and `_values` based on the self.boundaries and\n        self.values if not None, or based on the size of the colormap and\n        the vmin/vmax of the norm.\n        \"\"\"\n        # Ensure norm compatibility for LogNorm before processing\n        if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n            if isinstance(self.norm, colors.LogNorm):\n                # For LogNorm, ensure vmin > 0 to avoid division by zero\n                if self.norm.vmin <= 0:\n                    if hasattr(self, 'mappable') and self.mappable is not None:\n                        # Try to get a reasonable positive minimum from mappable data\n                        try:\n                            data = self.mappable.get_array()\n                            if data is not None:\n                                positive_data = data[data > 0]\n                                if len(positive_data) > 0:\n                                    self.norm.vmin = positive_data.min()\n                                else:\n                                    self.norm.vmin = 1e-10\n                            else:\n                                self.norm.vmin = 1e-10\n                        except (AttributeError, ValueError):\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n        \n        if self.values is not None:\n            # set self._boundaries from the values...\n            self._values = np.array(self.values)\n            if self.boundaries is None:\n                # bracket values by 1/2 dv:\n                b = np.zeros(len(self.values) + 1)\n                b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])\n                b[0] = 2.0 * b[1] - b[2]\n                b[-1] = 2.0 * b[-2] - b[-3]\n                self._boundaries = b\n",
      "\n    def _process_values(self):\n        \"\"\"\n        Set `_boundaries` and `_values` based on the self.boundaries and\n        self.values if not None, or based on the size of the colormap and\n        the vmin/vmax of the norm.\n        \"\"\"\n        # Early validation for norm compatibility, especially LogNorm\n        if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n            if isinstance(self.norm, colors.LogNorm):\n                # For LogNorm, ensure vmin > 0 to prevent division by zero\n                if self.norm.vmin <= 0:\n                    # Try to get a reasonable positive vmin from the mappable's data\n                    if hasattr(self, 'mappable') and hasattr(self.mappable, 'get_array'):\n                        array = self.mappable.get_array()\n                        if array is not None and len(array) > 0:\n                            positive_data = array[array > 0]\n                            if len(positive_data) > 0:\n                                self.norm.vmin = float(np.min(positive_data))\n                            else:\n                                self.norm.vmin = 1e-10\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n        \n        if self.values is not None:\n            # set self._boundaries from the values...\n            self._values = np.array(self.values)\n            if self.boundaries is None:\n                # bracket values by 1/2 dv:\n                b = np.zeros(len(self.values) + 1)\n                b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])\n                b[0] = 2.0 * b[1] - b[2]\n                b[-1] = 2.0 * b[-2] - b[-3]\n                self._boundaries = b\n",
      "\n    def _process_values(self):\n        \"\"\"\n        Set `_boundaries` and `_values` based on the self.boundaries and\n        self.values if not None, or based on the size of the colormap and\n        the vmin/vmax of the norm.\n        \"\"\"\n        # Handle LogNorm compatibility - ensure vmin > 0 for LogNorm\n        if isinstance(self.norm, colors.LogNorm):\n            if self.norm.vmin is not None and self.norm.vmin <= 0:\n                # Try to get a reasonable positive vmin from mappable data\n                if hasattr(self.mappable, 'get_array'):\n                    array = self.mappable.get_array()\n                    if array is not None and len(array) > 0:\n                        positive_data = array[array > 0]\n                        if len(positive_data) > 0:\n                            self.norm.vmin = float(np.min(positive_data))\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n                else:\n                    self.norm.vmin = 1e-10\n"
    ],
    "Location 5 (/root/hy/projects_4/matplotlib/lib/matplotlib/colorbar.py lines 493-520)": [
      "\n    def update_normal(self, mappable):\n        \"\"\"\n        Update solid patches, lines, etc.\n\n        This is meant to be called when the norm of the image or contour plot\n        to which this colorbar belongs changes.\n\n        If the norm on the mappable is different than before, this resets the\n        locator and formatter for the axis, so if these have been customized,\n        they will need to be customized again.  However, if the norm only\n        changes values of *vmin*, *vmax* or *cmap* then the old formatter\n        and locator will be preserved.\n        \"\"\"\n        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n        self.mappable = mappable\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        if mappable.norm != self.norm:\n            self.norm = mappable.norm\n            # Ensure colorbar boundaries are compatible with the new norm\n            if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n                # For LogNorm and similar norms, ensure vmin/vmax are compatible\n                if isinstance(self.norm, colors.LogNorm):\n                    # LogNorm requires positive vmin, inherit from mappable if needed\n                    if self.norm.vmin <= 0:\n                        if hasattr(mappable, 'get_clim'):\n                            vmin, vmax = mappable.get_clim()\n                            if vmin > 0:\n                                self.norm.vmin = vmin\n                            else:\n                                # Use a small positive value as fallback\n                                self.norm.vmin = max(1e-10, self.norm.vmax * 1e-10)\n            self._reset_locator_formatter_scale()\n\n        self._draw_all()\n        if isinstance(self.mappable, contour.ContourSet):\n            CS = self.mappable\n            if not CS.filled:\n                self.add_lines(CS)\n        self.stale = True\n",
      "\ndef update_normal(self, mappable):\n    \"\"\"\n    Update solid patches, lines, etc.\n\n    This is meant to be called when the norm of the image or contour plot\n    to which this colorbar belongs changes.\n\n    If the norm on the mappable is different than before, this resets the\n    locator and formatter for the axis, so if these have been customized,\n    they will need to be customized again.  However, if the norm only\n    changes values of *vmin*, *vmax* or *cmap* then the old formatter\n    and locator will be preserved.\n    \"\"\"\n    _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n    self.mappable = mappable\n    self.set_alpha(mappable.get_alpha())\n    self.cmap = mappable.cmap\n    if mappable.norm != self.norm:\n        self.norm = mappable.norm\n        # Ensure colorbar boundaries are compatible with the new norm\n        if hasattr(mappable.norm, 'vmin') and hasattr(mappable.norm, 'vmax'):\n            self.norm.vmin = mappable.norm.vmin\n            self.norm.vmax = mappable.norm.vmax\n        self._reset_locator_formatter_scale()\n\n    self._draw_all()\n    if isinstance(self.mappable, contour.ContourSet):\n        CS = self.mappable\n        if not CS.filled:\n            self.add_lines(CS)\n    self.stale = True\n",
      "\n    def update_normal(self, mappable):\n        \"\"\"\n        Update solid patches, lines, etc.\n\n        This is meant to be called when the norm of the image or contour plot\n        to which this colorbar belongs changes.\n\n        If the norm on the mappable is different than before, this resets the\n        locator and formatter for the axis, so if these have been customized,\n        they will need to be customized again.  However, if the norm only\n        changes values of *vmin*, *vmax* or *cmap* then the old formatter\n        and locator will be preserved.\n        \"\"\"\n        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n        self.mappable = mappable\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        if mappable.norm != self.norm:\n            self.norm = mappable.norm\n            # For LogNorm, ensure colorbar boundaries are compatible\n            if isinstance(self.norm, colors.LogNorm):\n                # Inherit proper vmin/vmax from mappable to avoid division by zero\n                self.norm = mappable.norm\n                if hasattr(mappable.norm, 'vmin') and hasattr(mappable.norm, 'vmax'):\n                    # Ensure we use the mappable's norm boundaries\n                    pass  # norm assignment above already handles this\n            self._reset_locator_formatter_scale()\n\n        self._draw_all()\n        if isinstance(self.mappable, contour.ContourSet):\n            CS = self.mappable\n            if not CS.filled:\n                self.add_lines(CS)\n        self.stale = True\n",
      "\ndef update_normal(self, mappable):\n    \"\"\"\n    Update solid patches, lines, etc.\n\n    This is meant to be called when the norm of the image or contour plot\n    to which this colorbar belongs changes.\n\n    If the norm on the mappable is different than before, this resets the\n    locator and formatter for the axis, so if these have been customized,\n    they will need to be customized again.  However, if the norm only\n    changes values of *vmin*, *vmax* or *cmap* then the old formatter\n    and locator will be preserved.\n    \"\"\"\n    _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n    self.mappable = mappable\n    self.set_alpha(mappable.get_alpha())\n    self.cmap = mappable.cmap\n    if mappable.norm != self.norm:\n        self.norm = mappable.norm\n        # Ensure colorbar boundaries are compatible with the new norm\n        if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n            if isinstance(self.norm, colors.LogNorm):\n                # For LogNorm, ensure vmin > 0 to avoid division by zero\n                if self.norm.vmin <= 0:\n                    # Use mappable's actual data range for proper LogNorm bounds\n                    array = mappable.get_array()\n                    if array is not None:\n                        array_min = np.ma.masked_invalid(array, copy=False)\n                        array_min = array_min[array_min > 0]\n                        if array_min.size > 0:\n                            self.norm.vmin = float(np.min(array_min))\n                        else:\n                            self.norm.vmin = 1e-10\n                    else:\n                        self.norm.vmin = 1e-10\n        self._reset_locator_formatter_scale()\n\n    self._draw_all()\n    if isinstance(self.mappable, contour.ContourSet):\n        CS = self.mappable\n        if not CS.filled:\n            self.add_lines(CS)\n    self.stale = True\n",
      "\n    def update_normal(self, mappable):\n        \"\"\"\n        Update solid patches, lines, etc.\n\n        This is meant to be called when the norm of the image or contour plot\n        to which this colorbar belongs changes.\n\n        If the norm on the mappable is different than before, this resets the\n        locator and formatter for the axis, so if these have been customized,\n        they will need to be customized again.  However, if the norm only\n        changes values of *vmin*, *vmax* or *cmap* then the old formatter\n        and locator will be preserved.\n        \"\"\"\n        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n        self.mappable = mappable\n        self.set_alpha(mappable.get_alpha())\n        self.cmap = mappable.cmap\n        if mappable.norm != self.norm:\n            self.norm = mappable.norm\n            # For LogNorm, ensure compatible vmin/vmax values\n            if isinstance(self.norm, colors.LogNorm):\n                # Get the actual data range from the mappable\n                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n                    data = mappable.get_array()\n                    if hasattr(data, 'compressed'):  # masked array\n                        data = data.compressed()\n                    if len(data) > 0:\n                        data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                        data_max = np.max(data) if len(data) > 0 else 1.0\n                        # Update norm bounds if they're problematic\n                        if self.norm.vmin <= 0:\n                            self.norm.vmin = data_min\n                        if self.norm.vmax <= self.norm.vmin:\n                            self.norm.vmax = max(data_max, self.norm.vmin * 10)\n            self._reset_locator_formatter_scale()\n\n        self._draw_all()\n        if isinstance(self.mappable, contour.ContourSet):\n            CS = self.mappable\n            if not CS.filled:\n                self.add_lines(CS)\n        self.stale = True\n",
      "\ndef update_normal(self, mappable):\n    \"\"\"\n    Update solid patches, lines, etc.\n\n    This is meant to be called when the norm of the image or contour plot\n    to which this colorbar belongs changes.\n\n    If the norm on the mappable is different than before, this resets the\n    locator and formatter for the axis, so if these have been customized,\n    they will need to be customized again.  However, if the norm only\n    changes values of *vmin*, *vmax* or *cmap* then the old formatter\n    and locator will be preserved.\n    \"\"\"\n    _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n    self.mappable = mappable\n    self.set_alpha(mappable.get_alpha())\n    self.cmap = mappable.cmap\n    if mappable.norm != self.norm:\n        self.norm = mappable.norm\n        # Ensure colorbar boundaries are compatible with the new norm\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, ensure vmin and vmax are positive and compatible\n            mappable_vmin, mappable_vmax = mappable.norm.vmin, mappable.norm.vmax\n            if mappable_vmin is not None and mappable_vmax is not None:\n                if mappable_vmin <= 0:\n                    # Use a small positive value or derive from mappable data\n                    if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n                        data = mappable.get_array()\n                        data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n                        mappable_vmin = max(data_min, 1e-10)\n                    else:\n                        mappable_vmin = 1e-10\n                # Update norm with compatible values\n                self.norm.vmin, self.norm.vmax = mappable_vmin, mappable_vmax\n        self._reset_locator_formatter_scale()\n\n    self._draw_all()\n    if isinstance(self.mappable, contour.ContourSet):\n        CS = self.mappable\n        if not CS.filled:\n            self.add_lines(CS)\n    self.stale = True\n",
      "\ndef update_normal(self, mappable):\n    \"\"\"\n    Update solid patches, lines, etc.\n\n    This is meant to be called when the norm of the image or contour plot\n    to which this colorbar belongs changes.\n\n    If the norm on the mappable is different than before, this resets the\n    locator and formatter for the axis, so if these have been customized,\n    they will need to be customized again.  However, if the norm only\n    changes values of *vmin*, *vmax* or *cmap* then the old formatter\n    and locator will be preserved.\n    \"\"\"\n    _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n    self.mappable = mappable\n    self.set_alpha(mappable.get_alpha())\n    self.cmap = mappable.cmap\n    if mappable.norm != self.norm:\n        self.norm = mappable.norm\n        # Ensure colorbar boundaries are compatible with the new norm\n        if isinstance(self.norm, colors.LogNorm):\n            # For LogNorm, ensure vmin and vmax are positive\n            mappable_vmin, mappable_vmax = mappable.get_clim()\n            if mappable_vmin <= 0:\n                # Use a small positive value or the actual data minimum\n                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n                    data = mappable.get_array()\n                    positive_data = data[data > 0]\n                    if len(positive_data) > 0:\n                        mappable_vmin = np.min(positive_data)\n                    else:\n                        mappable_vmin = 1e-10\n                else:\n                    mappable_vmin = 1e-10\n            # Update the norm's vmin/vmax to ensure compatibility\n            self.norm.vmin = mappable_vmin\n            self.norm.vmax = mappable_vmax\n        self._reset_locator_formatter_scale()\n\n    self._draw_all()\n    if isinstance(self.mappable, contour.ContourSet):\n        CS = self.mappable\n        if not CS.filled:\n            self.add_lines(CS)\n    self.stale = True\n",
      "\ndef update_normal(self, mappable):\n    \"\"\"\n    Update solid patches, lines, etc.\n\n    This is meant to be called when the norm of the image or contour plot\n    to which this colorbar belongs changes.\n\n    If the norm on the mappable is different than before, this resets the\n    locator and formatter for the axis, so if these have been customized,\n    they will need to be customized again.  However, if the norm only\n    changes values of *vmin*, *vmax* or *cmap* then the old formatter\n    and locator will be preserved.\n    \"\"\"\n    _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n    self.mappable = mappable\n    self.set_alpha(mappable.get_alpha())\n    self.cmap = mappable.cmap\n    if mappable.norm != self.norm:\n        self.norm = mappable.norm\n        # Ensure colorbar boundaries are compatible with the new norm\n        if hasattr(mappable.norm, 'vmin') and hasattr(mappable.norm, 'vmax'):\n            self.norm.vmin = mappable.norm.vmin\n            self.norm.vmax = mappable.norm.vmax\n        self._reset_locator_formatter_scale()\n\n    self._draw_all()\n    if isinstance(self.mappable, contour.ContourSet):\n        CS = self.mappable\n        if not CS.filled:\n            self.add_lines(CS)\n    self.stale = True\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..1c8e97db39 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -490,6 +490,7 @@ class Colorbar:\n \n     filled = _api.deprecate_privatize_attribute(\"3.6\")\n \n+\n     def update_normal(self, mappable):\n         \"\"\"\n         Update solid patches, lines, etc.\n@@ -509,6 +510,12 @@ class Colorbar:\n         self.cmap = mappable.cmap\n         if mappable.norm != self.norm:\n             self.norm = mappable.norm\n+            # Ensure norm compatibility by copying vmin/vmax from mappable\n+            if hasattr(mappable.norm, 'vmin') and hasattr(mappable.norm, 'vmax'):\n+                if mappable.norm.vmin is not None:\n+                    self.norm.vmin = mappable.norm.vmin\n+                if mappable.norm.vmax is not None:\n+                    self.norm.vmax = mappable.norm.vmax\n             self._reset_locator_formatter_scale()\n \n         self._draw_all()\n@@ -517,6 +524,12 @@ class Colorbar:\n             if not CS.filled:\n                 self.add_lines(CS)\n         self.stale = True\n+        self._draw_all()\n+        if isinstance(self.mappable, contour.ContourSet):\n+            CS = self.mappable\n+            if not CS.filled:\n+                self.add_lines(CS)\n+        self.stale = True\n \n     @_api.deprecated(\"3.6\", alternative=\"fig.draw_without_rendering()\")\n     def draw_all(self):\n@@ -1062,6 +1075,7 @@ class Colorbar:\n             # use_gridspec was True\n             ax.set_subplotspec(subplotspec)\n \n+\n     def _process_values(self):\n         \"\"\"\n         Set `_boundaries` and `_values` based on the self.boundaries and\n@@ -1101,6 +1115,7 @@ class Colorbar:\n             b = np.hstack((b, b[-1] + 1))\n \n         # transform from 0-1 to vmin-vmax:\n+\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n             self.norm.vmax = 1\n@@ -1108,6 +1123,13 @@ class Colorbar:\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n+            # Fix for LogNorm compatibility: ensure vmin > 0 for LogNorm\n+            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+                # Use a small positive value or inherit from mappable if available\n+                if hasattr(self, 'mappable') and hasattr(self.mappable.norm, 'vmin') and self.mappable.norm.vmin > 0:\n+                    self.norm.vmin = self.mappable.norm.vmin\n+                else:\n+                    self.norm.vmin = 1e-10\n             b = self.norm.inverse(b)\n \n         self._boundaries = np.asarray(b, dtype=float)\n@@ -1164,6 +1186,7 @@ class Colorbar:\n         b = self._boundaries\n         return np.interp(x, np.linspace(0, 1, len(b)), b)\n \n+\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n",
    "variant_0": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..ad3d903480 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -490,25 +490,45 @@ class Colorbar:\n \n     filled = _api.deprecate_privatize_attribute(\"3.6\")\n \n-    def update_normal(self, mappable):\n-        \"\"\"\n-        Update solid patches, lines, etc.\n \n-        This is meant to be called when the norm of the image or contour plot\n-        to which this colorbar belongs changes.\n+def update_normal(self, mappable):\n+    \"\"\"\n+    Update solid patches, lines, etc.\n \n-        If the norm on the mappable is different than before, this resets the\n-        locator and formatter for the axis, so if these have been customized,\n-        they will need to be customized again.  However, if the norm only\n-        changes values of *vmin*, *vmax* or *cmap* then the old formatter\n-        and locator will be preserved.\n-        \"\"\"\n-        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n-        self.mappable = mappable\n-        self.set_alpha(mappable.get_alpha())\n-        self.cmap = mappable.cmap\n-        if mappable.norm != self.norm:\n-            self.norm = mappable.norm\n+    This is meant to be called when the norm of the image or contour plot\n+    to which this colorbar belongs changes.\n+\n+    If the norm on the mappable is different than before, this resets the\n+    locator and formatter for the axis, so if these have been customized,\n+    they will need to be customized again.  However, if the norm only\n+    changes values of *vmin*, *vmax* or *cmap* then the old formatter\n+    and locator will be preserved.\n+    \"\"\"\n+    _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n+    self.mappable = mappable\n+    self.set_alpha(mappable.get_alpha())\n+    self.cmap = mappable.cmap\n+    if mappable.norm != self.norm:\n+        self.norm = mappable.norm\n+        # Ensure colorbar vmin/vmax are compatible with the new norm\n+        if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n+            # For LogNorm and similar norms, inherit vmin/vmax from mappable's norm\n+            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+                # Use mappable's actual data range for LogNorm compatibility\n+                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n+                    data = mappable.get_array()\n+                    data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                    if self.norm.vmin <= 0:\n+                        self.norm.vmin = data_min\n+        self._reset_locator_formatter_scale()\n+\n+    self._draw_all()\n+    if isinstance(self.mappable, contour.ContourSet):\n+        CS = self.mappable\n+        if not CS.filled:\n+            self.add_lines(CS)\n+    self.stale = True\n+                        self._boundaries = None  # Reset boundaries to force recalculation\n             self._reset_locator_formatter_scale()\n \n         self._draw_all()\n@@ -1062,12 +1082,32 @@ class Colorbar:\n             # use_gridspec was True\n             ax.set_subplotspec(subplotspec)\n \n-    def _process_values(self):\n-        \"\"\"\n-        Set `_boundaries` and `_values` based on the self.boundaries and\n-        self.values if not None, or based on the size of the colormap and\n-        the vmin/vmax of the norm.\n-        \"\"\"\n+\n+def _process_values(self):\n+    \"\"\"\n+    Set `_boundaries` and `_values` based on the self.boundaries and\n+    self.values if not None, or based on the size of the colormap and\n+    the vmin/vmax of the norm.\n+    \"\"\"\n+    # Handle LogNorm compatibility - ensure vmin > 0 to prevent ZeroDivisionError\n+    if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            if hasattr(self, 'mappable') and self.mappable is not None:\n+                # Try to get positive vmin from mappable data\n+                try:\n+                    data = self.mappable.get_array()\n+                    if data is not None:\n+                        positive_data = data[data > 0]\n+                        if len(positive_data) > 0:\n+                            self.norm.vmin = positive_data.min()\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                except (AttributeError, IndexError):\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n         if self.values is not None:\n             # set self._boundaries from the values...\n             self._values = np.array(self.values)\n@@ -1100,6 +1140,8 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n@@ -1108,6 +1150,21 @@ class Colorbar:\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n+            # Handle LogNorm compatibility - prevent division by zero\n+            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+                # Use a small positive value or inherit from mappable if available\n+                if hasattr(self, 'mappable') and self.mappable is not None:\n+                    data = self.mappable.get_array()\n+                    if data is not None:\n+                        positive_data = data[data > 0]\n+                        if len(positive_data) > 0:\n+                            self.norm.vmin = np.min(positive_data)\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                else:\n+                    self.norm.vmin = 1e-10\n             b = self.norm.inverse(b)\n \n         self._boundaries = np.asarray(b, dtype=float)\n@@ -1164,12 +1221,33 @@ class Colorbar:\n         b = self._boundaries\n         return np.interp(x, np.linspace(0, 1, len(b)), b)\n \n+\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n         need to be re-entered if this gets called (either at init, or when\n         the mappable normal gets changed: Colorbar.update_normal)\n         \"\"\"\n+        # Ensure norm compatibility before processing values\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, ensure vmin and vmax are positive\n+            if hasattr(self.mappable, 'get_array'):\n+                array = self.mappable.get_array()\n+                if array is not None and array.size > 0:\n+                    array_min = np.ma.masked_invalid(array).compressed()\n+                    if array_min.size > 0:\n+                        array_min = array_min[array_min > 0].min() if (array_min > 0).any() else 1e-10\n+                        if self.norm.vmin <= 0:\n+                            self.norm.vmin = array_min\n+                        if self.norm.vmax <= 0:\n+                            self.norm.vmax = max(array_min * 10, 1.0)\n+            else:\n+                # Fallback if no array data available\n+                if self.norm.vmin <= 0:\n+                    self.norm.vmin = 1e-10\n+                if self.norm.vmax <= 0:\n+                    self.norm.vmax = 1.0\n+        \n         self._process_values()\n         self._locator = None\n         self._minorlocator = None\n",
    "variant_1": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..f586997a16 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -490,6 +490,7 @@ class Colorbar:\n \n     filled = _api.deprecate_privatize_attribute(\"3.6\")\n \n+\n     def update_normal(self, mappable):\n         \"\"\"\n         Update solid patches, lines, etc.\n@@ -509,6 +510,28 @@ class Colorbar:\n         self.cmap = mappable.cmap\n         if mappable.norm != self.norm:\n             self.norm = mappable.norm\n+            # Ensure colorbar boundaries are compatible with the new norm\n+            if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n+                # For LogNorm and similar norms, ensure vmin/vmax are compatible\n+                if isinstance(self.norm, colors.LogNorm):\n+                    # LogNorm requires positive vmin, inherit from mappable if needed\n+                    if self.norm.vmin <= 0:\n+                        if hasattr(mappable, 'get_clim'):\n+                            vmin, vmax = mappable.get_clim()\n+                            if vmin > 0:\n+                                self.norm.vmin = vmin\n+                            else:\n+                                # Use a small positive value as fallback\n+                                self.norm.vmin = max(1e-10, self.norm.vmax * 1e-10)\n+            self._reset_locator_formatter_scale()\n+\n+        self._draw_all()\n+        if isinstance(self.mappable, contour.ContourSet):\n+            CS = self.mappable\n+            if not CS.filled:\n+                self.add_lines(CS)\n+        self.stale = True\n+                self.norm.vmax = mappable.norm.vmax\n             self._reset_locator_formatter_scale()\n \n         self._draw_all()\n@@ -1062,12 +1085,39 @@ class Colorbar:\n             # use_gridspec was True\n             ax.set_subplotspec(subplotspec)\n \n-    def _process_values(self):\n-        \"\"\"\n-        Set `_boundaries` and `_values` based on the self.boundaries and\n-        self.values if not None, or based on the size of the colormap and\n-        the vmin/vmax of the norm.\n-        \"\"\"\n+\n+def _process_values(self):\n+    \"\"\"\n+    Set `_boundaries` and `_values` based on the self.boundaries and\n+    self.values if not None, or based on the size of the colormap and\n+    the vmin/vmax of the norm.\n+    \"\"\"\n+    # Handle LogNorm compatibility - ensure vmin > 0 to prevent division by zero\n+    if isinstance(self.norm, colors.LogNorm):\n+        if self.norm.vmin is None or self.norm.vmin <= 0:\n+            # Try to get a reasonable positive minimum from the mappable\n+            if hasattr(self.mappable, 'get_array'):\n+                array = self.mappable.get_array()\n+                if array is not None and len(array) > 0:\n+                    positive_data = array[array > 0]\n+                    if len(positive_data) > 0:\n+                        self.norm.vmin = positive_data.min()\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                else:\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n+        \n+        if self.norm.vmax is None or self.norm.vmax <= self.norm.vmin:\n+            if hasattr(self.mappable, 'get_array'):\n+                array = self.mappable.get_array()\n+                if array is not None and len(array) > 0:\n+                    self.norm.vmax = array.max()\n+                else:\n+                    self.norm.vmax = max(self.norm.vmin * 10, 1.0)\n+            else:\n+                self.norm.vmax = max(self.norm.vmin * 10, 1.0)\n         if self.values is not None:\n             # set self._boundaries from the values...\n             self._values = np.array(self.values)\n@@ -1100,6 +1150,8 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n@@ -1108,6 +1160,21 @@ class Colorbar:\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n+            # Handle LogNorm compatibility - ensure vmin > 0 to avoid division by zero\n+            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+                if hasattr(self, 'mappable') and self.mappable is not None:\n+                    # Try to get a reasonable vmin from the mappable's data\n+                    try:\n+                        data = self.mappable.get_array()\n+                        if data is not None and len(data) > 0:\n+                            data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                            self.norm.vmin = max(data_min, 1e-10)\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    except (AttributeError, ValueError):\n+                        self.norm.vmin = 1e-10\n+                else:\n+                    self.norm.vmin = 1e-10\n             b = self.norm.inverse(b)\n \n         self._boundaries = np.asarray(b, dtype=float)\n@@ -1164,12 +1231,31 @@ class Colorbar:\n         b = self._boundaries\n         return np.interp(x, np.linspace(0, 1, len(b)), b)\n \n+\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n         need to be re-entered if this gets called (either at init, or when\n         the mappable normal gets changed: Colorbar.update_normal)\n         \"\"\"\n+        # Ensure norm compatibility before processing values\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, ensure vmin and vmax are positive\n+            if hasattr(self.mappable, 'get_array') and self.mappable.get_array() is not None:\n+                data = self.mappable.get_array()\n+                if data.size > 0:\n+                    data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                    if self.norm.vmin <= 0:\n+                        self.norm.vmin = data_min\n+                    if self.norm.vmax <= 0:\n+                        self.norm.vmax = max(np.max(data), self.norm.vmin * 10)\n+            else:\n+                # Fallback if no data available\n+                if self.norm.vmin <= 0:\n+                    self.norm.vmin = 1e-10\n+                if self.norm.vmax <= self.norm.vmin:\n+                    self.norm.vmax = self.norm.vmin * 10\n+        \n         self._process_values()\n         self._locator = None\n         self._minorlocator = None\n",
    "variant_2": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..aef790c067 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -490,25 +490,49 @@ class Colorbar:\n \n     filled = _api.deprecate_privatize_attribute(\"3.6\")\n \n-    def update_normal(self, mappable):\n-        \"\"\"\n-        Update solid patches, lines, etc.\n \n-        This is meant to be called when the norm of the image or contour plot\n-        to which this colorbar belongs changes.\n+def update_normal(self, mappable):\n+    \"\"\"\n+    Update solid patches, lines, etc.\n \n-        If the norm on the mappable is different than before, this resets the\n-        locator and formatter for the axis, so if these have been customized,\n-        they will need to be customized again.  However, if the norm only\n-        changes values of *vmin*, *vmax* or *cmap* then the old formatter\n-        and locator will be preserved.\n-        \"\"\"\n-        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n-        self.mappable = mappable\n-        self.set_alpha(mappable.get_alpha())\n-        self.cmap = mappable.cmap\n-        if mappable.norm != self.norm:\n-            self.norm = mappable.norm\n+    This is meant to be called when the norm of the image or contour plot\n+    to which this colorbar belongs changes.\n+\n+    If the norm on the mappable is different than before, this resets the\n+    locator and formatter for the axis, so if these have been customized,\n+    they will need to be customized again.  However, if the norm only\n+    changes values of *vmin*, *vmax* or *cmap* then the old formatter\n+    and locator will be preserved.\n+    \"\"\"\n+    _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n+    self.mappable = mappable\n+    self.set_alpha(mappable.get_alpha())\n+    self.cmap = mappable.cmap\n+    if mappable.norm != self.norm:\n+        self.norm = mappable.norm\n+        # Ensure colorbar boundaries are compatible with the new norm\n+        if hasattr(mappable.norm, 'vmin') and hasattr(mappable.norm, 'vmax'):\n+            self.norm.vmin = mappable.norm.vmin\n+            self.norm.vmax = mappable.norm.vmax\n+        self._reset_locator_formatter_scale()\n+\n+    self._draw_all()\n+    if isinstance(self.mappable, contour.ContourSet):\n+        CS = self.mappable\n+        if not CS.filled:\n+            self.add_lines(CS)\n+    self.stale = True\n+                    if self.norm.vmin <= 0:\n+                        # Get valid range from mappable data if available\n+                        if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n+                            data = mappable.get_array()\n+                            valid_data = data[data > 0] if np.ma.is_masked(data) else data[data > 0]\n+                            if len(valid_data) > 0:\n+                                self.norm.vmin = np.min(valid_data)\n+                            else:\n+                                self.norm.vmin = 1e-10\n+                        else:\n+                            self.norm.vmin = 1e-10\n             self._reset_locator_formatter_scale()\n \n         self._draw_all()\n@@ -1062,12 +1086,30 @@ class Colorbar:\n             # use_gridspec was True\n             ax.set_subplotspec(subplotspec)\n \n+\n     def _process_values(self):\n         \"\"\"\n         Set `_boundaries` and `_values` based on the self.boundaries and\n         self.values if not None, or based on the size of the colormap and\n         the vmin/vmax of the norm.\n         \"\"\"\n+        # Handle LogNorm compatibility - ensure vmin > 0 for LogNorm\n+        if isinstance(self.norm, colors.LogNorm):\n+            if self.norm.vmin is not None and self.norm.vmin <= 0:\n+                # Get actual data range from mappable if available\n+                if hasattr(self, 'mappable') and self.mappable is not None:\n+                    try:\n+                        data = self.mappable.get_array()\n+                        if data is not None:\n+                            data_min = np.ma.masked_invalid(data).min()\n+                            if data_min > 0:\n+                                self.norm.vmin = data_min\n+                            else:\n+                                self.norm.vmin = max(1e-10, self.norm.vmax * 1e-10 if self.norm.vmax else 1e-10)\n+                    except (AttributeError, ValueError):\n+                        self.norm.vmin = max(1e-10, self.norm.vmax * 1e-10 if self.norm.vmax else 1e-10)\n+                else:\n+                    self.norm.vmin = max(1e-10, self.norm.vmax * 1e-10 if self.norm.vmax else 1e-10)\n         if self.values is not None:\n             # set self._boundaries from the values...\n             self._values = np.array(self.values)\n@@ -1100,6 +1142,8 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n@@ -1108,6 +1152,21 @@ class Colorbar:\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n+            # Handle LogNorm case to prevent division by zero\n+            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+                # Use mappable's data range if available, otherwise use small positive value\n+                if hasattr(self, 'mappable') and self.mappable is not None:\n+                    data = getattr(self.mappable, '_A', None)\n+                    if data is not None:\n+                        data_min = np.ma.masked_invalid(data).min()\n+                        if data_min > 0:\n+                            self.norm.vmin = data_min\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                else:\n+                    self.norm.vmin = 1e-10\n             b = self.norm.inverse(b)\n \n         self._boundaries = np.asarray(b, dtype=float)\n@@ -1164,12 +1223,31 @@ class Colorbar:\n         b = self._boundaries\n         return np.interp(x, np.linspace(0, 1, len(b)), b)\n \n+\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n         need to be re-entered if this gets called (either at init, or when\n         the mappable normal gets changed: Colorbar.update_normal)\n         \"\"\"\n+        # Ensure norm compatibility before processing values\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, ensure vmin > 0 to avoid division by zero\n+            if hasattr(self, 'vmin') and self.vmin is not None and self.vmin <= 0:\n+                # Try to get a reasonable vmin from the mappable's data\n+                if hasattr(self.mappable, 'get_array'):\n+                    array = self.mappable.get_array()\n+                    if array is not None and len(array) > 0:\n+                        positive_data = array[array > 0]\n+                        if len(positive_data) > 0:\n+                            self.vmin = np.min(positive_data)\n+                        else:\n+                            self.vmin = 1e-10\n+                    else:\n+                        self.vmin = 1e-10\n+                else:\n+                    self.vmin = 1e-10\n+        \n         self._process_values()\n         self._locator = None\n         self._minorlocator = None\n",
    "variant_3": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..6910a46ba0 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -490,6 +490,7 @@ class Colorbar:\n \n     filled = _api.deprecate_privatize_attribute(\"3.6\")\n \n+\n     def update_normal(self, mappable):\n         \"\"\"\n         Update solid patches, lines, etc.\n@@ -509,6 +510,35 @@ class Colorbar:\n         self.cmap = mappable.cmap\n         if mappable.norm != self.norm:\n             self.norm = mappable.norm\n+            # For LogNorm, ensure colorbar boundaries are compatible\n+            if isinstance(self.norm, colors.LogNorm):\n+                # Inherit proper vmin/vmax from mappable to avoid division by zero\n+                self.norm = mappable.norm\n+                if hasattr(mappable.norm, 'vmin') and hasattr(mappable.norm, 'vmax'):\n+                    # Ensure we use the mappable's norm boundaries\n+                    pass  # norm assignment above already handles this\n+            self._reset_locator_formatter_scale()\n+\n+        self._draw_all()\n+        if isinstance(self.mappable, contour.ContourSet):\n+            CS = self.mappable\n+            if not CS.filled:\n+                self.add_lines(CS)\n+        self.stale = True\n+                    if self.norm.vmin <= 0:\n+                        # Use mappable's data to determine appropriate vmin\n+                        if hasattr(mappable, 'get_array'):\n+                            array = mappable.get_array()\n+                            if array is not None:\n+                                pos_data = array[array > 0]\n+                                if len(pos_data) > 0:\n+                                    self.norm.vmin = float(np.min(pos_data))\n+                                else:\n+                                    self.norm.vmin = 1e-10\n+                            else:\n+                                self.norm.vmin = 1e-10\n+                        else:\n+                            self.norm.vmin = 1e-10\n             self._reset_locator_formatter_scale()\n \n         self._draw_all()\n@@ -1062,12 +1092,39 @@ class Colorbar:\n             # use_gridspec was True\n             ax.set_subplotspec(subplotspec)\n \n+\n     def _process_values(self):\n         \"\"\"\n         Set `_boundaries` and `_values` based on the self.boundaries and\n         self.values if not None, or based on the size of the colormap and\n         the vmin/vmax of the norm.\n         \"\"\"\n+        # Handle LogNorm compatibility - ensure vmin > 0 for LogNorm\n+        if isinstance(self.norm, colors.LogNorm):\n+            if self.norm.vmin is None or self.norm.vmin <= 0:\n+                # Get valid vmin from mappable data if available\n+                if hasattr(self, 'mappable') and self.mappable is not None:\n+                    data = self.mappable.get_array()\n+                    if data is not None and len(data) > 0:\n+                        valid_data = data[data > 0]\n+                        if len(valid_data) > 0:\n+                            self.norm.vmin = valid_data.min()\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                else:\n+                    self.norm.vmin = 1e-10\n+            \n+            if self.norm.vmax is None or self.norm.vmax <= self.norm.vmin:\n+                if hasattr(self, 'mappable') and self.mappable is not None:\n+                    data = self.mappable.get_array()\n+                    if data is not None and len(data) > 0:\n+                        self.norm.vmax = data.max()\n+                    else:\n+                        self.norm.vmax = max(self.norm.vmin * 10, 1.0)\n+                else:\n+                    self.norm.vmax = max(self.norm.vmin * 10, 1.0)\n         if self.values is not None:\n             # set self._boundaries from the values...\n             self._values = np.array(self.values)\n@@ -1100,6 +1157,8 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n@@ -1108,6 +1167,19 @@ class Colorbar:\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n+            # Handle LogNorm compatibility - ensure vmin > 0 to avoid division by zero\n+            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+                # Use mappable's actual data range if available, otherwise use small positive value\n+                if hasattr(self, 'mappable') and self.mappable is not None:\n+                    try:\n+                        array = self.mappable.get_array()\n+                        if array is not None and array.size > 0:\n+                            data_min = np.nanmin(array[array > 0]) if np.any(array > 0) else 1e-10\n+                            self.norm.vmin = max(data_min, 1e-10)\n+                    except (AttributeError, TypeError):\n+                        self.norm.vmin = 1e-10\n+                else:\n+                    self.norm.vmin = 1e-10\n             b = self.norm.inverse(b)\n \n         self._boundaries = np.asarray(b, dtype=float)\n@@ -1164,12 +1236,25 @@ class Colorbar:\n         b = self._boundaries\n         return np.interp(x, np.linspace(0, 1, len(b)), b)\n \n+\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n         need to be re-entered if this gets called (either at init, or when\n         the mappable normal gets changed: Colorbar.update_normal)\n         \"\"\"\n+        # Ensure norm compatibility before processing values\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, ensure vmin > 0 to avoid ZeroDivisionError\n+            if hasattr(self.mappable, 'get_clim'):\n+                mappable_vmin, mappable_vmax = self.mappable.get_clim()\n+                if mappable_vmin > 0:\n+                    self.norm.vmin = max(self.norm.vmin or mappable_vmin, mappable_vmin)\n+                    self.norm.vmax = self.norm.vmax or mappable_vmax\n+                elif self.norm.vmin <= 0:\n+                    # Set a small positive value if vmin is non-positive\n+                    self.norm.vmin = 1e-10\n+        \n         self._process_values()\n         self._locator = None\n         self._minorlocator = None\n",
    "variant_4": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..5c6f518a04 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -490,25 +490,57 @@ class Colorbar:\n \n     filled = _api.deprecate_privatize_attribute(\"3.6\")\n \n-    def update_normal(self, mappable):\n-        \"\"\"\n-        Update solid patches, lines, etc.\n \n-        This is meant to be called when the norm of the image or contour plot\n-        to which this colorbar belongs changes.\n+def update_normal(self, mappable):\n+    \"\"\"\n+    Update solid patches, lines, etc.\n \n-        If the norm on the mappable is different than before, this resets the\n-        locator and formatter for the axis, so if these have been customized,\n-        they will need to be customized again.  However, if the norm only\n-        changes values of *vmin*, *vmax* or *cmap* then the old formatter\n-        and locator will be preserved.\n-        \"\"\"\n-        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n-        self.mappable = mappable\n-        self.set_alpha(mappable.get_alpha())\n-        self.cmap = mappable.cmap\n-        if mappable.norm != self.norm:\n-            self.norm = mappable.norm\n+    This is meant to be called when the norm of the image or contour plot\n+    to which this colorbar belongs changes.\n+\n+    If the norm on the mappable is different than before, this resets the\n+    locator and formatter for the axis, so if these have been customized,\n+    they will need to be customized again.  However, if the norm only\n+    changes values of *vmin*, *vmax* or *cmap* then the old formatter\n+    and locator will be preserved.\n+    \"\"\"\n+    _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n+    self.mappable = mappable\n+    self.set_alpha(mappable.get_alpha())\n+    self.cmap = mappable.cmap\n+    if mappable.norm != self.norm:\n+        self.norm = mappable.norm\n+        # Ensure colorbar boundaries are compatible with the new norm\n+        if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n+            if isinstance(self.norm, colors.LogNorm):\n+                # For LogNorm, ensure vmin > 0 to avoid division by zero\n+                if self.norm.vmin <= 0:\n+                    # Use mappable's actual data range for proper LogNorm bounds\n+                    array = mappable.get_array()\n+                    if array is not None:\n+                        array_min = np.ma.masked_invalid(array, copy=False)\n+                        array_min = array_min[array_min > 0]\n+                        if array_min.size > 0:\n+                            self.norm.vmin = float(np.min(array_min))\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+        self._reset_locator_formatter_scale()\n+\n+    self._draw_all()\n+    if isinstance(self.mappable, contour.ContourSet):\n+        CS = self.mappable\n+        if not CS.filled:\n+            self.add_lines(CS)\n+    self.stale = True\n+                    # Use mappable's actual data range or a small positive value\n+                    if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n+                        data = mappable.get_array()\n+                        data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                        self.norm.vmin = data_min\n+                    else:\n+                        self.norm.vmin = 1e-10\n             self._reset_locator_formatter_scale()\n \n         self._draw_all()\n@@ -1062,12 +1094,29 @@ class Colorbar:\n             # use_gridspec was True\n             ax.set_subplotspec(subplotspec)\n \n+\n     def _process_values(self):\n         \"\"\"\n         Set `_boundaries` and `_values` based on the self.boundaries and\n         self.values if not None, or based on the size of the colormap and\n         the vmin/vmax of the norm.\n         \"\"\"\n+        # Handle LogNorm compatibility early to prevent ZeroDivisionError\n+        if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n+            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+                # For LogNorm, vmin must be positive. Use mappable's data range if available.\n+                if hasattr(self, 'mappable') and self.mappable is not None:\n+                    try:\n+                        data = self.mappable.get_array()\n+                        if data is not None and len(data) > 0:\n+                            data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                            self.norm.vmin = max(data_min, 1e-10)\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    except (AttributeError, ValueError):\n+                        self.norm.vmin = 1e-10\n+                else:\n+                    self.norm.vmin = 1e-10\n         if self.values is not None:\n             # set self._boundaries from the values...\n             self._values = np.array(self.values)\n@@ -1100,6 +1149,8 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n@@ -1108,6 +1159,21 @@ class Colorbar:\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n+            # Handle LogNorm compatibility - ensure vmin > 0 to avoid division by zero\n+            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+                if hasattr(self, 'mappable') and self.mappable is not None:\n+                    # Try to get positive vmin from mappable's data\n+                    data = getattr(self.mappable, 'get_array', lambda: None)()\n+                    if data is not None:\n+                        data_min = np.ma.min(data[data > 0]) if np.ma.is_masked(data) else np.min(data[data > 0])\n+                        if np.isfinite(data_min) and data_min > 0:\n+                            self.norm.vmin = data_min\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                else:\n+                    self.norm.vmin = 1e-10\n             b = self.norm.inverse(b)\n \n         self._boundaries = np.asarray(b, dtype=float)\n@@ -1164,12 +1230,31 @@ class Colorbar:\n         b = self._boundaries\n         return np.interp(x, np.linspace(0, 1, len(b)), b)\n \n+\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n         need to be re-entered if this gets called (either at init, or when\n         the mappable normal gets changed: Colorbar.update_normal)\n         \"\"\"\n+        # Ensure norm compatibility before processing values\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, ensure vmin > 0 to avoid division by zero\n+            if hasattr(self.mappable, 'get_array') and self.mappable.get_array() is not None:\n+                data = self.mappable.get_array()\n+                if data.size > 0:\n+                    data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                    if self.norm.vmin <= 0:\n+                        self.norm.vmin = max(data_min, 1e-10)\n+                    if self.norm.vmax <= 0:\n+                        self.norm.vmax = max(self.norm.vmin * 10, 1.0)\n+            else:\n+                # Fallback if no data available\n+                if self.norm.vmin <= 0:\n+                    self.norm.vmin = 1e-10\n+                if self.norm.vmax <= self.norm.vmin:\n+                    self.norm.vmax = self.norm.vmin * 10\n+        \n         self._process_values()\n         self._locator = None\n         self._minorlocator = None\n",
    "variant_5": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..aeb8fc8164 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -490,6 +490,7 @@ class Colorbar:\n \n     filled = _api.deprecate_privatize_attribute(\"3.6\")\n \n+\n     def update_normal(self, mappable):\n         \"\"\"\n         Update solid patches, lines, etc.\n@@ -509,6 +510,50 @@ class Colorbar:\n         self.cmap = mappable.cmap\n         if mappable.norm != self.norm:\n             self.norm = mappable.norm\n+            # For LogNorm, ensure compatible vmin/vmax values\n+            if isinstance(self.norm, colors.LogNorm):\n+                # Get the actual data range from the mappable\n+                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n+                    data = mappable.get_array()\n+                    if hasattr(data, 'compressed'):  # masked array\n+                        data = data.compressed()\n+                    if len(data) > 0:\n+                        data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                        data_max = np.max(data) if len(data) > 0 else 1.0\n+                        # Update norm bounds if they're problematic\n+                        if self.norm.vmin <= 0:\n+                            self.norm.vmin = data_min\n+                        if self.norm.vmax <= self.norm.vmin:\n+                            self.norm.vmax = max(data_max, self.norm.vmin * 10)\n+            self._reset_locator_formatter_scale()\n+\n+        self._draw_all()\n+        if isinstance(self.mappable, contour.ContourSet):\n+            CS = self.mappable\n+            if not CS.filled:\n+                self.add_lines(CS)\n+        self.stale = True\n+        mappable : `.ScalarMappable`\n+            The mappable whose properties are to be reflected in this colorbar.\n+\n+        Notes\n+        -----\n+        If the norm on the mappable is different than before, this resets the\n+        locator and formatter for the axis, so if these have been customized,\n+        they will need to be customized again.  However, if the norm only\n+        changes values of *vmin*, *vmax* or *cmap* then the old formatter\n+        and locator will be preserved.\n+        \"\"\"\n+        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n+        self.mappable = mappable\n+        self.set_alpha(mappable.get_alpha())\n+        self.cmap = mappable.cmap\n+        if mappable.norm != self.norm:\n+            self.norm = mappable.norm\n+            # Ensure colorbar vmin/vmax are compatible with the new norm\n+            if hasattr(mappable.norm, 'vmin') and hasattr(mappable.norm, 'vmax'):\n+                self.vmin = mappable.norm.vmin\n+                self.vmax = mappable.norm.vmax\n             self._reset_locator_formatter_scale()\n \n         self._draw_all()\n@@ -1062,12 +1107,36 @@ class Colorbar:\n             # use_gridspec was True\n             ax.set_subplotspec(subplotspec)\n \n-    def _process_values(self):\n-        \"\"\"\n-        Set `_boundaries` and `_values` based on the self.boundaries and\n-        self.values if not None, or based on the size of the colormap and\n-        the vmin/vmax of the norm.\n-        \"\"\"\n+\n+def _process_values(self):\n+    \"\"\"\n+    Set `_boundaries` and `_values` based on the self.boundaries and\n+    self.values if not None, or based on the size of the colormap and\n+    the vmin/vmax of the norm.\n+    \"\"\"\n+    # Handle LogNorm compatibility early - ensure vmin > 0 for LogNorm\n+    if isinstance(self.norm, colors.LogNorm):\n+        if self.norm.vmin is not None and self.norm.vmin <= 0:\n+            # Try to get a reasonable vmin from the mappable's data\n+            if hasattr(self.mappable, 'get_array') and self.mappable.get_array() is not None:\n+                data = self.mappable.get_array()\n+                data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                self.norm.vmin = max(data_min, 1e-10)\n+            else:\n+                self.norm.vmin = 1e-10\n+        elif self.norm.vmin is None:\n+            self.norm.vmin = 1e-10\n+            \n+    if self.values is not None:\n+        # set self._boundaries from the values...\n+        self._values = np.array(self.values)\n+        if self.boundaries is None:\n+            # bracket values by 1/2 dv:\n+            b = np.zeros(len(self.values) + 1)\n+            b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])\n+            b[0] = 2.0 * b[1] - b[2]\n+            b[-1] = 2.0 * b[-2] - b[-3]\n+            self._boundaries = b\n         if self.values is not None:\n             # set self._boundaries from the values...\n             self._values = np.array(self.values)\n@@ -1100,6 +1169,8 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n@@ -1108,6 +1179,21 @@ class Colorbar:\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n+            # For LogNorm, ensure vmin > 0 to avoid division by zero\n+            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+                if hasattr(self, 'mappable') and self.mappable is not None:\n+                    # Try to get a positive minimum from the mappable's data\n+                    data = self.mappable.get_array()\n+                    if data is not None and len(data) > 0:\n+                        positive_data = data[data > 0]\n+                        if len(positive_data) > 0:\n+                            self.norm.vmin = float(np.min(positive_data))\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                else:\n+                    self.norm.vmin = 1e-10\n             b = self.norm.inverse(b)\n \n         self._boundaries = np.asarray(b, dtype=float)\n@@ -1164,12 +1250,26 @@ class Colorbar:\n         b = self._boundaries\n         return np.interp(x, np.linspace(0, 1, len(b)), b)\n \n+\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n         need to be re-entered if this gets called (either at init, or when\n         the mappable normal gets changed: Colorbar.update_normal)\n         \"\"\"\n+        # Ensure norm compatibility before processing values\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, ensure vmin/vmax are positive\n+            if hasattr(self.mappable, 'get_array'):\n+                array = self.mappable.get_array()\n+                if array is not None and len(array) > 0:\n+                    array_min = np.ma.min(array[array > 0]) if np.ma.is_masked(array) else np.min(array[array > 0])\n+                    if len(array[array > 0]) > 0:\n+                        if self.norm.vmin <= 0:\n+                            self.norm.vmin = float(array_min)\n+                        if self.norm.vmax <= 0:\n+                            self.norm.vmax = float(np.ma.max(array) if np.ma.is_masked(array) else np.max(array))\n+        \n         self._process_values()\n         self._locator = None\n         self._minorlocator = None\n",
    "variant_6": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..00996fa3e0 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -490,26 +490,64 @@ class Colorbar:\n \n     filled = _api.deprecate_privatize_attribute(\"3.6\")\n \n-    def update_normal(self, mappable):\n-        \"\"\"\n-        Update solid patches, lines, etc.\n \n-        This is meant to be called when the norm of the image or contour plot\n-        to which this colorbar belongs changes.\n+def update_normal(self, mappable):\n+    \"\"\"\n+    Update solid patches, lines, etc.\n \n-        If the norm on the mappable is different than before, this resets the\n-        locator and formatter for the axis, so if these have been customized,\n-        they will need to be customized again.  However, if the norm only\n-        changes values of *vmin*, *vmax* or *cmap* then the old formatter\n-        and locator will be preserved.\n-        \"\"\"\n-        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n-        self.mappable = mappable\n-        self.set_alpha(mappable.get_alpha())\n-        self.cmap = mappable.cmap\n-        if mappable.norm != self.norm:\n-            self.norm = mappable.norm\n-            self._reset_locator_formatter_scale()\n+    This is meant to be called when the norm of the image or contour plot\n+    to which this colorbar belongs changes.\n+\n+    If the norm on the mappable is different than before, this resets the\n+    locator and formatter for the axis, so if these have been customized,\n+    they will need to be customized again.  However, if the norm only\n+    changes values of *vmin*, *vmax* or *cmap* then the old formatter\n+    and locator will be preserved.\n+    \"\"\"\n+    _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n+    self.mappable = mappable\n+    self.set_alpha(mappable.get_alpha())\n+    self.cmap = mappable.cmap\n+    if mappable.norm != self.norm:\n+        self.norm = mappable.norm\n+        # Ensure colorbar boundaries are compatible with the new norm\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, ensure vmin and vmax are positive and compatible\n+            mappable_vmin, mappable_vmax = mappable.norm.vmin, mappable.norm.vmax\n+            if mappable_vmin is not None and mappable_vmax is not None:\n+                if mappable_vmin <= 0:\n+                    # Use a small positive value or derive from mappable data\n+                    if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n+                        data = mappable.get_array()\n+                        data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                        mappable_vmin = max(data_min, 1e-10)\n+                    else:\n+                        mappable_vmin = 1e-10\n+                # Update norm with compatible values\n+                self.norm.vmin, self.norm.vmax = mappable_vmin, mappable_vmax\n+        self._reset_locator_formatter_scale()\n+\n+    self._draw_all()\n+    if isinstance(self.mappable, contour.ContourSet):\n+        CS = self.mappable\n+        if not CS.filled:\n+            self.add_lines(CS)\n+    self.stale = True\n+                if mappable_vmin <= 0:\n+                    # Use a small positive value or the actual data minimum\n+                    if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n+                        data = mappable.get_array()\n+                        positive_data = data[data > 0]\n+                        if len(positive_data) > 0:\n+                            mappable_vmin = positive_data.min()\n+                        else:\n+                            mappable_vmin = 1e-10\n+                    else:\n+                        mappable_vmin = 1e-10\n+                # Update norm bounds\n+                self.norm.vmin = mappable_vmin\n+                self.norm.vmax = mappable_vmax\n+            _reset_locator_formatter_scale()\n \n         self._draw_all()\n         if isinstance(self.mappable, contour.ContourSet):\n@@ -1062,12 +1100,45 @@ class Colorbar:\n             # use_gridspec was True\n             ax.set_subplotspec(subplotspec)\n \n+\n     def _process_values(self):\n         \"\"\"\n         Set `_boundaries` and `_values` based on the self.boundaries and\n         self.values if not None, or based on the size of the colormap and\n         the vmin/vmax of the norm.\n         \"\"\"\n+        # Ensure norm compatibility for LogNorm before processing\n+        if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n+            if isinstance(self.norm, colors.LogNorm):\n+                # For LogNorm, ensure vmin > 0 to avoid division by zero\n+                if self.norm.vmin <= 0:\n+                    if hasattr(self, 'mappable') and self.mappable is not None:\n+                        # Try to get a reasonable positive minimum from mappable data\n+                        try:\n+                            data = self.mappable.get_array()\n+                            if data is not None:\n+                                positive_data = data[data > 0]\n+                                if len(positive_data) > 0:\n+                                    self.norm.vmin = positive_data.min()\n+                                else:\n+                                    self.norm.vmin = 1e-10\n+                            else:\n+                                self.norm.vmin = 1e-10\n+                        except (AttributeError, ValueError):\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+        \n+        if self.values is not None:\n+            # set self._boundaries from the values...\n+            self._values = np.array(self.values)\n+            if self.boundaries is None:\n+                # bracket values by 1/2 dv:\n+                b = np.zeros(len(self.values) + 1)\n+                b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])\n+                b[0] = 2.0 * b[1] - b[2]\n+                b[-1] = 2.0 * b[-2] - b[-3]\n+                self._boundaries = b\n         if self.values is not None:\n             # set self._boundaries from the values...\n             self._values = np.array(self.values)\n@@ -1100,12 +1171,31 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n             self.norm.vmax = 1\n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n+        \n+        # Handle LogNorm compatibility - ensure vmin > 0 to prevent division by zero\n+        if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+            if hasattr(self, 'mappable') and self.mappable is not None:\n+                # Try to get a reasonable vmin from the mappable's data\n+                try:\n+                    data = self.mappable.get_array()\n+                    if data is not None:\n+                        data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                        self.norm.vmin = max(data_min, 1e-10)\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                except (AttributeError, ValueError):\n+                    self.norm.vmin = 1e-10\n+            else:\n+                self.norm.vmin = 1e-10\n+        \n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n             b = self.norm.inverse(b)\n@@ -1164,12 +1254,30 @@ class Colorbar:\n         b = self._boundaries\n         return np.interp(x, np.linspace(0, 1, len(b)), b)\n \n+\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n         need to be re-entered if this gets called (either at init, or when\n         the mappable normal gets changed: Colorbar.update_normal)\n         \"\"\"\n+        # Ensure norm compatibility before processing values\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, ensure vmin > 0 to avoid division by zero\n+            if self.vmin <= 0:\n+                if hasattr(self.mappable, 'get_array'):\n+                    array = self.mappable.get_array()\n+                    if array is not None and array.size > 0:\n+                        positive_data = array[array > 0]\n+                        if positive_data.size > 0:\n+                            self.vmin = float(positive_data.min())\n+                        else:\n+                            self.vmin = 1e-10\n+                    else:\n+                        self.vmin = 1e-10\n+                else:\n+                    self.vmin = 1e-10\n+        \n         self._process_values()\n         self._locator = None\n         self._minorlocator = None\n",
    "variant_7": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..bd3a34969d 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -490,25 +490,56 @@ class Colorbar:\n \n     filled = _api.deprecate_privatize_attribute(\"3.6\")\n \n-    def update_normal(self, mappable):\n-        \"\"\"\n-        Update solid patches, lines, etc.\n \n-        This is meant to be called when the norm of the image or contour plot\n-        to which this colorbar belongs changes.\n+def update_normal(self, mappable):\n+    \"\"\"\n+    Update solid patches, lines, etc.\n \n-        If the norm on the mappable is different than before, this resets the\n-        locator and formatter for the axis, so if these have been customized,\n-        they will need to be customized again.  However, if the norm only\n-        changes values of *vmin*, *vmax* or *cmap* then the old formatter\n-        and locator will be preserved.\n-        \"\"\"\n-        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n-        self.mappable = mappable\n-        self.set_alpha(mappable.get_alpha())\n-        self.cmap = mappable.cmap\n-        if mappable.norm != self.norm:\n-            self.norm = mappable.norm\n+    This is meant to be called when the norm of the image or contour plot\n+    to which this colorbar belongs changes.\n+\n+    If the norm on the mappable is different than before, this resets the\n+    locator and formatter for the axis, so if these have been customized,\n+    they will need to be customized again.  However, if the norm only\n+    changes values of *vmin*, *vmax* or *cmap* then the old formatter\n+    and locator will be preserved.\n+    \"\"\"\n+    _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n+    self.mappable = mappable\n+    self.set_alpha(mappable.get_alpha())\n+    self.cmap = mappable.cmap\n+    if mappable.norm != self.norm:\n+        self.norm = mappable.norm\n+        # Ensure colorbar boundaries are compatible with the new norm\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, ensure vmin and vmax are positive\n+            mappable_vmin, mappable_vmax = mappable.get_clim()\n+            if mappable_vmin <= 0:\n+                # Use a small positive value or the actual data minimum\n+                if hasattr(mappable, 'get_array') and mappable.get_array() is not None:\n+                    data = mappable.get_array()\n+                    positive_data = data[data > 0]\n+                    if len(positive_data) > 0:\n+                        mappable_vmin = np.min(positive_data)\n+                    else:\n+                        mappable_vmin = 1e-10\n+                else:\n+                    mappable_vmin = 1e-10\n+            # Update the norm's vmin/vmax to ensure compatibility\n+            self.norm.vmin = mappable_vmin\n+            self.norm.vmax = mappable_vmax\n+        self._reset_locator_formatter_scale()\n+\n+    self._draw_all()\n+    if isinstance(self.mappable, contour.ContourSet):\n+        CS = self.mappable\n+        if not CS.filled:\n+            self.add_lines(CS)\n+    self.stale = True\n+                    vmin, vmax = mappable.get_clim()\n+                    if vmin is not None and vmax is not None:\n+                        self.norm.vmin = vmin\n+                        self.norm.vmax = vmax\n             self._reset_locator_formatter_scale()\n \n         self._draw_all()\n@@ -1062,12 +1093,42 @@ class Colorbar:\n             # use_gridspec was True\n             ax.set_subplotspec(subplotspec)\n \n+\n     def _process_values(self):\n         \"\"\"\n         Set `_boundaries` and `_values` based on the self.boundaries and\n         self.values if not None, or based on the size of the colormap and\n         the vmin/vmax of the norm.\n         \"\"\"\n+        # Early validation for norm compatibility, especially LogNorm\n+        if hasattr(self.norm, 'vmin') and hasattr(self.norm, 'vmax'):\n+            if isinstance(self.norm, colors.LogNorm):\n+                # For LogNorm, ensure vmin > 0 to prevent division by zero\n+                if self.norm.vmin <= 0:\n+                    # Try to get a reasonable positive vmin from the mappable's data\n+                    if hasattr(self, 'mappable') and hasattr(self.mappable, 'get_array'):\n+                        array = self.mappable.get_array()\n+                        if array is not None and len(array) > 0:\n+                            positive_data = array[array > 0]\n+                            if len(positive_data) > 0:\n+                                self.norm.vmin = float(np.min(positive_data))\n+                            else:\n+                                self.norm.vmin = 1e-10\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+        \n+        if self.values is not None:\n+            # set self._boundaries from the values...\n+            self._values = np.array(self.values)\n+            if self.boundaries is None:\n+                # bracket values by 1/2 dv:\n+                b = np.zeros(len(self.values) + 1)\n+                b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])\n+                b[0] = 2.0 * b[1] - b[2]\n+                b[-1] = 2.0 * b[-2] - b[-3]\n+                self._boundaries = b\n         if self.values is not None:\n             # set self._boundaries from the values...\n             self._values = np.array(self.values)\n@@ -1100,6 +1161,8 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n@@ -1108,6 +1171,21 @@ class Colorbar:\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n+            # Handle LogNorm compatibility - ensure vmin > 0 to avoid division by zero\n+            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+                # Use mappable's actual data range or fallback to small positive value\n+                if hasattr(self, 'mappable') and self.mappable is not None:\n+                    array = self.mappable.get_array()\n+                    if array is not None and array.size > 0:\n+                        data_min = np.ma.masked_invalid(array).min()\n+                        if np.ma.is_masked(data_min) or data_min <= 0:\n+                            self.norm.vmin = 1e-10\n+                        else:\n+                            self.norm.vmin = float(data_min)\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                else:\n+                    self.norm.vmin = 1e-10\n             b = self.norm.inverse(b)\n \n         self._boundaries = np.asarray(b, dtype=float)\n@@ -1164,12 +1242,30 @@ class Colorbar:\n         b = self._boundaries\n         return np.interp(x, np.linspace(0, 1, len(b)), b)\n \n+\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n         need to be re-entered if this gets called (either at init, or when\n         the mappable normal gets changed: Colorbar.update_normal)\n         \"\"\"\n+        # Ensure norm compatibility before processing values\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, ensure vmin > 0\n+            if hasattr(self, 'vmin') and self.vmin is not None and self.vmin <= 0:\n+                if hasattr(self.mappable, 'get_array'):\n+                    array = self.mappable.get_array()\n+                    if array is not None and len(array) > 0:\n+                        positive_values = array[array > 0]\n+                        if len(positive_values) > 0:\n+                            self.vmin = positive_values.min()\n+                        else:\n+                            self.vmin = 1e-10\n+                    else:\n+                        self.vmin = 1e-10\n+                else:\n+                    self.vmin = 1e-10\n+        \n         self._process_values()\n         self._locator = None\n         self._minorlocator = None\n",
    "variant_8": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\nindex d3d53e3d98..13e0f15fb1 100644\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -490,25 +490,41 @@ class Colorbar:\n \n     filled = _api.deprecate_privatize_attribute(\"3.6\")\n \n-    def update_normal(self, mappable):\n-        \"\"\"\n-        Update solid patches, lines, etc.\n \n-        This is meant to be called when the norm of the image or contour plot\n-        to which this colorbar belongs changes.\n+def update_normal(self, mappable):\n+    \"\"\"\n+    Update solid patches, lines, etc.\n \n-        If the norm on the mappable is different than before, this resets the\n-        locator and formatter for the axis, so if these have been customized,\n-        they will need to be customized again.  However, if the norm only\n-        changes values of *vmin*, *vmax* or *cmap* then the old formatter\n-        and locator will be preserved.\n-        \"\"\"\n-        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n-        self.mappable = mappable\n-        self.set_alpha(mappable.get_alpha())\n-        self.cmap = mappable.cmap\n-        if mappable.norm != self.norm:\n-            self.norm = mappable.norm\n+    This is meant to be called when the norm of the image or contour plot\n+    to which this colorbar belongs changes.\n+\n+    If the norm on the mappable is different than before, this resets the\n+    locator and formatter for the axis, so if these have been customized,\n+    they will need to be customized again.  However, if the norm only\n+    changes values of *vmin*, *vmax* or *cmap* then the old formatter\n+    and locator will be preserved.\n+    \"\"\"\n+    _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n+    self.mappable = mappable\n+    self.set_alpha(mappable.get_alpha())\n+    self.cmap = mappable.cmap\n+    if mappable.norm != self.norm:\n+        self.norm = mappable.norm\n+        # Ensure colorbar boundaries are compatible with the new norm\n+        if hasattr(mappable.norm, 'vmin') and hasattr(mappable.norm, 'vmax'):\n+            self.norm.vmin = mappable.norm.vmin\n+            self.norm.vmax = mappable.norm.vmax\n+        self._reset_locator_formatter_scale()\n+\n+    self._draw_all()\n+    if isinstance(self.mappable, contour.ContourSet):\n+        CS = self.mappable\n+        if not CS.filled:\n+            self.add_lines(CS)\n+    self.stale = True\n+                    if vmin is not None and vmax is not None:\n+                        self.norm.vmin = max(vmin, 1e-10) if vmin <= 0 else vmin\n+                        self.norm.vmax = vmax\n             self._reset_locator_formatter_scale()\n \n         self._draw_all()\n@@ -1062,12 +1078,29 @@ class Colorbar:\n             # use_gridspec was True\n             ax.set_subplotspec(subplotspec)\n \n+\n     def _process_values(self):\n         \"\"\"\n         Set `_boundaries` and `_values` based on the self.boundaries and\n         self.values if not None, or based on the size of the colormap and\n         the vmin/vmax of the norm.\n         \"\"\"\n+        # Handle LogNorm compatibility - ensure vmin > 0 for LogNorm\n+        if isinstance(self.norm, colors.LogNorm):\n+            if self.norm.vmin is not None and self.norm.vmin <= 0:\n+                # Try to get a reasonable positive vmin from mappable data\n+                if hasattr(self.mappable, 'get_array'):\n+                    array = self.mappable.get_array()\n+                    if array is not None and len(array) > 0:\n+                        positive_data = array[array > 0]\n+                        if len(positive_data) > 0:\n+                            self.norm.vmin = float(np.min(positive_data))\n+                        else:\n+                            self.norm.vmin = 1e-10\n+                    else:\n+                        self.norm.vmin = 1e-10\n+                else:\n+                    self.norm.vmin = 1e-10\n         if self.values is not None:\n             # set self._boundaries from the values...\n             self._values = np.array(self.values)\n@@ -1100,6 +1133,8 @@ class Colorbar:\n         if self._extend_upper():\n             b = np.hstack((b, b[-1] + 1))\n \n+        # transform from 0-1 to vmin-vmax:\n+\n         # transform from 0-1 to vmin-vmax:\n         if not self.norm.scaled():\n             self.norm.vmin = 0\n@@ -1108,6 +1143,19 @@ class Colorbar:\n             self.norm.vmin, self.norm.vmax, expander=0.1)\n         if (not isinstance(self.norm, colors.BoundaryNorm) and\n                 (self.boundaries is None)):\n+            # Handle LogNorm compatibility - ensure vmin > 0 to avoid division by zero\n+            if isinstance(self.norm, colors.LogNorm) and self.norm.vmin <= 0:\n+                # Use mappable's data range or fallback to small positive value\n+                if hasattr(self, 'mappable') and self.mappable is not None:\n+                    try:\n+                        data = self.mappable.get_array()\n+                        if data is not None and len(data) > 0:\n+                            data_min = np.min(data[data > 0]) if np.any(data > 0) else 1e-10\n+                            self.norm.vmin = max(data_min, 1e-10)\n+                    except (AttributeError, ValueError):\n+                        self.norm.vmin = 1e-10\n+                else:\n+                    self.norm.vmin = 1e-10\n             b = self.norm.inverse(b)\n \n         self._boundaries = np.asarray(b, dtype=float)\n@@ -1164,12 +1212,31 @@ class Colorbar:\n         b = self._boundaries\n         return np.interp(x, np.linspace(0, 1, len(b)), b)\n \n+\n     def _reset_locator_formatter_scale(self):\n         \"\"\"\n         Reset the locator et al to defaults.  Any user-hardcoded changes\n         need to be re-entered if this gets called (either at init, or when\n         the mappable normal gets changed: Colorbar.update_normal)\n         \"\"\"\n+        # Ensure norm compatibility before processing values\n+        if isinstance(self.norm, colors.LogNorm):\n+            # For LogNorm, ensure vmin and vmax are positive\n+            if hasattr(self.mappable, 'get_array'):\n+                array = self.mappable.get_array()\n+                if array is not None:\n+                    array_min = np.nanmin(array[array > 0]) if np.any(array > 0) else 1e-10\n+                    if self.vmin <= 0:\n+                        self.vmin = array_min\n+                    if self.vmax <= 0:\n+                        self.vmax = max(np.nanmax(array), self.vmin * 10)\n+            else:\n+                # Fallback if no array available\n+                if self.vmin <= 0:\n+                    self.vmin = 1e-10\n+                if self.vmax <= self.vmin:\n+                    self.vmax = self.vmin * 10\n+        \n         self._process_values()\n         self._locator = None\n         self._minorlocator = None\n"
  }
}