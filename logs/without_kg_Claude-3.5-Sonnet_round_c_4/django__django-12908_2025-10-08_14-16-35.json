{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/query.py lines 1137-1145)": "\n    def distinct(self, *field_names):\n        \"\"\"\n        Return a new QuerySet instance that will select only distinct results.\n        \"\"\"\n        assert not self.query.is_sliced, \\\n            \"Cannot create distinct fields once a slice has been taken.\"\n        obj = self._chain()\n        \n        # Handle combinator queries (UNION, INTERSECT, EXCEPT) with distinct\n        if obj.query.combinator:\n            # Create a subquery wrapper to apply distinct on top of combinator\n            from django.db.models.sql.subqueries import Query\n            outer_query = Query(obj.model)\n            \n            # Set the inner query as a subquery\n            outer_query.add_subquery(obj.query, obj.query.get_meta().db_table)\n            \n            # Apply distinct on the outer query\n            outer_query.add_distinct_fields(*field_names)\n            \n            # Create new QuerySet with the wrapped query\n            result = obj._clone()\n            result.query = outer_query\n            return result\n        else:\n            obj.query.add_distinct_fields(*field_names)\n            return obj\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/query.py lines 1137-1145)": [
      "\ndef distinct(self, *field_names):\n    \"\"\"\n    Return a new QuerySet instance that will select only distinct results.\n    \"\"\"\n    assert not self.query.is_sliced, \\\n        \"Cannot create distinct fields once a slice has been taken.\"\n    obj = self._chain()\n    \n    # Handle distinct on combinator queries (UNION, INTERSECTION, DIFFERENCE)\n    if obj.query.combinator:\n        # Create a subquery wrapper to apply distinct at the outer level\n        from django.db.models import Subquery\n        \n        # Get the model for the outer query\n        model = obj.model\n        \n        # Create a new query that wraps the combinator query as a subquery\n        outer_qs = model.objects.filter(pk__in=Subquery(obj.values('pk')))\n        \n        # Apply distinct to the outer query\n        outer_qs.query.add_distinct_fields(*field_names)\n        return outer_qs\n    else:\n        obj.query.add_distinct_fields(*field_names)\n        return obj\n",
      "\ndef distinct(self, *field_names):\n    \"\"\"\n    Return a new QuerySet instance that will select only distinct results.\n    \"\"\"\n    assert not self.query.is_sliced, \\\n        \"Cannot create distinct fields once a slice has been taken.\"\n    obj = self._chain()\n    \n    # Handle distinct with combinator queries (union, intersection, difference)\n    if obj.query.combinator:\n        # Create a subquery wrapper to apply distinct at outer level\n        # This generates SQL like: SELECT DISTINCT ON (field) * FROM (union_query) AS subquery\n        from django.db.models.sql.subqueries import Query\n        from django.db.models.sql.where import WhereNode\n        \n        # Create new outer query that wraps the combinator query as a subquery\n        outer_query = obj.query.__class__(obj.model)\n        outer_query.add_subquery(obj.query, alias='subquery')\n        \n        # Apply distinct fields to the outer query\n        outer_query.add_distinct_fields(*field_names)\n        \n        # Create new QuerySet with the wrapped query\n        new_obj = obj._clone()\n        new_obj.query = outer_query\n        return new_obj\n    else:\n        # Normal case - no combinator\n        obj.query.add_distinct_fields(*field_names)\n        return obj\n",
      "\ndef distinct(self, *field_names):\n    \"\"\"\n    Return a new QuerySet instance that will select only distinct results.\n    \"\"\"\n    assert not self.query.is_sliced, \\\n        \"Cannot create distinct fields once a slice has been taken.\"\n    obj = self._chain()\n    \n    # Handle distinct on combinator queries by wrapping in a subquery\n    if obj.query.combinator:\n        # Create a new QuerySet that wraps the current combinator query as a subquery\n        from django.db.models.sql.query import Query\n        from django.db.models.sql.subqueries import AggregateQuery\n        \n        # Create outer query that will contain the distinct\n        outer_query = Query(obj.model)\n        outer_query.add_distinct_fields(*field_names)\n        \n        # Set the current combinator query as a subquery\n        outer_query.subquery = True\n        obj.query.subquery = True\n        \n        # Create new QuerySet with the outer query\n        outer_obj = obj._clone()\n        outer_obj.query = outer_query\n        \n        # Set the combinator query as the inner query for the subquery\n        compiler = obj.query.get_compiler(using=obj.db)\n        subquery_sql, subquery_params = compiler.as_sql()\n        \n        # Add the subquery to the outer query\n        outer_query.add_extra_restriction(\n            (\"(%s)\" % subquery_sql, subquery_params)\n        )\n        \n        return outer_obj\n    else:\n        obj.query.add_distinct_fields(*field_names)\n        return obj\n",
      "\ndef distinct(self, *field_names):\n    \"\"\"\n    Return a new QuerySet instance that will select only distinct results.\n    \"\"\"\n    assert not self.query.is_sliced, \\\n        \"Cannot create distinct fields once a slice has been taken.\"\n    obj = self._chain()\n    \n    # Handle distinct on combinator queries by wrapping in a subquery\n    if obj.query.combinator:\n        # Create a new QuerySet that treats the current combinator query as a subquery\n        from django.db.models.sql.subqueries import Query\n        from django.db import connection\n        \n        # Get the model and create a new query\n        model = obj.model\n        new_query = Query(model)\n        \n        # Set the subquery as the current combinator query\n        compiler = obj.query.get_compiler(connection=connection.default_alias)\n        subquery_sql, subquery_params = compiler.as_sql()\n        \n        # Create a new QuerySet with the subquery and apply distinct\n        new_obj = obj.__class__(model=model, query=new_query, using=obj._db, hints=obj._hints)\n        new_obj.query.add_extra_select({'*': '(%s)' % subquery_sql}, subquery_params)\n        new_obj.query.add_distinct_fields(*field_names)\n        return new_obj\n    else:\n        obj.query.add_distinct_fields(*field_names)\n        return obj\n",
      "\ndef distinct(self, *field_names):\n    \"\"\"\n    Return a new QuerySet instance that will select only distinct results.\n    \"\"\"\n    assert not self.query.is_sliced, \\\n        \"Cannot create distinct fields once a slice has been taken.\"\n    obj = self._chain()\n    \n    # Handle distinct on combinator queries (union, intersection, difference)\n    if obj.query.combinator:\n        # Create a subquery wrapper to apply distinct at the outer level\n        from django.db.models.sql import Query\n        from django.db.models.sql.subqueries import UpdateQuery\n        \n        # Create a new query that wraps the current combinator query as a subquery\n        outer_query = obj.query.clone()\n        outer_query.combinator = None\n        outer_query.combinator_all = False\n        outer_query.combined_queries = ()\n        \n        # Set up the subquery\n        subquery = obj.query.clone()\n        outer_query.subquery = True\n        outer_query.select = []\n        outer_query.add_subquery(subquery, using=obj.db)\n        \n        # Apply distinct to the outer query\n        outer_query.add_distinct_fields(*field_names)\n        \n        # Create new QuerySet with the restructured query\n        new_obj = obj._chain()\n        new_obj.query = outer_query\n        return new_obj\n    else:\n        obj.query.add_distinct_fields(*field_names)\n        return obj\n",
      "\ndef distinct(self, *field_names):\n    \"\"\"\n    Return a new QuerySet instance that will select only distinct results.\n    \"\"\"\n    assert not self.query.is_sliced, \\\n        \"Cannot create distinct fields once a slice has been taken.\"\n    obj = self._chain()\n    \n    # Handle distinct with combinator queries by wrapping in a subquery\n    if obj.query.combinator:\n        # Create a new QuerySet that wraps the current combinator query as a subquery\n        from django.db.models.sql.query import Query\n        from django.db.models.sql.subqueries import UpdateQuery\n        \n        # Create outer query\n        outer_query = obj.query.clone()\n        outer_query.combinator = None\n        outer_query.combinator_all = False\n        outer_query.combined_queries = ()\n        \n        # Reset the outer query's tables and use the combinator query as subquery\n        outer_query.clear_select_clause()\n        outer_query.clear_where()\n        outer_query.clear_ordering(force_empty=True)\n        outer_query.extra = {}\n        outer_query.distinct = True\n        outer_query.distinct_fields = field_names\n        \n        # Set the current combinator query as a subquery\n        subquery_alias = outer_query.get_meta().db_table\n        outer_query.add_subquery(obj.query, subquery_alias)\n        \n        # Update the model to point to the subquery\n        obj.query = outer_query\n        return obj\n    \n    obj.query.add_distinct_fields(*field_names)\n    return obj\n",
      "\ndef distinct(self, *field_names):\n    \"\"\"\n    Return a new QuerySet instance that will select only distinct results.\n    \"\"\"\n    assert not self.query.is_sliced, \\\n        \"Cannot create distinct fields once a slice has been taken.\"\n    obj = self._chain()\n    \n    # Handle distinct for combined queries by wrapping in a subquery\n    if obj.query.combinator:\n        # Create a new query that wraps the combined query as a subquery\n        from django.db.models.sql.query import Query\n        outer_query = Query(obj.model)\n        \n        # Set the inner query as a subquery\n        outer_query.add_subquery(obj.query, alias='subquery')\n        \n        # Apply distinct to the outer query\n        outer_query.add_distinct_fields(*field_names)\n        \n        # Create new QuerySet with the wrapped query\n        new_obj = obj._clone()\n        new_obj.query = outer_query\n        return new_obj\n    else:\n        obj.query.add_distinct_fields(*field_names)\n        return obj\n",
      "\n    def distinct(self, *field_names):\n        \"\"\"\n        Return a new QuerySet instance that will select only distinct results.\n        \"\"\"\n        assert not self.query.is_sliced, \\\n            \"Cannot create distinct fields once a slice has been taken.\"\n        obj = self._chain()\n        \n        # Handle distinct on combinator queries (union, intersection, difference)\n        if obj.query.combinator:\n            # Create a subquery wrapper to apply distinct at the outer level\n            from django.db.models.sql.subqueries import Query\n            from django.db.models.sql import compiler\n            \n            # Create a new query that wraps the current combinator query as a subquery\n            outer_query = Query(obj.model)\n            \n            # Set up the subquery\n            outer_query.add_subquery(obj.query, alias='subquery')\n            \n            # Add distinct fields to the outer query\n            outer_query.add_distinct_fields(*field_names)\n            \n            # Create new QuerySet with the wrapped query\n            new_obj = obj._clone()\n            new_obj.query = outer_query\n            return new_obj\n        else:\n            # Normal case - no combinator\n            obj.query.add_distinct_fields(*field_names)\n            return obj\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..d7d0f8e3c9 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,6 +1134,7 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n+\n     def distinct(self, *field_names):\n         \"\"\"\n         Return a new QuerySet instance that will select only distinct results.\n@@ -1141,6 +1142,26 @@ class QuerySet:\n         assert not self.query.is_sliced, \\\n             \"Cannot create distinct fields once a slice has been taken.\"\n         obj = self._chain()\n+        \n+        # Handle distinct on combinator queries (union, intersection, difference)\n+        if obj.query.combinator:\n+            # Create a subquery from the current combinator query\n+            from django.db.models.sql.subqueries import Query\n+            from django.db.models import Subquery, OuterRef\n+            \n+            # Create a new query that wraps the combinator query as a subquery\n+            # This allows distinct to be applied at the outer level\n+            outer_query = obj.model.objects.all()\n+            outer_query.query = Query(obj.model)\n+            \n+            # Convert the combinator query to a subquery\n+            subquery = Subquery(obj.values('pk'))\n+            outer_query = outer_query.filter(pk__in=subquery)\n+            \n+            # Apply distinct to the outer query\n+            outer_query.query.add_distinct_fields(*field_names)\n+            return outer_query\n+        \n         obj.query.add_distinct_fields(*field_names)\n         return obj\n \n",
    "variant_0": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..21cb1a1896 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,6 +1134,7 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n+\n     def distinct(self, *field_names):\n         \"\"\"\n         Return a new QuerySet instance that will select only distinct results.\n@@ -1141,8 +1142,26 @@ class QuerySet:\n         assert not self.query.is_sliced, \\\n             \"Cannot create distinct fields once a slice has been taken.\"\n         obj = self._chain()\n-        obj.query.add_distinct_fields(*field_names)\n-        return obj\n+        \n+        # Handle combinator queries (UNION, INTERSECT, EXCEPT) with distinct\n+        if obj.query.combinator:\n+            # Create a subquery wrapper to apply distinct on top of combinator\n+            from django.db.models.sql.subqueries import Query\n+            outer_query = Query(obj.model)\n+            \n+            # Set the inner query as a subquery\n+            outer_query.add_subquery(obj.query, obj.query.get_meta().db_table)\n+            \n+            # Apply distinct on the outer query\n+            outer_query.add_distinct_fields(*field_names)\n+            \n+            # Create new QuerySet with the wrapped query\n+            result = obj._clone()\n+            result.query = outer_query\n+            return result\n+        else:\n+            obj.query.add_distinct_fields(*field_names)\n+            return obj\n \n     def extra(self, select=None, where=None, params=None, tables=None,\n               order_by=None, select_params=None):\n",
    "variant_1": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..e4dfc674c0 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,13 +1134,30 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n-    def distinct(self, *field_names):\n-        \"\"\"\n-        Return a new QuerySet instance that will select only distinct results.\n-        \"\"\"\n-        assert not self.query.is_sliced, \\\n-            \"Cannot create distinct fields once a slice has been taken.\"\n-        obj = self._chain()\n+\n+def distinct(self, *field_names):\n+    \"\"\"\n+    Return a new QuerySet instance that will select only distinct results.\n+    \"\"\"\n+    assert not self.query.is_sliced, \\\n+        \"Cannot create distinct fields once a slice has been taken.\"\n+    obj = self._chain()\n+    \n+    # Handle distinct on combinator queries (UNION, INTERSECTION, DIFFERENCE)\n+    if obj.query.combinator:\n+        # Create a subquery wrapper to apply distinct at the outer level\n+        from django.db.models import Subquery\n+        \n+        # Get the model for the outer query\n+        model = obj.model\n+        \n+        # Create a new query that wraps the combinator query as a subquery\n+        outer_qs = model.objects.filter(pk__in=Subquery(obj.values('pk')))\n+        \n+        # Apply distinct to the outer query\n+        outer_qs.query.add_distinct_fields(*field_names)\n+        return outer_qs\n+    else:\n         obj.query.add_distinct_fields(*field_names)\n         return obj\n \n",
    "variant_2": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..3ca4b7a711 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,13 +1134,35 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n-    def distinct(self, *field_names):\n-        \"\"\"\n-        Return a new QuerySet instance that will select only distinct results.\n-        \"\"\"\n-        assert not self.query.is_sliced, \\\n-            \"Cannot create distinct fields once a slice has been taken.\"\n-        obj = self._chain()\n+\n+def distinct(self, *field_names):\n+    \"\"\"\n+    Return a new QuerySet instance that will select only distinct results.\n+    \"\"\"\n+    assert not self.query.is_sliced, \\\n+        \"Cannot create distinct fields once a slice has been taken.\"\n+    obj = self._chain()\n+    \n+    # Handle distinct with combinator queries (union, intersection, difference)\n+    if obj.query.combinator:\n+        # Create a subquery wrapper to apply distinct at outer level\n+        # This generates SQL like: SELECT DISTINCT ON (field) * FROM (union_query) AS subquery\n+        from django.db.models.sql.subqueries import Query\n+        from django.db.models.sql.where import WhereNode\n+        \n+        # Create new outer query that wraps the combinator query as a subquery\n+        outer_query = obj.query.__class__(obj.model)\n+        outer_query.add_subquery(obj.query, alias='subquery')\n+        \n+        # Apply distinct fields to the outer query\n+        outer_query.add_distinct_fields(*field_names)\n+        \n+        # Create new QuerySet with the wrapped query\n+        new_obj = obj._clone()\n+        new_obj.query = outer_query\n+        return new_obj\n+    else:\n+        # Normal case - no combinator\n         obj.query.add_distinct_fields(*field_names)\n         return obj\n \n",
    "variant_3": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..e78b0f9405 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,13 +1134,44 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n-    def distinct(self, *field_names):\n-        \"\"\"\n-        Return a new QuerySet instance that will select only distinct results.\n-        \"\"\"\n-        assert not self.query.is_sliced, \\\n-            \"Cannot create distinct fields once a slice has been taken.\"\n-        obj = self._chain()\n+\n+def distinct(self, *field_names):\n+    \"\"\"\n+    Return a new QuerySet instance that will select only distinct results.\n+    \"\"\"\n+    assert not self.query.is_sliced, \\\n+        \"Cannot create distinct fields once a slice has been taken.\"\n+    obj = self._chain()\n+    \n+    # Handle distinct on combinator queries by wrapping in a subquery\n+    if obj.query.combinator:\n+        # Create a new QuerySet that wraps the current combinator query as a subquery\n+        from django.db.models.sql.query import Query\n+        from django.db.models.sql.subqueries import AggregateQuery\n+        \n+        # Create outer query that will contain the distinct\n+        outer_query = Query(obj.model)\n+        outer_query.add_distinct_fields(*field_names)\n+        \n+        # Set the current combinator query as a subquery\n+        outer_query.subquery = True\n+        obj.query.subquery = True\n+        \n+        # Create new QuerySet with the outer query\n+        outer_obj = obj._clone()\n+        outer_obj.query = outer_query\n+        \n+        # Set the combinator query as the inner query for the subquery\n+        compiler = obj.query.get_compiler(using=obj.db)\n+        subquery_sql, subquery_params = compiler.as_sql()\n+        \n+        # Add the subquery to the outer query\n+        outer_query.add_extra_restriction(\n+            (\"(%s)\" % subquery_sql, subquery_params)\n+        )\n+        \n+        return outer_obj\n+    else:\n         obj.query.add_distinct_fields(*field_names)\n         return obj\n \n",
    "variant_4": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..d9cd9552ab 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,13 +1134,35 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n-    def distinct(self, *field_names):\n-        \"\"\"\n-        Return a new QuerySet instance that will select only distinct results.\n-        \"\"\"\n-        assert not self.query.is_sliced, \\\n-            \"Cannot create distinct fields once a slice has been taken.\"\n-        obj = self._chain()\n+\n+def distinct(self, *field_names):\n+    \"\"\"\n+    Return a new QuerySet instance that will select only distinct results.\n+    \"\"\"\n+    assert not self.query.is_sliced, \\\n+        \"Cannot create distinct fields once a slice has been taken.\"\n+    obj = self._chain()\n+    \n+    # Handle distinct on combinator queries by wrapping in a subquery\n+    if obj.query.combinator:\n+        # Create a new QuerySet that treats the current combinator query as a subquery\n+        from django.db.models.sql.subqueries import Query\n+        from django.db import connection\n+        \n+        # Get the model and create a new query\n+        model = obj.model\n+        new_query = Query(model)\n+        \n+        # Set the subquery as the current combinator query\n+        compiler = obj.query.get_compiler(connection=connection.default_alias)\n+        subquery_sql, subquery_params = compiler.as_sql()\n+        \n+        # Create a new QuerySet with the subquery and apply distinct\n+        new_obj = obj.__class__(model=model, query=new_query, using=obj._db, hints=obj._hints)\n+        new_obj.query.add_extra_select({'*': '(%s)' % subquery_sql}, subquery_params)\n+        new_obj.query.add_distinct_fields(*field_names)\n+        return new_obj\n+    else:\n         obj.query.add_distinct_fields(*field_names)\n         return obj\n \n",
    "variant_5": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..dee81739c2 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,13 +1134,41 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n-    def distinct(self, *field_names):\n-        \"\"\"\n-        Return a new QuerySet instance that will select only distinct results.\n-        \"\"\"\n-        assert not self.query.is_sliced, \\\n-            \"Cannot create distinct fields once a slice has been taken.\"\n-        obj = self._chain()\n+\n+def distinct(self, *field_names):\n+    \"\"\"\n+    Return a new QuerySet instance that will select only distinct results.\n+    \"\"\"\n+    assert not self.query.is_sliced, \\\n+        \"Cannot create distinct fields once a slice has been taken.\"\n+    obj = self._chain()\n+    \n+    # Handle distinct on combinator queries (union, intersection, difference)\n+    if obj.query.combinator:\n+        # Create a subquery wrapper to apply distinct at the outer level\n+        from django.db.models.sql import Query\n+        from django.db.models.sql.subqueries import UpdateQuery\n+        \n+        # Create a new query that wraps the current combinator query as a subquery\n+        outer_query = obj.query.clone()\n+        outer_query.combinator = None\n+        outer_query.combinator_all = False\n+        outer_query.combined_queries = ()\n+        \n+        # Set up the subquery\n+        subquery = obj.query.clone()\n+        outer_query.subquery = True\n+        outer_query.select = []\n+        outer_query.add_subquery(subquery, using=obj.db)\n+        \n+        # Apply distinct to the outer query\n+        outer_query.add_distinct_fields(*field_names)\n+        \n+        # Create new QuerySet with the restructured query\n+        new_obj = obj._chain()\n+        new_obj.query = outer_query\n+        return new_obj\n+    else:\n         obj.query.add_distinct_fields(*field_names)\n         return obj\n \n",
    "variant_6": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..10f568a6d6 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,15 +1134,45 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n-    def distinct(self, *field_names):\n-        \"\"\"\n-        Return a new QuerySet instance that will select only distinct results.\n-        \"\"\"\n-        assert not self.query.is_sliced, \\\n-            \"Cannot create distinct fields once a slice has been taken.\"\n-        obj = self._chain()\n-        obj.query.add_distinct_fields(*field_names)\n+\n+def distinct(self, *field_names):\n+    \"\"\"\n+    Return a new QuerySet instance that will select only distinct results.\n+    \"\"\"\n+    assert not self.query.is_sliced, \\\n+        \"Cannot create distinct fields once a slice has been taken.\"\n+    obj = self._chain()\n+    \n+    # Handle distinct with combinator queries by wrapping in a subquery\n+    if obj.query.combinator:\n+        # Create a new QuerySet that wraps the current combinator query as a subquery\n+        from django.db.models.sql.query import Query\n+        from django.db.models.sql.subqueries import UpdateQuery\n+        \n+        # Create outer query\n+        outer_query = obj.query.clone()\n+        outer_query.combinator = None\n+        outer_query.combinator_all = False\n+        outer_query.combined_queries = ()\n+        \n+        # Reset the outer query's tables and use the combinator query as subquery\n+        outer_query.clear_select_clause()\n+        outer_query.clear_where()\n+        outer_query.clear_ordering(force_empty=True)\n+        outer_query.extra = {}\n+        outer_query.distinct = True\n+        outer_query.distinct_fields = field_names\n+        \n+        # Set the current combinator query as a subquery\n+        subquery_alias = outer_query.get_meta().db_table\n+        outer_query.add_subquery(obj.query, subquery_alias)\n+        \n+        # Update the model to point to the subquery\n+        obj.query = outer_query\n         return obj\n+    \n+    obj.query.add_distinct_fields(*field_names)\n+    return obj\n \n     def extra(self, select=None, where=None, params=None, tables=None,\n               order_by=None, select_params=None):\n",
    "variant_7": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..34f6eda72c 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,13 +1134,32 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n-    def distinct(self, *field_names):\n-        \"\"\"\n-        Return a new QuerySet instance that will select only distinct results.\n-        \"\"\"\n-        assert not self.query.is_sliced, \\\n-            \"Cannot create distinct fields once a slice has been taken.\"\n-        obj = self._chain()\n+\n+def distinct(self, *field_names):\n+    \"\"\"\n+    Return a new QuerySet instance that will select only distinct results.\n+    \"\"\"\n+    assert not self.query.is_sliced, \\\n+        \"Cannot create distinct fields once a slice has been taken.\"\n+    obj = self._chain()\n+    \n+    # Handle distinct for combined queries by wrapping in a subquery\n+    if obj.query.combinator:\n+        # Create a new query that wraps the combined query as a subquery\n+        from django.db.models.sql.query import Query\n+        outer_query = Query(obj.model)\n+        \n+        # Set the inner query as a subquery\n+        outer_query.add_subquery(obj.query, alias='subquery')\n+        \n+        # Apply distinct to the outer query\n+        outer_query.add_distinct_fields(*field_names)\n+        \n+        # Create new QuerySet with the wrapped query\n+        new_obj = obj._clone()\n+        new_obj.query = outer_query\n+        return new_obj\n+    else:\n         obj.query.add_distinct_fields(*field_names)\n         return obj\n \n",
    "variant_8": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex e0eeccefa6..6bf35c0d78 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1134,6 +1134,7 @@ class QuerySet:\n         obj.query.add_ordering(*field_names)\n         return obj\n \n+\n     def distinct(self, *field_names):\n         \"\"\"\n         Return a new QuerySet instance that will select only distinct results.\n@@ -1141,8 +1142,30 @@ class QuerySet:\n         assert not self.query.is_sliced, \\\n             \"Cannot create distinct fields once a slice has been taken.\"\n         obj = self._chain()\n-        obj.query.add_distinct_fields(*field_names)\n-        return obj\n+        \n+        # Handle distinct on combinator queries (union, intersection, difference)\n+        if obj.query.combinator:\n+            # Create a subquery wrapper to apply distinct at the outer level\n+            from django.db.models.sql.subqueries import Query\n+            from django.db.models.sql import compiler\n+            \n+            # Create a new query that wraps the current combinator query as a subquery\n+            outer_query = Query(obj.model)\n+            \n+            # Set up the subquery\n+            outer_query.add_subquery(obj.query, alias='subquery')\n+            \n+            # Add distinct fields to the outer query\n+            outer_query.add_distinct_fields(*field_names)\n+            \n+            # Create new QuerySet with the wrapped query\n+            new_obj = obj._clone()\n+            new_obj.query = outer_query\n+            return new_obj\n+        else:\n+            # Normal case - no combinator\n+            obj.query.add_distinct_fields(*field_names)\n+            return obj\n \n     def extra(self, select=None, where=None, params=None, tables=None,\n               order_by=None, select_params=None):\n"
  }
}