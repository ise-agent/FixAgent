{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/lookups.py lines 266-267)": "\n    def process_rhs(self, compiler, connection):\n        from django.db.models.sql.query import Query\n        if isinstance(self.rhs, Query):\n            if self.rhs.has_limit_one():\n                # The subquery must select only the pk.\n                # Store the original group_by to preserve grouping semantics\n                original_group_by = self.rhs.group_by[:]\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n                # Restore original group_by to preserve annotation grouping\n                if original_group_by:\n                    self.rhs.group_by = original_group_by\n            else:\n                raise ValueError(\n                    'The QuerySet value for an exact lookup must be limited to '\n                    'one result using slicing.'\n                )\n        return super().process_rhs(compiler, connection)\n",
    "Location 2 (/root/hy/projects_4/django/django/db/models/sql/query.py lines 1920-1920)": "\n    def set_group_by(self):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        # Check if GROUP BY should be preserved from lookup optimization\n        if hasattr(self, '_preserve_group_by') and self._preserve_group_by and self.group_by:\n            # Keep existing GROUP BY when it was preserved during lookup optimization\n            return\n            \n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n",
    "Location 3 (/root/hy/projects_4/django/django/db/models/lookups.py lines 235-241)": "\n    def resolve_expression_parameter(self, compiler, connection, sql, param):\n        params = [param]\n        if hasattr(param, 'resolve_expression'):\n            param = param.resolve_expression(compiler.query)\n        if hasattr(param, 'as_sql'):\n            # Store original group_by before potential modification\n            original_group_by = None\n            if hasattr(param, 'query') and hasattr(param.query, 'group_by'):\n                original_group_by = param.query.group_by[:]\n            \n            sql, params = param.as_sql(compiler, connection)\n            \n            # Restore original group_by if it was modified during as_sql()\n            if (original_group_by is not None and \n                hasattr(param, 'query') and \n                hasattr(param.query, 'group_by') and\n                param.query.group_by != original_group_by):\n                param.query.group_by = original_group_by\n        return sql, params\n",
    "Location 4 (/root/hy/projects_4/django/django/db/models/sql/query.py lines 1838-1860)": "\n    def add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n        \"\"\"\n        Add the given (model) fields to the select set. Add the field names in\n        the order specified.\n        \"\"\"\n        alias = self.get_initial_alias()\n        opts = self.get_meta()\n\n        # Store original group_by if preservation is requested\n        original_group_by = None\n        if preserve_group_by and self.group_by is not None:\n            original_group_by = self.group_by[:]\n\n        try:\n            cols = []\n            for name in field_names:\n                # Join promotion note - we must not remove any rows here, so\n                # if there is no existing joins, use outer join.\n                join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)\n                targets, final_alias, joins = self.trim_joins(\n                    join_info.targets,\n                    join_info.joins,\n                    join_info.path,\n                )\n                for target in targets:\n                    cols.append(join_info.transform_function(target, final_alias))\n            if cols:\n                self.set_select(cols)\n                # Restore original group_by if preservation was requested\n                if preserve_group_by and original_group_by is not None:\n                    self.group_by = original_group_by\n",
    "Location 5 (/root/hy/projects_4/django/django/db/models/sql/query.py lines 1911-1936)": "\n    def set_group_by(self, preserve_existing=False):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \n        If preserve_existing is True, keep the current group_by if it exists.\n        \"\"\"\n        if preserve_existing and hasattr(self, 'group_by') and self.group_by:\n            return\n            \n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/lookups.py lines 266-267)": [
      "\n    def process_rhs(self, compiler, connection):\n        from django.db.models.sql.query import Query\n        if isinstance(self.rhs, Query):\n            if self.rhs.has_limit_one():\n                # The subquery must select only the pk.\n                # Preserve the original group_by to maintain grouping semantics\n                original_group_by = self.rhs.group_by[:]\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n                # Restore original group_by if it existed to preserve annotation grouping\n                if original_group_by:\n                    self.rhs.group_by = original_group_by\n            else:\n                raise ValueError(\n                    'The QuerySet value for an exact lookup must be limited to '\n                    'one result using slicing.'\n                )\n        return super().process_rhs(compiler, connection)\n",
      "\n    def process_rhs(self, compiler, connection):\n        from django.db.models.sql.query import Query\n        if isinstance(self.rhs, Query):\n            if self.rhs.has_limit_one():\n                # The subquery must select only the pk.\n                # Preserve the original group_by to maintain grouping semantics\n                original_group_by = self.rhs.group_by\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n                # Restore the original group_by if it existed\n                if original_group_by:\n                    self.rhs.group_by = original_group_by\n            else:\n                raise ValueError(\n                    'The QuerySet value for an exact lookup must be limited to '\n                    'one result using slicing.'\n                )\n        return super().process_rhs(compiler, connection)\n",
      "\n    def process_rhs(self, compiler, connection):\n        from django.db.models.sql.query import Query\n        if isinstance(self.rhs, Query):\n            if self.rhs.has_limit_one():\n                # The subquery must select only the pk.\n                # Store original group_by to preserve grouping semantics\n                original_group_by = self.rhs.group_by[:]\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n                # Restore original group_by if it existed to preserve annotation semantics\n                if original_group_by:\n                    self.rhs.group_by = original_group_by\n            else:\n                raise ValueError(\n                    'The QuerySet value for an exact lookup must be limited to '\n                    'one result using slicing.'\n                )\n        return super().process_rhs(compiler, connection)\n",
      "\n    def process_rhs(self, compiler, connection):\n        from django.db.models.sql.query import Query\n        if isinstance(self.rhs, Query):\n            if self.rhs.has_limit_one():\n                # The subquery must select only the pk.\n                # Preserve original GROUP BY clause before modifying SELECT\n                original_group_by = self.rhs.group_by[:]\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n                # Restore original GROUP BY to preserve annotation semantics\n                if original_group_by:\n                    self.rhs.group_by = original_group_by\n            else:\n                raise ValueError(\n                    'The QuerySet value for an exact lookup must be limited to '\n                    'one result using slicing.'\n                )\n        return super().process_rhs(compiler, connection)\n",
      "\n    def process_rhs(self, compiler, connection):\n        from django.db.models.sql.query import Query\n        if isinstance(self.rhs, Query):\n            if self.rhs.has_limit_one():\n                # The subquery must select only the pk.\n                # Store original group_by to preserve grouping semantics\n                original_group_by = self.rhs.group_by[:]\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n                # Restore original group_by if it existed to preserve annotation semantics\n                if original_group_by:\n                    self.rhs.group_by = original_group_by\n            else:\n                raise ValueError(\n                    'The QuerySet value for an exact lookup must be limited to '\n                    'one result using slicing.'\n                )\n        return super().process_rhs(compiler, connection)\n",
      "\n    def process_rhs(self, compiler, connection):\n        from django.db.models.sql.query import Query\n        if isinstance(self.rhs, Query):\n            if self.rhs.has_limit_one():\n                # The subquery must select only the pk.\n                # Preserve the original GROUP BY clause before clearing select\n                original_group_by = self.rhs.group_by[:]\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n                # Restore the original GROUP BY to preserve annotation semantics\n                if original_group_by:\n                    self.rhs.group_by = original_group_by\n            else:\n                raise ValueError(\n                    'The QuerySet value for an exact lookup must be limited to '\n                    'one result using slicing.'\n                )\n        return super().process_rhs(compiler, connection)\n",
      "\n    def process_rhs(self, compiler, connection):\n        from django.db.models.sql.query import Query\n        if isinstance(self.rhs, Query):\n            if self.rhs.has_limit_one():\n                # The subquery must select only the pk.\n                # Preserve the original GROUP BY clause to maintain query semantics\n                original_group_by = self.rhs.group_by[:]\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n                # Restore the original GROUP BY if it existed\n                if original_group_by:\n                    self.rhs.group_by = original_group_by\n            else:\n                raise ValueError(\n                    'The QuerySet value for an exact lookup must be limited to '\n                    'one result using slicing.'\n                )\n        return super().process_rhs(compiler, connection)\n",
      "\n    def process_rhs(self, compiler, connection):\n        from django.db.models.sql.query import Query\n        if isinstance(self.rhs, Query):\n            if self.rhs.has_limit_one():\n                # The subquery must select only the pk.\n                # Store original group_by to preserve grouping semantics\n                original_group_by = self.rhs.group_by[:]\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n                # Restore original group_by if it existed to preserve annotation semantics\n                if original_group_by:\n                    self.rhs.group_by = original_group_by\n            else:\n                raise ValueError(\n                    'The QuerySet value for an exact lookup must be limited to '\n                    'one result using slicing.'\n                )\n        return super().process_rhs(compiler, connection)\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/db/models/sql/query.py lines 1920-1920)": [
      "\n        group_by = list(self.select)\n        # Preserve existing group_by if it was explicitly set to maintain\n        # correct semantics for annotated queries used in subqueries\n        if hasattr(self, '_preserve_group_by') and self._preserve_group_by and self.group_by is not None:\n            return\n",
      "\n        group_by = list(self.select)\n        # Preserve original group_by if it was explicitly set to maintain semantics\n        if hasattr(self, '_preserve_group_by') and self._preserve_group_by:\n            return\n",
      "\n        group_by = list(self.select)\n        # Preserve existing group_by if it was explicitly set to maintain\n        # grouping semantics when SELECT clause was modified by lookups\n        if hasattr(self, '_preserved_group_by') and self._preserved_group_by:\n            group_by = self._preserved_group_by\n        elif self.select:\n            group_by = list(self.select)\n        else:\n            group_by = []\n",
      "\n    def set_group_by(self):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        # Check if we should preserve the existing group_by clause\n        # This happens when the query has been optimized for lookups\n        # but we need to maintain the original grouping semantics\n        if hasattr(self, '_preserve_group_by') and self._preserve_group_by and self.group_by is not None:\n            return\n        \n        group_by = list(self.select)\n",
      "\n        group_by = list(self.select)\n        # Preserve existing group_by if it was explicitly set to maintain\n        # grouping semantics when SELECT clause was modified by lookups\n        if hasattr(self, '_preserve_group_by') and self._preserve_group_by:\n            return\n",
      "\ngroup_by = list(self.select)\nif self.annotation_select:\n    for alias, annotation in self.annotation_select.items():\n        try:\n            inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n        except TypeError:\n            annotation_class = annotation.__class__\n            msg = (\n                '`alias=None` must be added to the signature of '\n                '%s.%s.get_group_by_cols().'\n            ) % (annotation_class.__module__, annotation_class.__qualname__)\n            warnings.warn(msg, RemovedInDjango40Warning, stacklevel=2)\n            group_by_cols = annotation.get_group_by_cols()\n        else:\n            group_by_cols = annotation.get_group_by_cols(alias=alias)\n        group_by.extend(group_by_cols)\n# Preserve existing GROUP BY if it was set externally (e.g., by lookup optimization)\nif hasattr(self, '_preserve_group_by') and self._preserve_group_by and self.group_by is not None:\n    group_by = self.group_by\nself.add_group_by(group_by, self.get_meta())\n",
      "\n        group_by = list(self.select)\n        # Preserve original group_by if it was explicitly set to maintain\n        # the correct grouping semantics, especially for annotated queries\n        if hasattr(self, '_preserve_group_by') and self._preserve_group_by and hasattr(self, '_original_group_by'):\n            group_by = list(self._original_group_by)\n",
      "\n        group_by = list(self.select)\n        # Preserve existing group_by if it was explicitly set to maintain\n        # the original grouping semantics, especially for annotated queries\n        if hasattr(self, '_preserve_group_by') and self._preserve_group_by and hasattr(self, '_original_group_by'):\n            group_by = self._original_group_by\n"
    ],
    "Location 3 (/root/hy/projects_4/django/django/db/models/lookups.py lines 235-241)": [
      "\n    def resolve_expression_parameter(self, compiler, connection, sql, param):\n        params = [param]\n        if hasattr(param, 'resolve_expression'):\n            param = param.resolve_expression(compiler.query)\n        if hasattr(param, 'as_sql'):\n            sql, params = param.as_sql(compiler, connection)\n        return sql, params\n",
      "\n    def resolve_expression_parameter(self, compiler, connection, sql, param):\n        params = [param]\n        if hasattr(param, 'resolve_expression'):\n            param = param.resolve_expression(compiler.query)\n        if hasattr(param, 'as_sql'):\n            # Check if this is a QuerySet that might need GROUP BY preservation\n            preserve_group_by = (hasattr(param, 'query') and \n                               hasattr(param.query, 'group_by') and \n                               param.query.group_by)\n            if preserve_group_by:\n                # Store original GROUP BY before as_sql processing\n                original_group_by = param.query.group_by[:]\n                sql, params = param.as_sql(compiler, connection)\n                # Restore original GROUP BY if it was cleared during optimization\n                if not param.query.group_by and original_group_by:\n                    param.query.group_by = original_group_by\n            else:\n                sql, params = param.as_sql(compiler, connection)\n        return sql, params\n",
      "\n    def resolve_expression_parameter(self, compiler, connection, sql, param):\n        params = [param]\n        if hasattr(param, 'resolve_expression'):\n            param = param.resolve_expression(compiler.query)\n        if hasattr(param, 'as_sql'):\n            # Store original group_by before potential modifications\n            original_group_by = None\n            if hasattr(param, 'query') and hasattr(param.query, 'group_by'):\n                original_group_by = param.query.group_by[:]\n            \n            sql, params = param.as_sql(compiler, connection)\n            \n            # Restore original group_by if it was modified during as_sql()\n            if (original_group_by is not None and \n                hasattr(param, 'query') and \n                hasattr(param.query, 'group_by') and\n                param.query.group_by != original_group_by):\n                param.query.group_by = original_group_by\n        return sql, params\n",
      "\ndef resolve_expression_parameter(self, compiler, connection, sql, param):\n    params = [param]\n    if hasattr(param, 'resolve_expression'):\n        param = param.resolve_expression(compiler.query)\n    if hasattr(param, 'as_sql'):\n        # Store original GROUP BY before potential modification\n        original_group_by = None\n        if hasattr(param, 'query') and hasattr(param.query, 'group_by'):\n            original_group_by = param.query.group_by[:]\n        \n        sql, params = param.as_sql(compiler, connection)\n        \n        # Restore original GROUP BY if it was modified during as_sql()\n        if (original_group_by is not None and \n            hasattr(param, 'query') and \n            hasattr(param.query, 'group_by') and\n            param.query.group_by != original_group_by):\n            param.query.group_by = original_group_by\n    return sql, params\n",
      "\n    def resolve_expression_parameter(self, compiler, connection, sql, param):\n        params = [param]\n        if hasattr(param, 'resolve_expression'):\n            param = param.resolve_expression(compiler.query)\n        if hasattr(param, 'as_sql'):\n            sql, params = param.as_sql(compiler, connection)\n        return sql, params\n",
      "\n    def resolve_expression_parameter(self, compiler, connection, sql, param):\n        params = [param]\n        if hasattr(param, 'resolve_expression'):\n            param = param.resolve_expression(compiler.query)\n        if hasattr(param, 'as_sql'):\n            # Store original group_by before potential modification\n            original_group_by = getattr(param.query, 'group_by', None) if hasattr(param, 'query') else None\n            sql, params = param.as_sql(compiler, connection)\n            # Restore original group_by if it was modified during as_sql()\n            if original_group_by is not None and hasattr(param, 'query') and hasattr(param.query, 'group_by'):\n                if param.query.group_by != original_group_by:\n                    param.query.group_by = original_group_by\n        return sql, params\n",
      "\n    def resolve_expression_parameter(self, compiler, connection, sql, param):\n        params = [param]\n        if hasattr(param, 'resolve_expression'):\n            param = param.resolve_expression(compiler.query)\n        if hasattr(param, 'as_sql'):\n            # Store original group_by before potential modifications\n            original_group_by = getattr(param.query, 'group_by', None) if hasattr(param, 'query') else None\n            sql, params = param.as_sql(compiler, connection)\n            # Restore original group_by if it was modified during as_sql()\n            if original_group_by is not None and hasattr(param, 'query') and hasattr(param.query, 'group_by'):\n                param.query.group_by = original_group_by\n        return sql, params\n",
      "\n    def resolve_expression_parameter(self, compiler, connection, sql, param):\n        params = [param]\n        # Store original group_by if param is a Query to preserve it during optimization\n        preserve_group_by = None\n        if hasattr(param, 'resolve_expression'):\n            if hasattr(param, 'query') and hasattr(param.query, 'group_by'):\n                preserve_group_by = param.query.group_by[:]\n            param = param.resolve_expression(compiler.query)\n        if hasattr(param, 'as_sql'):\n            # Pass group_by preservation context to the compiler\n            if preserve_group_by is not None and hasattr(param, 'query'):\n                param.query._preserve_group_by = preserve_group_by\n            sql, params = param.as_sql(compiler, connection)\n        return sql, params\n"
    ],
    "Location 4 (/root/hy/projects_4/django/django/db/models/sql/query.py lines 1838-1860)": [
      "\n    def add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n        \"\"\"\n        Add the given (model) fields to the select set. Add the field names in\n        the order specified.\n        \"\"\"\n        alias = self.get_initial_alias()\n        opts = self.get_meta()\n\n        # Store original group_by if preservation is requested\n        original_group_by = None\n        if preserve_group_by and self.group_by is not None:\n            original_group_by = self.group_by[:]\n\n        try:\n            cols = []\n            for name in field_names:\n                # Join promotion note - we must not remove any rows here, so\n                # if there is no existing joins, use outer join.\n                join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)\n                targets, final_alias, joins = self.trim_joins(\n                    join_info.targets,\n                    join_info.joins,\n                    join_info.path,\n                )\n                for target in targets:\n                    cols.append(join_info.transform_function(target, final_alias))\n            if cols:\n                self.set_select(cols)\n                # Restore original group_by if preservation was requested\n                if preserve_group_by and original_group_by is not None:\n                    self.group_by = original_group_by\n",
      "\n    def add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n        \"\"\"\n        Add the given (model) fields to the select set. Add the field names in\n        the order specified.\n        \"\"\"\n        alias = self.get_initial_alias()\n        opts = self.get_meta()\n\n        # Store original group_by if preservation is requested\n        original_group_by = None\n        if preserve_group_by and self.group_by is not None:\n            original_group_by = self.group_by[:]\n\n        try:\n            cols = []\n            for name in field_names:\n                # Join promotion note - we must not remove any rows here, so\n                # if there is no existing joins, use outer join.\n                join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)\n                targets, final_alias, joins = self.trim_joins(\n                    join_info.targets,\n                    join_info.joins,\n                    join_info.path,\n                )\n                for target in targets:\n                    cols.append(join_info.transform_function(target, final_alias))\n            if cols:\n                self.set_select(cols)\n                # Restore original group_by if preservation was requested\n                if preserve_group_by and original_group_by is not None:\n                    self.group_by = original_group_by\n",
      "\ndef add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n    \"\"\"\n    Add the given (model) fields to the select set. Add the field names in\n    the order specified.\n    \"\"\"\n    alias = self.get_initial_alias()\n    opts = self.get_meta()\n\n    # Store original group_by if preservation is requested\n    original_group_by = None\n    if preserve_group_by and self.group_by is not None:\n        original_group_by = self.group_by[:]\n\n    try:\n        cols = []\n        for name in field_names:\n            # Join promotion note - we must not remove any rows here, so\n            # if there is no existing joins, use outer join.\n            join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)\n            targets, final_alias, joins = self.trim_joins(\n                join_info.targets,\n                join_info.joins,\n                join_info.path,\n            )\n            for target in targets:\n                cols.append(join_info.transform_function(target, final_alias))\n        if cols:\n            self.set_select(cols)\n            # Restore original group_by if preservation was requested\n            if preserve_group_by and original_group_by is not None:\n                self.group_by = original_group_by\n",
      "\n    def add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n        \"\"\"\n        Add the given (model) fields to the select set. Add the field names in\n        the order specified.\n        \"\"\"\n        alias = self.get_initial_alias()\n        opts = self.get_meta()\n\n        try:\n            cols = []\n            for name in field_names:\n                # Join promotion note - we must not remove any rows here, so\n                # if there is no existing joins, use outer join.\n                join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)\n                targets, final_alias, joins = self.trim_joins(\n                    join_info.targets,\n                    join_info.joins,\n                    join_info.path,\n                )\n                for target in targets:\n                    cols.append(join_info.transform_function(target, final_alias))\n            if cols:\n                self.set_select(cols, preserve_group_by=preserve_group_by)\n",
      "\n    def add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n        \"\"\"\n        Add the given (model) fields to the select set. Add the field names in\n        the order specified.\n        \"\"\"\n        alias = self.get_initial_alias()\n        opts = self.get_meta()\n\n        # Store original group_by if preservation is requested\n        original_group_by = None\n        if preserve_group_by and self.group_by is not None:\n            original_group_by = list(self.group_by)\n\n        try:\n            cols = []\n            for name in field_names:\n                # Join promotion note - we must not remove any rows here, so\n                # if there is no existing joins, use outer join.\n                join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)\n                targets, final_alias, joins = self.trim_joins(\n                    join_info.targets,\n                    join_info.joins,\n                    join_info.path,\n                )\n                for target in targets:\n                    cols.append(join_info.transform_function(target, final_alias))\n            if cols:\n                self.set_select(cols)\n                # Restore original group_by if preservation was requested\n                if preserve_group_by and original_group_by is not None:\n                    self.group_by = original_group_by\n",
      "\n    def add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n        \"\"\"\n        Add the given (model) fields to the select set. Add the field names in\n        the order specified.\n        \"\"\"\n        alias = self.get_initial_alias()\n        opts = self.get_meta()\n\n        # Store original group_by if preservation is requested\n        original_group_by = None\n        if preserve_group_by and self.group_by is not False:\n            original_group_by = self.group_by\n\n        try:\n            cols = []\n            for name in field_names:\n                # Join promotion note - we must not remove any rows here, so\n                # if there is no existing joins, use outer join.\n                join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)\n                targets, final_alias, joins = self.trim_joins(\n                    join_info.targets,\n                    join_info.joins,\n                    join_info.path,\n                )\n                for target in targets:\n                    cols.append(join_info.transform_function(target, final_alias))\n            if cols:\n                self.set_select(cols)\n                # Restore original group_by if preservation was requested\n                if preserve_group_by and original_group_by is not None:\n                    self.group_by = original_group_by\n",
      "\n    def add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n        \"\"\"\n        Add the given (model) fields to the select set. Add the field names in\n        the order specified.\n        \"\"\"\n        alias = self.get_initial_alias()\n        opts = self.get_meta()\n\n        try:\n            # Store original group_by if preservation is requested\n            original_group_by = None\n            if preserve_group_by and self.group_by is not None:\n                original_group_by = self.group_by[:]\n            \n            cols = []\n            for name in field_names:\n                # Join promotion note - we must not remove any rows here, so\n                # if there is no existing joins, use outer join.\n                join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)\n                targets, final_alias, joins = self.trim_joins(\n                    join_info.targets,\n                    join_info.joins,\n                    join_info.path,\n                )\n                for target in targets:\n                    cols.append(join_info.transform_function(target, final_alias))\n            if cols:\n                self.set_select(cols)\n                # Restore original group_by if preservation was requested\n                if preserve_group_by and original_group_by is not None:\n                    self.group_by = original_group_by\n",
      "\n    def add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n        \"\"\"\n        Add the given (model) fields to the select set. Add the field names in\n        the order specified.\n        \"\"\"\n        alias = self.get_initial_alias()\n        opts = self.get_meta()\n        \n        # Store original group_by if preservation is requested\n        original_group_by = None\n        if preserve_group_by and self.group_by is not None:\n            original_group_by = list(self.group_by)\n\n        try:\n            cols = []\n            for name in field_names:\n                # Join promotion note - we must not remove any rows here, so\n                # if there is no existing joins, use outer join.\n                join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)\n                targets, final_alias, joins = self.trim_joins(\n                    join_info.targets,\n                    join_info.joins,\n                    join_info.path,\n                )\n                for target in targets:\n                    cols.append(join_info.transform_function(target, final_alias))\n            if cols:\n                self.set_select(cols)\n                # Restore original group_by if preservation was requested\n                if preserve_group_by and original_group_by is not None:\n                    self.group_by = tuple(original_group_by)\n"
    ],
    "Location 5 (/root/hy/projects_4/django/django/db/models/sql/query.py lines 1911-1936)": [
      "\n    def set_group_by(self, preserve_existing=False):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        if preserve_existing and self.group_by:\n            # Preserve existing GROUP BY when requested (e.g., from lookup optimizations)\n            return\n            \n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
      "\n    def set_group_by(self, preserve_existing=False):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        # If preserve_existing is True and we already have a group_by, keep it\n        if preserve_existing and hasattr(self, 'group_by') and self.group_by:\n            return\n            \n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
      "\n    def set_group_by(self, preserve_existing=False):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \n        If preserve_existing is True, preserve the current group_by when\n        it exists and contains meaningful grouping information.\n        \"\"\"\n        # If we should preserve existing GROUP BY and it contains meaningful grouping\n        if preserve_existing and hasattr(self, 'group_by') and self.group_by:\n            # Check if the existing group_by contains non-pk fields or annotations\n            has_meaningful_grouping = False\n            for group_expr in self.group_by:\n                if hasattr(group_expr, 'target') and hasattr(group_expr.target, 'primary_key'):\n                    if not group_expr.target.primary_key:\n                        has_meaningful_grouping = True\n                        break\n                elif not (hasattr(group_expr, 'target') and getattr(group_expr.target, 'primary_key', False)):\n                    has_meaningful_grouping = True\n                    break\n            \n            if has_meaningful_grouping:\n                return\n        \n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
      "\n    def set_group_by(self):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        # Check if we should preserve existing group_by (e.g., from lookup optimization)\n        if hasattr(self, '_preserve_group_by') and self._preserve_group_by and self.group_by:\n            return\n            \n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
      "\ndef set_group_by(self, allow_aliases=True):\n    \"\"\"\n    Expand the GROUP BY clause required by the query.\n\n    This will usually be the set of all non-aggregate fields in the\n    return data. If the database backend supports grouping by the\n    primary key, and the query would be equivalent, the optimization\n    will be made automatically.\n    \"\"\"\n    # Check if GROUP BY should be preserved (e.g., from lookup optimizations)\n    if hasattr(self, '_preserve_group_by') and self._preserve_group_by:\n        return\n        \n    group_by = list(self.select)\n    if self.annotation_select:\n        for alias, annotation in self.annotation_select.items():\n            try:\n                inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n            except TypeError:\n                annotation_class = annotation.__class__\n                msg = (\n                    '`alias=None` must be added to the signature of '\n                    '%s.%s.get_group_by_cols().'\n                ) % (annotation_class.__module__, annotation_class.__qualname__)\n                warnings.warn(msg, category=RemovedInDjango40Warning)\n                group_by_cols = annotation.get_group_by_cols()\n            else:\n                group_by_cols = annotation.get_group_by_cols(alias=alias)\n            group_by.extend(group_by_cols)\n    self.group_by = tuple(group_by)\n",
      "\n    def set_group_by(self):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        # Check if we have a preserved group_by that should not be recalculated\n        if hasattr(self, '_preserve_group_by') and self._preserve_group_by:\n            return\n            \n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
      "\n    def set_group_by(self):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        # Check if GROUP BY should be preserved (e.g., from lookup optimizations)\n        if hasattr(self, '_preserve_group_by') and self._preserve_group_by and hasattr(self, '_original_group_by'):\n            self.group_by = self._original_group_by\n            return\n            \n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
      "\n    def set_group_by(self):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        # Check if GROUP BY should be preserved (set by lookup optimizations)\n        if getattr(self, '_preserve_group_by', False):\n            return\n            \n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                try:\n                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n                except TypeError:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 105dc93251..d51b4e7099 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -232,6 +232,7 @@ class FieldGetDbPrepValueIterableMixin(FieldGetDbPrepValueMixin):\n         else:\n             return super().process_rhs(compiler, connection)\n \n+\n     def resolve_expression_parameter(self, compiler, connection, sql, param):\n         params = [param]\n         if hasattr(param, 'resolve_expression'):\n@@ -263,8 +264,13 @@ class Exact(FieldGetDbPrepValueMixin, BuiltinLookup):\n         if isinstance(self.rhs, Query):\n             if self.rhs.has_limit_one():\n                 # The subquery must select only the pk.\n+\n+                # Store the original group_by before modifying the SELECT clause\n+                original_group_by = self.rhs.group_by\n                 self.rhs.clear_select_clause()\n                 self.rhs.add_fields(['pk'])\n+                # Restore the original group_by to preserve grouping semantics\n+                self.rhs.group_by = original_group_by\n             else:\n                 raise ValueError(\n                     'The QuerySet value for an exact lookup must be limited to '\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..14bb6691a4 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1835,6 +1835,7 @@ class Query(BaseExpression):\n         self.distinct_fields = field_names\n         self.distinct = True\n \n+\n     def add_fields(self, field_names, allow_m2m=True):\n         \"\"\"\n         Add the given (model) fields to the select set. Add the field names in\n@@ -1908,6 +1909,7 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n+\n     def set_group_by(self):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n@@ -1934,6 +1936,7 @@ class Query(BaseExpression):\n                     group_by_cols = annotation.get_group_by_cols(alias=alias)\n                 group_by.extend(group_by_cols)\n         self.group_by = tuple(group_by)\n+        self.group_by = tuple(group_by)\n \n     def add_select_related(self, fields):\n         \"\"\"\n",
    "variant_0": "diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 105dc93251..56f30a6f5e 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -232,12 +232,25 @@ class FieldGetDbPrepValueIterableMixin(FieldGetDbPrepValueMixin):\n         else:\n             return super().process_rhs(compiler, connection)\n \n+\n     def resolve_expression_parameter(self, compiler, connection, sql, param):\n         params = [param]\n         if hasattr(param, 'resolve_expression'):\n             param = param.resolve_expression(compiler.query)\n         if hasattr(param, 'as_sql'):\n+            # Store original group_by before potential modification\n+            original_group_by = None\n+            if hasattr(param, 'query') and hasattr(param.query, 'group_by'):\n+                original_group_by = param.query.group_by[:]\n+            \n             sql, params = param.as_sql(compiler, connection)\n+            \n+            # Restore original group_by if it was modified during as_sql()\n+            if (original_group_by is not None and \n+                hasattr(param, 'query') and \n+                hasattr(param.query, 'group_by') and\n+                param.query.group_by != original_group_by):\n+                param.query.group_by = original_group_by\n         return sql, params\n \n     def batch_process_rhs(self, compiler, connection, rhs=None):\n@@ -263,8 +276,25 @@ class Exact(FieldGetDbPrepValueMixin, BuiltinLookup):\n         if isinstance(self.rhs, Query):\n             if self.rhs.has_limit_one():\n                 # The subquery must select only the pk.\n+\n+    def process_rhs(self, compiler, connection):\n+        from django.db.models.sql.query import Query\n+        if isinstance(self.rhs, Query):\n+            if self.rhs.has_limit_one():\n+                # The subquery must select only the pk.\n+                # Store the original group_by to preserve grouping semantics\n+                original_group_by = self.rhs.group_by[:]\n                 self.rhs.clear_select_clause()\n                 self.rhs.add_fields(['pk'])\n+                # Restore original group_by to preserve annotation grouping\n+                if original_group_by:\n+                    self.rhs.group_by = original_group_by\n+            else:\n+                raise ValueError(\n+                    'The QuerySet value for an exact lookup must be limited to '\n+                    'one result using slicing.'\n+                )\n+        return super().process_rhs(compiler, connection)\n             else:\n                 raise ValueError(\n                     'The QuerySet value for an exact lookup must be limited to '\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..138c6e2dfb 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1835,7 +1835,8 @@ class Query(BaseExpression):\n         self.distinct_fields = field_names\n         self.distinct = True\n \n-    def add_fields(self, field_names, allow_m2m=True):\n+\n+    def add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n         \"\"\"\n         Add the given (model) fields to the select set. Add the field names in\n         the order specified.\n@@ -1843,6 +1844,11 @@ class Query(BaseExpression):\n         alias = self.get_initial_alias()\n         opts = self.get_meta()\n \n+        # Store original group_by if preservation is requested\n+        original_group_by = None\n+        if preserve_group_by and self.group_by is not None:\n+            original_group_by = self.group_by[:]\n+\n         try:\n             cols = []\n             for name in field_names:\n@@ -1858,6 +1864,9 @@ class Query(BaseExpression):\n                     cols.append(join_info.transform_function(target, final_alias))\n             if cols:\n                 self.set_select(cols)\n+                # Restore original group_by if preservation was requested\n+                if preserve_group_by and original_group_by is not None:\n+                    self.group_by = original_group_by\n         except MultiJoin:\n             raise FieldError(\"Invalid field name: '%s'\" % name)\n         except FieldError:\n@@ -1908,7 +1917,8 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n-    def set_group_by(self):\n+\n+    def set_group_by(self, preserve_existing=False):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n \n@@ -1916,7 +1926,12 @@ class Query(BaseExpression):\n         return data. If the database backend supports grouping by the\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n+        \n+        If preserve_existing is True, keep the current group_by if it exists.\n         \"\"\"\n+        if preserve_existing and hasattr(self, 'group_by') and self.group_by:\n+            return\n+            \n         group_by = list(self.select)\n         if self.annotation_select:\n             for alias, annotation in self.annotation_select.items():\n@@ -1934,6 +1949,31 @@ class Query(BaseExpression):\n                     group_by_cols = annotation.get_group_by_cols(alias=alias)\n                 group_by.extend(group_by_cols)\n         self.group_by = tuple(group_by)\n+            for alias, annotation in self.annotation_select.items():\n+                try:\n+                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n+                except TypeError:\n+                    annotation_class = annotation.__class__\n+                    msg = (\n+                        '`alias=None` must be added to the signature of '\n+                        '%s.%s.get_group_by_cols().'\n+                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n+        if self.annotation_select:\n+            for alias, annotation in self.annotation_select.items():\n+                try:\n+                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n+                except TypeError:\n+                    annotation_class = annotation.__class__\n+                    msg = (\n+                        '`alias=None` must be added to the signature of '\n+                        '%s.%s.get_group_by_cols().'\n+                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n+                    warnings.warn(msg, category=RemovedInDjango40Warning)\n+                    group_by_cols = annotation.get_group_by_cols()\n+                else:\n+                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n+                group_by.extend(group_by_cols)\n+        self.group_by = tuple(group_by)\n \n     def add_select_related(self, fields):\n         \"\"\"\n",
    "variant_1": "diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 105dc93251..61bfc1f676 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -232,6 +232,7 @@ class FieldGetDbPrepValueIterableMixin(FieldGetDbPrepValueMixin):\n         else:\n             return super().process_rhs(compiler, connection)\n \n+\n     def resolve_expression_parameter(self, compiler, connection, sql, param):\n         params = [param]\n         if hasattr(param, 'resolve_expression'):\n@@ -263,8 +264,25 @@ class Exact(FieldGetDbPrepValueMixin, BuiltinLookup):\n         if isinstance(self.rhs, Query):\n             if self.rhs.has_limit_one():\n                 # The subquery must select only the pk.\n+\n+    def process_rhs(self, compiler, connection):\n+        from django.db.models.sql.query import Query\n+        if isinstance(self.rhs, Query):\n+            if self.rhs.has_limit_one():\n+                # The subquery must select only the pk.\n+                # Preserve the original group_by to maintain grouping semantics\n+                original_group_by = self.rhs.group_by[:]\n                 self.rhs.clear_select_clause()\n                 self.rhs.add_fields(['pk'])\n+                # Restore original group_by if it existed to preserve annotation grouping\n+                if original_group_by:\n+                    self.rhs.group_by = original_group_by\n+            else:\n+                raise ValueError(\n+                    'The QuerySet value for an exact lookup must be limited to '\n+                    'one result using slicing.'\n+                )\n+        return super().process_rhs(compiler, connection)\n             else:\n                 raise ValueError(\n                     'The QuerySet value for an exact lookup must be limited to '\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..2415d45153 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1835,7 +1835,8 @@ class Query(BaseExpression):\n         self.distinct_fields = field_names\n         self.distinct = True\n \n-    def add_fields(self, field_names, allow_m2m=True):\n+\n+    def add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n         \"\"\"\n         Add the given (model) fields to the select set. Add the field names in\n         the order specified.\n@@ -1843,6 +1844,11 @@ class Query(BaseExpression):\n         alias = self.get_initial_alias()\n         opts = self.get_meta()\n \n+        # Store original group_by if preservation is requested\n+        original_group_by = None\n+        if preserve_group_by and self.group_by is not None:\n+            original_group_by = self.group_by[:]\n+\n         try:\n             cols = []\n             for name in field_names:\n@@ -1858,6 +1864,9 @@ class Query(BaseExpression):\n                     cols.append(join_info.transform_function(target, final_alias))\n             if cols:\n                 self.set_select(cols)\n+                # Restore original group_by if preservation was requested\n+                if preserve_group_by and original_group_by is not None:\n+                    self.group_by = original_group_by\n         except MultiJoin:\n             raise FieldError(\"Invalid field name: '%s'\" % name)\n         except FieldError:\n@@ -1908,7 +1917,8 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n-    def set_group_by(self):\n+\n+    def set_group_by(self, preserve_existing=False):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n \n@@ -1917,6 +1927,10 @@ class Query(BaseExpression):\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n         \"\"\"\n+        if preserve_existing and self.group_by:\n+            # Preserve existing GROUP BY when requested (e.g., from lookup optimizations)\n+            return\n+            \n         group_by = list(self.select)\n         if self.annotation_select:\n             for alias, annotation in self.annotation_select.items():\n@@ -1933,6 +1947,11 @@ class Query(BaseExpression):\n                 else:\n                     group_by_cols = annotation.get_group_by_cols(alias=alias)\n                 group_by.extend(group_by_cols)\n+        self.group_by = tuple(group_by)\n+                    group_by_cols = annotation.get_group_by_cols()\n+                else:\n+                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n+                group_by.extend(group_by_cols)\n         self.group_by = tuple(group_by)\n \n     def add_select_related(self, fields):\n",
    "variant_2": "diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 105dc93251..ffe03b4617 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -232,12 +232,25 @@ class FieldGetDbPrepValueIterableMixin(FieldGetDbPrepValueMixin):\n         else:\n             return super().process_rhs(compiler, connection)\n \n+\n     def resolve_expression_parameter(self, compiler, connection, sql, param):\n         params = [param]\n         if hasattr(param, 'resolve_expression'):\n             param = param.resolve_expression(compiler.query)\n         if hasattr(param, 'as_sql'):\n-            sql, params = param.as_sql(compiler, connection)\n+            # Check if this is a QuerySet that might need GROUP BY preservation\n+            preserve_group_by = (hasattr(param, 'query') and \n+                               hasattr(param.query, 'group_by') and \n+                               param.query.group_by)\n+            if preserve_group_by:\n+                # Store original GROUP BY before as_sql processing\n+                original_group_by = param.query.group_by[:]\n+                sql, params = param.as_sql(compiler, connection)\n+                # Restore original GROUP BY if it was cleared during optimization\n+                if not param.query.group_by and original_group_by:\n+                    param.query.group_by = original_group_by\n+            else:\n+                sql, params = param.as_sql(compiler, connection)\n         return sql, params\n \n     def batch_process_rhs(self, compiler, connection, rhs=None):\n@@ -263,8 +276,25 @@ class Exact(FieldGetDbPrepValueMixin, BuiltinLookup):\n         if isinstance(self.rhs, Query):\n             if self.rhs.has_limit_one():\n                 # The subquery must select only the pk.\n+\n+    def process_rhs(self, compiler, connection):\n+        from django.db.models.sql.query import Query\n+        if isinstance(self.rhs, Query):\n+            if self.rhs.has_limit_one():\n+                # The subquery must select only the pk.\n+                # Preserve the original group_by to maintain grouping semantics\n+                original_group_by = self.rhs.group_by\n                 self.rhs.clear_select_clause()\n                 self.rhs.add_fields(['pk'])\n+                # Restore the original group_by if it existed\n+                if original_group_by:\n+                    self.rhs.group_by = original_group_by\n+            else:\n+                raise ValueError(\n+                    'The QuerySet value for an exact lookup must be limited to '\n+                    'one result using slicing.'\n+                )\n+        return super().process_rhs(compiler, connection)\n             else:\n                 raise ValueError(\n                     'The QuerySet value for an exact lookup must be limited to '\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..e115a7aa39 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1835,7 +1835,8 @@ class Query(BaseExpression):\n         self.distinct_fields = field_names\n         self.distinct = True\n \n-    def add_fields(self, field_names, allow_m2m=True):\n+\n+    def add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n         \"\"\"\n         Add the given (model) fields to the select set. Add the field names in\n         the order specified.\n@@ -1843,6 +1844,11 @@ class Query(BaseExpression):\n         alias = self.get_initial_alias()\n         opts = self.get_meta()\n \n+        # Store original group_by if preservation is requested\n+        original_group_by = None\n+        if preserve_group_by and self.group_by is not None:\n+            original_group_by = self.group_by[:]\n+\n         try:\n             cols = []\n             for name in field_names:\n@@ -1858,6 +1864,9 @@ class Query(BaseExpression):\n                     cols.append(join_info.transform_function(target, final_alias))\n             if cols:\n                 self.set_select(cols)\n+                # Restore original group_by if preservation was requested\n+                if preserve_group_by and original_group_by is not None:\n+                    self.group_by = original_group_by\n         except MultiJoin:\n             raise FieldError(\"Invalid field name: '%s'\" % name)\n         except FieldError:\n@@ -1908,7 +1917,8 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n-    def set_group_by(self):\n+\n+    def set_group_by(self, preserve_existing=False):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n \n@@ -1917,6 +1927,10 @@ class Query(BaseExpression):\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n         \"\"\"\n+        # If preserve_existing is True and we already have a group_by, keep it\n+        if preserve_existing and hasattr(self, 'group_by') and self.group_by:\n+            return\n+            \n         group_by = list(self.select)\n         if self.annotation_select:\n             for alias, annotation in self.annotation_select.items():\n@@ -1933,6 +1947,10 @@ class Query(BaseExpression):\n                 else:\n                     group_by_cols = annotation.get_group_by_cols(alias=alias)\n                 group_by.extend(group_by_cols)\n+        self.group_by = tuple(group_by)\n+                else:\n+                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n+                group_by.extend(group_by_cols)\n         self.group_by = tuple(group_by)\n \n     def add_select_related(self, fields):\n",
    "variant_3": "diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 105dc93251..bfe7d61e08 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -232,12 +232,25 @@ class FieldGetDbPrepValueIterableMixin(FieldGetDbPrepValueMixin):\n         else:\n             return super().process_rhs(compiler, connection)\n \n+\n     def resolve_expression_parameter(self, compiler, connection, sql, param):\n         params = [param]\n         if hasattr(param, 'resolve_expression'):\n             param = param.resolve_expression(compiler.query)\n         if hasattr(param, 'as_sql'):\n+            # Store original group_by before potential modifications\n+            original_group_by = None\n+            if hasattr(param, 'query') and hasattr(param.query, 'group_by'):\n+                original_group_by = param.query.group_by[:]\n+            \n             sql, params = param.as_sql(compiler, connection)\n+            \n+            # Restore original group_by if it was modified during as_sql()\n+            if (original_group_by is not None and \n+                hasattr(param, 'query') and \n+                hasattr(param.query, 'group_by') and\n+                param.query.group_by != original_group_by):\n+                param.query.group_by = original_group_by\n         return sql, params\n \n     def batch_process_rhs(self, compiler, connection, rhs=None):\n@@ -263,8 +276,25 @@ class Exact(FieldGetDbPrepValueMixin, BuiltinLookup):\n         if isinstance(self.rhs, Query):\n             if self.rhs.has_limit_one():\n                 # The subquery must select only the pk.\n+\n+    def process_rhs(self, compiler, connection):\n+        from django.db.models.sql.query import Query\n+        if isinstance(self.rhs, Query):\n+            if self.rhs.has_limit_one():\n+                # The subquery must select only the pk.\n+                # Store original group_by to preserve grouping semantics\n+                original_group_by = self.rhs.group_by[:]\n                 self.rhs.clear_select_clause()\n                 self.rhs.add_fields(['pk'])\n+                # Restore original group_by if it existed to preserve annotation semantics\n+                if original_group_by:\n+                    self.rhs.group_by = original_group_by\n+            else:\n+                raise ValueError(\n+                    'The QuerySet value for an exact lookup must be limited to '\n+                    'one result using slicing.'\n+                )\n+        return super().process_rhs(compiler, connection)\n             else:\n                 raise ValueError(\n                     'The QuerySet value for an exact lookup must be limited to '\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..bd683c2a80 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1835,29 +1835,38 @@ class Query(BaseExpression):\n         self.distinct_fields = field_names\n         self.distinct = True\n \n-    def add_fields(self, field_names, allow_m2m=True):\n-        \"\"\"\n-        Add the given (model) fields to the select set. Add the field names in\n-        the order specified.\n-        \"\"\"\n-        alias = self.get_initial_alias()\n-        opts = self.get_meta()\n \n-        try:\n-            cols = []\n-            for name in field_names:\n-                # Join promotion note - we must not remove any rows here, so\n-                # if there is no existing joins, use outer join.\n-                join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)\n-                targets, final_alias, joins = self.trim_joins(\n-                    join_info.targets,\n-                    join_info.joins,\n-                    join_info.path,\n-                )\n-                for target in targets:\n-                    cols.append(join_info.transform_function(target, final_alias))\n-            if cols:\n-                self.set_select(cols)\n+def add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n+    \"\"\"\n+    Add the given (model) fields to the select set. Add the field names in\n+    the order specified.\n+    \"\"\"\n+    alias = self.get_initial_alias()\n+    opts = self.get_meta()\n+\n+    # Store original group_by if preservation is requested\n+    original_group_by = None\n+    if preserve_group_by and self.group_by is not None:\n+        original_group_by = self.group_by[:]\n+\n+    try:\n+        cols = []\n+        for name in field_names:\n+            # Join promotion note - we must not remove any rows here, so\n+            # if there is no existing joins, use outer join.\n+            join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)\n+            targets, final_alias, joins = self.trim_joins(\n+                join_info.targets,\n+                join_info.joins,\n+                join_info.path,\n+            )\n+            for target in targets:\n+                cols.append(join_info.transform_function(target, final_alias))\n+        if cols:\n+            self.set_select(cols)\n+            # Restore original group_by if preservation was requested\n+            if preserve_group_by and original_group_by is not None:\n+                self.group_by = original_group_by\n         except MultiJoin:\n             raise FieldError(\"Invalid field name: '%s'\" % name)\n         except FieldError:\n@@ -1908,7 +1917,8 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n-    def set_group_by(self):\n+\n+    def set_group_by(self, preserve_existing=False):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n \n@@ -1916,7 +1926,26 @@ class Query(BaseExpression):\n         return data. If the database backend supports grouping by the\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n-        \"\"\"\n+        \n+        If preserve_existing is True, preserve the current group_by when\n+        it exists and contains meaningful grouping information.\n+        \"\"\"\n+        # If we should preserve existing GROUP BY and it contains meaningful grouping\n+        if preserve_existing and hasattr(self, 'group_by') and self.group_by:\n+            # Check if the existing group_by contains non-pk fields or annotations\n+            has_meaningful_grouping = False\n+            for group_expr in self.group_by:\n+                if hasattr(group_expr, 'target') and hasattr(group_expr.target, 'primary_key'):\n+                    if not group_expr.target.primary_key:\n+                        has_meaningful_grouping = True\n+                        break\n+                elif not (hasattr(group_expr, 'target') and getattr(group_expr.target, 'primary_key', False)):\n+                    has_meaningful_grouping = True\n+                    break\n+            \n+            if has_meaningful_grouping:\n+                return\n+        \n         group_by = list(self.select)\n         if self.annotation_select:\n             for alias, annotation in self.annotation_select.items():\n@@ -1933,6 +1962,15 @@ class Query(BaseExpression):\n                 else:\n                     group_by_cols = annotation.get_group_by_cols(alias=alias)\n                 group_by.extend(group_by_cols)\n+        self.group_by = tuple(group_by)\n+                        '`alias=None` must be added to the signature of '\n+                        '%s.%s.get_group_by_cols().'\n+                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n+                    warnings.warn(msg, category=RemovedInDjango40Warning)\n+                    group_by_cols = annotation.get_group_by_cols()\n+                else:\n+                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n+                group_by.extend(group_by_cols)\n         self.group_by = tuple(group_by)\n \n     def add_select_related(self, fields):\n",
    "variant_4": "diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 105dc93251..d8e309b263 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -232,13 +232,26 @@ class FieldGetDbPrepValueIterableMixin(FieldGetDbPrepValueMixin):\n         else:\n             return super().process_rhs(compiler, connection)\n \n-    def resolve_expression_parameter(self, compiler, connection, sql, param):\n-        params = [param]\n-        if hasattr(param, 'resolve_expression'):\n-            param = param.resolve_expression(compiler.query)\n-        if hasattr(param, 'as_sql'):\n-            sql, params = param.as_sql(compiler, connection)\n-        return sql, params\n+\n+def resolve_expression_parameter(self, compiler, connection, sql, param):\n+    params = [param]\n+    if hasattr(param, 'resolve_expression'):\n+        param = param.resolve_expression(compiler.query)\n+    if hasattr(param, 'as_sql'):\n+        # Store original GROUP BY before potential modification\n+        original_group_by = None\n+        if hasattr(param, 'query') and hasattr(param.query, 'group_by'):\n+            original_group_by = param.query.group_by[:]\n+        \n+        sql, params = param.as_sql(compiler, connection)\n+        \n+        # Restore original GROUP BY if it was modified during as_sql()\n+        if (original_group_by is not None and \n+            hasattr(param, 'query') and \n+            hasattr(param.query, 'group_by') and\n+            param.query.group_by != original_group_by):\n+            param.query.group_by = original_group_by\n+    return sql, params\n \n     def batch_process_rhs(self, compiler, connection, rhs=None):\n         pre_processed = super().batch_process_rhs(compiler, connection, rhs)\n@@ -263,8 +276,25 @@ class Exact(FieldGetDbPrepValueMixin, BuiltinLookup):\n         if isinstance(self.rhs, Query):\n             if self.rhs.has_limit_one():\n                 # The subquery must select only the pk.\n+\n+    def process_rhs(self, compiler, connection):\n+        from django.db.models.sql.query import Query\n+        if isinstance(self.rhs, Query):\n+            if self.rhs.has_limit_one():\n+                # The subquery must select only the pk.\n+                # Preserve original GROUP BY clause before modifying SELECT\n+                original_group_by = self.rhs.group_by[:]\n                 self.rhs.clear_select_clause()\n                 self.rhs.add_fields(['pk'])\n+                # Restore original GROUP BY to preserve annotation semantics\n+                if original_group_by:\n+                    self.rhs.group_by = original_group_by\n+            else:\n+                raise ValueError(\n+                    'The QuerySet value for an exact lookup must be limited to '\n+                    'one result using slicing.'\n+                )\n+        return super().process_rhs(compiler, connection)\n             else:\n                 raise ValueError(\n                     'The QuerySet value for an exact lookup must be limited to '\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..d4eb388e00 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1835,7 +1835,8 @@ class Query(BaseExpression):\n         self.distinct_fields = field_names\n         self.distinct = True\n \n-    def add_fields(self, field_names, allow_m2m=True):\n+\n+    def add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n         \"\"\"\n         Add the given (model) fields to the select set. Add the field names in\n         the order specified.\n@@ -1857,7 +1858,7 @@ class Query(BaseExpression):\n                 for target in targets:\n                     cols.append(join_info.transform_function(target, final_alias))\n             if cols:\n-                self.set_select(cols)\n+                self.set_select(cols, preserve_group_by=preserve_group_by)\n         except MultiJoin:\n             raise FieldError(\"Invalid field name: '%s'\" % name)\n         except FieldError:\n@@ -1908,6 +1909,7 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n+\n     def set_group_by(self):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n@@ -1917,6 +1919,10 @@ class Query(BaseExpression):\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n         \"\"\"\n+        # Check if we should preserve existing group_by (e.g., from lookup optimization)\n+        if hasattr(self, '_preserve_group_by') and self._preserve_group_by and self.group_by:\n+            return\n+            \n         group_by = list(self.select)\n         if self.annotation_select:\n             for alias, annotation in self.annotation_select.items():\n@@ -1934,6 +1940,22 @@ class Query(BaseExpression):\n                     group_by_cols = annotation.get_group_by_cols(alias=alias)\n                 group_by.extend(group_by_cols)\n         self.group_by = tuple(group_by)\n+        if self.annotation_select:\n+            for alias, annotation in self.annotation_select.items():\n+                try:\n+                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n+                except TypeError:\n+                    annotation_class = annotation.__class__\n+                    msg = (\n+                        '`alias=None` must be added to the signature of '\n+                        '%s.%s.get_group_by_cols().'\n+                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n+                    warnings.warn(msg, category=RemovedInDjango40Warning)\n+                    group_by_cols = annotation.get_group_by_cols()\n+                else:\n+                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n+                group_by.extend(group_by_cols)\n+        self.group_by = tuple(group_by)\n \n     def add_select_related(self, fields):\n         \"\"\"\n",
    "variant_5": "diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 105dc93251..5f6bf9c9d7 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -232,6 +232,7 @@ class FieldGetDbPrepValueIterableMixin(FieldGetDbPrepValueMixin):\n         else:\n             return super().process_rhs(compiler, connection)\n \n+\n     def resolve_expression_parameter(self, compiler, connection, sql, param):\n         params = [param]\n         if hasattr(param, 'resolve_expression'):\n@@ -263,8 +264,25 @@ class Exact(FieldGetDbPrepValueMixin, BuiltinLookup):\n         if isinstance(self.rhs, Query):\n             if self.rhs.has_limit_one():\n                 # The subquery must select only the pk.\n+\n+    def process_rhs(self, compiler, connection):\n+        from django.db.models.sql.query import Query\n+        if isinstance(self.rhs, Query):\n+            if self.rhs.has_limit_one():\n+                # The subquery must select only the pk.\n+                # Store original group_by to preserve grouping semantics\n+                original_group_by = self.rhs.group_by[:]\n                 self.rhs.clear_select_clause()\n                 self.rhs.add_fields(['pk'])\n+                # Restore original group_by if it existed to preserve annotation semantics\n+                if original_group_by:\n+                    self.rhs.group_by = original_group_by\n+            else:\n+                raise ValueError(\n+                    'The QuerySet value for an exact lookup must be limited to '\n+                    'one result using slicing.'\n+                )\n+        return super().process_rhs(compiler, connection)\n             else:\n                 raise ValueError(\n                     'The QuerySet value for an exact lookup must be limited to '\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..c5acd696cf 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1835,7 +1835,8 @@ class Query(BaseExpression):\n         self.distinct_fields = field_names\n         self.distinct = True\n \n-    def add_fields(self, field_names, allow_m2m=True):\n+\n+    def add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n         \"\"\"\n         Add the given (model) fields to the select set. Add the field names in\n         the order specified.\n@@ -1843,6 +1844,11 @@ class Query(BaseExpression):\n         alias = self.get_initial_alias()\n         opts = self.get_meta()\n \n+        # Store original group_by if preservation is requested\n+        original_group_by = None\n+        if preserve_group_by and self.group_by is not None:\n+            original_group_by = list(self.group_by)\n+\n         try:\n             cols = []\n             for name in field_names:\n@@ -1858,6 +1864,9 @@ class Query(BaseExpression):\n                     cols.append(join_info.transform_function(target, final_alias))\n             if cols:\n                 self.set_select(cols)\n+                # Restore original group_by if preservation was requested\n+                if preserve_group_by and original_group_by is not None:\n+                    self.group_by = original_group_by\n         except MultiJoin:\n             raise FieldError(\"Invalid field name: '%s'\" % name)\n         except FieldError:\n@@ -1908,27 +1917,37 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n-    def set_group_by(self):\n-        \"\"\"\n-        Expand the GROUP BY clause required by the query.\n \n-        This will usually be the set of all non-aggregate fields in the\n-        return data. If the database backend supports grouping by the\n-        primary key, and the query would be equivalent, the optimization\n-        will be made automatically.\n-        \"\"\"\n-        group_by = list(self.select)\n-        if self.annotation_select:\n-            for alias, annotation in self.annotation_select.items():\n-                try:\n-                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n-                except TypeError:\n-                    annotation_class = annotation.__class__\n-                    msg = (\n-                        '`alias=None` must be added to the signature of '\n-                        '%s.%s.get_group_by_cols().'\n-                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n-                    warnings.warn(msg, category=RemovedInDjango40Warning)\n+def set_group_by(self, allow_aliases=True):\n+    \"\"\"\n+    Expand the GROUP BY clause required by the query.\n+\n+    This will usually be the set of all non-aggregate fields in the\n+    return data. If the database backend supports grouping by the\n+    primary key, and the query would be equivalent, the optimization\n+    will be made automatically.\n+    \"\"\"\n+    # Check if GROUP BY should be preserved (e.g., from lookup optimizations)\n+    if hasattr(self, '_preserve_group_by') and self._preserve_group_by:\n+        return\n+        \n+    group_by = list(self.select)\n+    if self.annotation_select:\n+        for alias, annotation in self.annotation_select.items():\n+            try:\n+                inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n+            except TypeError:\n+                annotation_class = annotation.__class__\n+                msg = (\n+                    '`alias=None` must be added to the signature of '\n+                    '%s.%s.get_group_by_cols().'\n+                ) % (annotation_class.__module__, annotation_class.__qualname__)\n+                warnings.warn(msg, category=RemovedInDjango40Warning)\n+                group_by_cols = annotation.get_group_by_cols()\n+            else:\n+                group_by_cols = annotation.get_group_by_cols(alias=alias)\n+            group_by.extend(group_by_cols)\n+    self.group_by = tuple(group_by)\n                     group_by_cols = annotation.get_group_by_cols()\n                 else:\n                     group_by_cols = annotation.get_group_by_cols(alias=alias)\n",
    "variant_6": "diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 105dc93251..cac5fbbc95 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -232,12 +232,19 @@ class FieldGetDbPrepValueIterableMixin(FieldGetDbPrepValueMixin):\n         else:\n             return super().process_rhs(compiler, connection)\n \n+\n     def resolve_expression_parameter(self, compiler, connection, sql, param):\n         params = [param]\n         if hasattr(param, 'resolve_expression'):\n             param = param.resolve_expression(compiler.query)\n         if hasattr(param, 'as_sql'):\n+            # Store original group_by before potential modification\n+            original_group_by = getattr(param.query, 'group_by', None) if hasattr(param, 'query') else None\n             sql, params = param.as_sql(compiler, connection)\n+            # Restore original group_by if it was modified during as_sql()\n+            if original_group_by is not None and hasattr(param, 'query') and hasattr(param.query, 'group_by'):\n+                if param.query.group_by != original_group_by:\n+                    param.query.group_by = original_group_by\n         return sql, params\n \n     def batch_process_rhs(self, compiler, connection, rhs=None):\n@@ -263,8 +270,25 @@ class Exact(FieldGetDbPrepValueMixin, BuiltinLookup):\n         if isinstance(self.rhs, Query):\n             if self.rhs.has_limit_one():\n                 # The subquery must select only the pk.\n+\n+    def process_rhs(self, compiler, connection):\n+        from django.db.models.sql.query import Query\n+        if isinstance(self.rhs, Query):\n+            if self.rhs.has_limit_one():\n+                # The subquery must select only the pk.\n+                # Preserve the original GROUP BY clause before clearing select\n+                original_group_by = self.rhs.group_by[:]\n                 self.rhs.clear_select_clause()\n                 self.rhs.add_fields(['pk'])\n+                # Restore the original GROUP BY to preserve annotation semantics\n+                if original_group_by:\n+                    self.rhs.group_by = original_group_by\n+            else:\n+                raise ValueError(\n+                    'The QuerySet value for an exact lookup must be limited to '\n+                    'one result using slicing.'\n+                )\n+        return super().process_rhs(compiler, connection)\n             else:\n                 raise ValueError(\n                     'The QuerySet value for an exact lookup must be limited to '\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..901cd6a1df 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1835,7 +1835,8 @@ class Query(BaseExpression):\n         self.distinct_fields = field_names\n         self.distinct = True\n \n-    def add_fields(self, field_names, allow_m2m=True):\n+\n+    def add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n         \"\"\"\n         Add the given (model) fields to the select set. Add the field names in\n         the order specified.\n@@ -1843,6 +1844,11 @@ class Query(BaseExpression):\n         alias = self.get_initial_alias()\n         opts = self.get_meta()\n \n+        # Store original group_by if preservation is requested\n+        original_group_by = None\n+        if preserve_group_by and self.group_by is not False:\n+            original_group_by = self.group_by\n+\n         try:\n             cols = []\n             for name in field_names:\n@@ -1858,6 +1864,9 @@ class Query(BaseExpression):\n                     cols.append(join_info.transform_function(target, final_alias))\n             if cols:\n                 self.set_select(cols)\n+                # Restore original group_by if preservation was requested\n+                if preserve_group_by and original_group_by is not None:\n+                    self.group_by = original_group_by\n         except MultiJoin:\n             raise FieldError(\"Invalid field name: '%s'\" % name)\n         except FieldError:\n@@ -1908,6 +1917,7 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n+\n     def set_group_by(self):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n@@ -1917,6 +1927,10 @@ class Query(BaseExpression):\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n         \"\"\"\n+        # Check if we have a preserved group_by that should not be recalculated\n+        if hasattr(self, '_preserve_group_by') and self._preserve_group_by:\n+            return\n+            \n         group_by = list(self.select)\n         if self.annotation_select:\n             for alias, annotation in self.annotation_select.items():\n@@ -1934,6 +1948,26 @@ class Query(BaseExpression):\n                     group_by_cols = annotation.get_group_by_cols(alias=alias)\n                 group_by.extend(group_by_cols)\n         self.group_by = tuple(group_by)\n+# Preserve existing GROUP BY if it was set externally (e.g., by lookup optimization)\n+if hasattr(self, '_preserve_group_by') and self._preserve_group_by and self.group_by is not None:\n+    group_by = self.group_by\n+self.add_group_by(group_by, self.get_meta())\n+        if self.annotation_select:\n+            for alias, annotation in self.annotation_select.items():\n+                try:\n+                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n+                except TypeError:\n+                    annotation_class = annotation.__class__\n+                    msg = (\n+                        '`alias=None` must be added to the signature of '\n+                        '%s.%s.get_group_by_cols().'\n+                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n+                    warnings.warn(msg, category=RemovedInDjango40Warning)\n+                    group_by_cols = annotation.get_group_by_cols()\n+                else:\n+                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n+                group_by.extend(group_by_cols)\n+        self.group_by = tuple(group_by)\n \n     def add_select_related(self, fields):\n         \"\"\"\n",
    "variant_7": "diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 105dc93251..7d2551cc44 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -232,12 +232,18 @@ class FieldGetDbPrepValueIterableMixin(FieldGetDbPrepValueMixin):\n         else:\n             return super().process_rhs(compiler, connection)\n \n+\n     def resolve_expression_parameter(self, compiler, connection, sql, param):\n         params = [param]\n         if hasattr(param, 'resolve_expression'):\n             param = param.resolve_expression(compiler.query)\n         if hasattr(param, 'as_sql'):\n+            # Store original group_by before potential modifications\n+            original_group_by = getattr(param.query, 'group_by', None) if hasattr(param, 'query') else None\n             sql, params = param.as_sql(compiler, connection)\n+            # Restore original group_by if it was modified during as_sql()\n+            if original_group_by is not None and hasattr(param, 'query') and hasattr(param.query, 'group_by'):\n+                param.query.group_by = original_group_by\n         return sql, params\n \n     def batch_process_rhs(self, compiler, connection, rhs=None):\n@@ -263,8 +269,25 @@ class Exact(FieldGetDbPrepValueMixin, BuiltinLookup):\n         if isinstance(self.rhs, Query):\n             if self.rhs.has_limit_one():\n                 # The subquery must select only the pk.\n+\n+    def process_rhs(self, compiler, connection):\n+        from django.db.models.sql.query import Query\n+        if isinstance(self.rhs, Query):\n+            if self.rhs.has_limit_one():\n+                # The subquery must select only the pk.\n+                # Preserve the original GROUP BY clause to maintain query semantics\n+                original_group_by = self.rhs.group_by[:]\n                 self.rhs.clear_select_clause()\n                 self.rhs.add_fields(['pk'])\n+                # Restore the original GROUP BY if it existed\n+                if original_group_by:\n+                    self.rhs.group_by = original_group_by\n+            else:\n+                raise ValueError(\n+                    'The QuerySet value for an exact lookup must be limited to '\n+                    'one result using slicing.'\n+                )\n+        return super().process_rhs(compiler, connection)\n             else:\n                 raise ValueError(\n                     'The QuerySet value for an exact lookup must be limited to '\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..6e574c3e8d 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1835,7 +1835,8 @@ class Query(BaseExpression):\n         self.distinct_fields = field_names\n         self.distinct = True\n \n-    def add_fields(self, field_names, allow_m2m=True):\n+\n+    def add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n         \"\"\"\n         Add the given (model) fields to the select set. Add the field names in\n         the order specified.\n@@ -1844,6 +1845,11 @@ class Query(BaseExpression):\n         opts = self.get_meta()\n \n         try:\n+            # Store original group_by if preservation is requested\n+            original_group_by = None\n+            if preserve_group_by and self.group_by is not None:\n+                original_group_by = self.group_by[:]\n+            \n             cols = []\n             for name in field_names:\n                 # Join promotion note - we must not remove any rows here, so\n@@ -1858,6 +1864,9 @@ class Query(BaseExpression):\n                     cols.append(join_info.transform_function(target, final_alias))\n             if cols:\n                 self.set_select(cols)\n+                # Restore original group_by if preservation was requested\n+                if preserve_group_by and original_group_by is not None:\n+                    self.group_by = original_group_by\n         except MultiJoin:\n             raise FieldError(\"Invalid field name: '%s'\" % name)\n         except FieldError:\n@@ -1908,6 +1917,7 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n+\n     def set_group_by(self):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n@@ -1917,6 +1927,11 @@ class Query(BaseExpression):\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n         \"\"\"\n+        # Check if GROUP BY should be preserved (e.g., from lookup optimizations)\n+        if hasattr(self, '_preserve_group_by') and self._preserve_group_by and hasattr(self, '_original_group_by'):\n+            self.group_by = self._original_group_by\n+            return\n+            \n         group_by = list(self.select)\n         if self.annotation_select:\n             for alias, annotation in self.annotation_select.items():\n@@ -1933,6 +1948,11 @@ class Query(BaseExpression):\n                 else:\n                     group_by_cols = annotation.get_group_by_cols(alias=alias)\n                 group_by.extend(group_by_cols)\n+        self.group_by = tuple(group_by)\n+                    group_by_cols = annotation.get_group_by_cols()\n+                else:\n+                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n+                group_by.extend(group_by_cols)\n         self.group_by = tuple(group_by)\n \n     def add_select_related(self, fields):\n",
    "variant_8": "diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 105dc93251..d01e704717 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -232,11 +232,19 @@ class FieldGetDbPrepValueIterableMixin(FieldGetDbPrepValueMixin):\n         else:\n             return super().process_rhs(compiler, connection)\n \n+\n     def resolve_expression_parameter(self, compiler, connection, sql, param):\n         params = [param]\n+        # Store original group_by if param is a Query to preserve it during optimization\n+        preserve_group_by = None\n         if hasattr(param, 'resolve_expression'):\n+            if hasattr(param, 'query') and hasattr(param.query, 'group_by'):\n+                preserve_group_by = param.query.group_by[:]\n             param = param.resolve_expression(compiler.query)\n         if hasattr(param, 'as_sql'):\n+            # Pass group_by preservation context to the compiler\n+            if preserve_group_by is not None and hasattr(param, 'query'):\n+                param.query._preserve_group_by = preserve_group_by\n             sql, params = param.as_sql(compiler, connection)\n         return sql, params\n \n@@ -263,8 +271,25 @@ class Exact(FieldGetDbPrepValueMixin, BuiltinLookup):\n         if isinstance(self.rhs, Query):\n             if self.rhs.has_limit_one():\n                 # The subquery must select only the pk.\n+\n+    def process_rhs(self, compiler, connection):\n+        from django.db.models.sql.query import Query\n+        if isinstance(self.rhs, Query):\n+            if self.rhs.has_limit_one():\n+                # The subquery must select only the pk.\n+                # Store original group_by to preserve grouping semantics\n+                original_group_by = self.rhs.group_by[:]\n                 self.rhs.clear_select_clause()\n                 self.rhs.add_fields(['pk'])\n+                # Restore original group_by if it existed to preserve annotation semantics\n+                if original_group_by:\n+                    self.rhs.group_by = original_group_by\n+            else:\n+                raise ValueError(\n+                    'The QuerySet value for an exact lookup must be limited to '\n+                    'one result using slicing.'\n+                )\n+        return super().process_rhs(compiler, connection)\n             else:\n                 raise ValueError(\n                     'The QuerySet value for an exact lookup must be limited to '\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 8e55bd092d..4b1bfc8254 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1835,13 +1835,19 @@ class Query(BaseExpression):\n         self.distinct_fields = field_names\n         self.distinct = True\n \n-    def add_fields(self, field_names, allow_m2m=True):\n+\n+    def add_fields(self, field_names, allow_m2m=True, preserve_group_by=False):\n         \"\"\"\n         Add the given (model) fields to the select set. Add the field names in\n         the order specified.\n         \"\"\"\n         alias = self.get_initial_alias()\n         opts = self.get_meta()\n+        \n+        # Store original group_by if preservation is requested\n+        original_group_by = None\n+        if preserve_group_by and self.group_by is not None:\n+            original_group_by = list(self.group_by)\n \n         try:\n             cols = []\n@@ -1858,6 +1864,9 @@ class Query(BaseExpression):\n                     cols.append(join_info.transform_function(target, final_alias))\n             if cols:\n                 self.set_select(cols)\n+                # Restore original group_by if preservation was requested\n+                if preserve_group_by and original_group_by is not None:\n+                    self.group_by = tuple(original_group_by)\n         except MultiJoin:\n             raise FieldError(\"Invalid field name: '%s'\" % name)\n         except FieldError:\n@@ -1908,6 +1917,7 @@ class Query(BaseExpression):\n         if force_empty:\n             self.default_ordering = False\n \n+\n     def set_group_by(self):\n         \"\"\"\n         Expand the GROUP BY clause required by the query.\n@@ -1917,6 +1927,10 @@ class Query(BaseExpression):\n         primary key, and the query would be equivalent, the optimization\n         will be made automatically.\n         \"\"\"\n+        # Check if GROUP BY should be preserved (set by lookup optimizations)\n+        if getattr(self, '_preserve_group_by', False):\n+            return\n+            \n         group_by = list(self.select)\n         if self.annotation_select:\n             for alias, annotation in self.annotation_select.items():\n@@ -1933,6 +1947,11 @@ class Query(BaseExpression):\n                 else:\n                     group_by_cols = annotation.get_group_by_cols(alias=alias)\n                 group_by.extend(group_by_cols)\n+        self.group_by = tuple(group_by)\n+                    group_by_cols = annotation.get_group_by_cols()\n+                else:\n+                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n+                group_by.extend(group_by_cols)\n         self.group_by = tuple(group_by)\n \n     def add_select_related(self, fields):\n"
  }
}