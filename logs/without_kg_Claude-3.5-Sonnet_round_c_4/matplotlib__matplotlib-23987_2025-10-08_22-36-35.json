{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/matplotlib/lib/matplotlib/figure.py lines 2428-2429)": "\n        elif constrained_layout:\n            self.set_layout_engine(layout='constrained')\n",
    "Location 2 (/root/hy/projects_4/matplotlib/lib/matplotlib/figure.py lines 1312-1318)": "\n        if (self.get_layout_engine() is not None and\n                not self.get_layout_engine().adjust_compatible):\n            _api.warn_external(\n                \"This figure was using a layout engine that is \"\n                \"incompatible with subplots_adjust and/or tight_layout; \"\n                \"not calling subplots_adjust.\")\n            return\n",
    "Location 3 (/root/hy/projects_4/matplotlib/lib/matplotlib/figure.py lines 2562-2563)": "\n        elif constrained_layout:\n            layout = 'constrained'\n",
    "Location 4 (/root/hy/projects_4/matplotlib/lib/matplotlib/figure.py lines 2580-2582)": "\n        elif constrained_layout:\n            new_layout_engine = ConstrainedLayoutEngine(\n                adjust_compatible=self._layout_engine.adjust_compatible,\n                colorbar_gridspec=self._layout_engine.colorbar_gridspec\n            )\n",
    "Location 5 (/root/hy/projects_4/matplotlib/lib/matplotlib/figure.py lines 2588-2589)": "\n        elif constrained_layout:\n            self.set_layout_engine('constrained')\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/matplotlib/lib/matplotlib/figure.py lines 2428-2429)": [
      "\n        elif constrained_layout:\n            self.set_layout_engine(layout='constrained')\n",
      "\n        elif constrained_layout:\n            self.set_layout_engine(layout='constrained')\n",
      "\n        elif constrained_layout:\n            self.set_layout_engine(layout='constrained')\n",
      "\n        elif constrained_layout:\n            self.set_layout_engine(layout='constrained')\n",
      "\n        elif constrained_layout:\n            self.set_layout_engine(layout='constrained')\n",
      "\n        elif constrained_layout:\n            self.set_layout_engine(layout='constrained')\n",
      "\n        elif constrained_layout:\n            self.set_layout_engine(layout='constrained')\n",
      "\n        elif constrained_layout:\n            self.set_layout_engine(layout='constrained')\n"
    ],
    "Location 2 (/root/hy/projects_4/matplotlib/lib/matplotlib/figure.py lines 1312-1318)": [
      "\n        elif constrained_layout:\n            self.set_layout_engine(ConstrainedLayoutEngine(\n",
      "\n    def subplots_adjust(self, left=None, bottom=None, right=None, top=None,\n                        wspace=None, hspace=None):\n        \"\"\"\n        Adjust the subplot layout parameters.\n\n        Unset parameters are left unmodified; initial values are given by\n        :rc:`figure.subplot.[name]`.\n\n        Parameters\n        ----------\n        left : float, optional\n            The position of the left edge of the subplots,\n            as a fraction of the figure width.\n        bottom : float, optional\n            The position of the bottom edge of the subplots,\n            as a fraction of the figure height.\n        right : float, optional\n            The position of the right edge of the subplots,\n            as a fraction of the figure width.\n        top : float, optional\n            The position of the top edge of the subplots,\n            as a fraction of the figure height.\n        wspace : float, optional\n            The width of the padding between subplots,\n            as a fraction of the average Axes width.\n        hspace : float, optional\n            The height of the padding between subplots,\n            as a fraction of the average Axes height.\n        \"\"\"\n        if (self.get_layout_engine() is not None and\n                not self.get_layout_engine().adjust_compatible):\n            _api.warn_external(\n                \"This figure was using a layout engine that is \"\n                \"incompatible with subplots_adjust and/or tight_layout; \"\n                \"not calling subplots_adjust.\")\n            return\n        self.subplotpars.update(left, bottom, right, top, wspace, hspace)\n        for ax in self.axes:\n            if hasattr(ax, 'get_subplotspec'):\n                ax._set_position(ax.get_subplotspec().get_position(self))\n        self.stale = True\n",
      "\n        if (self.get_layout_engine() is not None and\n                not self.get_layout_engine().adjust_compatible):\n            _api.warn_external(\n                \"This figure was using a layout engine that is \"\n                \"incompatible with subplots_adjust and/or tight_layout; \"\n                \"not calling subplots_adjust.\")\n            return\n",
      "\n        elif constrained_layout:\n            self.set_layout_engine(ConstrainedLayoutEngine(\n                h_pad=layoutbox_kw.get('h_pad', None),\n                w_pad=layoutbox_kw.get('w_pad', None),\n                hspace=layoutbox_kw.get('hspace', None),\n                wspace=layoutbox_kw.get('wspace', None),\n                rect=layoutbox_kw.get('rect', None),\n            ))\n",
      "\n        if (self.get_layout_engine() is not None and\n                not self.get_layout_engine().adjust_compatible):\n            _api.warn_external(\n                \"This figure was using a layout engine that is \"\n                \"incompatible with subplots_adjust and/or tight_layout; \"\n                \"not calling subplots_adjust.\")\n            return\n",
      "\n        if (self.get_layout_engine() is not None and\n                not self.get_layout_engine().adjust_compatible):\n            _api.warn_external(\n                \"This figure was using a layout engine that is \"\n                \"incompatible with subplots_adjust and/or tight_layout; \"\n                \"not calling subplots_adjust.\")\n            return\n",
      "\n        if (self.get_layout_engine() is not None and\n                not self.get_layout_engine().adjust_compatible):\n            _api.warn_external(\n                \"This figure was using a layout engine that is \"\n                \"incompatible with subplots_adjust and/or tight_layout; \"\n                \"not calling subplots_adjust.\")\n            return\n",
      "\n        if (self.get_layout_engine() is not None and\n                not self.get_layout_engine().adjust_compatible):\n            _api.warn_external(\n                \"This figure was using a layout engine that is \"\n                \"incompatible with subplots_adjust and/or tight_layout; \"\n                \"not calling subplots_adjust.\")\n            return\n"
    ],
    "Location 3 (/root/hy/projects_4/matplotlib/lib/matplotlib/figure.py lines 2562-2563)": [
      "\n        elif constrained_layout:\n            layout = 'constrained'\n",
      "\n        elif constrained_layout:\n            layout = 'constrained'\n",
      "\n        elif constrained_layout:\n            layout = 'constrained'\n",
      "\n        elif constrained_layout:\n            layout = 'constrained'\n",
      "\n        elif constrained_layout:\n            layout = 'constrained'\n",
      "\n        elif constrained_layout:\n            layout = 'constrained'\n",
      "\n        elif constrained_layout:\n            layout = 'constrained'\n",
      "\n        elif constrained_layout:\n            layout = 'constrained'\n"
    ],
    "Location 4 (/root/hy/projects_4/matplotlib/lib/matplotlib/figure.py lines 2580-2582)": [
      "\n        elif constrained_layout:\n            new_layout_engine = ConstrainedLayoutEngine(\n                tight_layout_pad=self._constrained_layout_pads,\n                **layout_engine_kwargs\n            )\n",
      "\n        elif constrained_layout:\n            new_layout_engine = ConstrainedLayoutEngine(\n                h_pad=constrained_layout_pads['h_pad'],\n                w_pad=constrained_layout_pads['w_pad'],\n                hspace=constrained_layout_pads['hspace'],\n                wspace=constrained_layout_pads['wspace'],\n            )\n",
      "\n        elif constrained_layout:\n            new_layout_engine = ConstrainedLayoutEngine(\n                adjust_compatible=self._layout_engine.adjust_compatible,\n                colorbar_gridspec=self._layout_engine.colorbar_gridspec\n            )\n",
      "\n        elif constrained_layout:\n            new_layout_engine = ConstrainedLayoutEngine(\n                h_pad=self.subplotpars.hspace,\n                w_pad=self.subplotpars.wspace,\n            )\n",
      "\n        elif constrained_layout:\n            new_layout_engine = ConstrainedLayoutEngine(\n",
      "\n        elif constrained_layout:\n            new_layout_engine = ConstrainedLayoutEngine(\n                adjust_compatible=True, colorbar_gridspec=True)\n",
      "\n        elif constrained_layout:\n            if self._layout_engine is None:\n",
      "\n        elif constrained_layout:\n            new_layout_engine = ConstrainedLayoutEngine(\n"
    ],
    "Location 5 (/root/hy/projects_4/matplotlib/lib/matplotlib/figure.py lines 2588-2589)": [
      "\n        elif constrained_layout:\n            new_layout_engine = ConstrainedLayoutEngine()\n",
      "\n        elif constrained_layout:\n            new_layout_engine = ConstrainedLayoutEngine(**kwargs)\n",
      "\n        elif constrained_layout:\n            new_layout_engine = ConstrainedLayoutEngine(\n                w_pad=w_pad, h_pad=h_pad, hspace=hspace, wspace=wspace)\n",
      "\n        elif constrained_layout:\n            new_layout_engine = ConstrainedLayoutEngine(\n                w_pad=w_pad, h_pad=h_pad,\n                hspace=hspace, wspace=wspace,\n                rect=rect,\n            )\n",
      "\n        elif constrained_layout:\n            new_layout_engine = ConstrainedLayoutEngine()\n",
      "\n        elif constrained_layout:\n            new_layout_engine = ConstrainedLayoutEngine(**kwargs)\n",
      "\n        elif constrained_layout:\n            new_layout_engine = ConstrainedLayoutEngine()\n",
      "\n        elif constrained_layout:\n            new_layout_engine = ConstrainedLayoutEngine(\n                compress=True,\n                h_pad=constrained_layout_pads['h_pad'],\n                w_pad=constrained_layout_pads['w_pad'],\n                hspace=constrained_layout_pads['hspace'],\n                wspace=constrained_layout_pads['wspace'],\n            )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 5bbb786984..07eb03721a 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -1309,6 +1309,7 @@ default: %(va)s\n             The height of the padding between subplots,\n             as a fraction of the average Axes height.\n         \"\"\"\n+\n         if (self.get_layout_engine() is not None and\n                 not self.get_layout_engine().adjust_compatible):\n             _api.warn_external(\n@@ -2425,7 +2426,8 @@ class Figure(FigureBase):\n             self.set_layout_engine(layout='tight')\n             if isinstance(tight_layout, dict):\n                 self.get_layout_engine().set(**tight_layout)\n-        elif constrained_layout is not None:\n+\n+        elif constrained_layout:\n             self.set_layout_engine(layout='constrained')\n             if isinstance(constrained_layout, dict):\n                 self.get_layout_engine().set(**constrained_layout)\n@@ -2559,6 +2561,7 @@ class Figure(FigureBase):\n                 return\n         if layout == 'tight':\n             new_layout_engine = TightLayoutEngine(**kwargs)\n+\n         elif layout == 'constrained':\n             new_layout_engine = ConstrainedLayoutEngine(**kwargs)\n         elif layout == 'compressed':\n@@ -2577,6 +2580,7 @@ class Figure(FigureBase):\n         else:\n             raise ValueError(f\"Invalid value for 'layout': {layout!r}\")\n \n+\n         if self._check_layout_engines_compat(self._layout_engine,\n                                              new_layout_engine):\n             self._layout_engine = new_layout_engine\n@@ -2585,6 +2589,7 @@ class Figure(FigureBase):\n                                'compatible with old engine, and a colorbar '\n                                'has been created.  Engine not changed.')\n \n+\n     def get_layout_engine(self):\n         return self._layout_engine\n \n",
    "variant_0": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 5bbb786984..989753dc26 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -1309,6 +1309,7 @@ default: %(va)s\n             The height of the padding between subplots,\n             as a fraction of the average Axes height.\n         \"\"\"\n+\n         if (self.get_layout_engine() is not None and\n                 not self.get_layout_engine().adjust_compatible):\n             _api.warn_external(\n@@ -2425,7 +2426,8 @@ class Figure(FigureBase):\n             self.set_layout_engine(layout='tight')\n             if isinstance(tight_layout, dict):\n                 self.get_layout_engine().set(**tight_layout)\n-        elif constrained_layout is not None:\n+\n+        elif constrained_layout:\n             self.set_layout_engine(layout='constrained')\n             if isinstance(constrained_layout, dict):\n                 self.get_layout_engine().set(**constrained_layout)\n@@ -2559,8 +2561,9 @@ class Figure(FigureBase):\n                 return\n         if layout == 'tight':\n             new_layout_engine = TightLayoutEngine(**kwargs)\n-        elif layout == 'constrained':\n-            new_layout_engine = ConstrainedLayoutEngine(**kwargs)\n+\n+        elif constrained_layout:\n+            layout = 'constrained'\n         elif layout == 'compressed':\n             new_layout_engine = ConstrainedLayoutEngine(compress=True,\n                                                         **kwargs)\n@@ -2577,16 +2580,20 @@ class Figure(FigureBase):\n         else:\n             raise ValueError(f\"Invalid value for 'layout': {layout!r}\")\n \n-        if self._check_layout_engines_compat(self._layout_engine,\n-                                             new_layout_engine):\n-            self._layout_engine = new_layout_engine\n+\n+        elif constrained_layout:\n+            new_layout_engine = ConstrainedLayoutEngine(\n+                adjust_compatible=self._layout_engine.adjust_compatible,\n+                colorbar_gridspec=self._layout_engine.colorbar_gridspec\n+            )\n         else:\n             raise RuntimeError('Colorbar layout of new layout engine not '\n                                'compatible with old engine, and a colorbar '\n                                'has been created.  Engine not changed.')\n \n-    def get_layout_engine(self):\n-        return self._layout_engine\n+\n+        elif constrained_layout:\n+            self.set_layout_engine('constrained')\n \n     # TODO: I'd like to dynamically add the _repr_html_ method\n     # to the figure in the right context, but then IPython doesn't\n",
    "variant_1": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 5bbb786984..1b703ad2a2 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -1309,13 +1309,9 @@ default: %(va)s\n             The height of the padding between subplots,\n             as a fraction of the average Axes height.\n         \"\"\"\n-        if (self.get_layout_engine() is not None and\n-                not self.get_layout_engine().adjust_compatible):\n-            _api.warn_external(\n-                \"This figure was using a layout engine that is \"\n-                \"incompatible with subplots_adjust and/or tight_layout; \"\n-                \"not calling subplots_adjust.\")\n-            return\n+\n+        elif constrained_layout:\n+            self.set_layout_engine(ConstrainedLayoutEngine(\n         self.subplotpars.update(left, bottom, right, top, wspace, hspace)\n         for ax in self.axes:\n             if hasattr(ax, 'get_subplotspec'):\n@@ -2425,7 +2421,8 @@ class Figure(FigureBase):\n             self.set_layout_engine(layout='tight')\n             if isinstance(tight_layout, dict):\n                 self.get_layout_engine().set(**tight_layout)\n-        elif constrained_layout is not None:\n+\n+        elif constrained_layout:\n             self.set_layout_engine(layout='constrained')\n             if isinstance(constrained_layout, dict):\n                 self.get_layout_engine().set(**constrained_layout)\n@@ -2559,8 +2556,9 @@ class Figure(FigureBase):\n                 return\n         if layout == 'tight':\n             new_layout_engine = TightLayoutEngine(**kwargs)\n-        elif layout == 'constrained':\n-            new_layout_engine = ConstrainedLayoutEngine(**kwargs)\n+\n+        elif constrained_layout:\n+            layout = 'constrained'\n         elif layout == 'compressed':\n             new_layout_engine = ConstrainedLayoutEngine(compress=True,\n                                                         **kwargs)\n@@ -2577,16 +2575,20 @@ class Figure(FigureBase):\n         else:\n             raise ValueError(f\"Invalid value for 'layout': {layout!r}\")\n \n-        if self._check_layout_engines_compat(self._layout_engine,\n-                                             new_layout_engine):\n-            self._layout_engine = new_layout_engine\n+\n+        elif constrained_layout:\n+            new_layout_engine = ConstrainedLayoutEngine(\n+                tight_layout_pad=self._constrained_layout_pads,\n+                **layout_engine_kwargs\n+            )\n         else:\n             raise RuntimeError('Colorbar layout of new layout engine not '\n                                'compatible with old engine, and a colorbar '\n                                'has been created.  Engine not changed.')\n \n-    def get_layout_engine(self):\n-        return self._layout_engine\n+\n+        elif constrained_layout:\n+            new_layout_engine = ConstrainedLayoutEngine()\n \n     # TODO: I'd like to dynamically add the _repr_html_ method\n     # to the figure in the right context, but then IPython doesn't\n",
    "variant_2": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 5bbb786984..1226a04f42 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -1309,6 +1309,36 @@ default: %(va)s\n             The height of the padding between subplots,\n             as a fraction of the average Axes height.\n         \"\"\"\n+\n+    def subplots_adjust(self, left=None, bottom=None, right=None, top=None,\n+                        wspace=None, hspace=None):\n+        \"\"\"\n+        Adjust the subplot layout parameters.\n+\n+        Unset parameters are left unmodified; initial values are given by\n+        :rc:`figure.subplot.[name]`.\n+\n+        Parameters\n+        ----------\n+        left : float, optional\n+            The position of the left edge of the subplots,\n+            as a fraction of the figure width.\n+        bottom : float, optional\n+            The position of the bottom edge of the subplots,\n+            as a fraction of the figure height.\n+        right : float, optional\n+            The position of the right edge of the subplots,\n+            as a fraction of the figure width.\n+        top : float, optional\n+            The position of the top edge of the subplots,\n+            as a fraction of the figure height.\n+        wspace : float, optional\n+            The width of the padding between subplots,\n+            as a fraction of the average Axes width.\n+        hspace : float, optional\n+            The height of the padding between subplots,\n+            as a fraction of the average Axes height.\n+        \"\"\"\n         if (self.get_layout_engine() is not None and\n                 not self.get_layout_engine().adjust_compatible):\n             _api.warn_external(\n@@ -1321,6 +1351,11 @@ default: %(va)s\n             if hasattr(ax, 'get_subplotspec'):\n                 ax._set_position(ax.get_subplotspec().get_position(self))\n         self.stale = True\n+        self.subplotpars.update(left, bottom, right, top, wspace, hspace)\n+        for ax in self.axes:\n+            if hasattr(ax, 'get_subplotspec'):\n+                ax._set_position(ax.get_subplotspec().get_position(self))\n+        self.stale = True\n \n     def align_xlabels(self, axs=None):\n         \"\"\"\n@@ -2425,7 +2460,8 @@ class Figure(FigureBase):\n             self.set_layout_engine(layout='tight')\n             if isinstance(tight_layout, dict):\n                 self.get_layout_engine().set(**tight_layout)\n-        elif constrained_layout is not None:\n+\n+        elif constrained_layout:\n             self.set_layout_engine(layout='constrained')\n             if isinstance(constrained_layout, dict):\n                 self.get_layout_engine().set(**constrained_layout)\n@@ -2559,8 +2595,9 @@ class Figure(FigureBase):\n                 return\n         if layout == 'tight':\n             new_layout_engine = TightLayoutEngine(**kwargs)\n-        elif layout == 'constrained':\n-            new_layout_engine = ConstrainedLayoutEngine(**kwargs)\n+\n+        elif constrained_layout:\n+            layout = 'constrained'\n         elif layout == 'compressed':\n             new_layout_engine = ConstrainedLayoutEngine(compress=True,\n                                                         **kwargs)\n@@ -2577,16 +2614,22 @@ class Figure(FigureBase):\n         else:\n             raise ValueError(f\"Invalid value for 'layout': {layout!r}\")\n \n-        if self._check_layout_engines_compat(self._layout_engine,\n-                                             new_layout_engine):\n-            self._layout_engine = new_layout_engine\n+\n+        elif constrained_layout:\n+            new_layout_engine = ConstrainedLayoutEngine(\n+                h_pad=constrained_layout_pads['h_pad'],\n+                w_pad=constrained_layout_pads['w_pad'],\n+                hspace=constrained_layout_pads['hspace'],\n+                wspace=constrained_layout_pads['wspace'],\n+            )\n         else:\n             raise RuntimeError('Colorbar layout of new layout engine not '\n                                'compatible with old engine, and a colorbar '\n                                'has been created.  Engine not changed.')\n \n-    def get_layout_engine(self):\n-        return self._layout_engine\n+\n+        elif constrained_layout:\n+            new_layout_engine = ConstrainedLayoutEngine(**kwargs)\n \n     # TODO: I'd like to dynamically add the _repr_html_ method\n     # to the figure in the right context, but then IPython doesn't\n",
    "variant_3": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 5bbb786984..73075f5935 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -1309,6 +1309,7 @@ default: %(va)s\n             The height of the padding between subplots,\n             as a fraction of the average Axes height.\n         \"\"\"\n+\n         if (self.get_layout_engine() is not None and\n                 not self.get_layout_engine().adjust_compatible):\n             _api.warn_external(\n@@ -2425,7 +2426,8 @@ class Figure(FigureBase):\n             self.set_layout_engine(layout='tight')\n             if isinstance(tight_layout, dict):\n                 self.get_layout_engine().set(**tight_layout)\n-        elif constrained_layout is not None:\n+\n+        elif constrained_layout:\n             self.set_layout_engine(layout='constrained')\n             if isinstance(constrained_layout, dict):\n                 self.get_layout_engine().set(**constrained_layout)\n@@ -2559,8 +2561,9 @@ class Figure(FigureBase):\n                 return\n         if layout == 'tight':\n             new_layout_engine = TightLayoutEngine(**kwargs)\n-        elif layout == 'constrained':\n-            new_layout_engine = ConstrainedLayoutEngine(**kwargs)\n+\n+        elif constrained_layout:\n+            layout = 'constrained'\n         elif layout == 'compressed':\n             new_layout_engine = ConstrainedLayoutEngine(compress=True,\n                                                         **kwargs)\n@@ -2577,16 +2580,21 @@ class Figure(FigureBase):\n         else:\n             raise ValueError(f\"Invalid value for 'layout': {layout!r}\")\n \n-        if self._check_layout_engines_compat(self._layout_engine,\n-                                             new_layout_engine):\n-            self._layout_engine = new_layout_engine\n+\n+        elif constrained_layout:\n+            new_layout_engine = ConstrainedLayoutEngine(\n+                adjust_compatible=self._layout_engine.adjust_compatible,\n+                colorbar_gridspec=self._layout_engine.colorbar_gridspec\n+            )\n         else:\n             raise RuntimeError('Colorbar layout of new layout engine not '\n                                'compatible with old engine, and a colorbar '\n                                'has been created.  Engine not changed.')\n \n-    def get_layout_engine(self):\n-        return self._layout_engine\n+\n+        elif constrained_layout:\n+            new_layout_engine = ConstrainedLayoutEngine(\n+                w_pad=w_pad, h_pad=h_pad, hspace=hspace, wspace=wspace)\n \n     # TODO: I'd like to dynamically add the _repr_html_ method\n     # to the figure in the right context, but then IPython doesn't\n",
    "variant_4": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 5bbb786984..ac6d2695f5 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -1309,13 +1309,15 @@ default: %(va)s\n             The height of the padding between subplots,\n             as a fraction of the average Axes height.\n         \"\"\"\n-        if (self.get_layout_engine() is not None and\n-                not self.get_layout_engine().adjust_compatible):\n-            _api.warn_external(\n-                \"This figure was using a layout engine that is \"\n-                \"incompatible with subplots_adjust and/or tight_layout; \"\n-                \"not calling subplots_adjust.\")\n-            return\n+\n+        elif constrained_layout:\n+            self.set_layout_engine(ConstrainedLayoutEngine(\n+                h_pad=layoutbox_kw.get('h_pad', None),\n+                w_pad=layoutbox_kw.get('w_pad', None),\n+                hspace=layoutbox_kw.get('hspace', None),\n+                wspace=layoutbox_kw.get('wspace', None),\n+                rect=layoutbox_kw.get('rect', None),\n+            ))\n         self.subplotpars.update(left, bottom, right, top, wspace, hspace)\n         for ax in self.axes:\n             if hasattr(ax, 'get_subplotspec'):\n@@ -2425,7 +2427,8 @@ class Figure(FigureBase):\n             self.set_layout_engine(layout='tight')\n             if isinstance(tight_layout, dict):\n                 self.get_layout_engine().set(**tight_layout)\n-        elif constrained_layout is not None:\n+\n+        elif constrained_layout:\n             self.set_layout_engine(layout='constrained')\n             if isinstance(constrained_layout, dict):\n                 self.get_layout_engine().set(**constrained_layout)\n@@ -2559,8 +2562,9 @@ class Figure(FigureBase):\n                 return\n         if layout == 'tight':\n             new_layout_engine = TightLayoutEngine(**kwargs)\n-        elif layout == 'constrained':\n-            new_layout_engine = ConstrainedLayoutEngine(**kwargs)\n+\n+        elif constrained_layout:\n+            layout = 'constrained'\n         elif layout == 'compressed':\n             new_layout_engine = ConstrainedLayoutEngine(compress=True,\n                                                         **kwargs)\n@@ -2577,16 +2581,24 @@ class Figure(FigureBase):\n         else:\n             raise ValueError(f\"Invalid value for 'layout': {layout!r}\")\n \n-        if self._check_layout_engines_compat(self._layout_engine,\n-                                             new_layout_engine):\n-            self._layout_engine = new_layout_engine\n+\n+        elif constrained_layout:\n+            new_layout_engine = ConstrainedLayoutEngine(\n+                h_pad=self.subplotpars.hspace,\n+                w_pad=self.subplotpars.wspace,\n+            )\n         else:\n             raise RuntimeError('Colorbar layout of new layout engine not '\n                                'compatible with old engine, and a colorbar '\n                                'has been created.  Engine not changed.')\n \n-    def get_layout_engine(self):\n-        return self._layout_engine\n+\n+        elif constrained_layout:\n+            new_layout_engine = ConstrainedLayoutEngine(\n+                w_pad=w_pad, h_pad=h_pad,\n+                hspace=hspace, wspace=wspace,\n+                rect=rect,\n+            )\n \n     # TODO: I'd like to dynamically add the _repr_html_ method\n     # to the figure in the right context, but then IPython doesn't\n",
    "variant_5": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 5bbb786984..ec0fbd18d8 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -1309,6 +1309,7 @@ default: %(va)s\n             The height of the padding between subplots,\n             as a fraction of the average Axes height.\n         \"\"\"\n+\n         if (self.get_layout_engine() is not None and\n                 not self.get_layout_engine().adjust_compatible):\n             _api.warn_external(\n@@ -2425,7 +2426,8 @@ class Figure(FigureBase):\n             self.set_layout_engine(layout='tight')\n             if isinstance(tight_layout, dict):\n                 self.get_layout_engine().set(**tight_layout)\n-        elif constrained_layout is not None:\n+\n+        elif constrained_layout:\n             self.set_layout_engine(layout='constrained')\n             if isinstance(constrained_layout, dict):\n                 self.get_layout_engine().set(**constrained_layout)\n@@ -2559,8 +2561,9 @@ class Figure(FigureBase):\n                 return\n         if layout == 'tight':\n             new_layout_engine = TightLayoutEngine(**kwargs)\n-        elif layout == 'constrained':\n-            new_layout_engine = ConstrainedLayoutEngine(**kwargs)\n+\n+        elif constrained_layout:\n+            layout = 'constrained'\n         elif layout == 'compressed':\n             new_layout_engine = ConstrainedLayoutEngine(compress=True,\n                                                         **kwargs)\n@@ -2577,16 +2580,17 @@ class Figure(FigureBase):\n         else:\n             raise ValueError(f\"Invalid value for 'layout': {layout!r}\")\n \n-        if self._check_layout_engines_compat(self._layout_engine,\n-                                             new_layout_engine):\n-            self._layout_engine = new_layout_engine\n+\n+        elif constrained_layout:\n+            new_layout_engine = ConstrainedLayoutEngine(\n         else:\n             raise RuntimeError('Colorbar layout of new layout engine not '\n                                'compatible with old engine, and a colorbar '\n                                'has been created.  Engine not changed.')\n \n-    def get_layout_engine(self):\n-        return self._layout_engine\n+\n+        elif constrained_layout:\n+            new_layout_engine = ConstrainedLayoutEngine()\n \n     # TODO: I'd like to dynamically add the _repr_html_ method\n     # to the figure in the right context, but then IPython doesn't\n",
    "variant_6": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 5bbb786984..c8d9b413de 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -1309,6 +1309,7 @@ default: %(va)s\n             The height of the padding between subplots,\n             as a fraction of the average Axes height.\n         \"\"\"\n+\n         if (self.get_layout_engine() is not None and\n                 not self.get_layout_engine().adjust_compatible):\n             _api.warn_external(\n@@ -2425,7 +2426,8 @@ class Figure(FigureBase):\n             self.set_layout_engine(layout='tight')\n             if isinstance(tight_layout, dict):\n                 self.get_layout_engine().set(**tight_layout)\n-        elif constrained_layout is not None:\n+\n+        elif constrained_layout:\n             self.set_layout_engine(layout='constrained')\n             if isinstance(constrained_layout, dict):\n                 self.get_layout_engine().set(**constrained_layout)\n@@ -2559,8 +2561,9 @@ class Figure(FigureBase):\n                 return\n         if layout == 'tight':\n             new_layout_engine = TightLayoutEngine(**kwargs)\n-        elif layout == 'constrained':\n-            new_layout_engine = ConstrainedLayoutEngine(**kwargs)\n+\n+        elif constrained_layout:\n+            layout = 'constrained'\n         elif layout == 'compressed':\n             new_layout_engine = ConstrainedLayoutEngine(compress=True,\n                                                         **kwargs)\n@@ -2577,16 +2580,18 @@ class Figure(FigureBase):\n         else:\n             raise ValueError(f\"Invalid value for 'layout': {layout!r}\")\n \n-        if self._check_layout_engines_compat(self._layout_engine,\n-                                             new_layout_engine):\n-            self._layout_engine = new_layout_engine\n+\n+        elif constrained_layout:\n+            new_layout_engine = ConstrainedLayoutEngine(\n+                adjust_compatible=True, colorbar_gridspec=True)\n         else:\n             raise RuntimeError('Colorbar layout of new layout engine not '\n                                'compatible with old engine, and a colorbar '\n                                'has been created.  Engine not changed.')\n \n-    def get_layout_engine(self):\n-        return self._layout_engine\n+\n+        elif constrained_layout:\n+            new_layout_engine = ConstrainedLayoutEngine(**kwargs)\n \n     # TODO: I'd like to dynamically add the _repr_html_ method\n     # to the figure in the right context, but then IPython doesn't\n",
    "variant_7": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 5bbb786984..9fcf2dbb89 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -1309,6 +1309,7 @@ default: %(va)s\n             The height of the padding between subplots,\n             as a fraction of the average Axes height.\n         \"\"\"\n+\n         if (self.get_layout_engine() is not None and\n                 not self.get_layout_engine().adjust_compatible):\n             _api.warn_external(\n@@ -2425,7 +2426,8 @@ class Figure(FigureBase):\n             self.set_layout_engine(layout='tight')\n             if isinstance(tight_layout, dict):\n                 self.get_layout_engine().set(**tight_layout)\n-        elif constrained_layout is not None:\n+\n+        elif constrained_layout:\n             self.set_layout_engine(layout='constrained')\n             if isinstance(constrained_layout, dict):\n                 self.get_layout_engine().set(**constrained_layout)\n@@ -2559,8 +2561,9 @@ class Figure(FigureBase):\n                 return\n         if layout == 'tight':\n             new_layout_engine = TightLayoutEngine(**kwargs)\n-        elif layout == 'constrained':\n-            new_layout_engine = ConstrainedLayoutEngine(**kwargs)\n+\n+        elif constrained_layout:\n+            layout = 'constrained'\n         elif layout == 'compressed':\n             new_layout_engine = ConstrainedLayoutEngine(compress=True,\n                                                         **kwargs)\n@@ -2577,16 +2580,17 @@ class Figure(FigureBase):\n         else:\n             raise ValueError(f\"Invalid value for 'layout': {layout!r}\")\n \n-        if self._check_layout_engines_compat(self._layout_engine,\n-                                             new_layout_engine):\n-            self._layout_engine = new_layout_engine\n+\n+        elif constrained_layout:\n+            if self._layout_engine is None:\n         else:\n             raise RuntimeError('Colorbar layout of new layout engine not '\n                                'compatible with old engine, and a colorbar '\n                                'has been created.  Engine not changed.')\n \n-    def get_layout_engine(self):\n-        return self._layout_engine\n+\n+        elif constrained_layout:\n+            new_layout_engine = ConstrainedLayoutEngine()\n \n     # TODO: I'd like to dynamically add the _repr_html_ method\n     # to the figure in the right context, but then IPython doesn't\n",
    "variant_8": "diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py\nindex 5bbb786984..5c5a81d474 100644\n--- a/lib/matplotlib/figure.py\n+++ b/lib/matplotlib/figure.py\n@@ -1309,6 +1309,7 @@ default: %(va)s\n             The height of the padding between subplots,\n             as a fraction of the average Axes height.\n         \"\"\"\n+\n         if (self.get_layout_engine() is not None and\n                 not self.get_layout_engine().adjust_compatible):\n             _api.warn_external(\n@@ -2425,7 +2426,8 @@ class Figure(FigureBase):\n             self.set_layout_engine(layout='tight')\n             if isinstance(tight_layout, dict):\n                 self.get_layout_engine().set(**tight_layout)\n-        elif constrained_layout is not None:\n+\n+        elif constrained_layout:\n             self.set_layout_engine(layout='constrained')\n             if isinstance(constrained_layout, dict):\n                 self.get_layout_engine().set(**constrained_layout)\n@@ -2559,8 +2561,9 @@ class Figure(FigureBase):\n                 return\n         if layout == 'tight':\n             new_layout_engine = TightLayoutEngine(**kwargs)\n-        elif layout == 'constrained':\n-            new_layout_engine = ConstrainedLayoutEngine(**kwargs)\n+\n+        elif constrained_layout:\n+            layout = 'constrained'\n         elif layout == 'compressed':\n             new_layout_engine = ConstrainedLayoutEngine(compress=True,\n                                                         **kwargs)\n@@ -2577,16 +2580,23 @@ class Figure(FigureBase):\n         else:\n             raise ValueError(f\"Invalid value for 'layout': {layout!r}\")\n \n-        if self._check_layout_engines_compat(self._layout_engine,\n-                                             new_layout_engine):\n-            self._layout_engine = new_layout_engine\n+\n+        elif constrained_layout:\n+            new_layout_engine = ConstrainedLayoutEngine(\n         else:\n             raise RuntimeError('Colorbar layout of new layout engine not '\n                                'compatible with old engine, and a colorbar '\n                                'has been created.  Engine not changed.')\n \n-    def get_layout_engine(self):\n-        return self._layout_engine\n+\n+        elif constrained_layout:\n+            new_layout_engine = ConstrainedLayoutEngine(\n+                compress=True,\n+                h_pad=constrained_layout_pads['h_pad'],\n+                w_pad=constrained_layout_pads['w_pad'],\n+                hspace=constrained_layout_pads['hspace'],\n+                wspace=constrained_layout_pads['wspace'],\n+            )\n \n     # TODO: I'd like to dynamically add the _repr_html_ method\n     # to the figure in the right context, but then IPython doesn't\n"
  }
}