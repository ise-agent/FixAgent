{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 2526-2527)": "\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
    "Location 2 (/root/hy/projects_4/django/django/db/models/options.py lines 245-246)": "\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
    "Location 3 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 2502-2504)": "\nclass AutoFieldMeta(type):\n    \"\"\"\n    Metaclass to maintain backward inheritance compatibility for AutoField.\n\n    It is intended that AutoFieldMixin become public API when it is possible to\n    create a non-integer automatically-generated field using column defaults\n    stored in the database.\n\n    In many areas Django also relies on using isinstance() to check for an\n    automatically-generated field as a subclass of AutoField. A new flag needs\n    to be implemented on Field to be used instead.\n\n    When these issues have been addressed, this metaclass could be used to\n    deprecate backward inheritance compatibility.\n    \"\"\"\n\n    @property\n    def _subclasses(self):\n        return (BigAutoField, SmallAutoField)\n\n    def __instancecheck__(cls, instance):\n        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n\n    def __subclasscheck__(cls, subclass):\n        return (\n            subclass in cls._subclasses or \n            any(issubclass(subclass, subcls) for subcls in cls._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
    "Location 4 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 2530-2532)": "\nclass AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n    \"\"\"\n    An IntegerField which automatically increments according to available IDs.\n    \"\"\"\n    def get_internal_type(self):\n",
    "Location 5 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 2548-2554)": "\nclass SmallAutoField(AutoFieldMixin, SmallIntegerField):\n\n    def get_internal_type(self):\n        return 'SmallAutoField'\n\n    def rel_db_type(self, connection):\n        return SmallIntegerField().db_type(connection=connection)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 2526-2527)": [
      "\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/db/models/options.py lines 245-246)": [
      "\ndef __subclasscheck__(self, subclass):\n    return (\n        subclass in self._subclasses or \n        any(issubclass(subclass, cls) for cls in self._subclasses) or \n        super().__subclasscheck__(subclass)\n    )\n",
      "\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\ndef __subclasscheck__(self, subclass):\n    return (\n        subclass in self._subclasses or \n        any(issubclass(subclass, cls) for cls in self._subclasses) or \n        super().__subclasscheck__(subclass)\n    )\n"
    ],
    "Location 3 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 2502-2504)": [
      "\nclass AutoFieldMeta(type):\n    \"\"\"\n    Metaclass to maintain backward inheritance compatibility for AutoField.\n\n    It is intended that AutoFieldMixin become public API when it is possible to\n    create a non-integer automatically-generated field using column defaults\n    stored in the database.\n\n    In many areas Django also relies on using isinstance() to check for an\n    automatically-generated field as a subclass of AutoField. A new flag needs\n    to be implemented on Field to be used instead.\n\n    When these issues have been addressed, this metaclass could be used to\n    deprecate the AutoFieldMixin.\n    \"\"\"\n\n    @property\n    def _subclasses(self):\n        return (BigAutoField, SmallAutoField)\n\n    def __instancecheck__(cls, instance):\n        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n\n    def __subclasscheck__(cls, subclass):\n        return (\n            subclass in cls._subclasses or \n            any(issubclass(subclass, subcls) for subcls in cls._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\nclass AutoFieldMeta(type):\n    \"\"\"\n    Metaclass to maintain backward inheritance compatibility for AutoField.\n\n    It is intended that AutoFieldMixin become public API when it is possible to\n    create a non-integer automatically-generated field using column defaults\n    stored in the database.\n\n    In many areas Django also relies on using isinstance() to check for an\n    automatically-generated field as a subclass of AutoField. A new flag needs\n    to be implemented on Field to be used instead.\n\n    When these issues have been addressed, this metaclass could be used to\n    deprecate backward inheritance compatibility.\n    \"\"\"\n\n    @property\n    def _subclasses(self):\n        return (BigAutoField, SmallAutoField)\n\n    def __instancecheck__(self, instance):\n        return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\nclass AutoFieldMeta(type):\n    \"\"\"\n    Metaclass to maintain backward inheritance compatibility for AutoField.\n\n    It is intended that AutoFieldMixin become public API when it is possible to\n    create a non-integer automatically-generated field using column defaults\n    stored in the database.\n\n    In many areas Django also relies on using isinstance() to check for an\n    automatically-generated field as a subclass of AutoField. A new flag needs\n    to be implemented on Field to be used instead.\n\n    When these issues have been addressed, this metaclass could be used to\n    deprecate backward inheritance compatibility for AutoField.\n\n    See PEP 3119 -- Introducing Abstract Base Classes (#9264).\n    \"\"\"\n\n    @property\n    def _subclasses(self):\n        return (BigAutoField, SmallAutoField)\n\n    def __instancecheck__(cls, instance):\n        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n\n    def __subclasscheck__(cls, subclass):\n        return (\n            subclass in cls._subclasses or \n            any(issubclass(subclass, cls) for cls in cls._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\nclass AutoFieldMeta(type):\n    \"\"\"\n    Metaclass to maintain backward inheritance compatibility for AutoField.\n\n    It is intended that AutoFieldMixin become public API when it is possible to\n    create a non-integer automatically-generated field using column defaults\n    stored in the database.\n\n    In many areas Django also relies on using isinstance() to check for an\n    automatically-generated field as a subclass of AutoField. A new flag needs\n    to be implemented on Field to be used instead.\n\n    When these issues have been addressed, this metaclass could be used to\n    deprecate backward inheritance compatibility.\n    \"\"\"\n\n    @property\n    def _subclasses(self):\n        return (BigAutoField, SmallAutoField)\n\n    def __instancecheck__(cls, instance):\n        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n\n    def __subclasscheck__(cls, subclass):\n        return (\n            subclass in cls._subclasses or \n            any(issubclass(subclass, subcls) for subcls in cls._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\nclass AutoFieldMeta(type):\n    \"\"\"\n    Metaclass to maintain backward inheritance compatibility for AutoField.\n\n    It is intended that AutoFieldMixin become public API when it is possible to\n    create a non-integer automatically-generated field using column defaults\n    stored in the database.\n\n    In many areas Django also relies on using isinstance() to check for an\n    automatically-generated field as a subclass of AutoField. A new flag needs\n    to be implemented on Field to be used instead.\n\n    When these issues have been addressed, this metaclass could be used to\n    deprecate inheritance from AutoField and use the mixin instead.\n    \"\"\"\n\n    @property\n    def _subclasses(self):\n        return (BigAutoField, SmallAutoField)\n\n    def __instancecheck__(self, instance):\n        return isinstance(instance, self._subclasses) or super().__instancecheck__(\n            instance\n        )\n\n    def __subclasscheck__(self, subclass):\n        return (\n            subclass in self._subclasses or \n            any(issubclass(subclass, cls) for cls in self._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\nclass AutoFieldMeta(type):\n    \"\"\"\n    Metaclass to maintain backward inheritance compatibility for AutoField.\n\n    It is intended that AutoFieldMixin become public API when it is possible to\n    create a non-integer automatically-generated field using column defaults\n    stored in the database.\n\n    In many areas Django also relies on using isinstance() to check for an\n    automatically-generated field as a subclass of AutoField. A new flag needs\n    to be implemented on Field to be used instead.\n\n    When these issues have been addressed, this metaclass could be used to\n    deprecate the AutoFieldMixin.\n    \"\"\"\n\n    @property\n    def _subclasses(self):\n        return (BigAutoField, SmallAutoField)\n\n    def __instancecheck__(cls, instance):\n        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n\n    def __subclasscheck__(cls, subclass):\n        return (\n            subclass in cls._subclasses or \n            any(issubclass(subclass, subcls) for subcls in cls._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\nclass AutoFieldMeta(type):\n    \"\"\"\n    Metaclass to maintain backward inheritance compatibility for AutoField.\n\n    It is intended that AutoFieldMixin become public API when it is possible to\n    create a non-integer automatically-generated field using column defaults\n    stored in the database.\n\n    In many areas Django also relies on using isinstance() to check for an\n    automatically-generated field as a subclass of AutoField. A new flag needs\n    to be implemented on Field to be used instead.\n\n    When these issues have been addressed, this metaclass could be used to\n    deprecate the AutoFieldMixin.\n    \"\"\"\n\n    @property\n    def _subclasses(self):\n        return (BigAutoField, SmallAutoField)\n\n    def __instancecheck__(cls, instance):\n        return (\n            instance.__class__ in cls._subclasses\n            or super().__instancecheck__(instance)\n        )\n\n    def __subclasscheck__(cls, subclass):\n        return (\n            subclass in cls._subclasses or \n            any(issubclass(subclass, cls) for cls in cls._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n",
      "\nclass AutoFieldMeta(type):\n    \"\"\"\n    Metaclass to maintain backward inheritance compatibility for AutoField.\n\n    It is intended that AutoFieldMixin become public API when it is possible to\n    create a non-integer automatically-generated field using column defaults\n    stored in the database.\n\n    In many areas Django also relies on using isinstance() to check for an\n    automatically-generated field as a subclass of AutoField. A new flag needs\n    to be implemented on Field to be used instead.\n\n    When these issues have been addressed, this metaclass could be used to\n    deprecate backward inheritance compatibility.\n    \"\"\"\n\n    @property\n    def _subclasses(self):\n        return (BigAutoField, SmallAutoField)\n\n    def __instancecheck__(cls, instance):\n        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n\n    def __subclasscheck__(cls, subclass):\n        return (\n            subclass in cls._subclasses or \n            any(issubclass(subclass, subcls) for subcls in cls._subclasses) or \n            super().__subclasscheck__(subclass)\n        )\n"
    ],
    "Location 4 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 2530-2532)": [
      "\nclass AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n    \"\"\"\n    A IntegerField which automatically populates itself with an auto-\n    incrementing primary key.\n    \"\"\"\n    def get_internal_type(self):\n        return 'AutoField'\n",
      "\nclass AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n\n    def get_internal_type(self):\n",
      "\nclass AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n    \"\"\"\n    An IntegerField which automatically increments according to available IDs.\n    \"\"\"\n    def get_internal_type(self):\n        return 'AutoField'\n",
      "\nclass AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n    \"\"\"\n    An IntegerField which automatically populates itself with an auto-\n    incrementing primary key.\n    \"\"\"\n    def get_internal_type(self):\n        return 'AutoField'\n",
      "\nclass AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n    \"\"\"\n    A primary key field that automatically increments.\n    \"\"\"\n\n    def get_internal_type(self):\n        return 'AutoField'\n",
      "\nclass AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n    \"\"\"\n    An IntegerField which automatically increments according to available IDs.\n    \"\"\"\n    \n    def get_internal_type(self):\n        return 'AutoField'\n",
      "\nclass AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n\n    def get_internal_type(self):\n",
      "\nclass AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n    \"\"\"\n    An IntegerField which automatically increments according to available IDs.\n    \"\"\"\n    def get_internal_type(self):\n        return 'AutoField'\n"
    ],
    "Location 5 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 2548-2554)": [
      "\nclass SmallAutoField(AutoFieldMixin, SmallIntegerField):\n\n    def get_internal_type(self):\n        return 'SmallAutoField'\n\n    def rel_db_type(self, connection):\n        return SmallIntegerField().db_type(connection=connection)\n",
      "\nclass SmallAutoField(AutoFieldMixin, SmallIntegerField):\n\n    def get_internal_type(self):\n        return 'SmallAutoField'\n\n    def rel_db_type(self, connection):\n        return SmallIntegerField().db_type(connection=connection)\n",
      "\nclass SmallAutoField(AutoFieldMixin, SmallIntegerField):\n\n    def get_internal_type(self):\n        return 'SmallAutoField'\n\n    def rel_db_type(self, connection):\n        return SmallIntegerField().db_type(connection=connection)\n",
      "\nclass SmallAutoField(AutoFieldMixin, SmallIntegerField):\n\n    def get_internal_type(self):\n        return 'SmallAutoField'\n\n    def rel_db_type(self, connection):\n        return SmallIntegerField().db_type(connection=connection)\n",
      "\nclass SmallAutoField(AutoFieldMixin, SmallIntegerField):\n\n    def get_internal_type(self):\n        return 'SmallAutoField'\n\n    def rel_db_type(self, connection):\n        return SmallIntegerField().db_type(connection=connection)\n",
      "\nclass SmallAutoField(AutoFieldMixin, SmallIntegerField):\n\n    def get_internal_type(self):\n        return 'SmallAutoField'\n\n    def rel_db_type(self, connection):\n        return SmallIntegerField().db_type(connection=connection)\n",
      "\nclass SmallAutoField(AutoFieldMixin, SmallIntegerField):\n\n    def get_internal_type(self):\n        return 'SmallAutoField'\n\n    def rel_db_type(self, connection):\n        return SmallIntegerField().db_type(connection=connection)\n",
      "\nclass SmallAutoField(AutoFieldMixin, SmallIntegerField):\n\n    def get_internal_type(self):\n        return 'SmallAutoField'\n\n    def rel_db_type(self, connection):\n        return SmallIntegerField().db_type(connection=connection)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..b65d2ad59e 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2499,6 +2499,7 @@ class AutoFieldMixin:\n         return None\n \n \n+\n class AutoFieldMeta(type):\n     \"\"\"\n     Metaclass to maintain backward inheritance compatibility for AutoField.\n@@ -2523,8 +2524,14 @@ class AutoFieldMeta(type):\n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n+\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n@@ -2545,6 +2552,7 @@ class BigAutoField(AutoFieldMixin, BigIntegerField):\n         return BigIntegerField().db_type(connection=connection)\n \n \n+\n class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n     def get_internal_type(self):\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..31a45cd95b 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,6 +242,7 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n+\n         if not issubclass(pk_class, AutoField):\n             raise ValueError(\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n",
    "variant_0": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..5dc7ef3b8d 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2499,6 +2499,7 @@ class AutoFieldMixin:\n         return None\n \n \n+\n class AutoFieldMeta(type):\n     \"\"\"\n     Metaclass to maintain backward inheritance compatibility for AutoField.\n@@ -2511,6 +2512,32 @@ class AutoFieldMeta(type):\n     automatically-generated field as a subclass of AutoField. A new flag needs\n     to be implemented on Field to be used instead.\n \n+    When these issues have been addressed, this metaclass could be used to\n+    deprecate backward inheritance compatibility.\n+    \"\"\"\n+\n+    @property\n+    def _subclasses(self):\n+        return (BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(cls, instance):\n+        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n+\n+    def __subclasscheck__(cls, subclass):\n+        return (\n+            subclass in cls._subclasses or \n+            any(issubclass(subclass, subcls) for subcls in cls._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n+\n+    It is intended that AutoFieldMixin become public API when it is possible to\n+    create a non-integer automatically-generated field using column defaults\n+    stored in the database.\n+\n+    In many areas Django also relies on using isinstance() to check for an\n+    automatically-generated field as a subclass of AutoField. A new flag needs\n+    to be implemented on Field to be used instead.\n+\n     When these issues have been addressed, this metaclass could be used to\n     deprecate inheritance from AutoField and use of isinstance() with AutoField\n     for detecting automatically-generated fields.\n@@ -2523,12 +2550,20 @@ class AutoFieldMeta(type):\n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n \n \n-class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n \n+class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n+    \"\"\"\n+    An IntegerField which automatically increments according to available IDs.\n+    \"\"\"\n     def get_internal_type(self):\n         return 'AutoField'\n \n@@ -2545,6 +2580,7 @@ class BigAutoField(AutoFieldMixin, BigIntegerField):\n         return BigIntegerField().db_type(connection=connection)\n \n \n+\n class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n     def get_internal_type(self):\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..31b748251d 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,13 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+    def __subclasscheck__(self, subclass):\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n",
    "variant_1": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..d3fa6d9ea2 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2499,6 +2499,7 @@ class AutoFieldMixin:\n         return None\n \n \n+\n class AutoFieldMeta(type):\n     \"\"\"\n     Metaclass to maintain backward inheritance compatibility for AutoField.\n@@ -2511,6 +2512,32 @@ class AutoFieldMeta(type):\n     automatically-generated field as a subclass of AutoField. A new flag needs\n     to be implemented on Field to be used instead.\n \n+    When these issues have been addressed, this metaclass could be used to\n+    deprecate the AutoFieldMixin.\n+    \"\"\"\n+\n+    @property\n+    def _subclasses(self):\n+        return (BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(cls, instance):\n+        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n+\n+    def __subclasscheck__(cls, subclass):\n+        return (\n+            subclass in cls._subclasses or \n+            any(issubclass(subclass, subcls) for subcls in cls._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n+\n+    It is intended that AutoFieldMixin become public API when it is possible to\n+    create a non-integer automatically-generated field using column defaults\n+    stored in the database.\n+\n+    In many areas Django also relies on using isinstance() to check for an\n+    automatically-generated field as a subclass of AutoField. A new flag needs\n+    to be implemented on Field to be used instead.\n+\n     When these issues have been addressed, this metaclass could be used to\n     deprecate inheritance from AutoField and use of isinstance() with AutoField\n     for detecting automatically-generated fields.\n@@ -2523,14 +2550,24 @@ class AutoFieldMeta(type):\n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n \n \n-class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n \n+class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n+    \"\"\"\n+    A IntegerField which automatically populates itself with an auto-\n+    incrementing primary key.\n+    \"\"\"\n     def get_internal_type(self):\n         return 'AutoField'\n+        return 'AutoField'\n \n     def rel_db_type(self, connection):\n         return IntegerField().db_type(connection=connection)\n@@ -2545,6 +2582,7 @@ class BigAutoField(AutoFieldMixin, BigIntegerField):\n         return BigIntegerField().db_type(connection=connection)\n \n \n+\n class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n     def get_internal_type(self):\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..a58807e41f 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,13 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+def __subclasscheck__(self, subclass):\n+    return (\n+        subclass in self._subclasses or \n+        any(issubclass(subclass, cls) for cls in self._subclasses) or \n+        super().__subclasscheck__(subclass)\n+    )\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n",
    "variant_2": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..57cd93953f 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2499,6 +2499,7 @@ class AutoFieldMixin:\n         return None\n \n \n+\n class AutoFieldMeta(type):\n     \"\"\"\n     Metaclass to maintain backward inheritance compatibility for AutoField.\n@@ -2511,6 +2512,32 @@ class AutoFieldMeta(type):\n     automatically-generated field as a subclass of AutoField. A new flag needs\n     to be implemented on Field to be used instead.\n \n+    When these issues have been addressed, this metaclass could be used to\n+    deprecate backward inheritance compatibility.\n+    \"\"\"\n+\n+    @property\n+    def _subclasses(self):\n+        return (BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(self, instance):\n+        return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n+\n+    def __subclasscheck__(self, subclass):\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n+\n+    It is intended that AutoFieldMixin become public API when it is possible to\n+    create a non-integer automatically-generated field using column defaults\n+    stored in the database.\n+\n+    In many areas Django also relies on using isinstance() to check for an\n+    automatically-generated field as a subclass of AutoField. A new flag needs\n+    to be implemented on Field to be used instead.\n+\n     When these issues have been addressed, this metaclass could be used to\n     deprecate inheritance from AutoField and use of isinstance() with AutoField\n     for detecting automatically-generated fields.\n@@ -2523,8 +2550,14 @@ class AutoFieldMeta(type):\n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n+\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n@@ -2545,6 +2578,7 @@ class BigAutoField(AutoFieldMixin, BigIntegerField):\n         return BigIntegerField().db_type(connection=connection)\n \n \n+\n class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n     def get_internal_type(self):\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..31b748251d 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,13 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+    def __subclasscheck__(self, subclass):\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n",
    "variant_3": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..8cf33885b4 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2499,6 +2499,7 @@ class AutoFieldMixin:\n         return None\n \n \n+\n class AutoFieldMeta(type):\n     \"\"\"\n     Metaclass to maintain backward inheritance compatibility for AutoField.\n@@ -2511,6 +2512,34 @@ class AutoFieldMeta(type):\n     automatically-generated field as a subclass of AutoField. A new flag needs\n     to be implemented on Field to be used instead.\n \n+    When these issues have been addressed, this metaclass could be used to\n+    deprecate backward inheritance compatibility for AutoField.\n+\n+    See PEP 3119 -- Introducing Abstract Base Classes (#9264).\n+    \"\"\"\n+\n+    @property\n+    def _subclasses(self):\n+        return (BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(cls, instance):\n+        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n+\n+    def __subclasscheck__(cls, subclass):\n+        return (\n+            subclass in cls._subclasses or \n+            any(issubclass(subclass, cls) for cls in cls._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n+\n+    It is intended that AutoFieldMixin become public API when it is possible to\n+    create a non-integer automatically-generated field using column defaults\n+    stored in the database.\n+\n+    In many areas Django also relies on using isinstance() to check for an\n+    automatically-generated field as a subclass of AutoField. A new flag needs\n+    to be implemented on Field to be used instead.\n+\n     When these issues have been addressed, this metaclass could be used to\n     deprecate inheritance from AutoField and use of isinstance() with AutoField\n     for detecting automatically-generated fields.\n@@ -2523,14 +2552,23 @@ class AutoFieldMeta(type):\n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n \n \n-class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n \n+class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n+    \"\"\"\n+    An IntegerField which automatically increments according to available IDs.\n+    \"\"\"\n     def get_internal_type(self):\n         return 'AutoField'\n+        return 'AutoField'\n \n     def rel_db_type(self, connection):\n         return IntegerField().db_type(connection=connection)\n@@ -2545,6 +2583,7 @@ class BigAutoField(AutoFieldMixin, BigIntegerField):\n         return BigIntegerField().db_type(connection=connection)\n \n \n+\n class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n     def get_internal_type(self):\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..31b748251d 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,13 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+    def __subclasscheck__(self, subclass):\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n",
    "variant_4": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..94ffb06a14 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2499,6 +2499,7 @@ class AutoFieldMixin:\n         return None\n \n \n+\n class AutoFieldMeta(type):\n     \"\"\"\n     Metaclass to maintain backward inheritance compatibility for AutoField.\n@@ -2511,6 +2512,32 @@ class AutoFieldMeta(type):\n     automatically-generated field as a subclass of AutoField. A new flag needs\n     to be implemented on Field to be used instead.\n \n+    When these issues have been addressed, this metaclass could be used to\n+    deprecate backward inheritance compatibility.\n+    \"\"\"\n+\n+    @property\n+    def _subclasses(self):\n+        return (BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(cls, instance):\n+        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n+\n+    def __subclasscheck__(cls, subclass):\n+        return (\n+            subclass in cls._subclasses or \n+            any(issubclass(subclass, subcls) for subcls in cls._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n+\n+    It is intended that AutoFieldMixin become public API when it is possible to\n+    create a non-integer automatically-generated field using column defaults\n+    stored in the database.\n+\n+    In many areas Django also relies on using isinstance() to check for an\n+    automatically-generated field as a subclass of AutoField. A new flag needs\n+    to be implemented on Field to be used instead.\n+\n     When these issues have been addressed, this metaclass could be used to\n     deprecate inheritance from AutoField and use of isinstance() with AutoField\n     for detecting automatically-generated fields.\n@@ -2523,14 +2550,24 @@ class AutoFieldMeta(type):\n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n \n \n-class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n \n+class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n+    \"\"\"\n+    An IntegerField which automatically populates itself with an auto-\n+    incrementing primary key.\n+    \"\"\"\n     def get_internal_type(self):\n         return 'AutoField'\n+        return 'AutoField'\n \n     def rel_db_type(self, connection):\n         return IntegerField().db_type(connection=connection)\n@@ -2545,6 +2582,7 @@ class BigAutoField(AutoFieldMixin, BigIntegerField):\n         return BigIntegerField().db_type(connection=connection)\n \n \n+\n class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n     def get_internal_type(self):\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..31b748251d 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,13 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+    def __subclasscheck__(self, subclass):\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n",
    "variant_5": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..605f4b90cd 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2499,6 +2499,7 @@ class AutoFieldMixin:\n         return None\n \n \n+\n class AutoFieldMeta(type):\n     \"\"\"\n     Metaclass to maintain backward inheritance compatibility for AutoField.\n@@ -2511,6 +2512,34 @@ class AutoFieldMeta(type):\n     automatically-generated field as a subclass of AutoField. A new flag needs\n     to be implemented on Field to be used instead.\n \n+    When these issues have been addressed, this metaclass could be used to\n+    deprecate inheritance from AutoField and use the mixin instead.\n+    \"\"\"\n+\n+    @property\n+    def _subclasses(self):\n+        return (BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(self, instance):\n+        return isinstance(instance, self._subclasses) or super().__instancecheck__(\n+            instance\n+        )\n+\n+    def __subclasscheck__(self, subclass):\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n+\n+    It is intended that AutoFieldMixin become public API when it is possible to\n+    create a non-integer automatically-generated field using column defaults\n+    stored in the database.\n+\n+    In many areas Django also relies on using isinstance() to check for an\n+    automatically-generated field as a subclass of AutoField. A new flag needs\n+    to be implemented on Field to be used instead.\n+\n     When these issues have been addressed, this metaclass could be used to\n     deprecate inheritance from AutoField and use of isinstance() with AutoField\n     for detecting automatically-generated fields.\n@@ -2523,14 +2552,24 @@ class AutoFieldMeta(type):\n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n+\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n+    \"\"\"\n+    A primary key field that automatically increments.\n+    \"\"\"\n \n     def get_internal_type(self):\n         return 'AutoField'\n+        return 'AutoField'\n \n     def rel_db_type(self, connection):\n         return IntegerField().db_type(connection=connection)\n@@ -2545,6 +2584,7 @@ class BigAutoField(AutoFieldMixin, BigIntegerField):\n         return BigIntegerField().db_type(connection=connection)\n \n \n+\n class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n     def get_internal_type(self):\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..31b748251d 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,13 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+    def __subclasscheck__(self, subclass):\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n",
    "variant_6": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..26d9404a72 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2499,6 +2499,7 @@ class AutoFieldMixin:\n         return None\n \n \n+\n class AutoFieldMeta(type):\n     \"\"\"\n     Metaclass to maintain backward inheritance compatibility for AutoField.\n@@ -2511,6 +2512,32 @@ class AutoFieldMeta(type):\n     automatically-generated field as a subclass of AutoField. A new flag needs\n     to be implemented on Field to be used instead.\n \n+    When these issues have been addressed, this metaclass could be used to\n+    deprecate the AutoFieldMixin.\n+    \"\"\"\n+\n+    @property\n+    def _subclasses(self):\n+        return (BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(cls, instance):\n+        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n+\n+    def __subclasscheck__(cls, subclass):\n+        return (\n+            subclass in cls._subclasses or \n+            any(issubclass(subclass, subcls) for subcls in cls._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n+\n+    It is intended that AutoFieldMixin become public API when it is possible to\n+    create a non-integer automatically-generated field using column defaults\n+    stored in the database.\n+\n+    In many areas Django also relies on using isinstance() to check for an\n+    automatically-generated field as a subclass of AutoField. A new flag needs\n+    to be implemented on Field to be used instead.\n+\n     When these issues have been addressed, this metaclass could be used to\n     deprecate inheritance from AutoField and use of isinstance() with AutoField\n     for detecting automatically-generated fields.\n@@ -2523,14 +2550,24 @@ class AutoFieldMeta(type):\n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n \n \n-class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n \n+class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n+    \"\"\"\n+    An IntegerField which automatically increments according to available IDs.\n+    \"\"\"\n+    \n     def get_internal_type(self):\n         return 'AutoField'\n+        return 'AutoField'\n \n     def rel_db_type(self, connection):\n         return IntegerField().db_type(connection=connection)\n@@ -2545,6 +2582,7 @@ class BigAutoField(AutoFieldMixin, BigIntegerField):\n         return BigIntegerField().db_type(connection=connection)\n \n \n+\n class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n     def get_internal_type(self):\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..31b748251d 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,13 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+    def __subclasscheck__(self, subclass):\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n",
    "variant_7": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..86c704043f 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2499,6 +2499,7 @@ class AutoFieldMixin:\n         return None\n \n \n+\n class AutoFieldMeta(type):\n     \"\"\"\n     Metaclass to maintain backward inheritance compatibility for AutoField.\n@@ -2511,6 +2512,35 @@ class AutoFieldMeta(type):\n     automatically-generated field as a subclass of AutoField. A new flag needs\n     to be implemented on Field to be used instead.\n \n+    When these issues have been addressed, this metaclass could be used to\n+    deprecate the AutoFieldMixin.\n+    \"\"\"\n+\n+    @property\n+    def _subclasses(self):\n+        return (BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(cls, instance):\n+        return (\n+            instance.__class__ in cls._subclasses\n+            or super().__instancecheck__(instance)\n+        )\n+\n+    def __subclasscheck__(cls, subclass):\n+        return (\n+            subclass in cls._subclasses or \n+            any(issubclass(subclass, cls) for cls in cls._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n+\n+    It is intended that AutoFieldMixin become public API when it is possible to\n+    create a non-integer automatically-generated field using column defaults\n+    stored in the database.\n+\n+    In many areas Django also relies on using isinstance() to check for an\n+    automatically-generated field as a subclass of AutoField. A new flag needs\n+    to be implemented on Field to be used instead.\n+\n     When these issues have been addressed, this metaclass could be used to\n     deprecate inheritance from AutoField and use of isinstance() with AutoField\n     for detecting automatically-generated fields.\n@@ -2523,8 +2553,14 @@ class AutoFieldMeta(type):\n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n+\n \n \n class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n@@ -2545,6 +2581,7 @@ class BigAutoField(AutoFieldMixin, BigIntegerField):\n         return BigIntegerField().db_type(connection=connection)\n \n \n+\n class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n     def get_internal_type(self):\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..31b748251d 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,13 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+    def __subclasscheck__(self, subclass):\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n",
    "variant_8": "diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 0f53d9c30b..2c82031fb0 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2499,6 +2499,7 @@ class AutoFieldMixin:\n         return None\n \n \n+\n class AutoFieldMeta(type):\n     \"\"\"\n     Metaclass to maintain backward inheritance compatibility for AutoField.\n@@ -2511,6 +2512,32 @@ class AutoFieldMeta(type):\n     automatically-generated field as a subclass of AutoField. A new flag needs\n     to be implemented on Field to be used instead.\n \n+    When these issues have been addressed, this metaclass could be used to\n+    deprecate backward inheritance compatibility.\n+    \"\"\"\n+\n+    @property\n+    def _subclasses(self):\n+        return (BigAutoField, SmallAutoField)\n+\n+    def __instancecheck__(cls, instance):\n+        return isinstance(instance, cls._subclasses) or super().__instancecheck__(instance)\n+\n+    def __subclasscheck__(cls, subclass):\n+        return (\n+            subclass in cls._subclasses or \n+            any(issubclass(subclass, subcls) for subcls in cls._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n+\n+    It is intended that AutoFieldMixin become public API when it is possible to\n+    create a non-integer automatically-generated field using column defaults\n+    stored in the database.\n+\n+    In many areas Django also relies on using isinstance() to check for an\n+    automatically-generated field as a subclass of AutoField. A new flag needs\n+    to be implemented on Field to be used instead.\n+\n     When these issues have been addressed, this metaclass could be used to\n     deprecate inheritance from AutoField and use of isinstance() with AutoField\n     for detecting automatically-generated fields.\n@@ -2523,14 +2550,23 @@ class AutoFieldMeta(type):\n     def __instancecheck__(self, instance):\n         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n \n+\n     def __subclasscheck__(self, subclass):\n-        return subclass in self._subclasses or super().__subclasscheck__(subclass)\n+        return (\n+            subclass in self._subclasses or \n+            any(issubclass(subclass, cls) for cls in self._subclasses) or \n+            super().__subclasscheck__(subclass)\n+        )\n \n \n-class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n \n+class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n+    \"\"\"\n+    An IntegerField which automatically increments according to available IDs.\n+    \"\"\"\n     def get_internal_type(self):\n         return 'AutoField'\n+        return 'AutoField'\n \n     def rel_db_type(self, connection):\n         return IntegerField().db_type(connection=connection)\n@@ -2545,6 +2581,7 @@ class BigAutoField(AutoFieldMixin, BigIntegerField):\n         return BigIntegerField().db_type(connection=connection)\n \n \n+\n class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n \n     def get_internal_type(self):\ndiff --git a/django/db/models/options.py b/django/db/models/options.py\nindex 4028e05b99..a58807e41f 100644\n--- a/django/db/models/options.py\n+++ b/django/db/models/options.py\n@@ -242,8 +242,13 @@ class Options:\n                 f\"not be imported.\"\n             )\n             raise ImproperlyConfigured(msg) from e\n-        if not issubclass(pk_class, AutoField):\n-            raise ValueError(\n+\n+def __subclasscheck__(self, subclass):\n+    return (\n+        subclass in self._subclasses or \n+        any(issubclass(subclass, cls) for cls in self._subclasses) or \n+        super().__subclasscheck__(subclass)\n+    )\n                 f\"Primary key '{pk_class_path}' referred by {source} must \"\n                 f\"subclass AutoField.\"\n             )\n"
  }
}