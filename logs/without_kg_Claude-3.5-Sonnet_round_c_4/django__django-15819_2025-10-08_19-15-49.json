{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/core/management/commands/inspectdb.py lines 134-136)": "\n                used_column_names = []  # Holds column names used in the table so far\n                column_to_field_name = {}  # Maps column names to names of model fields\n                foreign_key_fields = {}  # Maps related model names to field names for related_name generation\n                for row in table_description:\n",
    "Location 2 (/root/hy/projects_4/django/django/core/management/commands/inspectdb.py lines 165-188)": "\n                # Track foreign key relationships for related_name generation\n                fk_relations = {}\n                for column_name in [row[0] for row in table_description]:\n                    if column_name in relations:\n                        ref_db_column, ref_db_table = relations[column_name]\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        if rel_to not in fk_relations:\n                            fk_relations[rel_to] = []\n                        fk_relations[rel_to].append(column_name)\n\n                for row in table_description:\n                    column_name = row[0]\n                    comment_notes = []\n                    extra_params = OrderedDict()\n                    column_name = row[0]\n                    is_relation = column_name in relations\n\n                    att_name, params, notes = self.normalize_col_name(\n                        column_name, used_column_names, is_relation\n                    )\n                    extra_params.update(params)\n                    comment_notes.extend(notes)\n\n                    used_column_names.add(att_name)\n\n                    # Add primary_key and unique, if necessary.\n                    if column_name in primary_key_columns:\n                        extra_params[\"primary_key\"] = True\n                        if len(primary_key_columns) > 1:\n                            comment_notes.append(\n                                \"The composite primary key (%s) found, that is not \"\n                                \"supported. The first column is selected.\"\n                                % \", \".join(primary_key_columns)\n                            )\n                    elif column_name in unique_columns:\n                        extra_params[\"unique\"] = True\n\n                    if is_relation:\n                        ref_db_column, ref_db_table = relations[column_name]\n                        if extra_params.pop(\"unique\", False) or extra_params.get(\n                            \"primary_key\"\n                        ):\n                            rel_type = \"OneToOneField\"\n                        else:\n                            rel_type = \"ForeignKey\"\n                            ref_pk_column = (\n                                connection.introspection.get_primary_key_column(\n                                    cursor, ref_db_table\n                                )\n                            )\n                            if ref_pk_column and ref_pk_column != ref_db_column:\n                                extra_params[\"to_field\"] = ref_db_column\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        \n                        # Add related_name if multiple FKs point to the same model\n                        if rel_to in fk_relations and len(fk_relations[rel_to]) > 1:\n                            extra_params[\"related_name\"] = att_name\n                        \n                        if rel_to in known_models:\n                            field_type = \"%s(%s\" % (rel_type, rel_to)\n                        else:\n                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n",
    "Location 3 (/root/hy/projects_4/django/django/core/management/commands/inspectdb.py lines 180-184)": "\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        \n                        # Track foreign key fields pointing to the same model\n                        fk_key = (table_name, rel_to)\n                        if fk_key not in fk_field_counts:\n                            fk_field_counts[fk_key] = []\n                        fk_field_counts[fk_key].append(att_name)\n",
    "Location 4 (/root/hy/projects_4/django/django/core/management/commands/inspectdb.py lines 227-232)": "\n                    if extra_params:\n                        if not field_desc.endswith(\"(\"):\n                            field_desc += \", \"\n                        field_desc += \", \".join(\n                            \"%s=%r\" % (k, v) for k, v in extra_params.items()\n                        )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/core/management/commands/inspectdb.py lines 134-136)": [
      "\n                used_column_names = []  # Holds column names used in the table so far\n                column_to_field_name = {}  # Maps column names to names of model fields\n                fk_relations = {}  # Maps related model names to list of field names that reference them\n                for row in table_description:\n",
      "\n                used_column_names = []  # Holds column names used in the table so far\n                column_to_field_name = {}  # Maps column names to names of model fields\n                foreign_key_targets = {}  # Maps related model names to list of field names pointing to them\n                for row in table_description:\n",
      "\n                used_column_names = []  # Holds column names used in the table so far\n                column_to_field_name = {}  # Maps column names to names of model fields\n                foreign_key_relations = {}  # Maps related model names to field names for related_name generation\n                for row in table_description:\n",
      "\n                used_column_names = []  # Holds column names used in the table so far\n                column_to_field_name = {}  # Maps column names to names of model fields\n                related_models = {}  # Maps related model names to list of field names\n                for row in table_description:\n",
      "\n                used_column_names = []  # Holds column names used in the table so far\n                column_to_field_name = {}  # Maps column names to names of model fields\n                foreign_key_relations = {}  # Track foreign key relations for related_name generation\n                for row in table_description:\n",
      "\n                used_column_names = []  # Holds column names used in the table so far\n                column_to_field_name = {}  # Maps column names to names of model fields\n                field_name_to_related_model = {}  # Maps field names to their related models\n                for row in table_description:\n",
      "\n                used_column_names = []  # Holds column names used in the table so far\n                column_to_field_name = {}  # Maps column names to names of model fields\n                foreign_key_targets = {}  # Maps target models to list of field names referencing them\n                for row in table_description:\n",
      "\n                used_column_names = []  # Holds column names used in the table so far\n                column_to_field_name = {}  # Maps column names to names of model fields\n                foreign_key_fields = {}  # Maps related model names to list of field names\n                for row in table_description:\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/core/management/commands/inspectdb.py lines 165-188)": [
      "\n                if is_relation:\n                    ref_db_column, ref_db_table = relations[column_name]\n                    if extra_params.pop(\"unique\", False) or extra_params.get(\n                        \"primary_key\"\n                    ):\n                        rel_type = \"OneToOneField\"\n                    else:\n                        rel_type = \"ForeignKey\"\n                        ref_pk_column = (\n                            connection.introspection.get_primary_key_column(\n                                cursor, ref_db_table\n                            )\n                        )\n                        if ref_pk_column and ref_pk_column != ref_db_column:\n                            extra_params[\"to_field\"] = ref_db_column\n                    rel_to = (\n                        \"self\"\n                        if ref_db_table == table_name\n                        else table2model(ref_db_table)\n                    )\n                    \n                    # Track foreign key relationships for related_name generation\n                    if rel_to not in fk_relations:\n                        fk_relations[rel_to] = []\n                    fk_relations[rel_to].append(column_name)\n                    \n                    if rel_to in known_models:\n                        field_type = \"%s(%s\" % (rel_type, rel_to)\n                    else:\n                        field_type = \"%s('%s'\" % (rel_type, rel_to)\n",
      "\n                # Track foreign key relationships to detect multiple FKs to same model\n                fk_relationships = {}\n                for column_name in [row.name for row in table_description]:\n                    is_relation = column_name in relations\n                    if is_relation:\n                        ref_db_column, ref_db_table = relations[column_name]\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        if rel_to not in fk_relationships:\n                            fk_relationships[rel_to] = []\n                        fk_relationships[rel_to].append(column_name)\n\n                for row in table_description:\n                    column_name = row.name\n                    comment_notes = []\n                    extra_params = OrderedDict()\n                    column_name = row.name\n                    is_relation = column_name in relations\n\n                    if column_name in primary_key_columns:\n                        extra_params[\"primary_key\"] = True\n                        if len(primary_key_columns) > 1:\n                            comment_notes.append(\n                                \"The composite primary key (%s) found, that is not \"\n                                \"supported. The first column is selected.\"\n                                % \", \".join(primary_key_columns)\n                            )\n                    elif column_name in unique_columns:\n                        extra_params[\"unique\"] = True\n\n                    if is_relation:\n                        ref_db_column, ref_db_table = relations[column_name]\n                        if extra_params.pop(\"unique\", False) or extra_params.get(\n                            \"primary_key\"\n                        ):\n                            rel_type = \"OneToOneField\"\n                        else:\n                            rel_type = \"ForeignKey\"\n                            ref_pk_column = (\n                                connection.introspection.get_primary_key_column(\n                                    cursor, ref_db_table\n                                )\n                            )\n                            if ref_pk_column and ref_pk_column != ref_db_column:\n                                extra_params[\"to_field\"] = ref_db_column\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        \n                        # Add related_name if multiple FKs point to the same model\n                        if len(fk_relationships.get(rel_to, [])) > 1:\n                            extra_params[\"related_name\"] = f\"{table_name.lower()}_{column_name}_set\"\n                        \n                        if rel_to in known_models:\n                            field_type = \"%s(%s\" % (rel_type, rel_to)\n                        else:\n                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n",
      "\n                # Track foreign key relationships for related_name generation\n                fk_relationships = {}\n                for row in table_description:\n                    column_name = row.name\n                    if column_name in relations:\n                        ref_db_column, ref_db_table = relations[column_name]\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        if rel_to not in fk_relationships:\n                            fk_relationships[rel_to] = []\n                        fk_relationships[rel_to].append(column_name)\n\n                for row in table_description:\n                    comment_notes = (\n                        []\n                    )  # Holds Field notes, to be displayed in a Python comment.\n                    extra_params = OrderedDict()  # Holds Field parameters such as 'db_column'.\n                    column_name = row.name\n                    is_relation = column_name in relations\n\n                    att_name, params, notes = self.normalize_col_name(\n                        column_name, used_column_names, is_relation\n                    )\n                    extra_params.update(params)\n                    comment_notes.extend(notes)\n\n                    used_column_names.add(att_name)\n\n                    # Add primary_key and unique, if necessary.\n                    if column_name in primary_key_columns:\n                        extra_params[\"primary_key\"] = True\n                        if len(primary_key_columns) > 1:\n                            comment_notes.append(\n                                \"The composite primary key (%s) found, that is not \"\n                                \"supported. The first column is selected.\"\n                                % \", \".join(primary_key_columns)\n                            )\n                    elif column_name in unique_columns:\n                        extra_params[\"unique\"] = True\n\n                    if is_relation:\n                        ref_db_column, ref_db_table = relations[column_name]\n                        if extra_params.pop(\"unique\", False) or extra_params.get(\n                            \"primary_key\"\n                        ):\n                            rel_type = \"OneToOneField\"\n                        else:\n                            rel_type = \"ForeignKey\"\n                            ref_pk_column = (\n                                connection.introspection.get_primary_key_column(\n                                    cursor, ref_db_table\n                                )\n                            )\n                            if ref_pk_column and ref_pk_column != ref_db_column:\n                                extra_params[\"to_field\"] = ref_db_column\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        \n                        # Add related_name if multiple FKs point to the same model\n                        if rel_to in fk_relationships and len(fk_relationships[rel_to]) > 1:\n                            extra_params[\"related_name\"] = f\"{table2model(table_name).lower()}_{att_name}_set\"\n                        \n                        if rel_to in known_models:\n                            field_type = \"%s(%s\" % (rel_type, rel_to)\n                        else:\n                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n",
      "\n                    # Track foreign key relationships for related_name generation\n                    if table_name not in fk_relationships:\n                        fk_relationships[table_name] = {}\n                    \n                    if is_relation:\n                        ref_db_column, ref_db_table = relations[column_name]\n                        if extra_params.pop(\"unique\", False) or extra_params.get(\n                            \"primary_key\"\n                        ):\n                            rel_type = \"OneToOneField\"\n                        else:\n                            rel_type = \"ForeignKey\"\n                            ref_pk_column = (\n                                connection.introspection.get_primary_key_column(\n                                    cursor, ref_db_table\n                                )\n                            )\n                            if ref_pk_column and ref_pk_column != ref_db_column:\n                                extra_params[\"to_field\"] = ref_db_column\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        \n                        # Track this relationship for related_name generation\n                        if rel_to not in fk_relationships[table_name]:\n                            fk_relationships[table_name][rel_to] = []\n                        fk_relationships[table_name][rel_to].append(column_name)\n                        \n                        if rel_to in known_models:\n                            field_type = \"%s(%s\" % (rel_type, rel_to)\n                        else:\n                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n",
      "\n                    # Keep track of foreign key relationships for related_name generation\n                    if not hasattr(self, '_fk_relationships'):\n                        self._fk_relationships = {}\n                    \n                    if is_relation:\n                        ref_db_column, ref_db_table = relations[column_name]\n                        if extra_params.pop(\"unique\", False) or extra_params.get(\n                            \"primary_key\"\n                        ):\n                            rel_type = \"OneToOneField\"\n                        else:\n                            rel_type = \"ForeignKey\"\n                            ref_pk_column = (\n                                connection.introspection.get_primary_key_column(\n                                    cursor, ref_db_table\n                                )\n                            )\n                            if ref_pk_column and ref_pk_column != ref_db_column:\n                                extra_params[\"to_field\"] = ref_db_column\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        \n                        # Track foreign key relationships for related_name generation\n                        if table_name not in self._fk_relationships:\n                            self._fk_relationships[table_name] = {}\n                        if rel_to not in self._fk_relationships[table_name]:\n                            self._fk_relationships[table_name][rel_to] = []\n                        self._fk_relationships[table_name][rel_to].append(att_name)\n                        \n                        # Add related_name if multiple FKs point to the same model\n                        if len(self._fk_relationships[table_name][rel_to]) > 1 or (\n                            len(self._fk_relationships[table_name][rel_to]) == 1 and\n                            any(len(fields) > 1 for target, fields in self._fk_relationships[table_name].items() if target != rel_to)\n                        ):\n                            extra_params[\"related_name\"] = f\"'{att_name}'\"\n                        \n                        if rel_to in known_models:\n                            field_type = \"%s(%s\" % (rel_type, rel_to)\n                        else:\n                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n",
      "\n                # Track foreign key fields to detect multiple FKs to same model\n                fk_fields = {}\n                for row in table_description:\n                    column_name = row.name\n                    if column_name in relations:\n                        ref_db_column, ref_db_table = relations[column_name]\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        if rel_to not in fk_fields:\n                            fk_fields[rel_to] = []\n                        fk_fields[rel_to].append(column_name)\n\n                for row in table_description:\n                    comment_notes = (\n                        []\n                    )  # Holds Field notes, to be displayed in a Python comment.\n                    extra_params = OrderedDict()  # Holds Field parameters such as 'db_column'.\n                    column_name = row.name\n                    is_relation = column_name in relations\n\n                    att_name, params, notes = self.normalize_col_name(\n                        column_name, used_column_names, is_relation\n                    )\n                    extra_params.update(params)\n                    comment_notes.extend(notes)\n\n                    used_column_names.add(att_name)\n\n                    # Add primary_key and unique, if necessary.\n                    if column_name in primary_key_columns:\n                        extra_params[\"primary_key\"] = True\n                        if len(primary_key_columns) > 1:\n                            comment_notes.append(\n                                \"The composite primary key (%s) found, that is not \"\n                                \"supported. The first column is selected.\"\n                                % \", \".join(primary_key_columns)\n                            )\n                    elif column_name in unique_columns:\n                        extra_params[\"unique\"] = True\n\n                    if is_relation:\n                        ref_db_column, ref_db_table = relations[column_name]\n                        if extra_params.pop(\"unique\", False) or extra_params.get(\n                            \"primary_key\"\n                        ):\n                            rel_type = \"OneToOneField\"\n                        else:\n                            rel_type = \"ForeignKey\"\n                            ref_pk_column = (\n                                connection.introspection.get_primary_key_column(\n                                    cursor, ref_db_table\n                                )\n                            )\n                            if ref_pk_column and ref_pk_column != ref_db_column:\n                                extra_params[\"to_field\"] = ref_db_column\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        \n                        # Add related_name if multiple FKs point to same model\n                        if len(fk_fields.get(rel_to, [])) > 1:\n                            extra_params[\"related_name\"] = att_name\n                        \n                        if rel_to in known_models:\n                            field_type = \"%s(%s\" % (rel_type, rel_to)\n                        else:\n                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n",
      "\n                    # Track foreign key relationships for related_name generation\n                    if not hasattr(self, '_fk_relations'):\n                        self._fk_relations = {}\n                    \n                    if is_relation:\n                        ref_db_column, ref_db_table = relations[column_name]\n                        if extra_params.pop(\"unique\", False) or extra_params.get(\n                            \"primary_key\"\n                        ):\n                            rel_type = \"OneToOneField\"\n                        else:\n                            rel_type = \"ForeignKey\"\n                            ref_pk_column = (\n                                connection.introspection.get_primary_key_column(\n                                    cursor, ref_db_table\n                                )\n                            )\n                            if ref_pk_column and ref_pk_column != ref_db_column:\n                                extra_params[\"to_field\"] = ref_db_column\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        \n                        # Track this relationship for related_name generation\n                        if table_name not in self._fk_relations:\n                            self._fk_relations[table_name] = {}\n                        if rel_to not in self._fk_relations[table_name]:\n                            self._fk_relations[table_name][rel_to] = []\n                        self._fk_relations[table_name][rel_to].append(att_name)\n                        \n                        if rel_to in known_models:\n                            field_type = \"%s(%s\" % (rel_type, rel_to)\n                        else:\n                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n",
      "\n                # Keep track of foreign key fields to handle multiple FKs to same model\n                fk_fields = {}\n                \n                for row in table_description:\n                    comment_notes = []\n                    extra_params = OrderedDict()\n                    column_name = row.name\n                    is_relation = column_name in relations\n\n                    att_name, params, notes = self.normalize_col_name(\n                        column_name, used_column_names, is_relation\n                    )\n                    extra_params.update(params)\n                    comment_notes.extend(notes)\n\n                    used_column_names.add(att_name)\n\n                    # Add primary_key and unique, if necessary.\n                    if column_name in primary_key_columns:\n                        extra_params[\"primary_key\"] = True\n                        if len(primary_key_columns) > 1:\n                            comment_notes.append(\n                                \"The composite primary key (%s) found, that is not \"\n                                \"supported. The first column is selected.\"\n                                % \", \".join(primary_key_columns)\n                            )\n                    elif column_name in unique_columns:\n                        extra_params[\"unique\"] = True\n\n                    if is_relation:\n                        ref_db_column, ref_db_table = relations[column_name]\n                        if extra_params.pop(\"unique\", False) or extra_params.get(\n                            \"primary_key\"\n                        ):\n                            rel_type = \"OneToOneField\"\n                        else:\n                            rel_type = \"ForeignKey\"\n                            ref_pk_column = (\n                                connection.introspection.get_primary_key_column(\n                                    cursor, ref_db_table\n                                )\n                            )\n                            if ref_pk_column and ref_pk_column != ref_db_column:\n                                extra_params[\"to_field\"] = ref_db_column\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        \n                        # Track foreign key fields for related_name generation\n                        if rel_to not in fk_fields:\n                            fk_fields[rel_to] = []\n                        fk_fields[rel_to].append(att_name)\n                        \n                        if rel_to in known_models:\n                            field_type = \"%s(%s\" % (rel_type, rel_to)\n                        else:\n                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n"
    ],
    "Location 3 (/root/hy/projects_4/django/django/core/management/commands/inspectdb.py lines 180-184)": [
      "\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        \n                        # Add related_name to avoid clashing reverse accessors\n                        if rel_to != \"'%s'\" % table2model(table_name):\n                            # Track foreign keys to the same model to detect duplicates\n                            if rel_to not in fk_counts:\n                                fk_counts[rel_to] = []\n                            fk_counts[rel_to].append(column_name)\n                            \n                            # If multiple FKs to same model, add related_name\n                            if len(fk_counts[rel_to]) > 1:\n                                extra_params[\"related_name\"] = f\"'{column_name}'\"\n                                # Also add related_name to previous FK if not already done\n                                for prev_col in fk_counts[rel_to][:-1]:\n                                    # This will be handled in the field output generation\n                                    pass\n",
      "\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        \n                        # Track foreign key relationships to detect duplicates\n                        if rel_to not in fk_targets:\n                            fk_targets[rel_to] = []\n                        fk_targets[rel_to].append(att_name)\n",
      "\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        \n                        # Check if we need to add related_name to avoid clashing reverse accessors\n                        if rel_to != \"self\":\n                            # Track foreign keys pointing to the same model\n                            if rel_to not in fk_relations:\n                                fk_relations[rel_to] = []\n                            fk_relations[rel_to].append(att_name)\n                            \n                            # If multiple fields point to same model, add related_name\n                            if len(fk_relations[rel_to]) > 1:\n                                extra_params[\"related_name\"] = att_name\n                                # Also add related_name to previously processed fields for this relation\n                                for prev_field in fk_relations[rel_to][:-1]:\n                                    if prev_field in field_params_map:\n                                        field_params_map[prev_field][\"related_name\"] = prev_field\n",
      "\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        # Auto-generate related_name for foreign keys to avoid reverse accessor clashes\n                        if rel_type in (\"ForeignKey\", \"OneToOneField\"):\n                            extra_params[\"related_name\"] = att_name\n",
      "\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        # Track foreign key relationships for related_name generation\n                        if rel_to not in fk_relations:\n                            fk_relations[rel_to] = []\n                        fk_relations[rel_to].append(att_name)\n",
      "\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        # Auto-generate related_name for foreign keys to avoid reverse accessor clashes\n                        if rel_to != \"self\":\n                            # Check if we already have a foreign key to this model\n                            existing_fk_count = sum(1 for prev_field in field_output \n                                                  if 'ForeignKey' in prev_field and rel_to in prev_field)\n                            if existing_fk_count > 0 or any(rel_to in prev_field and 'ForeignKey' in prev_field \n                                                          for prev_field in field_output):\n                                extra_params[\"related_name\"] = f\"'{att_name}'\"\n",
      "\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        \n                        # Track foreign keys to detect multiple FKs to same model\n                        if table_name not in fk_tracker:\n                            fk_tracker[table_name] = {}\n                        if rel_to not in fk_tracker[table_name]:\n                            fk_tracker[table_name][rel_to] = []\n                        fk_tracker[table_name][rel_to].append(att_name)\n                        \n                        # Add related_name if multiple FKs point to same model\n                        if len(fk_tracker[table_name][rel_to]) > 1:\n                            extra_params[\"related_name\"] = f\"'{att_name}'\"\n                            # Update previous FK fields for this rel_to if not already done\n                            for prev_field in fk_tracker[table_name][rel_to][:-1]:\n                                if prev_field not in updated_fields:\n                                    # Find and update the previous field definition\n                                    for i, (prev_att_name, prev_params, prev_notes, prev_field_type) in enumerate(yield_list):\n                                        if prev_att_name == prev_field and rel_to in prev_field_type:\n                                            if \"related_name\" not in prev_params:\n                                                prev_params[\"related_name\"] = f\"'{prev_field}'\"\n                                                yield_list[i] = (prev_att_name, prev_params, prev_notes, prev_field_type)\n                                                updated_fields.add(prev_field)\n                                            break\n",
      "\n                        rel_to = (\n                            \"self\"\n                            if ref_db_table == table_name\n                            else table2model(ref_db_table)\n                        )\n                        # Track foreign key relationships to detect duplicates\n                        fk_key = (rel_to, rel_type)\n                        if fk_key not in fk_counter:\n                            fk_counter[fk_key] = []\n                        fk_counter[fk_key].append(att_name)\n"
    ],
    "Location 4 (/root/hy/projects_4/django/django/core/management/commands/inspectdb.py lines 227-232)": [
      "\n                    if extra_params:\n                        if not field_desc.endswith(\"(\"):\n                            field_desc += \", \"\n                        field_desc += \", \".join(\n                            \"%s=%r\" % (k, v) for k, v in extra_params.items()\n                        )\n",
      "\n                    if extra_params:\n                        if not field_desc.endswith(\"(\"):\n                            field_desc += \", \"\n                        field_desc += \", \".join(\n                            \"%s=%r\" % (k, v) for k, v in extra_params.items()\n                        )\n",
      "\n                    if extra_params:\n                        if not field_desc.endswith(\"(\"):\n                            field_desc += \", \"\n                        field_desc += \", \".join(\n                            \"%s=%r\" % (k, v) for k, v in extra_params.items()\n                        )\n",
      "\n                    if extra_params:\n                        if not field_desc.endswith(\"(\"):\n                            field_desc += \", \"\n                        field_desc += \", \".join(\n                            \"%s=%s\" % (k, repr(v) if k != 'related_name' else \"'%s'\" % v) for k, v in extra_params.items()\n                        )\n",
      "\n                    if extra_params:\n                        if not field_desc.endswith(\"(\"):\n                            field_desc += \", \"\n                        field_desc += \", \".join(\n                            \"%s=%r\" % (k, v) for k, v in extra_params.items()\n                        )\n",
      "\n                    if extra_params:\n                        if not field_desc.endswith(\"(\"):\n                            field_desc += \", \"\n                        field_desc += \", \".join(\n                            \"%s=%r\" % (k, v) for k, v in extra_params.items()\n                        )\n",
      "\n                    if extra_params:\n                        # Add related_name for foreign keys to avoid reverse accessor conflicts\n                        if field_type.startswith((\"ForeignKey(\", \"OneToOneField(\")) and 'related_name' not in extra_params:\n                            extra_params['related_name'] = att_name\n                        \n                        if not field_desc.endswith(\"(\"):\n                            field_desc += \", \"\n                        field_desc += \", \".join(\n                            \"%s=%r\" % (k, v) for k, v in extra_params.items()\n                        )\n",
      "\n                    if extra_params:\n                        if not field_desc.endswith(\"(\"):\n                            field_desc += \", \"\n                        field_desc += \", \".join(\n                            \"%s=%r\" % (k, v) for k, v in extra_params.items()\n                        )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py\nindex f33bcbdccf..5bf6e15377 100644\n--- a/django/core/management/commands/inspectdb.py\n+++ b/django/core/management/commands/inspectdb.py\n@@ -131,8 +131,10 @@ class Command(BaseCommand):\n                 yield \"\"\n                 yield \"class %s(models.Model):\" % table2model(table_name)\n                 known_models.append(table2model(table_name))\n+\n                 used_column_names = []  # Holds column names used in the table so far\n                 column_to_field_name = {}  # Maps column names to names of model fields\n+                related_model_refs = {}  # Track references to each related model\n                 for row in table_description:\n                     comment_notes = (\n                         []\n@@ -162,6 +164,7 @@ class Command(BaseCommand):\n                     elif column_name in unique_columns:\n                         extra_params[\"unique\"] = True\n \n+\n                     if is_relation:\n                         ref_db_column, ref_db_table = relations[column_name]\n                         if extra_params.pop(\"unique\", False) or extra_params.get(\n@@ -182,10 +185,23 @@ class Command(BaseCommand):\n                             if ref_db_table == table_name\n                             else table2model(ref_db_table)\n                         )\n+                        # Track references to each related model\n+                        if rel_to not in related_model_refs:\n+                            related_model_refs[rel_to] = []\n+                        related_model_refs[rel_to].append(att_name)\n+                        \n+                        # Generate related_name if multiple fields reference the same model\n+                        if len(related_model_refs[rel_to]) > 1:\n+                            # Add related_name for all fields referencing this model\n+                            for field_name in related_model_refs[rel_to]:\n+                                if field_name == att_name:\n+                                    extra_params[\"related_name\"] = att_name\n+                        \n                         if rel_to in known_models:\n                             field_type = \"%s(%s\" % (rel_type, rel_to)\n                         else:\n                             field_type = \"%s('%s'\" % (rel_type, rel_to)\n+                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n                     else:\n                         # Calling `get_field_type` to get the field type string and any\n                         # additional parameters and notes.\n@@ -224,6 +240,7 @@ class Command(BaseCommand):\n                     if field_type.startswith((\"ForeignKey(\", \"OneToOneField(\")):\n                         field_desc += \", models.DO_NOTHING\"\n \n+\n                     if extra_params:\n                         if not field_desc.endswith(\"(\"):\n                             field_desc += \", \"\n",
    "variant_0": "diff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py\nindex f33bcbdccf..ea915a8fc7 100644\n--- a/django/core/management/commands/inspectdb.py\n+++ b/django/core/management/commands/inspectdb.py\n@@ -131,8 +131,10 @@ class Command(BaseCommand):\n                 yield \"\"\n                 yield \"class %s(models.Model):\" % table2model(table_name)\n                 known_models.append(table2model(table_name))\n+\n                 used_column_names = []  # Holds column names used in the table so far\n                 column_to_field_name = {}  # Maps column names to names of model fields\n+                foreign_key_fields = {}  # Maps related model names to field names for related_name generation\n                 for row in table_description:\n                     comment_notes = (\n                         []\n@@ -162,6 +164,48 @@ class Command(BaseCommand):\n                     elif column_name in unique_columns:\n                         extra_params[\"unique\"] = True\n \n+\n+                # Track foreign key relationships for related_name generation\n+                fk_relations = {}\n+                for column_name in [row[0] for row in table_description]:\n+                    if column_name in relations:\n+                        ref_db_column, ref_db_table = relations[column_name]\n+                        rel_to = (\n+                            \"self\"\n+                            if ref_db_table == table_name\n+                            else table2model(ref_db_table)\n+                        )\n+                        if rel_to not in fk_relations:\n+                            fk_relations[rel_to] = []\n+                        fk_relations[rel_to].append(column_name)\n+\n+                for row in table_description:\n+                    column_name = row[0]\n+                    comment_notes = []\n+                    extra_params = OrderedDict()\n+                    column_name = row[0]\n+                    is_relation = column_name in relations\n+\n+                    att_name, params, notes = self.normalize_col_name(\n+                        column_name, used_column_names, is_relation\n+                    )\n+                    extra_params.update(params)\n+                    comment_notes.extend(notes)\n+\n+                    used_column_names.add(att_name)\n+\n+                    # Add primary_key and unique, if necessary.\n+                    if column_name in primary_key_columns:\n+                        extra_params[\"primary_key\"] = True\n+                        if len(primary_key_columns) > 1:\n+                            comment_notes.append(\n+                                \"The composite primary key (%s) found, that is not \"\n+                                \"supported. The first column is selected.\"\n+                                % \", \".join(primary_key_columns)\n+                            )\n+                    elif column_name in unique_columns:\n+                        extra_params[\"unique\"] = True\n+\n                     if is_relation:\n                         ref_db_column, ref_db_table = relations[column_name]\n                         if extra_params.pop(\"unique\", False) or extra_params.get(\n@@ -182,6 +226,18 @@ class Command(BaseCommand):\n                             if ref_db_table == table_name\n                             else table2model(ref_db_table)\n                         )\n+                        \n+                        # Add related_name if multiple FKs point to the same model\n+                        if rel_to in fk_relations and len(fk_relations[rel_to]) > 1:\n+                            extra_params[\"related_name\"] = att_name\n+                        \n+                        if rel_to in known_models:\n+                            field_type = \"%s(%s\" % (rel_type, rel_to)\n+                        else:\n+                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n+                        if fk_key not in fk_field_counts:\n+                            fk_field_counts[fk_key] = []\n+                        fk_field_counts[fk_key].append(att_name)\n                         if rel_to in known_models:\n                             field_type = \"%s(%s\" % (rel_type, rel_to)\n                         else:\n@@ -224,6 +280,7 @@ class Command(BaseCommand):\n                     if field_type.startswith((\"ForeignKey(\", \"OneToOneField(\")):\n                         field_desc += \", models.DO_NOTHING\"\n \n+\n                     if extra_params:\n                         if not field_desc.endswith(\"(\"):\n                             field_desc += \", \"\n",
    "variant_1": "diff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py\nindex f33bcbdccf..8ed163da22 100644\n--- a/django/core/management/commands/inspectdb.py\n+++ b/django/core/management/commands/inspectdb.py\n@@ -131,8 +131,10 @@ class Command(BaseCommand):\n                 yield \"\"\n                 yield \"class %s(models.Model):\" % table2model(table_name)\n                 known_models.append(table2model(table_name))\n+\n                 used_column_names = []  # Holds column names used in the table so far\n                 column_to_field_name = {}  # Maps column names to names of model fields\n+                fk_relations = {}  # Maps related model names to list of field names that reference them\n                 for row in table_description:\n                     comment_notes = (\n                         []\n@@ -162,26 +164,49 @@ class Command(BaseCommand):\n                     elif column_name in unique_columns:\n                         extra_params[\"unique\"] = True\n \n-                    if is_relation:\n-                        ref_db_column, ref_db_table = relations[column_name]\n-                        if extra_params.pop(\"unique\", False) or extra_params.get(\n-                            \"primary_key\"\n-                        ):\n-                            rel_type = \"OneToOneField\"\n-                        else:\n-                            rel_type = \"ForeignKey\"\n-                            ref_pk_column = (\n-                                connection.introspection.get_primary_key_column(\n-                                    cursor, ref_db_table\n-                                )\n+\n+                if is_relation:\n+                    ref_db_column, ref_db_table = relations[column_name]\n+                    if extra_params.pop(\"unique\", False) or extra_params.get(\n+                        \"primary_key\"\n+                    ):\n+                        rel_type = \"OneToOneField\"\n+                    else:\n+                        rel_type = \"ForeignKey\"\n+                        ref_pk_column = (\n+                            connection.introspection.get_primary_key_column(\n+                                cursor, ref_db_table\n                             )\n-                            if ref_pk_column and ref_pk_column != ref_db_column:\n-                                extra_params[\"to_field\"] = ref_db_column\n-                        rel_to = (\n-                            \"self\"\n-                            if ref_db_table == table_name\n-                            else table2model(ref_db_table)\n                         )\n+                        if ref_pk_column and ref_pk_column != ref_db_column:\n+                            extra_params[\"to_field\"] = ref_db_column\n+                    rel_to = (\n+                        \"self\"\n+                        if ref_db_table == table_name\n+                        else table2model(ref_db_table)\n+                    )\n+                    \n+                    # Track foreign key relationships for related_name generation\n+                    if rel_to not in fk_relations:\n+                        fk_relations[rel_to] = []\n+                    fk_relations[rel_to].append(column_name)\n+                    \n+                    if rel_to in known_models:\n+                        field_type = \"%s(%s\" % (rel_type, rel_to)\n+                    else:\n+                        field_type = \"%s('%s'\" % (rel_type, rel_to)\n+                            # Track foreign keys to the same model to detect duplicates\n+                            if rel_to not in fk_counts:\n+                                fk_counts[rel_to] = []\n+                            fk_counts[rel_to].append(column_name)\n+                            \n+                            # If multiple FKs to same model, add related_name\n+                            if len(fk_counts[rel_to]) > 1:\n+                                extra_params[\"related_name\"] = f\"'{column_name}'\"\n+                                # Also add related_name to previous FK if not already done\n+                                for prev_col in fk_counts[rel_to][:-1]:\n+                                    # This will be handled in the field output generation\n+                                    pass\n                         if rel_to in known_models:\n                             field_type = \"%s(%s\" % (rel_type, rel_to)\n                         else:\n@@ -224,6 +249,7 @@ class Command(BaseCommand):\n                     if field_type.startswith((\"ForeignKey(\", \"OneToOneField(\")):\n                         field_desc += \", models.DO_NOTHING\"\n \n+\n                     if extra_params:\n                         if not field_desc.endswith(\"(\"):\n                             field_desc += \", \"\n",
    "variant_2": "diff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py\nindex f33bcbdccf..3faac4cee7 100644\n--- a/django/core/management/commands/inspectdb.py\n+++ b/django/core/management/commands/inspectdb.py\n@@ -131,8 +131,10 @@ class Command(BaseCommand):\n                 yield \"\"\n                 yield \"class %s(models.Model):\" % table2model(table_name)\n                 known_models.append(table2model(table_name))\n+\n                 used_column_names = []  # Holds column names used in the table so far\n                 column_to_field_name = {}  # Maps column names to names of model fields\n+                foreign_key_targets = {}  # Maps related model names to list of field names pointing to them\n                 for row in table_description:\n                     comment_notes = (\n                         []\n@@ -162,6 +164,40 @@ class Command(BaseCommand):\n                     elif column_name in unique_columns:\n                         extra_params[\"unique\"] = True\n \n+\n+                # Track foreign key relationships to detect multiple FKs to same model\n+                fk_relationships = {}\n+                for column_name in [row.name for row in table_description]:\n+                    is_relation = column_name in relations\n+                    if is_relation:\n+                        ref_db_column, ref_db_table = relations[column_name]\n+                        rel_to = (\n+                            \"self\"\n+                            if ref_db_table == table_name\n+                            else table2model(ref_db_table)\n+                        )\n+                        if rel_to not in fk_relationships:\n+                            fk_relationships[rel_to] = []\n+                        fk_relationships[rel_to].append(column_name)\n+\n+                for row in table_description:\n+                    column_name = row.name\n+                    comment_notes = []\n+                    extra_params = OrderedDict()\n+                    column_name = row.name\n+                    is_relation = column_name in relations\n+\n+                    if column_name in primary_key_columns:\n+                        extra_params[\"primary_key\"] = True\n+                        if len(primary_key_columns) > 1:\n+                            comment_notes.append(\n+                                \"The composite primary key (%s) found, that is not \"\n+                                \"supported. The first column is selected.\"\n+                                % \", \".join(primary_key_columns)\n+                            )\n+                    elif column_name in unique_columns:\n+                        extra_params[\"unique\"] = True\n+\n                     if is_relation:\n                         ref_db_column, ref_db_table = relations[column_name]\n                         if extra_params.pop(\"unique\", False) or extra_params.get(\n@@ -182,6 +218,17 @@ class Command(BaseCommand):\n                             if ref_db_table == table_name\n                             else table2model(ref_db_table)\n                         )\n+                        \n+                        # Add related_name if multiple FKs point to the same model\n+                        if len(fk_relationships.get(rel_to, [])) > 1:\n+                            extra_params[\"related_name\"] = f\"{table_name.lower()}_{column_name}_set\"\n+                        \n+                        if rel_to in known_models:\n+                            field_type = \"%s(%s\" % (rel_type, rel_to)\n+                        else:\n+                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n+                            fk_targets[rel_to] = []\n+                        fk_targets[rel_to].append(att_name)\n                         if rel_to in known_models:\n                             field_type = \"%s(%s\" % (rel_type, rel_to)\n                         else:\n@@ -224,6 +271,7 @@ class Command(BaseCommand):\n                     if field_type.startswith((\"ForeignKey(\", \"OneToOneField(\")):\n                         field_desc += \", models.DO_NOTHING\"\n \n+\n                     if extra_params:\n                         if not field_desc.endswith(\"(\"):\n                             field_desc += \", \"\n",
    "variant_3": "diff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py\nindex f33bcbdccf..57d4745796 100644\n--- a/django/core/management/commands/inspectdb.py\n+++ b/django/core/management/commands/inspectdb.py\n@@ -131,8 +131,10 @@ class Command(BaseCommand):\n                 yield \"\"\n                 yield \"class %s(models.Model):\" % table2model(table_name)\n                 known_models.append(table2model(table_name))\n+\n                 used_column_names = []  # Holds column names used in the table so far\n                 column_to_field_name = {}  # Maps column names to names of model fields\n+                foreign_key_relations = {}  # Maps related model names to field names for related_name generation\n                 for row in table_description:\n                     comment_notes = (\n                         []\n@@ -162,6 +164,50 @@ class Command(BaseCommand):\n                     elif column_name in unique_columns:\n                         extra_params[\"unique\"] = True\n \n+\n+                # Track foreign key relationships for related_name generation\n+                fk_relationships = {}\n+                for row in table_description:\n+                    column_name = row.name\n+                    if column_name in relations:\n+                        ref_db_column, ref_db_table = relations[column_name]\n+                        rel_to = (\n+                            \"self\"\n+                            if ref_db_table == table_name\n+                            else table2model(ref_db_table)\n+                        )\n+                        if rel_to not in fk_relationships:\n+                            fk_relationships[rel_to] = []\n+                        fk_relationships[rel_to].append(column_name)\n+\n+                for row in table_description:\n+                    comment_notes = (\n+                        []\n+                    )  # Holds Field notes, to be displayed in a Python comment.\n+                    extra_params = OrderedDict()  # Holds Field parameters such as 'db_column'.\n+                    column_name = row.name\n+                    is_relation = column_name in relations\n+\n+                    att_name, params, notes = self.normalize_col_name(\n+                        column_name, used_column_names, is_relation\n+                    )\n+                    extra_params.update(params)\n+                    comment_notes.extend(notes)\n+\n+                    used_column_names.add(att_name)\n+\n+                    # Add primary_key and unique, if necessary.\n+                    if column_name in primary_key_columns:\n+                        extra_params[\"primary_key\"] = True\n+                        if len(primary_key_columns) > 1:\n+                            comment_notes.append(\n+                                \"The composite primary key (%s) found, that is not \"\n+                                \"supported. The first column is selected.\"\n+                                % \", \".join(primary_key_columns)\n+                            )\n+                    elif column_name in unique_columns:\n+                        extra_params[\"unique\"] = True\n+\n                     if is_relation:\n                         ref_db_column, ref_db_table = relations[column_name]\n                         if extra_params.pop(\"unique\", False) or extra_params.get(\n@@ -182,6 +228,27 @@ class Command(BaseCommand):\n                             if ref_db_table == table_name\n                             else table2model(ref_db_table)\n                         )\n+                        \n+                        # Add related_name if multiple FKs point to the same model\n+                        if rel_to in fk_relationships and len(fk_relationships[rel_to]) > 1:\n+                            extra_params[\"related_name\"] = f\"{table2model(table_name).lower()}_{att_name}_set\"\n+                        \n+                        if rel_to in known_models:\n+                            field_type = \"%s(%s\" % (rel_type, rel_to)\n+                        else:\n+                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n+                            # Track foreign keys pointing to the same model\n+                            if rel_to not in fk_relations:\n+                                fk_relations[rel_to] = []\n+                            fk_relations[rel_to].append(att_name)\n+                            \n+                            # If multiple fields point to same model, add related_name\n+                            if len(fk_relations[rel_to]) > 1:\n+                                extra_params[\"related_name\"] = att_name\n+                                # Also add related_name to previously processed fields for this relation\n+                                for prev_field in fk_relations[rel_to][:-1]:\n+                                    if prev_field in field_params_map:\n+                                        field_params_map[prev_field][\"related_name\"] = prev_field\n                         if rel_to in known_models:\n                             field_type = \"%s(%s\" % (rel_type, rel_to)\n                         else:\n@@ -224,6 +291,7 @@ class Command(BaseCommand):\n                     if field_type.startswith((\"ForeignKey(\", \"OneToOneField(\")):\n                         field_desc += \", models.DO_NOTHING\"\n \n+\n                     if extra_params:\n                         if not field_desc.endswith(\"(\"):\n                             field_desc += \", \"\n",
    "variant_4": "diff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py\nindex f33bcbdccf..546d861590 100644\n--- a/django/core/management/commands/inspectdb.py\n+++ b/django/core/management/commands/inspectdb.py\n@@ -131,8 +131,10 @@ class Command(BaseCommand):\n                 yield \"\"\n                 yield \"class %s(models.Model):\" % table2model(table_name)\n                 known_models.append(table2model(table_name))\n+\n                 used_column_names = []  # Holds column names used in the table so far\n                 column_to_field_name = {}  # Maps column names to names of model fields\n+                related_models = {}  # Maps related model names to list of field names\n                 for row in table_description:\n                     comment_notes = (\n                         []\n@@ -162,6 +164,11 @@ class Command(BaseCommand):\n                     elif column_name in unique_columns:\n                         extra_params[\"unique\"] = True\n \n+\n+                    # Track foreign key relationships for related_name generation\n+                    if table_name not in fk_relationships:\n+                        fk_relationships[table_name] = {}\n+                    \n                     if is_relation:\n                         ref_db_column, ref_db_table = relations[column_name]\n                         if extra_params.pop(\"unique\", False) or extra_params.get(\n@@ -182,6 +189,16 @@ class Command(BaseCommand):\n                             if ref_db_table == table_name\n                             else table2model(ref_db_table)\n                         )\n+                        \n+                        # Track this relationship for related_name generation\n+                        if rel_to not in fk_relationships[table_name]:\n+                            fk_relationships[table_name][rel_to] = []\n+                        fk_relationships[table_name][rel_to].append(column_name)\n+                        \n+                        if rel_to in known_models:\n+                            field_type = \"%s(%s\" % (rel_type, rel_to)\n+                        else:\n+                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n                         if rel_to in known_models:\n                             field_type = \"%s(%s\" % (rel_type, rel_to)\n                         else:\n@@ -224,11 +241,12 @@ class Command(BaseCommand):\n                     if field_type.startswith((\"ForeignKey(\", \"OneToOneField(\")):\n                         field_desc += \", models.DO_NOTHING\"\n \n+\n                     if extra_params:\n                         if not field_desc.endswith(\"(\"):\n                             field_desc += \", \"\n                         field_desc += \", \".join(\n-                            \"%s=%r\" % (k, v) for k, v in extra_params.items()\n+                            \"%s=%s\" % (k, repr(v) if k != 'related_name' else \"'%s'\" % v) for k, v in extra_params.items()\n                         )\n                     field_desc += \")\"\n                     if comment_notes:\n",
    "variant_5": "diff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py\nindex f33bcbdccf..b285e7f7ac 100644\n--- a/django/core/management/commands/inspectdb.py\n+++ b/django/core/management/commands/inspectdb.py\n@@ -131,8 +131,10 @@ class Command(BaseCommand):\n                 yield \"\"\n                 yield \"class %s(models.Model):\" % table2model(table_name)\n                 known_models.append(table2model(table_name))\n+\n                 used_column_names = []  # Holds column names used in the table so far\n                 column_to_field_name = {}  # Maps column names to names of model fields\n+                foreign_key_relations = {}  # Track foreign key relations for related_name generation\n                 for row in table_description:\n                     comment_notes = (\n                         []\n@@ -162,6 +164,11 @@ class Command(BaseCommand):\n                     elif column_name in unique_columns:\n                         extra_params[\"unique\"] = True\n \n+\n+                    # Keep track of foreign key relationships for related_name generation\n+                    if not hasattr(self, '_fk_relationships'):\n+                        self._fk_relationships = {}\n+                    \n                     if is_relation:\n                         ref_db_column, ref_db_table = relations[column_name]\n                         if extra_params.pop(\"unique\", False) or extra_params.get(\n@@ -182,6 +189,26 @@ class Command(BaseCommand):\n                             if ref_db_table == table_name\n                             else table2model(ref_db_table)\n                         )\n+                        \n+                        # Track foreign key relationships for related_name generation\n+                        if table_name not in self._fk_relationships:\n+                            self._fk_relationships[table_name] = {}\n+                        if rel_to not in self._fk_relationships[table_name]:\n+                            self._fk_relationships[table_name][rel_to] = []\n+                        self._fk_relationships[table_name][rel_to].append(att_name)\n+                        \n+                        # Add related_name if multiple FKs point to the same model\n+                        if len(self._fk_relationships[table_name][rel_to]) > 1 or (\n+                            len(self._fk_relationships[table_name][rel_to]) == 1 and\n+                            any(len(fields) > 1 for target, fields in self._fk_relationships[table_name].items() if target != rel_to)\n+                        ):\n+                            extra_params[\"related_name\"] = f\"'{att_name}'\"\n+                        \n+                        if rel_to in known_models:\n+                            field_type = \"%s(%s\" % (rel_type, rel_to)\n+                        else:\n+                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n+                        fk_relations[rel_to].append(att_name)\n                         if rel_to in known_models:\n                             field_type = \"%s(%s\" % (rel_type, rel_to)\n                         else:\n@@ -224,6 +251,7 @@ class Command(BaseCommand):\n                     if field_type.startswith((\"ForeignKey(\", \"OneToOneField(\")):\n                         field_desc += \", models.DO_NOTHING\"\n \n+\n                     if extra_params:\n                         if not field_desc.endswith(\"(\"):\n                             field_desc += \", \"\n",
    "variant_6": "diff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py\nindex f33bcbdccf..fd7fc04f1f 100644\n--- a/django/core/management/commands/inspectdb.py\n+++ b/django/core/management/commands/inspectdb.py\n@@ -131,8 +131,10 @@ class Command(BaseCommand):\n                 yield \"\"\n                 yield \"class %s(models.Model):\" % table2model(table_name)\n                 known_models.append(table2model(table_name))\n+\n                 used_column_names = []  # Holds column names used in the table so far\n                 column_to_field_name = {}  # Maps column names to names of model fields\n+                field_name_to_related_model = {}  # Maps field names to their related models\n                 for row in table_description:\n                     comment_notes = (\n                         []\n@@ -162,6 +164,50 @@ class Command(BaseCommand):\n                     elif column_name in unique_columns:\n                         extra_params[\"unique\"] = True\n \n+\n+                # Track foreign key fields to detect multiple FKs to same model\n+                fk_fields = {}\n+                for row in table_description:\n+                    column_name = row.name\n+                    if column_name in relations:\n+                        ref_db_column, ref_db_table = relations[column_name]\n+                        rel_to = (\n+                            \"self\"\n+                            if ref_db_table == table_name\n+                            else table2model(ref_db_table)\n+                        )\n+                        if rel_to not in fk_fields:\n+                            fk_fields[rel_to] = []\n+                        fk_fields[rel_to].append(column_name)\n+\n+                for row in table_description:\n+                    comment_notes = (\n+                        []\n+                    )  # Holds Field notes, to be displayed in a Python comment.\n+                    extra_params = OrderedDict()  # Holds Field parameters such as 'db_column'.\n+                    column_name = row.name\n+                    is_relation = column_name in relations\n+\n+                    att_name, params, notes = self.normalize_col_name(\n+                        column_name, used_column_names, is_relation\n+                    )\n+                    extra_params.update(params)\n+                    comment_notes.extend(notes)\n+\n+                    used_column_names.add(att_name)\n+\n+                    # Add primary_key and unique, if necessary.\n+                    if column_name in primary_key_columns:\n+                        extra_params[\"primary_key\"] = True\n+                        if len(primary_key_columns) > 1:\n+                            comment_notes.append(\n+                                \"The composite primary key (%s) found, that is not \"\n+                                \"supported. The first column is selected.\"\n+                                % \", \".join(primary_key_columns)\n+                            )\n+                    elif column_name in unique_columns:\n+                        extra_params[\"unique\"] = True\n+\n                     if is_relation:\n                         ref_db_column, ref_db_table = relations[column_name]\n                         if extra_params.pop(\"unique\", False) or extra_params.get(\n@@ -182,6 +228,20 @@ class Command(BaseCommand):\n                             if ref_db_table == table_name\n                             else table2model(ref_db_table)\n                         )\n+                        \n+                        # Add related_name if multiple FKs point to same model\n+                        if len(fk_fields.get(rel_to, [])) > 1:\n+                            extra_params[\"related_name\"] = att_name\n+                        \n+                        if rel_to in known_models:\n+                            field_type = \"%s(%s\" % (rel_type, rel_to)\n+                        else:\n+                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n+                            existing_fk_count = sum(1 for prev_field in field_output \n+                                                  if 'ForeignKey' in prev_field and rel_to in prev_field)\n+                            if existing_fk_count > 0 or any(rel_to in prev_field and 'ForeignKey' in prev_field \n+                                                          for prev_field in field_output):\n+                                extra_params[\"related_name\"] = f\"'{att_name}'\"\n                         if rel_to in known_models:\n                             field_type = \"%s(%s\" % (rel_type, rel_to)\n                         else:\n@@ -224,6 +284,7 @@ class Command(BaseCommand):\n                     if field_type.startswith((\"ForeignKey(\", \"OneToOneField(\")):\n                         field_desc += \", models.DO_NOTHING\"\n \n+\n                     if extra_params:\n                         if not field_desc.endswith(\"(\"):\n                             field_desc += \", \"\n",
    "variant_7": "diff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py\nindex f33bcbdccf..38aa7b1df9 100644\n--- a/django/core/management/commands/inspectdb.py\n+++ b/django/core/management/commands/inspectdb.py\n@@ -131,8 +131,10 @@ class Command(BaseCommand):\n                 yield \"\"\n                 yield \"class %s(models.Model):\" % table2model(table_name)\n                 known_models.append(table2model(table_name))\n+\n                 used_column_names = []  # Holds column names used in the table so far\n                 column_to_field_name = {}  # Maps column names to names of model fields\n+                foreign_key_targets = {}  # Maps target models to list of field names referencing them\n                 for row in table_description:\n                     comment_notes = (\n                         []\n@@ -162,6 +164,11 @@ class Command(BaseCommand):\n                     elif column_name in unique_columns:\n                         extra_params[\"unique\"] = True\n \n+\n+                    # Track foreign key relationships for related_name generation\n+                    if not hasattr(self, '_fk_relations'):\n+                        self._fk_relations = {}\n+                    \n                     if is_relation:\n                         ref_db_column, ref_db_table = relations[column_name]\n                         if extra_params.pop(\"unique\", False) or extra_params.get(\n@@ -182,6 +189,37 @@ class Command(BaseCommand):\n                             if ref_db_table == table_name\n                             else table2model(ref_db_table)\n                         )\n+                        \n+                        # Track this relationship for related_name generation\n+                        if table_name not in self._fk_relations:\n+                            self._fk_relations[table_name] = {}\n+                        if rel_to not in self._fk_relations[table_name]:\n+                            self._fk_relations[table_name][rel_to] = []\n+                        self._fk_relations[table_name][rel_to].append(att_name)\n+                        \n+                        if rel_to in known_models:\n+                            field_type = \"%s(%s\" % (rel_type, rel_to)\n+                        else:\n+                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n+                            fk_tracker[table_name] = {}\n+                        if rel_to not in fk_tracker[table_name]:\n+                            fk_tracker[table_name][rel_to] = []\n+                        fk_tracker[table_name][rel_to].append(att_name)\n+                        \n+                        # Add related_name if multiple FKs point to same model\n+                        if len(fk_tracker[table_name][rel_to]) > 1:\n+                            extra_params[\"related_name\"] = f\"'{att_name}'\"\n+                            # Update previous FK fields for this rel_to if not already done\n+                            for prev_field in fk_tracker[table_name][rel_to][:-1]:\n+                                if prev_field not in updated_fields:\n+                                    # Find and update the previous field definition\n+                                    for i, (prev_att_name, prev_params, prev_notes, prev_field_type) in enumerate(yield_list):\n+                                        if prev_att_name == prev_field and rel_to in prev_field_type:\n+                                            if \"related_name\" not in prev_params:\n+                                                prev_params[\"related_name\"] = f\"'{prev_field}'\"\n+                                                yield_list[i] = (prev_att_name, prev_params, prev_notes, prev_field_type)\n+                                                updated_fields.add(prev_field)\n+                                            break\n                         if rel_to in known_models:\n                             field_type = \"%s(%s\" % (rel_type, rel_to)\n                         else:\n@@ -224,7 +262,12 @@ class Command(BaseCommand):\n                     if field_type.startswith((\"ForeignKey(\", \"OneToOneField(\")):\n                         field_desc += \", models.DO_NOTHING\"\n \n+\n                     if extra_params:\n+                        # Add related_name for foreign keys to avoid reverse accessor conflicts\n+                        if field_type.startswith((\"ForeignKey(\", \"OneToOneField(\")) and 'related_name' not in extra_params:\n+                            extra_params['related_name'] = att_name\n+                        \n                         if not field_desc.endswith(\"(\"):\n                             field_desc += \", \"\n                         field_desc += \", \".join(\n",
    "variant_8": "diff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py\nindex f33bcbdccf..ff563c973e 100644\n--- a/django/core/management/commands/inspectdb.py\n+++ b/django/core/management/commands/inspectdb.py\n@@ -131,8 +131,10 @@ class Command(BaseCommand):\n                 yield \"\"\n                 yield \"class %s(models.Model):\" % table2model(table_name)\n                 known_models.append(table2model(table_name))\n+\n                 used_column_names = []  # Holds column names used in the table so far\n                 column_to_field_name = {}  # Maps column names to names of model fields\n+                foreign_key_fields = {}  # Maps related model names to list of field names\n                 for row in table_description:\n                     comment_notes = (\n                         []\n@@ -162,6 +164,36 @@ class Command(BaseCommand):\n                     elif column_name in unique_columns:\n                         extra_params[\"unique\"] = True\n \n+\n+                # Keep track of foreign key fields to handle multiple FKs to same model\n+                fk_fields = {}\n+                \n+                for row in table_description:\n+                    comment_notes = []\n+                    extra_params = OrderedDict()\n+                    column_name = row.name\n+                    is_relation = column_name in relations\n+\n+                    att_name, params, notes = self.normalize_col_name(\n+                        column_name, used_column_names, is_relation\n+                    )\n+                    extra_params.update(params)\n+                    comment_notes.extend(notes)\n+\n+                    used_column_names.add(att_name)\n+\n+                    # Add primary_key and unique, if necessary.\n+                    if column_name in primary_key_columns:\n+                        extra_params[\"primary_key\"] = True\n+                        if len(primary_key_columns) > 1:\n+                            comment_notes.append(\n+                                \"The composite primary key (%s) found, that is not \"\n+                                \"supported. The first column is selected.\"\n+                                % \", \".join(primary_key_columns)\n+                            )\n+                    elif column_name in unique_columns:\n+                        extra_params[\"unique\"] = True\n+\n                     if is_relation:\n                         ref_db_column, ref_db_table = relations[column_name]\n                         if extra_params.pop(\"unique\", False) or extra_params.get(\n@@ -182,6 +214,18 @@ class Command(BaseCommand):\n                             if ref_db_table == table_name\n                             else table2model(ref_db_table)\n                         )\n+                        \n+                        # Track foreign key fields for related_name generation\n+                        if rel_to not in fk_fields:\n+                            fk_fields[rel_to] = []\n+                        fk_fields[rel_to].append(att_name)\n+                        \n+                        if rel_to in known_models:\n+                            field_type = \"%s(%s\" % (rel_type, rel_to)\n+                        else:\n+                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n+                            fk_counter[fk_key] = []\n+                        fk_counter[fk_key].append(att_name)\n                         if rel_to in known_models:\n                             field_type = \"%s(%s\" % (rel_type, rel_to)\n                         else:\n@@ -224,6 +268,7 @@ class Command(BaseCommand):\n                     if field_type.startswith((\"ForeignKey(\", \"OneToOneField(\")):\n                         field_desc += \", models.DO_NOTHING\"\n \n+\n                     if extra_params:\n                         if not field_desc.endswith(\"(\"):\n                             field_desc += \", \"\n"
  }
}