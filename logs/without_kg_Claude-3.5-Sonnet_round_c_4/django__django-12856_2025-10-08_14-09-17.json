{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/base.py lines 1867-1929)": "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    )\n                )\n            if not (\n                connection.features.supports_deferrable_unique_constraints or\n                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support deferrable unique constraints.'\n                        % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W038',\n                    )\n                )\n        \n        # Validate UniqueConstraint fields exist\n        forward_fields_map = {}\n        for field in cls._meta._get_fields(reverse=False):\n            forward_fields_map[field.name] = field\n            if hasattr(field, 'attname'):\n                forward_fields_map[field.attname] = field\n\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                for field_name in constraint.fields:\n                    if field_name not in forward_fields_map:\n                        errors.append(\n                            checks.Error(\n                                \"'%s' refers to the nonexistent field '%s'.\" % (\n                                    constraint.name, field_name,\n                                ),\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n        \n        return errors\n",
    "Location 2 (/root/hy/projects_4/django/django/db/models/base.py lines 1640-1680)": "\n    @classmethod\n    def _check_constraints(cls):\n        errors = []\n        for db in connections:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(\n                    check.check(using=db)\n                    for check in cls._meta.constraints\n                    if isinstance(check, CheckConstraint)\n                )\n            if not connection.features.supports_partial_indexes:\n                errors.extend(\n                    check.check(using=db)\n                    for check in cls._meta.constraints\n                    if isinstance(check, UniqueConstraint) and check.condition is not None\n                )\n        \n        # Check that constraint fields exist\n        forward_fields_map = {}\n        for field in cls._meta._get_fields(reverse=False):\n            forward_fields_map[field.name] = field\n            if hasattr(field, 'attname'):\n                forward_fields_map[field.attname] = field\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                for field_name in constraint.fields:\n                    if field_name not in forward_fields_map:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n        \n        return errors\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/base.py lines 1867-1929)": [
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    )\n                )\n            if not (\n                connection.features.supports_deferrable_unique_constraints or\n                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support deferrable unique constraints.'\n                        % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W038',\n                    )\n                )\n        \n        # Validate fields in UniqueConstraint\n        forward_fields_map = {}\n        for f in cls._meta._get_fields(reverse=False):\n            forward_fields_map[f.name] = f\n            if hasattr(f, 'attname'):\n                forward_fields_map[f.attname] = f\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'%s' refers to the nonexistent field '%s'.\" % (\n                                    constraint.name, field_name\n                                ),\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n        \n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    )\n                )\n            if not (\n                connection.features.supports_deferrable_unique_constraints or\n                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support deferrable unique constraints.'\n                        % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W038',\n                    )\n                )\n        \n        # Check that fields in UniqueConstraints exist\n        forward_fields_map = {}\n        for field in cls._meta.local_fields:\n            forward_fields_map[field.name] = field\n            if hasattr(field, 'attname'):\n                forward_fields_map[field.attname] = field\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                for field_name in constraint.fields:\n                    if field_name not in forward_fields_map:\n                        errors.append(\n                            checks.Error(\n                                \"'%s' refers to the nonexistent field '%s'.\" % (\n                                    constraint.name, field_name,\n                                ),\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n        \n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    )\n                )\n            if not (\n                connection.features.supports_deferrable_unique_constraints or\n                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support deferrable unique constraints.'\n                        % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W038',\n                    )\n                )\n        \n        # Validate UniqueConstraint fields exist\n        forward_fields_map = {}\n        for field in cls._meta._get_fields(reverse=False):\n            forward_fields_map[field.name] = field\n            # Due to the way Django's internals work, get_field() should also\n            # be able to fetch a field by attname. In the case of a concrete\n            # field with relation, includes the *_id name too\n            try:\n                forward_fields_map[field.attname] = field\n            except AttributeError:\n                pass\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                for field_name in constraint.fields:\n                    if field_name not in forward_fields_map:\n                        errors.append(\n                            checks.Error(\n                                \"'%s' refers to the nonexistent field '%s'.\" % (\n                                    constraint.name, field_name,\n                                ),\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n        \n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    )\n                )\n            if not (\n                connection.features.supports_deferrable_unique_constraints or\n                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support deferrable unique constraints.'\n                        % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W038',\n                    )\n                )\n        \n        # Validate UniqueConstraint fields exist\n        forward_fields_map = {\n            field.name: field for field in cls._meta.get_fields()\n            if hasattr(field, 'name')\n        }\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                for field_name in constraint.fields:\n                    if field_name not in forward_fields_map:\n                        errors.append(\n                            checks.Error(\n                                \"'%s' refers to the nonexistent field '%s'.\" % (\n                                    constraint.name, field_name,\n                                ),\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n        \n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    )\n                )\n            if not (\n                connection.features.supports_deferrable_unique_constraints or\n                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support deferrable unique constraints.'\n                        % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W038',\n                    )\n                )\n        \n        # Validate constraint fields exist\n        forward_fields_map = {}\n        for field in cls._meta._get_fields(reverse=False):\n            forward_fields_map[field.name] = field\n            # Due to the way Django's internals work, get_field() should also\n            # be able to fetch a field by attname. In the case of a concrete\n            # field with relation, includes the *_id name too\n            try:\n                forward_fields_map[field.attname] = field\n            except AttributeError:\n                pass\n\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                for field_name in constraint.fields:\n                    try:\n                        cls._meta.get_field(field_name)\n                    except FieldDoesNotExist:\n                        if field_name in forward_fields_map:\n                            continue\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    )\n                )\n            if not (\n                connection.features.supports_deferrable_unique_constraints or\n                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support deferrable unique constraints.'\n                        % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W038',\n                    )\n                )\n        \n        # Check that UniqueConstraint fields exist\n        forward_fields_map = {}\n        for field in cls._meta.get_fields():\n            forward_fields_map[field.name] = field\n            if hasattr(field, 'attname'):\n                forward_fields_map[field.attname] = field\n\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                for field_name in constraint.fields:\n                    if field_name not in forward_fields_map:\n                        errors.append(\n                            checks.Error(\n                                \"'%s' refers to the nonexistent field '%s'.\" % (\n                                    constraint.name, field_name,\n                                ),\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    )\n                )\n            if not (\n                connection.features.supports_deferrable_unique_constraints or\n                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support deferrable unique constraints.'\n                        % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W038',\n                    )\n                )\n        \n        # Check that fields in UniqueConstraints exist\n        forward_fields_map = {}\n        for field in cls._meta.get_fields():\n            forward_fields_map[field.name] = field\n            if hasattr(field, 'attname'):\n                forward_fields_map[field.attname] = field\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                for field_name in constraint.fields:\n                    if field_name not in forward_fields_map:\n                        errors.append(\n                            checks.Error(\n                                \"'%s' refers to the nonexistent field '%s'.\" % (\n                                    constraint.name, field_name,\n                                ),\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n        \n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                'supports_table_check_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, CheckConstraint)\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    )\n                )\n            if not (\n                connection.features.supports_partial_indexes or\n                'supports_partial_indexes' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    )\n                )\n            if not (\n                connection.features.supports_deferrable_unique_constraints or\n                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n            ) and any(\n                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n                for constraint in cls._meta.constraints\n            ):\n                errors.append(\n                    checks.Warning(\n                        '%s does not support deferrable unique constraints.'\n                        % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W038',\n                    )\n                )\n        \n        # Validate UniqueConstraint fields exist\n        forward_fields_map = {}\n        for field, model in cls._meta.get_fields_with_model():\n            forward_fields_map[field.name] = model\n            if hasattr(field, 'attname'):\n                forward_fields_map[field.attname] = model\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                for field_name in constraint.fields:\n                    if field_name not in forward_fields_map:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n        \n        return errors\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/db/models/base.py lines 1640-1680)": [
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(\n                    check.clone(id='models.W027') for check in\n                    cls._check_check_constraints(databases)\n                )\n            if not connection.features.supports_partial_indexes:\n                errors.extend(\n                    check.clone(id='models.W036') for check in\n                    cls._check_partial_indexes(databases)\n                )\n        \n        # Validate fields in UniqueConstraint instances\n        forward_fields_map = {}\n        for field in cls._meta._get_fields(reverse=False):\n            forward_fields_map[field.name] = field\n            if hasattr(field, 'attname'):\n                forward_fields_map[field.attname] = field\n        \n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields'):\n                for field_name in constraint.fields:\n                    if field_name not in forward_fields_map:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n        \n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls):\n        errors = []\n        for db in settings.DATABASES:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(cls._check_constraints_database_backends(connection))\n            if not connection.features.supports_partial_indexes:\n                errors.extend(cls._check_constraints_partial_indexes(connection))\n        \n        # Check that fields in UniqueConstraints exist\n        from django.db import models\n        \n        # Build fields map to avoid hitting relation tree prematurely\n        forward_fields_map = {}\n        for field in cls._meta._get_fields(reverse=False):\n            forward_fields_map[field.name] = field\n            if hasattr(field, 'attname'):\n                forward_fields_map[field.attname] = field\n        \n        # Validate fields in UniqueConstraints\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                for field_name in constraint.fields:\n                    if field_name not in forward_fields_map:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n        \n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls):\n        errors = []\n        for db in connections:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(\n                    check.check(using=db)\n                    for check in cls._meta.constraints\n                    if isinstance(check, CheckConstraint)\n                )\n        \n        # Validate UniqueConstraint fields\n        forward_fields_map = {}\n        for field in cls._meta._get_fields(reverse=False):\n            forward_fields_map[field.name] = field\n            if hasattr(field, 'attname'):\n                forward_fields_map[field.attname] = field\n        \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                for field_name in constraint.fields:\n                    if field_name not in forward_fields_map:\n                        errors.append(\n                            checks.Error(\n                                \"UniqueConstraint refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n        \n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(\n                    check.clone(\n                        id='models.W027',\n                        hint=(\n                            'A constraint won\\'t be created. Silence this '\n                            'warning if you don\\'t care about it.'\n                        ),\n                    ) for check in cls._check_check_constraints(databases)\n                )\n        \n        # Validate UniqueConstraint field names\n        from django.db import models\n        \n        # Build forward fields map to avoid hitting the relation tree prematurely\n        forward_fields_map = {}\n        for field in cls._meta._get_fields(reverse=False):\n            forward_fields_map[field.name] = field\n            if hasattr(field, 'attname'):\n                forward_fields_map[field.attname] = field\n        \n        # Check UniqueConstraint fields\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                for field_name in constraint.fields:\n                    if field_name not in forward_fields_map:\n                        errors.append(\n                            checks.Error(\n                                \"'%s' refers to the nonexistent field '%s'.\" % (\n                                    constraint.name, field_name,\n                                ),\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n        \n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls):\n        errors = []\n        if not django.VERSION >= (2, 2):\n            return errors\n            \n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, CheckConstraint):\n                if not connections[DEFAULT_DB_ALIAS].features.supports_table_check_constraints:\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support check constraints.' % (\n                                connections[DEFAULT_DB_ALIAS].display_name,\n                            ),\n                            hint=(\n                                \"A constraint won't be created. Silence this \"\n                                \"warning if you don't care about it.\"\n                            ),\n                            obj=cls,\n                            id='models.W027',\n                        )\n                    )\n            elif isinstance(constraint, UniqueConstraint):\n                if not connections[DEFAULT_DB_ALIAS].features.supports_partial_indexes and constraint.condition is not None:\n                    errors.append(\n                        checks.Warning(\n                            '%s does not support unique constraints with '\n                            'conditions.' % (\n                                connections[DEFAULT_DB_ALIAS].display_name,\n                            ),\n                            hint=(\n                                \"A constraint won't be created. Silence this \"\n                                \"warning if you don't care about it.\"\n                            ),\n                            obj=cls,\n                            id='models.W036',\n                        )\n                    )\n                \n                # Check that fields in UniqueConstraint exist\n                from django.db import models\n                forward_fields_map = {}\n                for field in cls._meta._get_fields(reverse=False):\n                    forward_fields_map[field.name] = field\n                    if hasattr(field, 'attname'):\n                        forward_fields_map[field.attname] = field\n                \n                for field_name in constraint.fields:\n                    if field_name not in forward_fields_map:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(\n                    check.check(using=db)\n                    for check in cls._meta.constraints\n                    if isinstance(check, CheckConstraint)\n                )\n        \n        # Check that fields referenced by UniqueConstraints exist\n        from django.db import models\n        \n        # Build forward fields map to avoid hitting relation tree prematurely\n        forward_fields_map = {}\n        for field in cls._meta._get_fields(reverse=False):\n            forward_fields_map[field.name] = field\n            if hasattr(field, 'attname'):\n                forward_fields_map[field.attname] = field\n        \n        # Validate UniqueConstraint fields\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                for field_name in constraint.fields:\n                    if field_name not in forward_fields_map:\n                        errors.append(\n                            checks.Error(\n                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n        \n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not (\n                connection.features.supports_table_check_constraints or\n                connection.features.supports_column_check_constraints\n            ):\n                errors.extend(cls._check_constraints_database_backends(connection))\n            if connection.features.supports_over_clause:\n                errors.extend(cls._check_constraints_sql_keywords(connection))\n        \n        # Check that constraint fields exist and are local\n        from django.db import models\n        forward_fields_map = {}\n        for field in cls._meta._get_fields(reverse=False):\n            forward_fields_map[field.name] = field\n            if hasattr(field, 'attname'):\n                forward_fields_map[field.attname] = field\n        \n        for constraint in cls._meta.constraints:\n            if hasattr(constraint, 'fields'):\n                for field_name in constraint.fields:\n                    try:\n                        field = forward_fields_map[field_name]\n                    except KeyError:\n                        errors.append(\n                            checks.Error(\n                                \"'%s' refers to the nonexistent field '%s'.\" % (\n                                    constraint.name, field_name,\n                                ),\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n                    else:\n                        if isinstance(field.remote_field, models.ManyToManyRel):\n                            errors.append(\n                                checks.Error(\n                                    \"'%s' refers to a ManyToManyField '%s', but \"\n                                    \"ManyToManyFields are not permitted in constraints.\" % (\n                                        constraint.name, field_name,\n                                    ),\n                                    obj=cls,\n                                    id='models.E013',\n                                )\n                            )\n                        elif field not in cls._meta.local_fields:\n                            errors.append(\n                                checks.Error(\n                                    \"'%s' refers to field '%s' which is not local to model '%s'.\"\n                                    % (constraint.name, field_name, cls._meta.object_name),\n                                    hint=\"This issue may be caused by multi-table inheritance.\",\n                                    obj=cls,\n                                    id='models.E016',\n                                )\n                            )\n        \n        return errors\n",
      "\n    @classmethod\n    def _check_constraints(cls, databases):\n        errors = []\n        for db in databases:\n            if not router.allow_migrate_model(db, cls):\n                continue\n            connection = connections[db]\n            if not getattr(connection.features, 'supports_table_check_constraints', True):\n                errors.extend(\n                    checks.Warning(\n                        '%s does not support check constraints.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W027',\n                    ) for constraint in cls._meta.constraints\n                    if isinstance(constraint, CheckConstraint)\n                )\n            if not getattr(connection.features, 'supports_partial_indexes', True):\n                errors.extend(\n                    checks.Warning(\n                        '%s does not support unique constraints with '\n                        'conditions.' % connection.display_name,\n                        hint=(\n                            \"A constraint won't be created. Silence this \"\n                            \"warning if you don't care about it.\"\n                        ),\n                        obj=cls,\n                        id='models.W036',\n                    ) for constraint in cls._meta.constraints\n                    if isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n                )\n        \n        # Validate UniqueConstraint fields\n        forward_fields_map = {}\n        for field in cls._meta._get_fields(reverse=False):\n            forward_fields_map[field.name] = field\n            if hasattr(field, 'attname'):\n                forward_fields_map[field.attname] = field\n\n        for constraint in cls._meta.constraints:\n            if isinstance(constraint, UniqueConstraint):\n                for field_name in constraint.fields:\n                    if field_name not in forward_fields_map:\n                        errors.append(\n                            checks.Error(\n                                \"'%s' refers to the nonexistent field '%s'.\" % (\n                                    constraint.name, field_name,\n                                ),\n                                obj=cls,\n                                id='models.E012',\n                            )\n                        )\n        \n        return errors\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..d8a04c5462 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,6 +1637,7 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n+\n     def _check_local_fields(cls, fields, option):\n         from django.db import models\n \n@@ -1864,6 +1865,7 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n+\n     def _check_constraints(cls, databases):\n         errors = []\n         for db in databases:\n@@ -1926,6 +1928,48 @@ class Model(metaclass=ModelBase):\n                         id='models.W038',\n                     )\n                 )\n+        \n+        # Validate that UniqueConstraint fields exist on the model\n+        forward_fields_map = {}\n+        for field in cls._meta._get_fields(reverse=False):\n+            forward_fields_map[field.name] = field\n+            if hasattr(field, 'attname'):\n+                forward_fields_map[field.attname] = field\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraint' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+                    else:\n+                        if hasattr(field, 'remote_field') and isinstance(field.remote_field, models.ManyToManyRel):\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraint' refers to a ManyToManyField '%s', but \"\n+                                    \"ManyToManyFields are not permitted in 'constraint'.\" % field_name,\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+                        elif field not in cls._meta.local_fields:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'constraint' refers to field '%s' which is not local to model '%s'.\"\n+                                    % (field_name, cls._meta.object_name),\n+                                    hint=\"This issue may be caused by multi-table inheritance.\",\n+                                    obj=cls,\n+                                    id='models.E016',\n+                                )\n+                            )\n+        \n         return errors\n \n \n",
    "variant_0": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..158f533d39 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,47 +1637,50 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n \n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n+    @classmethod\n+    def _check_constraints(cls):\n+        errors = []\n+        for db in connections:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(\n+                    check.check(using=db)\n+                    for check in cls._meta.constraints\n+                    if isinstance(check, CheckConstraint)\n+                )\n+            if not connection.features.supports_partial_indexes:\n+                errors.extend(\n+                    check.check(using=db)\n+                    for check in cls._meta.constraints\n+                    if isinstance(check, UniqueConstraint) and check.condition is not None\n+                )\n+        \n+        # Check that constraint fields exist\n         forward_fields_map = {}\n         for field in cls._meta._get_fields(reverse=False):\n             forward_fields_map[field.name] = field\n             if hasattr(field, 'attname'):\n                 forward_fields_map[field.attname] = field\n-\n-        errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for field_name in constraint.fields:\n+                    if field_name not in forward_fields_map:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n                         )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+        \n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,6 +1866,8 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n@@ -1926,6 +1931,28 @@ class Model(metaclass=ModelBase):\n                         id='models.W038',\n                     )\n                 )\n+        \n+        # Validate UniqueConstraint fields exist\n+        forward_fields_map = {}\n+        for field in cls._meta._get_fields(reverse=False):\n+            forward_fields_map[field.name] = field\n+            if hasattr(field, 'attname'):\n+                forward_fields_map[field.attname] = field\n+\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for field_name in constraint.fields:\n+                    if field_name not in forward_fields_map:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'%s' refers to the nonexistent field '%s'.\" % (\n+                                    constraint.name, field_name,\n+                                ),\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+        \n         return errors\n \n \n",
    "variant_1": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..9a4e27655d 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,47 +1637,48 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n \n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(\n+                    check.clone(id='models.W027') for check in\n+                    cls._check_check_constraints(databases)\n+                )\n+            if not connection.features.supports_partial_indexes:\n+                errors.extend(\n+                    check.clone(id='models.W036') for check in\n+                    cls._check_partial_indexes(databases)\n+                )\n+        \n+        # Validate fields in UniqueConstraint instances\n         forward_fields_map = {}\n         for field in cls._meta._get_fields(reverse=False):\n             forward_fields_map[field.name] = field\n             if hasattr(field, 'attname'):\n                 forward_fields_map[field.attname] = field\n-\n-        errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n+        \n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields'):\n+                for field_name in constraint.fields:\n+                    if field_name not in forward_fields_map:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n                         )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+        \n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,6 +1864,8 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n@@ -1926,6 +1929,30 @@ class Model(metaclass=ModelBase):\n                         id='models.W038',\n                     )\n                 )\n+        \n+        # Validate fields in UniqueConstraint\n+        forward_fields_map = {}\n+        for f in cls._meta._get_fields(reverse=False):\n+            forward_fields_map[f.name] = f\n+            if hasattr(f, 'attname'):\n+                forward_fields_map[f.attname] = f\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'%s' refers to the nonexistent field '%s'.\" % (\n+                                    constraint.name, field_name\n+                                ),\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+        \n         return errors\n \n \n",
    "variant_2": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..7cff2929ee 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,47 +1637,46 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n \n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n+    @classmethod\n+    def _check_constraints(cls):\n+        errors = []\n+        for db in settings.DATABASES:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(cls._check_constraints_database_backends(connection))\n+            if not connection.features.supports_partial_indexes:\n+                errors.extend(cls._check_constraints_partial_indexes(connection))\n+        \n+        # Check that fields in UniqueConstraints exist\n+        from django.db import models\n+        \n+        # Build fields map to avoid hitting relation tree prematurely\n         forward_fields_map = {}\n         for field in cls._meta._get_fields(reverse=False):\n             forward_fields_map[field.name] = field\n             if hasattr(field, 'attname'):\n                 forward_fields_map[field.attname] = field\n-\n-        errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n+        \n+        # Validate fields in UniqueConstraints\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for field_name in constraint.fields:\n+                    if field_name not in forward_fields_map:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n                         )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+        \n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,6 +1862,8 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n@@ -1926,6 +1927,28 @@ class Model(metaclass=ModelBase):\n                         id='models.W038',\n                     )\n                 )\n+        \n+        # Check that fields in UniqueConstraints exist\n+        forward_fields_map = {}\n+        for field in cls._meta.local_fields:\n+            forward_fields_map[field.name] = field\n+            if hasattr(field, 'attname'):\n+                forward_fields_map[field.attname] = field\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for field_name in constraint.fields:\n+                    if field_name not in forward_fields_map:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'%s' refers to the nonexistent field '%s'.\" % (\n+                                    constraint.name, field_name,\n+                                ),\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+        \n         return errors\n \n \n",
    "variant_3": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..3b5ffeb840 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,47 +1637,44 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n \n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n+    @classmethod\n+    def _check_constraints(cls):\n+        errors = []\n+        for db in connections:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(\n+                    check.check(using=db)\n+                    for check in cls._meta.constraints\n+                    if isinstance(check, CheckConstraint)\n+                )\n+        \n+        # Validate UniqueConstraint fields\n         forward_fields_map = {}\n         for field in cls._meta._get_fields(reverse=False):\n             forward_fields_map[field.name] = field\n             if hasattr(field, 'attname'):\n                 forward_fields_map[field.attname] = field\n-\n-        errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for field_name in constraint.fields:\n+                    if field_name not in forward_fields_map:\n+                        errors.append(\n+                            checks.Error(\n+                                \"UniqueConstraint refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n                         )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+        \n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,6 +1860,8 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n@@ -1926,6 +1925,33 @@ class Model(metaclass=ModelBase):\n                         id='models.W038',\n                     )\n                 )\n+        \n+        # Validate UniqueConstraint fields exist\n+        forward_fields_map = {}\n+        for field in cls._meta._get_fields(reverse=False):\n+            forward_fields_map[field.name] = field\n+            # Due to the way Django's internals work, get_field() should also\n+            # be able to fetch a field by attname. In the case of a concrete\n+            # field with relation, includes the *_id name too\n+            try:\n+                forward_fields_map[field.attname] = field\n+            except AttributeError:\n+                pass\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for field_name in constraint.fields:\n+                    if field_name not in forward_fields_map:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'%s' refers to the nonexistent field '%s'.\" % (\n+                                    constraint.name, field_name,\n+                                ),\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+        \n         return errors\n \n \n",
    "variant_4": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..b143afb86c 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,47 +1637,54 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n \n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(\n+                    check.clone(\n+                        id='models.W027',\n+                        hint=(\n+                            'A constraint won\\'t be created. Silence this '\n+                            'warning if you don\\'t care about it.'\n+                        ),\n+                    ) for check in cls._check_check_constraints(databases)\n+                )\n+        \n+        # Validate UniqueConstraint field names\n+        from django.db import models\n+        \n+        # Build forward fields map to avoid hitting the relation tree prematurely\n         forward_fields_map = {}\n         for field in cls._meta._get_fields(reverse=False):\n             forward_fields_map[field.name] = field\n             if hasattr(field, 'attname'):\n                 forward_fields_map[field.attname] = field\n-\n-        errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n+        \n+        # Check UniqueConstraint fields\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for field_name in constraint.fields:\n+                    if field_name not in forward_fields_map:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'%s' refers to the nonexistent field '%s'.\" % (\n+                                    constraint.name, field_name,\n+                                ),\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n                         )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+        \n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,6 +1870,8 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n@@ -1926,6 +1935,27 @@ class Model(metaclass=ModelBase):\n                         id='models.W038',\n                     )\n                 )\n+        \n+        # Validate UniqueConstraint fields exist\n+        forward_fields_map = {\n+            field.name: field for field in cls._meta.get_fields()\n+            if hasattr(field, 'name')\n+        }\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for field_name in constraint.fields:\n+                    if field_name not in forward_fields_map:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'%s' refers to the nonexistent field '%s'.\" % (\n+                                    constraint.name, field_name,\n+                                ),\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+        \n         return errors\n \n \n",
    "variant_5": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..401cbf3783 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,47 +1637,64 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n-\n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n-        forward_fields_map = {}\n-        for field in cls._meta._get_fields(reverse=False):\n-            forward_fields_map[field.name] = field\n-            if hasattr(field, 'attname'):\n-                forward_fields_map[field.attname] = field\n \n+    @classmethod\n+    def _check_constraints(cls):\n         errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n+        if not django.VERSION >= (2, 2):\n+            return errors\n+            \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, CheckConstraint):\n+                if not connections[DEFAULT_DB_ALIAS].features.supports_table_check_constraints:\n                     errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n+                        checks.Warning(\n+                            '%s does not support check constraints.' % (\n+                                connections[DEFAULT_DB_ALIAS].display_name,\n+                            ),\n+                            hint=(\n+                                \"A constraint won't be created. Silence this \"\n+                                \"warning if you don't care about it.\"\n                             ),\n                             obj=cls,\n-                            id='models.E013',\n+                            id='models.W027',\n                         )\n                     )\n-                elif field not in cls._meta.local_fields:\n+            elif isinstance(constraint, UniqueConstraint):\n+                if not connections[DEFAULT_DB_ALIAS].features.supports_partial_indexes and constraint.condition is not None:\n                     errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+                        checks.Warning(\n+                            '%s does not support unique constraints with '\n+                            'conditions.' % (\n+                                connections[DEFAULT_DB_ALIAS].display_name,\n+                            ),\n+                            hint=(\n+                                \"A constraint won't be created. Silence this \"\n+                                \"warning if you don't care about it.\"\n+                            ),\n+                            obj=cls,\n+                            id='models.W036',\n+                        )\n+                    )\n+                \n+                # Check that fields in UniqueConstraint exist\n+                from django.db import models\n+                forward_fields_map = {}\n+                for field in cls._meta._get_fields(reverse=False):\n+                    forward_fields_map[field.name] = field\n+                    if hasattr(field, 'attname'):\n+                        forward_fields_map[field.attname] = field\n+                \n+                for field_name in constraint.fields:\n+                    if field_name not in forward_fields_map:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,6 +1880,8 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n@@ -1926,6 +1945,34 @@ class Model(metaclass=ModelBase):\n                         id='models.W038',\n                     )\n                 )\n+        \n+        # Validate constraint fields exist\n+        forward_fields_map = {}\n+        for field in cls._meta._get_fields(reverse=False):\n+            forward_fields_map[field.name] = field\n+            # Due to the way Django's internals work, get_field() should also\n+            # be able to fetch a field by attname. In the case of a concrete\n+            # field with relation, includes the *_id name too\n+            try:\n+                forward_fields_map[field.attname] = field\n+            except AttributeError:\n+                pass\n+\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for field_name in constraint.fields:\n+                    try:\n+                        cls._meta.get_field(field_name)\n+                    except FieldDoesNotExist:\n+                        if field_name in forward_fields_map:\n+                            continue\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n         return errors\n \n \n",
    "variant_6": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..53e5b4c5bd 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,47 +1637,48 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n \n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(\n+                    check.check(using=db)\n+                    for check in cls._meta.constraints\n+                    if isinstance(check, CheckConstraint)\n+                )\n+        \n+        # Check that fields referenced by UniqueConstraints exist\n+        from django.db import models\n+        \n+        # Build forward fields map to avoid hitting relation tree prematurely\n         forward_fields_map = {}\n         for field in cls._meta._get_fields(reverse=False):\n             forward_fields_map[field.name] = field\n             if hasattr(field, 'attname'):\n                 forward_fields_map[field.attname] = field\n-\n-        errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n+        \n+        # Validate UniqueConstraint fields\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for field_name in constraint.fields:\n+                    if field_name not in forward_fields_map:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n                         )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+        \n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,6 +1864,8 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n@@ -1926,6 +1929,27 @@ class Model(metaclass=ModelBase):\n                         id='models.W038',\n                     )\n                 )\n+        \n+        # Check that UniqueConstraint fields exist\n+        forward_fields_map = {}\n+        for field in cls._meta.get_fields():\n+            forward_fields_map[field.name] = field\n+            if hasattr(field, 'attname'):\n+                forward_fields_map[field.attname] = field\n+\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for field_name in constraint.fields:\n+                    if field_name not in forward_fields_map:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'%s' refers to the nonexistent field '%s'.\" % (\n+                                    constraint.name, field_name,\n+                                ),\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n         return errors\n \n \n",
    "variant_7": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..fe595737ae 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,47 +1637,69 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n \n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                connection.features.supports_table_check_constraints or\n+                connection.features.supports_column_check_constraints\n+            ):\n+                errors.extend(cls._check_constraints_database_backends(connection))\n+            if connection.features.supports_over_clause:\n+                errors.extend(cls._check_constraints_sql_keywords(connection))\n+        \n+        # Check that constraint fields exist and are local\n+        from django.db import models\n         forward_fields_map = {}\n         for field in cls._meta._get_fields(reverse=False):\n             forward_fields_map[field.name] = field\n             if hasattr(field, 'attname'):\n                 forward_fields_map[field.attname] = field\n-\n-        errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n+        \n+        for constraint in cls._meta.constraints:\n+            if hasattr(constraint, 'fields'):\n+                for field_name in constraint.fields:\n+                    try:\n+                        field = forward_fields_map[field_name]\n+                    except KeyError:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'%s' refers to the nonexistent field '%s'.\" % (\n+                                    constraint.name, field_name,\n+                                ),\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n                         )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+                    else:\n+                        if isinstance(field.remote_field, models.ManyToManyRel):\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'%s' refers to a ManyToManyField '%s', but \"\n+                                    \"ManyToManyFields are not permitted in constraints.\" % (\n+                                        constraint.name, field_name,\n+                                    ),\n+                                    obj=cls,\n+                                    id='models.E013',\n+                                )\n+                            )\n+                        elif field not in cls._meta.local_fields:\n+                            errors.append(\n+                                checks.Error(\n+                                    \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+                                    % (constraint.name, field_name, cls._meta.object_name),\n+                                    hint=\"This issue may be caused by multi-table inheritance.\",\n+                                    obj=cls,\n+                                    id='models.E016',\n+                                )\n+                            )\n+        \n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,6 +1885,8 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n@@ -1926,6 +1950,28 @@ class Model(metaclass=ModelBase):\n                         id='models.W038',\n                     )\n                 )\n+        \n+        # Check that fields in UniqueConstraints exist\n+        forward_fields_map = {}\n+        for field in cls._meta.get_fields():\n+            forward_fields_map[field.name] = field\n+            if hasattr(field, 'attname'):\n+                forward_fields_map[field.attname] = field\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for field_name in constraint.fields:\n+                    if field_name not in forward_fields_map:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'%s' refers to the nonexistent field '%s'.\" % (\n+                                    constraint.name, field_name,\n+                                ),\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+        \n         return errors\n \n \n",
    "variant_8": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7bb3fa4706..caf7a50f81 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1637,47 +1637,64 @@ class Model(metaclass=ModelBase):\n         return errors\n \n     @classmethod\n-    def _check_local_fields(cls, fields, option):\n-        from django.db import models\n \n-        # In order to avoid hitting the relation tree prematurely, we use our\n-        # own fields_map instead of using get_field()\n+    @classmethod\n+    def _check_constraints(cls, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, cls):\n+                continue\n+            connection = connections[db]\n+            if not getattr(connection.features, 'supports_table_check_constraints', True):\n+                errors.extend(\n+                    checks.Warning(\n+                        '%s does not support check constraints.' % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n+                        ),\n+                        obj=cls,\n+                        id='models.W027',\n+                    ) for constraint in cls._meta.constraints\n+                    if isinstance(constraint, CheckConstraint)\n+                )\n+            if not getattr(connection.features, 'supports_partial_indexes', True):\n+                errors.extend(\n+                    checks.Warning(\n+                        '%s does not support unique constraints with '\n+                        'conditions.' % connection.display_name,\n+                        hint=(\n+                            \"A constraint won't be created. Silence this \"\n+                            \"warning if you don't care about it.\"\n+                        ),\n+                        obj=cls,\n+                        id='models.W036',\n+                    ) for constraint in cls._meta.constraints\n+                    if isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n+                )\n+        \n+        # Validate UniqueConstraint fields\n         forward_fields_map = {}\n         for field in cls._meta._get_fields(reverse=False):\n             forward_fields_map[field.name] = field\n             if hasattr(field, 'attname'):\n                 forward_fields_map[field.attname] = field\n \n-        errors = []\n-        for field_name in fields:\n-            try:\n-                field = forward_fields_map[field_name]\n-            except KeyError:\n-                errors.append(\n-                    checks.Error(\n-                        \"'%s' refers to the nonexistent field '%s'.\" % (\n-                            option, field_name,\n-                        ),\n-                        obj=cls,\n-                        id='models.E012',\n-                    )\n-                )\n-            else:\n-                if isinstance(field.remote_field, models.ManyToManyRel):\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to a ManyToManyField '%s', but \"\n-                            \"ManyToManyFields are not permitted in '%s'.\" % (\n-                                option, field_name, option,\n-                            ),\n-                            obj=cls,\n-                            id='models.E013',\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for field_name in constraint.fields:\n+                    if field_name not in forward_fields_map:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'%s' refers to the nonexistent field '%s'.\" % (\n+                                    constraint.name, field_name,\n+                                ),\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n                         )\n-                    )\n-                elif field not in cls._meta.local_fields:\n-                    errors.append(\n-                        checks.Error(\n-                            \"'%s' refers to field '%s' which is not local to model '%s'.\"\n+        \n+        return errors\n                             % (option, field_name, cls._meta.object_name),\n                             hint=\"This issue may be caused by multi-table inheritance.\",\n                             obj=cls,\n@@ -1863,6 +1880,8 @@ class Model(metaclass=ModelBase):\n \n         return errors\n \n+    @classmethod\n+\n     @classmethod\n     def _check_constraints(cls, databases):\n         errors = []\n@@ -1926,6 +1945,26 @@ class Model(metaclass=ModelBase):\n                         id='models.W038',\n                     )\n                 )\n+        \n+        # Validate UniqueConstraint fields exist\n+        forward_fields_map = {}\n+        for field, model in cls._meta.get_fields_with_model():\n+            forward_fields_map[field.name] = model\n+            if hasattr(field, 'attname'):\n+                forward_fields_map[field.attname] = model\n+        \n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint):\n+                for field_name in constraint.fields:\n+                    if field_name not in forward_fields_map:\n+                        errors.append(\n+                            checks.Error(\n+                                \"'constraints' refers to the nonexistent field '%s'.\" % field_name,\n+                                obj=cls,\n+                                id='models.E012',\n+                            )\n+                        )\n+        \n         return errors\n \n \n"
  }
}