{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 766-772)": "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
    "Location 2 (/root/hy/projects_4/django/django/db/models/base.py lines 946-950)": "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
    "Location 3 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 868-879)": "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 766-772)": [
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/db/models/base.py lines 946-950)": [
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\nif self.choices is not None:\n    if not hasattr(cls, 'get_%s_display' % self.name):\n        def make_get_display(field_name):\n            def get_display(self):\n                field = self._meta.get_field(field_name)\n                return self._get_FIELD_display(field)\n            return get_display\n        \n        setattr(\n            cls,\n            'get_%s_display' % self.name,\n            make_get_display(self.name),\n        )\n",
      "\nif self.choices is not None:\n    if not hasattr(cls, 'get_%s_display' % self.name):\n        def make_get_display(field_name):\n            def get_display(self):\n                field = self._meta.get_field(field_name)\n                return self._get_FIELD_display(field)\n            return get_display\n        \n        setattr(\n            cls,\n            'get_%s_display' % self.name,\n            make_get_display(self.name),\n        )\n",
      "\nif self.choices is not None:\n    if not hasattr(cls, 'get_%s_display' % self.name):\n        def make_get_display(field_name):\n            def get_display(self):\n                field = self._meta.get_field(field_name)\n                return self._get_FIELD_display(field)\n            return get_display\n        \n        setattr(\n            cls,\n            'get_%s_display' % self.name,\n            make_get_display(self.name),\n        )\n"
    ],
    "Location 3 (/root/hy/projects_4/django/django/db/models/fields/__init__.py lines 868-879)": [
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        if private_only:\n            cls._meta.add_field(self, private=True)\n        else:\n            cls._meta.add_field(self)\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n",
      "\n    def contribute_to_class(self, cls, name, private_only=False):\n        \"\"\"\n        Register the field with the model class it belongs to.\n\n        If private_only is True, create a separate instance of this field\n        for every subclass of cls, even if cls is not an abstract model.\n        \"\"\"\n        self.set_attributes_from_name(name)\n        self.model = cls\n        cls._meta.add_field(self, private=private_only)\n        if self.choices is not None:\n            if not hasattr(cls, 'get_%s_display' % self.name):\n                def make_get_display(field_name):\n                    def get_display(self):\n                        field = self._meta.get_field(field_name)\n                        return self._get_FIELD_display(field)\n                    return get_display\n                \n                setattr(\n                    cls,\n                    'get_%s_display' % self.name,\n                    make_get_display(self.name),\n                )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..3ab774fbc3 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,6 +943,7 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n+\n     def _get_FIELD_display(self, field):\n         value = getattr(self, field.attname)\n         choices_dict = dict(make_hashable(field.flatchoices))\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..ca725a5384 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,12 +763,19 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    make_get_display(self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,6 +872,7 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n+\n     def _get_flatchoices(self):\n         \"\"\"Flattened version of choices tuple.\"\"\"\n         if self.choices is None:\n",
    "variant_0": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..d996340620 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,11 +943,20 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n-    def _get_FIELD_display(self, field):\n-        value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n-        # force_str() to coerce lazy strings.\n-        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n+\n+        if self.choices is not None:\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n+                setattr(\n+                    cls,\n+                    'get_%s_display' % self.name,\n+                    make_get_display(self.name),\n+                )\n \n     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):\n         if not self.pk:\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..2a5174d9d0 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,12 +763,19 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    make_get_display(self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,18 +872,30 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n-    def _get_flatchoices(self):\n-        \"\"\"Flattened version of choices tuple.\"\"\"\n-        if self.choices is None:\n-            return []\n-        flat = []\n-        for choice, value in self.choices:\n-            if isinstance(value, (list, tuple)):\n-                flat.extend(value)\n-            else:\n-                flat.append((choice, value))\n-        return flat\n-    flatchoices = property(_get_flatchoices)\n+\n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.choices is not None:\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n+                setattr(\n+                    cls,\n+                    'get_%s_display' % self.name,\n+                    make_get_display(self.name),\n+                )\n \n     def save_form_data(self, instance, data):\n         setattr(instance, self.name, data)\n",
    "variant_1": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..b817096b38 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,11 +943,30 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n-    def _get_FIELD_display(self, field):\n-        value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n-        # force_str() to coerce lazy strings.\n-        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n+\n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.choices is not None:\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n+                setattr(\n+                    cls,\n+                    'get_%s_display' % self.name,\n+                    make_get_display(self.name),\n+                )\n \n     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):\n         if not self.pk:\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..2a5174d9d0 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,12 +763,19 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    make_get_display(self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,18 +872,30 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n-    def _get_flatchoices(self):\n-        \"\"\"Flattened version of choices tuple.\"\"\"\n-        if self.choices is None:\n-            return []\n-        flat = []\n-        for choice, value in self.choices:\n-            if isinstance(value, (list, tuple)):\n-                flat.extend(value)\n-            else:\n-                flat.append((choice, value))\n-        return flat\n-    flatchoices = property(_get_flatchoices)\n+\n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.choices is not None:\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n+                setattr(\n+                    cls,\n+                    'get_%s_display' % self.name,\n+                    make_get_display(self.name),\n+                )\n \n     def save_form_data(self, instance, data):\n         setattr(instance, self.name, data)\n",
    "variant_2": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..d996340620 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,11 +943,20 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n-    def _get_FIELD_display(self, field):\n-        value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n-        # force_str() to coerce lazy strings.\n-        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n+\n+        if self.choices is not None:\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n+                setattr(\n+                    cls,\n+                    'get_%s_display' % self.name,\n+                    make_get_display(self.name),\n+                )\n \n     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):\n         if not self.pk:\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..2a5174d9d0 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,12 +763,19 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    make_get_display(self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,18 +872,30 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n-    def _get_flatchoices(self):\n-        \"\"\"Flattened version of choices tuple.\"\"\"\n-        if self.choices is None:\n-            return []\n-        flat = []\n-        for choice, value in self.choices:\n-            if isinstance(value, (list, tuple)):\n-                flat.extend(value)\n-            else:\n-                flat.append((choice, value))\n-        return flat\n-    flatchoices = property(_get_flatchoices)\n+\n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.choices is not None:\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n+                setattr(\n+                    cls,\n+                    'get_%s_display' % self.name,\n+                    make_get_display(self.name),\n+                )\n \n     def save_form_data(self, instance, data):\n         setattr(instance, self.name, data)\n",
    "variant_3": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..d996340620 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,11 +943,20 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n-    def _get_FIELD_display(self, field):\n-        value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n-        # force_str() to coerce lazy strings.\n-        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n+\n+        if self.choices is not None:\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n+                setattr(\n+                    cls,\n+                    'get_%s_display' % self.name,\n+                    make_get_display(self.name),\n+                )\n \n     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):\n         if not self.pk:\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..198f22b811 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,12 +763,19 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    make_get_display(self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,18 +872,33 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n-    def _get_flatchoices(self):\n-        \"\"\"Flattened version of choices tuple.\"\"\"\n-        if self.choices is None:\n-            return []\n-        flat = []\n-        for choice, value in self.choices:\n-            if isinstance(value, (list, tuple)):\n-                flat.extend(value)\n-            else:\n-                flat.append((choice, value))\n-        return flat\n-    flatchoices = property(_get_flatchoices)\n+\n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        if private_only:\n+            cls._meta.add_field(self, private=True)\n+        else:\n+            cls._meta.add_field(self)\n+        if self.choices is not None:\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n+                setattr(\n+                    cls,\n+                    'get_%s_display' % self.name,\n+                    make_get_display(self.name),\n+                )\n \n     def save_form_data(self, instance, data):\n         setattr(instance, self.name, data)\n",
    "variant_4": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..d996340620 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,11 +943,20 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n-    def _get_FIELD_display(self, field):\n-        value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n-        # force_str() to coerce lazy strings.\n-        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n+\n+        if self.choices is not None:\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n+                setattr(\n+                    cls,\n+                    'get_%s_display' % self.name,\n+                    make_get_display(self.name),\n+                )\n \n     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):\n         if not self.pk:\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..2a5174d9d0 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,12 +763,19 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    make_get_display(self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,18 +872,30 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n-    def _get_flatchoices(self):\n-        \"\"\"Flattened version of choices tuple.\"\"\"\n-        if self.choices is None:\n-            return []\n-        flat = []\n-        for choice, value in self.choices:\n-            if isinstance(value, (list, tuple)):\n-                flat.extend(value)\n-            else:\n-                flat.append((choice, value))\n-        return flat\n-    flatchoices = property(_get_flatchoices)\n+\n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.choices is not None:\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n+                setattr(\n+                    cls,\n+                    'get_%s_display' % self.name,\n+                    make_get_display(self.name),\n+                )\n \n     def save_form_data(self, instance, data):\n         setattr(instance, self.name, data)\n",
    "variant_5": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..d996340620 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,11 +943,20 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n-    def _get_FIELD_display(self, field):\n-        value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n-        # force_str() to coerce lazy strings.\n-        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n+\n+        if self.choices is not None:\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n+                setattr(\n+                    cls,\n+                    'get_%s_display' % self.name,\n+                    make_get_display(self.name),\n+                )\n \n     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):\n         if not self.pk:\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..2a5174d9d0 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,12 +763,19 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    make_get_display(self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,18 +872,30 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n-    def _get_flatchoices(self):\n-        \"\"\"Flattened version of choices tuple.\"\"\"\n-        if self.choices is None:\n-            return []\n-        flat = []\n-        for choice, value in self.choices:\n-            if isinstance(value, (list, tuple)):\n-                flat.extend(value)\n-            else:\n-                flat.append((choice, value))\n-        return flat\n-    flatchoices = property(_get_flatchoices)\n+\n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.choices is not None:\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n+                setattr(\n+                    cls,\n+                    'get_%s_display' % self.name,\n+                    make_get_display(self.name),\n+                )\n \n     def save_form_data(self, instance, data):\n         setattr(instance, self.name, data)\n",
    "variant_6": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..26d0cc0be3 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,11 +943,20 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n-    def _get_FIELD_display(self, field):\n-        value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n-        # force_str() to coerce lazy strings.\n-        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n+\n+if self.choices is not None:\n+    if not hasattr(cls, 'get_%s_display' % self.name):\n+        def make_get_display(field_name):\n+            def get_display(self):\n+                field = self._meta.get_field(field_name)\n+                return self._get_FIELD_display(field)\n+            return get_display\n+        \n+        setattr(\n+            cls,\n+            'get_%s_display' % self.name,\n+            make_get_display(self.name),\n+        )\n \n     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):\n         if not self.pk:\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..2a5174d9d0 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,12 +763,19 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    make_get_display(self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,18 +872,30 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n-    def _get_flatchoices(self):\n-        \"\"\"Flattened version of choices tuple.\"\"\"\n-        if self.choices is None:\n-            return []\n-        flat = []\n-        for choice, value in self.choices:\n-            if isinstance(value, (list, tuple)):\n-                flat.extend(value)\n-            else:\n-                flat.append((choice, value))\n-        return flat\n-    flatchoices = property(_get_flatchoices)\n+\n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.choices is not None:\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n+                setattr(\n+                    cls,\n+                    'get_%s_display' % self.name,\n+                    make_get_display(self.name),\n+                )\n \n     def save_form_data(self, instance, data):\n         setattr(instance, self.name, data)\n",
    "variant_7": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..26d0cc0be3 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,11 +943,20 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n-    def _get_FIELD_display(self, field):\n-        value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n-        # force_str() to coerce lazy strings.\n-        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n+\n+if self.choices is not None:\n+    if not hasattr(cls, 'get_%s_display' % self.name):\n+        def make_get_display(field_name):\n+            def get_display(self):\n+                field = self._meta.get_field(field_name)\n+                return self._get_FIELD_display(field)\n+            return get_display\n+        \n+        setattr(\n+            cls,\n+            'get_%s_display' % self.name,\n+            make_get_display(self.name),\n+        )\n \n     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):\n         if not self.pk:\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..2a5174d9d0 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,12 +763,19 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    make_get_display(self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,18 +872,30 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n-    def _get_flatchoices(self):\n-        \"\"\"Flattened version of choices tuple.\"\"\"\n-        if self.choices is None:\n-            return []\n-        flat = []\n-        for choice, value in self.choices:\n-            if isinstance(value, (list, tuple)):\n-                flat.extend(value)\n-            else:\n-                flat.append((choice, value))\n-        return flat\n-    flatchoices = property(_get_flatchoices)\n+\n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.choices is not None:\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n+                setattr(\n+                    cls,\n+                    'get_%s_display' % self.name,\n+                    make_get_display(self.name),\n+                )\n \n     def save_form_data(self, instance, data):\n         setattr(instance, self.name, data)\n",
    "variant_8": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 8ea6c05ef9..26d0cc0be3 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -943,11 +943,20 @@ class Model(metaclass=ModelBase):\n \n     delete.alters_data = True\n \n-    def _get_FIELD_display(self, field):\n-        value = getattr(self, field.attname)\n-        choices_dict = dict(make_hashable(field.flatchoices))\n-        # force_str() to coerce lazy strings.\n-        return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)\n+\n+if self.choices is not None:\n+    if not hasattr(cls, 'get_%s_display' % self.name):\n+        def make_get_display(field_name):\n+            def get_display(self):\n+                field = self._meta.get_field(field_name)\n+                return self._get_FIELD_display(field)\n+            return get_display\n+        \n+        setattr(\n+            cls,\n+            'get_%s_display' % self.name,\n+            make_get_display(self.name),\n+        )\n \n     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):\n         if not self.pk:\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 1a55d3d417..2a5174d9d0 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -763,12 +763,19 @@ class Field(RegisterLookupMixin):\n             # such fields can't be deferred (we don't have a check for this).\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n+\n         if self.choices is not None:\n             if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n                 setattr(\n                     cls,\n                     'get_%s_display' % self.name,\n-                    partialmethod(cls._get_FIELD_display, field=self),\n+                    make_get_display(self.name),\n                 )\n \n     def get_filter_kwargs_for_object(self, obj):\n@@ -865,18 +872,30 @@ class Field(RegisterLookupMixin):\n         \"\"\"\n         return str(self.value_from_object(obj))\n \n-    def _get_flatchoices(self):\n-        \"\"\"Flattened version of choices tuple.\"\"\"\n-        if self.choices is None:\n-            return []\n-        flat = []\n-        for choice, value in self.choices:\n-            if isinstance(value, (list, tuple)):\n-                flat.extend(value)\n-            else:\n-                flat.append((choice, value))\n-        return flat\n-    flatchoices = property(_get_flatchoices)\n+\n+    def contribute_to_class(self, cls, name, private_only=False):\n+        \"\"\"\n+        Register the field with the model class it belongs to.\n+\n+        If private_only is True, create a separate instance of this field\n+        for every subclass of cls, even if cls is not an abstract model.\n+        \"\"\"\n+        self.set_attributes_from_name(name)\n+        self.model = cls\n+        cls._meta.add_field(self, private=private_only)\n+        if self.choices is not None:\n+            if not hasattr(cls, 'get_%s_display' % self.name):\n+                def make_get_display(field_name):\n+                    def get_display(self):\n+                        field = self._meta.get_field(field_name)\n+                        return self._get_FIELD_display(field)\n+                    return get_display\n+                \n+                setattr(\n+                    cls,\n+                    'get_%s_display' % self.name,\n+                    make_get_display(self.name),\n+                )\n \n     def save_form_data(self, instance, data):\n         setattr(instance, self.name, data)\n"
  }
}