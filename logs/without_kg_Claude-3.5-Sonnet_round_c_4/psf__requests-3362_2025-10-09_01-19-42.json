{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/requests/requests/utils.py lines 362-365)": "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
    "Location 2 (/root/hy/projects_4/requests/requests/models.py lines 777-779)": "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Given an iterator and a requests Response object, decode the bytes of\n    the iterator into unicode.\n    \"\"\"\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    for chunk in iterator:\n        yield chunk.decode(encoding, errors='replace')\n",
    "Location 3 (/root/hy/projects_4/requests/requests/models.py lines 649-651)": "\n@property\ndef apparent_encoding(self):\n    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n    return chardet.detect(self.content)['encoding']\n",
    "Location 4 (/root/hy/projects_4/requests/requests/utils.py lines 359-374)": "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
    "Location 5 (/root/hy/projects_4/requests/requests/models.py lines 653-700)": "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/requests/requests/utils.py lines 362-365)": [
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n        if encoding is None:\n            for item in iterator:\n                yield item\n            return\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n    \n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    if r.encoding is None:\n        r.encoding = r.apparent_encoding\n\n    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n        if encoding is None:\n            for item in iterator:\n                yield item\n            return\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n"
    ],
    "Location 2 (/root/hy/projects_4/requests/requests/models.py lines 777-779)": [
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    if r.encoding is None:\n        # Use the same fallback logic as the text property\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Given an iterator and a requests response, decode the response into unicode.\n\n    :param iterator: The iterator to decode.\n    :param r: The response object.\n    :return: An iterator that yields unicode strings.\n    \"\"\"\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    for chunk in iterator:\n        yield chunk.decode(encoding, errors='replace')\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Given an iterator and a requests response, decode the response into unicode.\n\n    :param iterator: The iterator to decode.\n    :param r: The response object.\n    :returns: The decoded iterator.\n    \"\"\"\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    for chunk in iterator:\n        if isinstance(chunk, str):\n            yield chunk\n        else:\n            yield str(chunk, encoding, errors='replace')\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Given an iterator and a request, attempt to decode the response as unicode.\n\n    This code is based on http://stackoverflow.com/a/22731016/1830334\n    \"\"\"\n\n    if r.encoding is None:\n        # Fallback to auto-detected encoding, same as r.text property\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    for chunk in iterator:\n        rv = chunk\n        if isinstance(rv, bytes):\n            rv = rv.decode(encoding, 'replace')\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Given an iterator and a response, decode the bytes-iterator and\n    generate unicode-iterator.\n    \"\"\"\n    \n    encoding = r.encoding\n    \n    # Fallback to auto-detected encoding when r.encoding is None\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Given an iterator and a requests response, decode the response into unicode.\n\n    :param iterator: An iterator over the response data.\n    :param r: A requests response object.\n    \"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    for chunk in iterator:\n        rv = chunk.decode(encoding, 'replace')\n        if rv:\n            yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    for chunk in iterator:\n        rv = chunk.decode(encoding, 'replace')\n        if rv:\n            yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Given an iterator and a requests response, decode the response into unicode.\n\n    If no encoding is found in the response's headers, fall back to the apparent\n    encoding to maintain consistency with the Response.text property.\n    \"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    for chunk in iterator:\n        yield chunk.decode(encoding, errors='replace')\n"
    ],
    "Location 3 (/root/hy/projects_4/requests/requests/models.py lines 649-651)": [
      "\n@property\ndef apparent_encoding(self):\n    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n    return chardet.detect(self.content)['encoding']\n",
      "\n    @property\n    def apparent_encoding(self):\n        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n        return chardet.detect(self.content)['encoding']\n",
      "\n@property\ndef apparent_encoding(self):\n    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n    return chardet.detect(self.content)['encoding']\n",
      "\n@property\ndef apparent_encoding(self):\n    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n    return chardet.detect(self.content)['encoding']\n",
      "\n@property\ndef apparent_encoding(self):\n    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n    return chardet.detect(self.content)['encoding']\n",
      "\n@property\ndef apparent_encoding(self):\n    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n    return chardet.detect(self.content)['encoding']\n",
      "\n    @property\n    def apparent_encoding(self):\n        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n        return chardet.detect(self.content)['encoding']\n",
      "\n    @property\n    def apparent_encoding(self):\n        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n        return chardet.detect(self.content)['encoding']\n"
    ],
    "Location 4 (/root/hy/projects_4/requests/requests/utils.py lines 359-374)": [
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    encoding = r.encoding\n    if encoding is None:\n        encoding = r.apparent_encoding\n\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n"
    ],
    "Location 5 (/root/hy/projects_4/requests/requests/models.py lines 653-700)": [
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)('replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Stream decodes a iterator.\"\"\"\n\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n",
      "\ndef stream_decode_response_unicode(iterator, r):\n    \"\"\"Given an iterator and a response, decode the bytes into unicode.\"\"\"\n    if r.encoding is None:\n        encoding = r.apparent_encoding\n    else:\n        encoding = r.encoding\n\n    decoder = codecs.getincrementaldecoder(encoding)('replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode(b'', final=True)\n    if rv:\n        yield rv\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..020d9367 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -646,10 +646,12 @@ class Response(object):\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n     @property\n+\n     def apparent_encoding(self):\n         \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n         return chardet.detect(self.content)['encoding']\n \n+\n     def iter_content(self, chunk_size=1, decode_unicode=False):\n         \"\"\"Iterates over the response data.  When stream=True is set on the\n         request, this avoids reading the content at once into memory for\n@@ -774,6 +776,7 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n+\n         # Fallback to auto-detected encoding.\n         if self.encoding is None:\n             encoding = self.apparent_encoding\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..03f245ba 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,12 +356,38 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n     if r.encoding is None:\n-        for item in iterator:\n-            yield item\n+        # Fallback to auto-detected encoding.\n+        encoding = r.apparent_encoding\n+        if encoding is None:\n+            for item in iterator:\n+                yield item\n+            return\n+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+        for chunk in iterator:\n+            rv = decoder.decode(chunk)\n+            if rv:\n+                yield rv\n+        rv = decoder.decode(b'', final=True)\n+        if rv:\n+            yield rv\n+        return\n+\n+    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+        rv = decoder.decode(b'', final=True)\n+        if rv:\n+            yield rv\n         return\n \n     decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n",
    "variant_0": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..ad3e3e58 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -646,58 +646,29 @@ class Response(object):\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n     @property\n-    def apparent_encoding(self):\n-        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n-        return chardet.detect(self.content)['encoding']\n-\n-    def iter_content(self, chunk_size=1, decode_unicode=False):\n-        \"\"\"Iterates over the response data.  When stream=True is set on the\n-        request, this avoids reading the content at once into memory for\n-        large responses.  The chunk size is the number of bytes it should\n-        read into memory.  This is not necessarily the length of each item\n-        returned as decoding can take place.\n-\n-        If decode_unicode is True, content will be decoded using the best\n-        available encoding based on the response.\n-        \"\"\"\n-\n-        def generate():\n-            # Special case for urllib3.\n-            if hasattr(self.raw, 'stream'):\n-                try:\n-                    for chunk in self.raw.stream(chunk_size, decode_content=True):\n-                        yield chunk\n-                except ProtocolError as e:\n-                    raise ChunkedEncodingError(e)\n-                except DecodeError as e:\n-                    raise ContentDecodingError(e)\n-                except ReadTimeoutError as e:\n-                    raise ConnectionError(e)\n-            else:\n-                # Standard file-like object.\n-                while True:\n-                    chunk = self.raw.read(chunk_size)\n-                    if not chunk:\n-                        break\n-                    yield chunk\n \n-            self._content_consumed = True\n+@property\n+def apparent_encoding(self):\n+    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n+    return chardet.detect(self.content)['encoding']\n \n-        if self._content_consumed and isinstance(self._content, bool):\n-            raise StreamConsumedError()\n-        elif not isinstance(chunk_size, int):\n-            raise TypeError(\"chunk_size must be an int, it is instead a %s.\" % type(chunk_size))\n-        # simulate reading small chunks of the content\n-        reused_chunks = iter_slices(self._content, chunk_size)\n \n-        stream_chunks = generate()\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n \n-        chunks = reused_chunks if self._content_consumed else stream_chunks\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n \n-        if decode_unicode:\n-            chunks = stream_decode_response_unicode(chunks, self)\n-\n-        return chunks\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n     def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=None, delimiter=None):\n         \"\"\"Iterates over the response data, one line at a time.  When\n@@ -774,9 +745,18 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Given an iterator and a requests Response object, decode the bytes of\n+    the iterator into unicode.\n+    \"\"\"\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n+\n+    for chunk in iterator:\n+        yield chunk.decode(encoding, errors='replace')\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..e2239044 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,14 +356,37 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n     decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n",
    "variant_1": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..2f0ba9dd 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -646,58 +646,29 @@ class Response(object):\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n     @property\n-    def apparent_encoding(self):\n-        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n-        return chardet.detect(self.content)['encoding']\n-\n-    def iter_content(self, chunk_size=1, decode_unicode=False):\n-        \"\"\"Iterates over the response data.  When stream=True is set on the\n-        request, this avoids reading the content at once into memory for\n-        large responses.  The chunk size is the number of bytes it should\n-        read into memory.  This is not necessarily the length of each item\n-        returned as decoding can take place.\n-\n-        If decode_unicode is True, content will be decoded using the best\n-        available encoding based on the response.\n-        \"\"\"\n-\n-        def generate():\n-            # Special case for urllib3.\n-            if hasattr(self.raw, 'stream'):\n-                try:\n-                    for chunk in self.raw.stream(chunk_size, decode_content=True):\n-                        yield chunk\n-                except ProtocolError as e:\n-                    raise ChunkedEncodingError(e)\n-                except DecodeError as e:\n-                    raise ContentDecodingError(e)\n-                except ReadTimeoutError as e:\n-                    raise ConnectionError(e)\n-            else:\n-                # Standard file-like object.\n-                while True:\n-                    chunk = self.raw.read(chunk_size)\n-                    if not chunk:\n-                        break\n-                    yield chunk\n \n-            self._content_consumed = True\n+@property\n+def apparent_encoding(self):\n+    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n+    return chardet.detect(self.content)['encoding']\n \n-        if self._content_consumed and isinstance(self._content, bool):\n-            raise StreamConsumedError()\n-        elif not isinstance(chunk_size, int):\n-            raise TypeError(\"chunk_size must be an int, it is instead a %s.\" % type(chunk_size))\n-        # simulate reading small chunks of the content\n-        reused_chunks = iter_slices(self._content, chunk_size)\n \n-        stream_chunks = generate()\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n \n-        chunks = reused_chunks if self._content_consumed else stream_chunks\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n \n-        if decode_unicode:\n-            chunks = stream_decode_response_unicode(chunks, self)\n-\n-        return chunks\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n     def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=None, delimiter=None):\n         \"\"\"Iterates over the response data, one line at a time.  When\n@@ -774,9 +745,24 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    if r.encoding is None:\n+        # Use the same fallback logic as the text property\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n+\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..dce14f13 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,14 +356,32 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n     decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n",
    "variant_2": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..e7ef40f9 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -645,59 +645,30 @@ class Response(object):\n         \"\"\"True if this Response one of the permanent versions of redirect\"\"\"\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n+    @property\n+\n     @property\n     def apparent_encoding(self):\n         \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n         return chardet.detect(self.content)['encoding']\n \n-    def iter_content(self, chunk_size=1, decode_unicode=False):\n-        \"\"\"Iterates over the response data.  When stream=True is set on the\n-        request, this avoids reading the content at once into memory for\n-        large responses.  The chunk size is the number of bytes it should\n-        read into memory.  This is not necessarily the length of each item\n-        returned as decoding can take place.\n-\n-        If decode_unicode is True, content will be decoded using the best\n-        available encoding based on the response.\n-        \"\"\"\n-\n-        def generate():\n-            # Special case for urllib3.\n-            if hasattr(self.raw, 'stream'):\n-                try:\n-                    for chunk in self.raw.stream(chunk_size, decode_content=True):\n-                        yield chunk\n-                except ProtocolError as e:\n-                    raise ChunkedEncodingError(e)\n-                except DecodeError as e:\n-                    raise ContentDecodingError(e)\n-                except ReadTimeoutError as e:\n-                    raise ConnectionError(e)\n-            else:\n-                # Standard file-like object.\n-                while True:\n-                    chunk = self.raw.read(chunk_size)\n-                    if not chunk:\n-                        break\n-                    yield chunk\n-\n-            self._content_consumed = True\n-\n-        if self._content_consumed and isinstance(self._content, bool):\n-            raise StreamConsumedError()\n-        elif not isinstance(chunk_size, int):\n-            raise TypeError(\"chunk_size must be an int, it is instead a %s.\" % type(chunk_size))\n-        # simulate reading small chunks of the content\n-        reused_chunks = iter_slices(self._content, chunk_size)\n \n-        stream_chunks = generate()\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n \n-        chunks = reused_chunks if self._content_consumed else stream_chunks\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n \n-        if decode_unicode:\n-            chunks = stream_decode_response_unicode(chunks, self)\n-\n-        return chunks\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n     def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=None, delimiter=None):\n         \"\"\"Iterates over the response data, one line at a time.  When\n@@ -774,9 +745,21 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Given an iterator and a requests response, decode the response into unicode.\n+\n+    :param iterator: The iterator to decode.\n+    :param r: The response object.\n+    :return: An iterator that yields unicode strings.\n+    \"\"\"\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n+\n+    for chunk in iterator:\n+        yield chunk.decode(encoding, errors='replace')\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..dce14f13 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,14 +356,32 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n     decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n",
    "variant_3": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..8f1d6ef8 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -646,58 +646,29 @@ class Response(object):\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n     @property\n-    def apparent_encoding(self):\n-        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n-        return chardet.detect(self.content)['encoding']\n-\n-    def iter_content(self, chunk_size=1, decode_unicode=False):\n-        \"\"\"Iterates over the response data.  When stream=True is set on the\n-        request, this avoids reading the content at once into memory for\n-        large responses.  The chunk size is the number of bytes it should\n-        read into memory.  This is not necessarily the length of each item\n-        returned as decoding can take place.\n-\n-        If decode_unicode is True, content will be decoded using the best\n-        available encoding based on the response.\n-        \"\"\"\n-\n-        def generate():\n-            # Special case for urllib3.\n-            if hasattr(self.raw, 'stream'):\n-                try:\n-                    for chunk in self.raw.stream(chunk_size, decode_content=True):\n-                        yield chunk\n-                except ProtocolError as e:\n-                    raise ChunkedEncodingError(e)\n-                except DecodeError as e:\n-                    raise ContentDecodingError(e)\n-                except ReadTimeoutError as e:\n-                    raise ConnectionError(e)\n-            else:\n-                # Standard file-like object.\n-                while True:\n-                    chunk = self.raw.read(chunk_size)\n-                    if not chunk:\n-                        break\n-                    yield chunk\n-\n-            self._content_consumed = True\n \n-        if self._content_consumed and isinstance(self._content, bool):\n-            raise StreamConsumedError()\n-        elif not isinstance(chunk_size, int):\n-            raise TypeError(\"chunk_size must be an int, it is instead a %s.\" % type(chunk_size))\n-        # simulate reading small chunks of the content\n-        reused_chunks = iter_slices(self._content, chunk_size)\n+@property\n+def apparent_encoding(self):\n+    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n+    return chardet.detect(self.content)['encoding']\n \n-        stream_chunks = generate()\n \n-        chunks = reused_chunks if self._content_consumed else stream_chunks\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n \n-        if decode_unicode:\n-            chunks = stream_decode_response_unicode(chunks, self)\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n \n-        return chunks\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n     def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=None, delimiter=None):\n         \"\"\"Iterates over the response data, one line at a time.  When\n@@ -774,9 +745,24 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Given an iterator and a requests response, decode the response into unicode.\n+\n+    :param iterator: The iterator to decode.\n+    :param r: The response object.\n+    :returns: The decoded iterator.\n+    \"\"\"\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n+\n+    for chunk in iterator:\n+        if isinstance(chunk, str):\n+            yield chunk\n+        else:\n+            yield str(chunk, encoding, errors='replace')\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..d8704e5d 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,14 +356,36 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n     decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n",
    "variant_4": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..10c8d82b 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -646,58 +646,29 @@ class Response(object):\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n     @property\n-    def apparent_encoding(self):\n-        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n-        return chardet.detect(self.content)['encoding']\n-\n-    def iter_content(self, chunk_size=1, decode_unicode=False):\n-        \"\"\"Iterates over the response data.  When stream=True is set on the\n-        request, this avoids reading the content at once into memory for\n-        large responses.  The chunk size is the number of bytes it should\n-        read into memory.  This is not necessarily the length of each item\n-        returned as decoding can take place.\n-\n-        If decode_unicode is True, content will be decoded using the best\n-        available encoding based on the response.\n-        \"\"\"\n-\n-        def generate():\n-            # Special case for urllib3.\n-            if hasattr(self.raw, 'stream'):\n-                try:\n-                    for chunk in self.raw.stream(chunk_size, decode_content=True):\n-                        yield chunk\n-                except ProtocolError as e:\n-                    raise ChunkedEncodingError(e)\n-                except DecodeError as e:\n-                    raise ContentDecodingError(e)\n-                except ReadTimeoutError as e:\n-                    raise ConnectionError(e)\n-            else:\n-                # Standard file-like object.\n-                while True:\n-                    chunk = self.raw.read(chunk_size)\n-                    if not chunk:\n-                        break\n-                    yield chunk\n-\n-            self._content_consumed = True\n \n-        if self._content_consumed and isinstance(self._content, bool):\n-            raise StreamConsumedError()\n-        elif not isinstance(chunk_size, int):\n-            raise TypeError(\"chunk_size must be an int, it is instead a %s.\" % type(chunk_size))\n-        # simulate reading small chunks of the content\n-        reused_chunks = iter_slices(self._content, chunk_size)\n+@property\n+def apparent_encoding(self):\n+    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n+    return chardet.detect(self.content)['encoding']\n \n-        stream_chunks = generate()\n \n-        chunks = reused_chunks if self._content_consumed else stream_chunks\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n \n-        if decode_unicode:\n-            chunks = stream_decode_response_unicode(chunks, self)\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n \n-        return chunks\n+    decoder = codecs.getincrementaldecoder(encoding)('replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n     def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=None, delimiter=None):\n         \"\"\"Iterates over the response data, one line at a time.  When\n@@ -774,9 +745,24 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Given an iterator and a request, attempt to decode the response as unicode.\n+\n+    This code is based on http://stackoverflow.com/a/22731016/1830334\n+    \"\"\"\n+\n+    if r.encoding is None:\n+        # Fallback to auto-detected encoding, same as r.text property\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n+\n+    for chunk in iterator:\n+        rv = chunk\n+        if isinstance(rv, bytes):\n+            rv = rv.decode(encoding, 'replace')\n+        yield rv\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..d8704e5d 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,14 +356,36 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n     decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n",
    "variant_5": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..3039b19d 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -646,58 +646,29 @@ class Response(object):\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n     @property\n-    def apparent_encoding(self):\n-        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n-        return chardet.detect(self.content)['encoding']\n-\n-    def iter_content(self, chunk_size=1, decode_unicode=False):\n-        \"\"\"Iterates over the response data.  When stream=True is set on the\n-        request, this avoids reading the content at once into memory for\n-        large responses.  The chunk size is the number of bytes it should\n-        read into memory.  This is not necessarily the length of each item\n-        returned as decoding can take place.\n-\n-        If decode_unicode is True, content will be decoded using the best\n-        available encoding based on the response.\n-        \"\"\"\n-\n-        def generate():\n-            # Special case for urllib3.\n-            if hasattr(self.raw, 'stream'):\n-                try:\n-                    for chunk in self.raw.stream(chunk_size, decode_content=True):\n-                        yield chunk\n-                except ProtocolError as e:\n-                    raise ChunkedEncodingError(e)\n-                except DecodeError as e:\n-                    raise ContentDecodingError(e)\n-                except ReadTimeoutError as e:\n-                    raise ConnectionError(e)\n-            else:\n-                # Standard file-like object.\n-                while True:\n-                    chunk = self.raw.read(chunk_size)\n-                    if not chunk:\n-                        break\n-                    yield chunk\n \n-            self._content_consumed = True\n+@property\n+def apparent_encoding(self):\n+    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n+    return chardet.detect(self.content)['encoding']\n \n-        if self._content_consumed and isinstance(self._content, bool):\n-            raise StreamConsumedError()\n-        elif not isinstance(chunk_size, int):\n-            raise TypeError(\"chunk_size must be an int, it is instead a %s.\" % type(chunk_size))\n-        # simulate reading small chunks of the content\n-        reused_chunks = iter_slices(self._content, chunk_size)\n \n-        stream_chunks = generate()\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n \n-        chunks = reused_chunks if self._content_consumed else stream_chunks\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n \n-        if decode_unicode:\n-            chunks = stream_decode_response_unicode(chunks, self)\n-\n-        return chunks\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n     def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=None, delimiter=None):\n         \"\"\"Iterates over the response data, one line at a time.  When\n@@ -774,9 +745,31 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Given an iterator and a response, decode the bytes-iterator and\n+    generate unicode-iterator.\n+    \"\"\"\n+    \n+    encoding = r.encoding\n+    \n+    # Fallback to auto-detected encoding when r.encoding is None\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    if encoding is None:\n+        for item in iterator:\n+            yield item\n+        return\n+\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..e2239044 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,14 +356,37 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n     decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n",
    "variant_6": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..50878838 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -646,58 +646,34 @@ class Response(object):\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n     @property\n-    def apparent_encoding(self):\n-        \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n-        return chardet.detect(self.content)['encoding']\n-\n-    def iter_content(self, chunk_size=1, decode_unicode=False):\n-        \"\"\"Iterates over the response data.  When stream=True is set on the\n-        request, this avoids reading the content at once into memory for\n-        large responses.  The chunk size is the number of bytes it should\n-        read into memory.  This is not necessarily the length of each item\n-        returned as decoding can take place.\n-\n-        If decode_unicode is True, content will be decoded using the best\n-        available encoding based on the response.\n-        \"\"\"\n \n-        def generate():\n-            # Special case for urllib3.\n-            if hasattr(self.raw, 'stream'):\n-                try:\n-                    for chunk in self.raw.stream(chunk_size, decode_content=True):\n-                        yield chunk\n-                except ProtocolError as e:\n-                    raise ChunkedEncodingError(e)\n-                except DecodeError as e:\n-                    raise ContentDecodingError(e)\n-                except ReadTimeoutError as e:\n-                    raise ConnectionError(e)\n-            else:\n-                # Standard file-like object.\n-                while True:\n-                    chunk = self.raw.read(chunk_size)\n-                    if not chunk:\n-                        break\n-                    yield chunk\n+@property\n+def apparent_encoding(self):\n+    \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n+    return chardet.detect(self.content)['encoding']\n \n-            self._content_consumed = True\n \n-        if self._content_consumed and isinstance(self._content, bool):\n-            raise StreamConsumedError()\n-        elif not isinstance(chunk_size, int):\n-            raise TypeError(\"chunk_size must be an int, it is instead a %s.\" % type(chunk_size))\n-        # simulate reading small chunks of the content\n-        reused_chunks = iter_slices(self._content, chunk_size)\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n \n-        stream_chunks = generate()\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n \n-        chunks = reused_chunks if self._content_consumed else stream_chunks\n+    if encoding is None:\n+        for item in iterator:\n+            yield item\n+        return\n \n-        if decode_unicode:\n-            chunks = stream_decode_response_unicode(chunks, self)\n-\n-        return chunks\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n     def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=None, delimiter=None):\n         \"\"\"Iterates over the response data, one line at a time.  When\n@@ -774,9 +750,23 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Given an iterator and a requests response, decode the response into unicode.\n+\n+    :param iterator: An iterator over the response data.\n+    :param r: A requests response object.\n+    \"\"\"\n+\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n+\n+    for chunk in iterator:\n+        rv = chunk.decode(encoding, 'replace')\n+        if rv:\n+            yield rv\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..71b01cc9 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,13 +356,24 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n-        for item in iterator:\n-            yield item\n-        return\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+    if rv:\n+        yield rv\n \n     decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n     for chunk in iterator:\n",
    "variant_7": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..c643ee4d 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -645,59 +645,30 @@ class Response(object):\n         \"\"\"True if this Response one of the permanent versions of redirect\"\"\"\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n+    @property\n+\n     @property\n     def apparent_encoding(self):\n         \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n         return chardet.detect(self.content)['encoding']\n \n-    def iter_content(self, chunk_size=1, decode_unicode=False):\n-        \"\"\"Iterates over the response data.  When stream=True is set on the\n-        request, this avoids reading the content at once into memory for\n-        large responses.  The chunk size is the number of bytes it should\n-        read into memory.  This is not necessarily the length of each item\n-        returned as decoding can take place.\n-\n-        If decode_unicode is True, content will be decoded using the best\n-        available encoding based on the response.\n-        \"\"\"\n-\n-        def generate():\n-            # Special case for urllib3.\n-            if hasattr(self.raw, 'stream'):\n-                try:\n-                    for chunk in self.raw.stream(chunk_size, decode_content=True):\n-                        yield chunk\n-                except ProtocolError as e:\n-                    raise ChunkedEncodingError(e)\n-                except DecodeError as e:\n-                    raise ContentDecodingError(e)\n-                except ReadTimeoutError as e:\n-                    raise ConnectionError(e)\n-            else:\n-                # Standard file-like object.\n-                while True:\n-                    chunk = self.raw.read(chunk_size)\n-                    if not chunk:\n-                        break\n-                    yield chunk\n \n-            self._content_consumed = True\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n \n-        if self._content_consumed and isinstance(self._content, bool):\n-            raise StreamConsumedError()\n-        elif not isinstance(chunk_size, int):\n-            raise TypeError(\"chunk_size must be an int, it is instead a %s.\" % type(chunk_size))\n-        # simulate reading small chunks of the content\n-        reused_chunks = iter_slices(self._content, chunk_size)\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n \n-        stream_chunks = generate()\n-\n-        chunks = reused_chunks if self._content_consumed else stream_chunks\n-\n-        if decode_unicode:\n-            chunks = stream_decode_response_unicode(chunks, self)\n-\n-        return chunks\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n     def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=None, delimiter=None):\n         \"\"\"Iterates over the response data, one line at a time.  When\n@@ -774,9 +745,19 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Stream decodes a iterator.\"\"\"\n+\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n+\n+    for chunk in iterator:\n+        rv = chunk.decode(encoding, 'replace')\n+        if rv:\n+            yield rv\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..d8704e5d 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,14 +356,36 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n     decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n",
    "variant_8": "diff --git a/requests/models.py b/requests/models.py\nindex fbb3c7e6..2afda57e 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -645,59 +645,29 @@ class Response(object):\n         \"\"\"True if this Response one of the permanent versions of redirect\"\"\"\n         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n \n+    @property\n+\n     @property\n     def apparent_encoding(self):\n         \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n         return chardet.detect(self.content)['encoding']\n \n-    def iter_content(self, chunk_size=1, decode_unicode=False):\n-        \"\"\"Iterates over the response data.  When stream=True is set on the\n-        request, this avoids reading the content at once into memory for\n-        large responses.  The chunk size is the number of bytes it should\n-        read into memory.  This is not necessarily the length of each item\n-        returned as decoding can take place.\n-\n-        If decode_unicode is True, content will be decoded using the best\n-        available encoding based on the response.\n-        \"\"\"\n-\n-        def generate():\n-            # Special case for urllib3.\n-            if hasattr(self.raw, 'stream'):\n-                try:\n-                    for chunk in self.raw.stream(chunk_size, decode_content=True):\n-                        yield chunk\n-                except ProtocolError as e:\n-                    raise ChunkedEncodingError(e)\n-                except DecodeError as e:\n-                    raise ContentDecodingError(e)\n-                except ReadTimeoutError as e:\n-                    raise ConnectionError(e)\n-            else:\n-                # Standard file-like object.\n-                while True:\n-                    chunk = self.raw.read(chunk_size)\n-                    if not chunk:\n-                        break\n-                    yield chunk\n-\n-            self._content_consumed = True\n \n-        if self._content_consumed and isinstance(self._content, bool):\n-            raise StreamConsumedError()\n-        elif not isinstance(chunk_size, int):\n-            raise TypeError(\"chunk_size must be an int, it is instead a %s.\" % type(chunk_size))\n-        # simulate reading small chunks of the content\n-        reused_chunks = iter_slices(self._content, chunk_size)\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Given an iterator and a response, decode the bytes into unicode.\"\"\"\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n \n-        stream_chunks = generate()\n-\n-        chunks = reused_chunks if self._content_consumed else stream_chunks\n-\n-        if decode_unicode:\n-            chunks = stream_decode_response_unicode(chunks, self)\n-\n-        return chunks\n+    decoder = codecs.getincrementaldecoder(encoding)('replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n \n     def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=None, delimiter=None):\n         \"\"\"Iterates over the response data, one line at a time.  When\n@@ -774,9 +744,21 @@ class Response(object):\n         if not self.content:\n             return str('')\n \n-        # Fallback to auto-detected encoding.\n-        if self.encoding is None:\n-            encoding = self.apparent_encoding\n+\n+def stream_decode_response_unicode(iterator, r):\n+    \"\"\"Given an iterator and a requests response, decode the response into unicode.\n+\n+    If no encoding is found in the response's headers, fall back to the apparent\n+    encoding to maintain consistency with the Response.text property.\n+    \"\"\"\n+\n+    if r.encoding is None:\n+        encoding = r.apparent_encoding\n+    else:\n+        encoding = r.encoding\n+\n+    for chunk in iterator:\n+        yield chunk.decode(encoding, errors='replace')\n \n         # Decode unicode from given encoding.\n         try:\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 8d17b6b2..d091177d 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -356,14 +356,31 @@ def get_encoding_from_headers(headers):\n         return 'ISO-8859-1'\n \n \n+\n def stream_decode_response_unicode(iterator, r):\n     \"\"\"Stream decodes a iterator.\"\"\"\n \n-    if r.encoding is None:\n+    encoding = r.encoding\n+    if encoding is None:\n+        encoding = r.apparent_encoding\n+\n+    if encoding is None:\n         for item in iterator:\n             yield item\n         return\n \n+    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n+    for chunk in iterator:\n+        rv = decoder.decode(chunk)\n+        if rv:\n+            yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+    rv = decoder.decode(b'', final=True)\n+    if rv:\n+        yield rv\n+\n     decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')\n     for chunk in iterator:\n         rv = decoder.decode(chunk)\n"
  }
}