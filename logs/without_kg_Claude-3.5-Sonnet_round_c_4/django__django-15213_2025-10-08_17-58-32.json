{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/sql/where.py lines 95-99)": "\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n",
    "Location 2 (/root/hy/projects_4/django/django/db/models/sql/where.py lines 100-104)": "\n            # Check if this node matches nothing or everything.\n            # First check the amount of full nodes and empty nodes\n            # to make this node empty/full.\n            # Now, check if this node is full/empty using the\n            # counts.\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n            if full_needed == 0:\n                if self.negated:\n                    raise EmptyResultSet\n                else:\n                    return '', []\n",
    "Location 3 (/root/hy/projects_4/django/django/db/models/lookups.py lines 416-417)": "\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                raise EmptyResultSet\n\n        if full_needed == 0:\n            if self.negated:\n                raise EmptyResultSet\n            else:\n                return '', []\n",
    "Location 4 (/root/hy/projects_4/django/django/db/models/expressions.py lines 968-972)": "\n    def as_sql(self, compiler, connection):\n        \"\"\"\n        Return the SQL version of the where clause and the value to be\n        substituted in. Return '', [] if this node matches everything and\n        '1=0', [] if this node is empty.\n\n        The 'split_subq' tells the caller if the current branch contains a\n        subquery that needs splitting. The split_subq is propagated by the\n        caller all the way up to the query.split_exclude().\n        \"\"\"\n        result = []\n        result_params = []\n        empty = True\n\n        for child in self.children:\n            try:\n                sql, params = compiler.compile(child)\n            except EmptyResultSet:\n                empty = False\n                continue\n            if sql:\n                result.append(sql)\n                result_params.extend(params)\n                empty = False\n\n        if empty:\n            raise EmptyResultSet\n\n        conn = ' %s ' % self.connector\n        sql_string = conn.join(result)\n        if sql_string:\n            if self.negated:\n                # Some backends (Oracle at least) need parentheses\n                # around the inner SQL in the negated case, even if the\n                # inner SQL contains just a single expression.\n                sql_string = 'NOT (%s)' % sql_string\n            elif len(result) > 1 or self.resolved:\n                sql_string = '(%s)' % sql_string\n        return sql_string, result_params\n\n    def get_group_by_cols(self, alias=None):\n        cols = []\n        for child in self.children:\n            cols.extend(child.get_group_by_cols(alias=alias))\n        return cols\n\n    def get_source_expressions(self):\n        return self.children[:]\n\n    def set_source_expressions(self, children):\n        assert len(children) == len(self.children)\n        self.children = children\n\n    def relabel_aliases(self, change_map):\n        \"\"\"\n        Relabel the alias values of any children. 'change_map' is a dictionary\n        mapping old (current) alias values to the new values.\n        \"\"\"\n        for child in self.children:\n            child.relabel_aliases(change_map)\n\n    def clone(self):\n        \"\"\"\n        Create a clone of the tree. Must only be called on root nodes (nodes\n        with empty subtree_parents). Childs must be either (Constraint, lookup,\n        value) tuples, or child WhereNodes.\n        \"\"\"\n        clone = self.__class__(children=[], connector=self.connector,\n                               negated=self.negated)\n        for child in self.children:\n            if hasattr(child, 'clone'):\n                clone.children.append(child.clone())\n            else:\n                clone.children.append(child)\n        return clone\n\n    def relabeled_clone(self, change_map):\n        clone = self.clone()\n        clone.relabel_aliases(change_map)\n        return clone\n\n    def copy(self):\n        return self.clone()\n\n    def _contains_aggregate(self, existing_inner):\n        for child in self.children:\n            if child._contains_aggregate(existing_inner):\n                return True\n        return False\n\n    def _contains_over_clause(self):\n        for child in self.children:\n            if child._contains_over_clause():\n                return True\n        return False\n",
    "Location 5 (/root/hy/projects_4/django/django/db/models/query_utils.py lines 71-78)": "\n    def as_sql(self, compiler, connection):\n        \"\"\"\n        Return the SQL version of the where clause and the value to be\n        substituted in. Return '', [] if this node matches everything and\n        '1=0', [] if this node is empty.\n\n        Test that the correct connector is AND:\n        >>> w = WhereNode(children=[Q(c=1), Q(c=2)], connector='AND')\n        >>> w.as_sql(compiler, connection) == ('(table.c = %s AND table.c = %s)', [1, 2])\n        True\n        \"\"\"\n        result, result_params = [], []\n        empty = True\n        for child in self.children:\n            try:\n                sql, params = compiler.compile(child)\n            except EmptyResultSet:\n                empty_needed -= 1\n            else:\n                if sql:\n                    result.append(sql)\n                    result_params.extend(params)\n                    empty = False\n                else:\n                    full_needed -= 1\n\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                return '', []\n        if full_needed == 0:\n            if self.negated:\n                return '1=0', []\n            else:\n                return '', []\n\n        conn = ' %s ' % self.connector\n        sql_string = conn.join(result)\n        if sql_string:\n            if self.negated:\n                # Some backends (Oracle at least) need parentheses\n                # around the inner SQL in the negated case, even if the\n                # inner SQL contains just a single expression.\n                sql_string = 'NOT (%s)' % sql_string\n            elif len(result) > 1 or self.resolved:\n                sql_string = '(%s)' % sql_string\n        return sql_string, result_params\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/models/sql/where.py lines 95-99)": [
      "\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n",
      "\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n",
      "\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n",
      "\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n",
      "\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n",
      "\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n",
      "\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n",
      "\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/db/models/sql/where.py lines 100-104)": [
      "\n            # Check if this node matches nothing or everything.\n            # First check the amount of full nodes and empty nodes\n            # to make this node empty/full.\n            # Now, check if this node is full/empty using the\n            # counts.\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n            if full_needed == 0:\n                if self.negated:\n                    raise EmptyResultSet\n                else:\n                    return '', []\n",
      "\n            # Check if this node matches nothing or everything.\n            # First check the amount of full nodes and empty nodes\n            # to make this node empty/full.\n            # Now, check if this node is full/empty using the\n            # counts.\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n            if full_needed == 0:\n                if self.negated:\n                    raise EmptyResultSet\n                else:\n                    return '', []\n",
      "\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n",
      "\n        # Check if this node matches nothing or everything.\n        # First check the amount of full nodes and empty nodes\n        # to make this node empty/full.\n        # Now, check if this node is full/empty using the\n        # counts.\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                raise EmptyResultSet\n        if full_needed == 0:\n            if self.negated:\n                raise EmptyResultSet\n            else:\n                return '', []\n",
      "\n            # Check if this node matches nothing or everything.\n            # First check the amount of full nodes and empty nodes\n            # to make this node empty/full.\n            # Now, check if this node is full/empty using the\n            # counts.\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n            if full_needed == 0:\n                if self.negated:\n                    raise EmptyResultSet\n                else:\n                    return '', []\n",
      "\n            # Check if this node matches nothing or everything.\n            # First check the amount of full nodes and empty nodes\n            # to make this node empty/full.\n            # Now, check if this node is full/empty using the\n            # counts.\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n            if full_needed == 0:\n                if self.negated:\n                    raise EmptyResultSet\n                else:\n                    return '', []\n",
      "\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n",
      "\n            # Check if this node matches nothing or everything.\n            # First check the amount of full nodes and empty nodes\n            # to make this node empty/full.\n            # Now, check if this node is full/empty using the\n            # counts.\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n            if full_needed == 0:\n                if self.negated:\n                    raise EmptyResultSet\n                else:\n                    return '', []\n"
    ],
    "Location 3 (/root/hy/projects_4/django/django/db/models/lookups.py lines 416-417)": [
      "\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                return '', []\n",
      "\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                raise EmptyResultSet\n",
      "\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                raise EmptyResultSet\n\n        if full_needed == 0:\n            if self.negated:\n                raise EmptyResultSet\n            else:\n                return '', []\n",
      "\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            return '', []\n",
      "\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                return '', []\n        \n        if full_needed == 0:\n            if self.negated:\n                return '', []\n            else:\n                return '1=1', []\n",
      "\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                return '', []\n",
      "\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                return '', []\n",
      "\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                return '', []\n        if full_needed == 0:\n            if self.negated:\n                return '', []\n            else:\n                return '1=1', []\n"
    ],
    "Location 4 (/root/hy/projects_4/django/django/db/models/expressions.py lines 968-972)": [
      "\n    def as_sql(self, compiler, connection):\n        \"\"\"\n        Return the SQL version of the where clause and the value to be\n        substituted in. Return '', [] if this node matches everything and\n        '1=0', [] if this node is empty.\n\n        The 'split_subq' tells the caller if the current branch contains a\n        subquery that needs special handling. We currently do subquery\n        special handling in the compiler.\n        \"\"\"\n        result = []\n        result_params = []\n        everything_childs, nothing_childs = 0, 0\n        non_empty_childs = len(self.children)\n\n        for child in self.children:\n            try:\n                if hasattr(child, 'as_sql'):\n                    sql, params = child.as_sql(compiler, connection)\n                    if sql:\n                        result.append(sql)\n                        result_params.extend(params)\n                    else:\n                        if sql is None:\n                            # Skip childs with empty results.\n                            non_empty_childs -= 1\n                            continue\n                        else:\n                            everything_childs += 1\n                else:\n                    # A leaf node in the tree.\n                    sql, params = self.make_atom(child, compiler, connection)\n                    if sql:\n                        result.append(sql)\n                        result_params.extend(params)\n                    else:\n                        if sql is None:\n                            non_empty_childs -= 1\n                            continue\n                        else:\n                            everything_childs += 1\n            except EmptyResultSet:\n                nothing_childs += 1\n                non_empty_childs -= 1\n\n        if not result:\n            if nothing_childs:\n                # A subtree didn't match anything; this makes this subtree\n                # match nothing too.\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n            if everything_childs:\n                # Everything in the subtree matched (got empty WHERE), and\n                # nothing else matched, so this subtree matches everything.\n                if self.negated:\n                    return '1=0', []\n                else:\n                    return '', []\n\n        conn = ' %s ' % self.connector\n        sql_string = conn.join(result)\n        if sql_string:\n            if self.negated:\n                # Some backends (Oracle at least) need parentheses\n                # around the inner SQL in the negated case, even if the\n                # inner SQL contains just a single expression.\n                sql_string = 'NOT (%s)' % sql_string\n            elif len(result) > 1 or self.resolved:\n                sql_string = '(%s)' % sql_string\n        return sql_string, result_params\n",
      "\n    def as_sql(self, compiler, connection):\n        \"\"\"\n        Return the SQL version of the where clause and the value to be\n        substituted in. Return '', [] if this node matches everything and\n        '1=0', [] if this node is empty.\n\n        The 'split_subq' tells the caller if the current branch contains a\n        subquery that needs split. The split_subq will be used by update and\n        delete queries mostly.\n        \"\"\"\n        result = []\n        result_params = []\n        empty = True\n\n        for child in self.children:\n            try:\n                if hasattr(child, 'split_subq'):\n                    sql, params = child.as_sql(compiler, connection)\n                    split_subq = child.split_subq\n                else:\n                    sql, params = compiler.compile(child)\n                    split_subq = False\n            except EmptyResultSet:\n                empty = False\n                continue\n            if sql:\n                result.append(sql)\n                result_params.extend(params)\n                if split_subq:\n                    self.split_subq = True\n                empty = False\n\n        if empty:\n            try:\n                empty_needed, full_needed = self.connector_class.empty_result_set_value\n            except AttributeError:\n                empty_needed, full_needed = self.default_empty_result_set_value\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    return '', []\n            elif full_needed == 0:\n                return '', []\n            else:\n                return '1=0', []\n\n        conn = ' %s ' % self.connector\n        sql = conn.join(result)\n        if sql:\n            if self.negated:\n                # Some backends (Oracle at least) need parentheses around the\n                # inner SQL in the negated case, even if the inner SQL contains\n                # just a single expression.\n                sql = 'NOT (%s)' % sql\n            elif len(result) > 1 or self.resolved:\n                sql = '(%s)' % sql\n        return sql, result_params\n",
      "\ndef as_sql(self, compiler, connection):\n    \"\"\"\n    Return the SQL version of the where clause and the value to be\n    substituted in. Return '', [] if this node matches everything,\n    None, [] if this node is empty, and raise EmptyResultSet if this\n    node can't match anything.\n    \"\"\"\n    result = []\n    result_params = []\n    if self.connector == AND:\n        full_needed, empty_needed = len(self.children), 1\n    else:\n        full_needed, empty_needed = 1, len(self.children)\n\n    for child in self.children:\n        try:\n            sql, params = compiler.compile(child)\n        except EmptyResultSet:\n            empty_needed -= 1\n        else:\n            if sql:\n                result.append(sql)\n                result_params.extend(params)\n            else:\n                full_needed -= 1\n        # Check if this node matches nothing or everything.\n        # First check the amount of full nodes and empty nodes\n        # to make this node empty/full.\n        # Now, check if this node is full/empty using the\n        # counts.\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                raise EmptyResultSet\n        if full_needed == 0:\n            if self.negated:\n                raise EmptyResultSet\n            else:\n                return '', []\n\n    conn = ' %s ' % self.connector\n    sql_string = conn.join(result)\n    if sql_string:\n        if self.negated:\n            # Some backends (Oracle at least) need parentheses\n            # around the inner SQL in the negated case, even if the\n            # inner SQL contains just a single expression.\n            sql_string = 'NOT (%s)' % sql_string\n        elif len(result) > 1 or self.resolved:\n            sql_string = '(%s)' % sql_string\n    return sql_string, result_params\n",
      "\n    def as_sql(self, compiler, connection):\n        \"\"\"\n        Return the SQL version of the where clause and the value to be\n        substituted in. Return '', [] if this node matches everything,\n        raise EmptyResultSet if this node is empty, and raise\n        FullResultSet if this node is full.\n        \"\"\"\n        result = []\n        result_params = []\n        if self.connector == AND:\n            full_needed, empty_needed = len(self.children), 1\n        else:\n            full_needed, empty_needed = 1, len(self.children)\n\n        for child in self.children:\n            try:\n                sql, params = compiler.compile(child)\n            except EmptyResultSet:\n                empty_needed -= 1\n            except FullResultSet:\n                full_needed -= 1\n            else:\n                if sql:\n                    result.append(sql)\n                    result_params.extend(params)\n                else:\n                    full_needed -= 1\n\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                raise EmptyResultSet\n\n        if full_needed == 0:\n            if self.negated:\n                raise EmptyResultSet\n            else:\n                return '', []\n\n        if not result:\n            raise FullResultSet\n\n        conn = ' %s ' % self.connector\n        sql_string = conn.join(result)\n        if len(result) > 1:\n            sql_string = '(%s)' % sql_string\n        if self.negated:\n            # Some backends (Oracle at least) need parentheses\n            # around the inner SQL in the negated case, even if the\n            # inner SQL contains just a single expression.\n            sql_string = 'NOT (%s)' % sql_string\n        return sql_string, result_params\n",
      "\n    def as_sql(self, compiler, connection):\n        \"\"\"\n        Return the SQL version of the where clause and the value to be\n        substituted in. Return '', [] if this node matches everything and\n        '1=0', [] if this node is empty.\n\n        The 'split_subq' tells the caller whether or not all the condition\n        children can be safely split across a join. It is always True for\n        LeafNode children.\n        \"\"\"\n        result = []\n        result_params = []\n        if self.connector == AND:\n            full_needed, empty_needed = len(self.children), 1\n        else:\n            full_needed, empty_needed = 1, len(self.children)\n\n        if self.children:\n            for child in self.children:\n                try:\n                    sql, params = compiler.compile(child)\n                except EmptyResultSet:\n                    empty_needed -= 1\n                else:\n                    if sql:\n                        result.append(sql)\n                        result_params.extend(params)\n                    else:\n                        full_needed -= 1\n                # Check if this node matches nothing or everything.\n                # First check the amount of full nodes and empty nodes\n                # to make this node empty/full.\n                # Now, check if this node is full/empty using the\n                # counts.\n                if empty_needed == 0:\n                    if self.negated:\n                        return '1=1', []\n                    else:\n                        return '', []\n                if full_needed == 0:\n                    if self.negated:\n                        return '', []\n                    else:\n                        return '1=0', []\n        if not result:\n            if self.negated:\n                return '1=1', []\n            else:\n                return '1=0', []\n\n        conn = ' %s ' % self.connector\n        sql_string = conn.join(result)\n        if sql_string:\n            if self.negated:\n                # Some backends (Oracle at least) need parentheses\n                # around the inner SQL in the negated case, even if the\n                # inner SQL contains just a single expression.\n                sql_string = 'NOT (%s)' % sql_string\n            elif len(result) > 1 or self.resolved:\n                sql_string = '(%s)' % sql_string\n        return sql_string, result_params\n",
      "\n    def as_sql(self, compiler, connection):\n        \"\"\"\n        Return the SQL version of the where clause and the value to be\n        substituted in. Return '', [] if this node matches everything and\n        '1=0', [] if this node is empty.\n\n        The 'node' parameter allows the caller to designate which node is the\n        root of the constructed SQL.\n        \"\"\"\n        result = []\n        result_params = []\n        everything_childs, nothing_childs = 0, 0\n        non_empty_childs = len(self.children)\n\n        for child in self.children:\n            try:\n                if hasattr(child, 'as_sql'):\n                    sql, params = child.as_sql(compiler, connection)\n                    format_string = '(%s)'\n                    if sql:\n                        result.append(sql)\n                        result_params.extend(params)\n                    else:\n                        if sql == '':\n                            everything_childs += 1\n                        else:\n                            nothing_childs += 1\n                        non_empty_childs -= 1\n                else:\n                    # This branch is reached when the child is a leaf node\n                    format_string = '%s'\n                    sql, params = self.make_atom(child, compiler, connection)\n                    if sql:\n                        result.append(format_string % sql)\n                        result_params.extend(params)\n                    else:\n                        if sql == '':\n                            everything_childs += 1\n                        else:\n                            nothing_childs += 1\n                        non_empty_childs -= 1\n            except EmptyResultSet:\n                nothing_childs += 1\n                non_empty_childs -= 1\n\n        if self.connector == AND:\n            full_needed, empty_needed = nothing_childs, everything_childs\n        else:\n            full_needed, empty_needed = everything_childs, nothing_childs\n\n        if self.negated:\n            full_needed, empty_needed = empty_needed, full_needed\n\n        if full_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                return '', []\n\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                return '1=0', []\n\n        conn = ' %s ' % self.connector\n        sql_string = conn.join(result)\n        if sql_string:\n            if self.negated:\n                # Some backends (Oracle at least) need parentheses\n                # around the inner SQL in the negated case, even if the\n                # inner SQL contains just a single expression.\n                sql_string = 'NOT (%s)' % sql_string\n            elif len(result) > 1 or self.resolved:\n                sql_string = '(%s)' % sql_string\n        return sql_string, result_params\n",
      "\n    def as_sql(self, compiler, connection):\n        \"\"\"\n        Return the SQL version of the where clause and the value to be\n        substituted in. Return '', [] if this node matches everything,\n        raise EmptyResultSet if this node is empty, and raise\n        FullResultSet if this node matches nothing.\n        \"\"\"\n        result = []\n        result_params = []\n        if self.connector == AND:\n            full_needed, empty_needed = len(self.children), 1\n        else:\n            full_needed, empty_needed = 1, len(self.children)\n\n        for child in self.children:\n            try:\n                sql, params = compiler.compile(child)\n            except EmptyResultSet:\n                empty_needed -= 1\n            except FullResultSet:\n                full_needed -= 1\n            else:\n                if sql:\n                    result.append(sql)\n                    result_params.extend(params)\n                else:\n                    full_needed -= 1\n\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                raise FullResultSet\n\n        if full_needed == 0:\n            if self.negated:\n                raise FullResultSet\n            else:\n                return '', []\n\n        if not result:\n            return '', []\n        conn = ' %s ' % self.connector\n        sql_string = conn.join(result)\n        if len(result) > 1:\n            sql_string = '(%s)' % sql_string\n        if self.negated:\n            # Some backends (Oracle at least) need parentheses\n            # around the inner SQL in the negated case, even if the\n            # inner SQL contains just a single expression.\n            sql_string = 'NOT (%s)' % sql_string\n        return sql_string, result_params\n",
      "\n    def as_sql(self, compiler, connection):\n        \"\"\"\n        Return the SQL version of the where clause and the value to be\n        substituted in. Return '', [] if this node matches everything,\n        raise EmptyResultSet if this node is empty, and raise\n        FullResultSet if this node matches nothing.\n        \"\"\"\n        result = []\n        result_params = []\n        if self.connector == AND:\n            full_needed, empty_needed = len(self.children), 1\n        else:\n            full_needed, empty_needed = 1, len(self.children)\n\n        for child in self.children:\n            try:\n                sql, params = compiler.compile(child)\n            except EmptyResultSet:\n                empty_needed -= 1\n            except FullResultSet:\n                full_needed -= 1\n            else:\n                if sql:\n                    result.append(sql)\n                    result_params.extend(params)\n                else:\n                    full_needed -= 1\n\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            raise FullResultSet\n\n        if full_needed == 0:\n            if self.negated:\n                raise FullResultSet\n            return '', []\n\n        if not result:\n            raise FullResultSet\n\n        conn = ' %s ' % self.connector\n        sql_string = conn.join(result)\n        if len(result) > 1:\n            sql_string = '(%s)' % sql_string\n        if self.negated:\n            # Some backends (Oracle at least) need parentheses\n            # around the inner SQL in the negated case, even if the\n            # inner SQL contains just a single expression.\n            sql_string = 'NOT (%s)' % sql_string\n        return sql_string, result_params\n"
    ],
    "Location 5 (/root/hy/projects_4/django/django/db/models/query_utils.py lines 71-78)": [
      "\n    def as_sql(self, compiler, connection):\n        \"\"\"\n        Return the SQL version of the where clause and the value to be\n        substituted in. Return '', [] if this node matches everything,\n        None, [] if this node is empty, and raise EmptyResultSet if this\n        node can't match anything.\n        \"\"\"\n        result = []\n        result_params = []\n        if self.connector == AND:\n            full_needed, empty_needed = len(self.children), 1\n        else:\n            full_needed, empty_needed = 1, len(self.children)\n\n        for child in self.children:\n            try:\n                sql, params = compiler.compile(child)\n            except EmptyResultSet:\n                empty_needed -= 1\n            else:\n                if sql:\n                    result.append(sql)\n                    result_params.extend(params)\n                else:\n                    full_needed -= 1\n            # Check if this node matches nothing or everything.\n            # First check the amount of full nodes and empty nodes\n            # to make this node empty/full.\n            # Now, check if this node is full/empty using the\n            # counts.\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n            if full_needed == 0:\n                if self.negated:\n                    raise EmptyResultSet\n                else:\n                    return '', []\n\n        conn = ' %s ' % self.connector\n        sql_string = conn.join(result)\n        if sql_string:\n            if self.negated:\n                # Some backends (Oracle at least) need parentheses\n                # around the inner SQL in the negated case, even if the\n                # inner SQL contains just a single expression.\n                sql_string = 'NOT (%s)' % sql_string\n            elif len(result) > 1 or self.resolved:\n                sql_string = '(%s)' % sql_string\n        return sql_string, result_params\n",
      "\n    def as_sql(self, compiler, connection):\n        \"\"\"\n        Return the SQL version of the where clause and the value to be\n        substituted in. Return '', [] if this node matches everything and\n        '1=0', [] if this node is empty.\n\n        The 'split_subq' tells the caller if the current branch contains a\n        LOUTER JOIN that might need special treatment.\n        \"\"\"\n        result = []\n        result_params = []\n        if self.connector == AND:\n            full_needed, empty_needed = len(self.children), 1\n        else:\n            full_needed, empty_needed = 1, len(self.children)\n\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                return '', []\n        if full_needed == 0:\n            if self.negated:\n                return '1=0', []\n            else:\n                return '', []\n\n        for child in self.children:\n            try:\n                if hasattr(child, 'split_subq'):\n                    # This is a subquery that might need special treatment\n                    sql, params = child.as_sql(compiler, connection)\n                    self.split_subq = self.split_subq or child.split_subq\n                else:\n                    sql, params = compiler.compile(child)\n            except EmptyResultSet:\n                empty_needed -= 1\n            else:\n                if sql:\n                    result.append(sql)\n                    result_params.extend(params)\n                else:\n                    full_needed -= 1\n\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                return '', []\n        if full_needed == 0:\n            if self.negated:\n                return '1=0', []\n            else:\n                return '', []\n\n        conn = ' %s ' % self.connector\n        sql_string = conn.join(result)\n        if sql_string:\n            if self.negated:\n                # Some backends (Oracle at least) need parentheses\n                # around the inner SQL in the negated case, even if the\n                # inner SQL contains just a single expression.\n                sql_string = 'NOT (%s)' % sql_string\n            elif len(result) > 1 or self.resolved:\n                sql_string = '(%s)' % sql_string\n        return sql_string, result_params\n",
      "\n    def as_sql(self, compiler, connection):\n        \"\"\"\n        Return the SQL version of the where clause and the value to be\n        substituted in. Return '', [] if this node matches everything and\n        '1=0', [] if this node is empty.\n\n        The 'split_subq' tells the caller if the current branch contains a\n        subquery that needs special treatment. The split_subq is initially\n        None, then it is set to True whenever there is a subquery, unless the\n        subquery is in a NOT branch, in which case it is set to False.\n        \"\"\"\n        result = []\n        result_params = []\n        everything_childs, nothing_childs = 0, 0\n        non_empty_childs = len(self.children)\n\n        for child in self.children:\n            try:\n                if hasattr(child, 'split_subq'):\n                    # This is a subquery, we need to be careful.\n                    child_sql, child_params = child.as_sql(compiler, connection)\n                    if child.split_subq and self.negated:\n                        split_subq = False\n                    elif child.split_subq:\n                        split_subq = True\n                else:\n                    child_sql, child_params = compiler.compile(child)\n            except EmptyResultSet:\n                empty_needed -= 1\n                if self.connector == self.AND:\n                    # We can bail out early - if one child is empty, everything\n                    # is empty.\n                    raise\n                empty_needed -= 1\n            except FullResultSet:\n                full_needed -= 1\n                if self.connector == self.OR:\n                    # We can bail out early - if one child matches everything,\n                    # everything matches.\n                    raise\n                full_needed -= 1\n            else:\n                if child_sql:\n                    result.append(child_sql)\n                    result_params.extend(child_params)\n                else:\n                    if child_sql == '':\n                        everything_childs += 1\n                    else:\n                        nothing_childs += 1\n                    non_empty_childs -= 1\n\n        try:\n            conn_type = self.AND if self.connector == self.AND else self.OR\n            sql_string = conn_type.join(result)\n        except EmptyResultSet:\n            if self.negated:\n                return '1=1', []\n            else:\n                return '1=0', []\n        except FullResultSet:\n            if self.negated:\n                return '1=0', []\n            else:\n                return '1=1', []\n\n        if not result:\n            if self.negated:\n                return '1=1', []\n            else:\n                return '1=0', []\n\n        if not non_empty_childs:\n            # All children were empty, so this node is empty.\n            if self.negated:\n                return '1=1', []\n            else:\n                return '1=0', []\n\n        result_sql = '(%s)' % sql_string if len(result) > 1 else sql_string\n        if self.negated:\n            # Some backends (Oracle at least) need parentheses around the\n            # inner query.\n            result_sql = 'NOT (%s)' % result_sql\n        return result_sql, result_params\n",
      "\n    def as_sql(self, compiler, connection):\n        \"\"\"\n        Return the SQL version of the where clause and the value to be\n        substituted in. Return '', [] if this node matches everything and\n        '1=0', [] if this node is empty.\n\n        The 'split_subq' tells the caller if the current branch contains\n        references to table aliases that are changing in the outer query (for\n        example, as a result of a subquery, that in SQL Server requires each\n        part of a query to be executed separately).\n        \"\"\"\n        result = []\n        result_params = []\n        everything_childs, nothing_childs = 0, 0\n        non_empty_childs = len(self.children)\n\n        for child in self.children:\n            try:\n                if hasattr(child, 'split_exclude'):\n                    split_subq = child.split_exclude(compiler, connection, child.alias)\n                    if split_subq:\n                        # If the child references a table alias that's being\n                        # changed, we need to compile the child separately.\n                        sql, params = child.as_sql(compiler, connection)\n                        result.append(sql)\n                        result_params.extend(params)\n                        continue\n                sql, params = compiler.compile(child)\n            except EmptyResultSet:\n                empty_needed -= 1\n                nothing_childs += 1\n            except FullResultSet:\n                full_needed -= 1\n                everything_childs += 1\n            else:\n                if sql:\n                    result.append(sql)\n                    result_params.extend(params)\n                else:\n                    full_needed -= 1\n                    everything_childs += 1\n\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                return '', []\n\n        if full_needed == 0:\n            if self.negated:\n                return '1=0', []\n            else:\n                return '', []\n\n        conn = ' %s ' % self.connector\n        sql_string = conn.join(result)\n        if sql_string:\n            if self.negated:\n                # Some backends (Oracle at least) need parentheses\n                # around the inner SQL in the negated case, even if the\n                # inner SQL contains just a single expression.\n                sql_string = 'NOT (%s)' % sql_string\n            elif len(result) > 1 or self.resolved:\n                sql_string = '(%s)' % sql_string\n        return sql_string, result_params\n",
      "\n    def as_sql(self, compiler, connection):\n        \"\"\"\n        Return the SQL version of the where clause and the value to be\n        substituted in. Return '', [] if this node matches everything and\n        '1=0', [] if this node is empty.\n\n        Test that the node is empty by seeing if the two sets of available\n        choices given by self.lhs and self.rhs are disjoint. Lazy evaluation\n        would be nice, but is tricky with combine().\n        \"\"\"\n        result, result_params = super().as_sql(compiler, connection)\n        if result:\n            return result, result_params\n        # When the query is empty, return '1=0' or '1=1' depending on negation.\n        # For negated empty conditions (like ~Q(pk__in=[])), we want True (1=1).\n        # For non-negated empty conditions (like Q(pk__in=[])), we want False (1=0).\n        if self.negated:\n            return '1=1', []\n        else:\n            return '1=0', []\n",
      "\n    def as_sql(self, compiler, connection):\n        \"\"\"\n        Return the SQL version of the where clause and the value to be\n        substituted in. Return '', [] if this node matches everything,\n        None, [] if this node is empty, and raise EmptyResultSet if this\n        node can't match anything.\n        \"\"\"\n        result = []\n        result_params = []\n        if self.connector == AND:\n            full_needed, empty_needed = len(self.children), 1\n        else:\n            full_needed, empty_needed = 1, len(self.children)\n\n        for child in self.children:\n            try:\n                sql, params = compiler.compile(child)\n            except EmptyResultSet:\n                empty_needed -= 1\n            else:\n                if sql:\n                    result.append(sql)\n                    result_params.extend(params)\n                else:\n                    full_needed -= 1\n            # Check if this node matches nothing or everything.\n            # First check the amount of full nodes and empty nodes\n            # to make this node empty/full.\n            # Now, check if this node is full/empty using the\n            # counts.\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    raise EmptyResultSet\n            if full_needed == 0:\n                if self.negated:\n                    raise EmptyResultSet\n                else:\n                    return '', []\n\n        conn = ' %s ' % self.connector\n        sql_string = conn.join(result)\n        if sql_string:\n            if self.negated:\n                # Some backends (Oracle at least) need parentheses\n                # around the inner SQL in the negated case, even if the\n                # inner SQL contains just a single expression.\n                sql_string = 'NOT (%s)' % sql_string\n            elif len(result) > 1 or self.resolved:\n                sql_string = '(%s)' % sql_string\n        return sql_string, result_params\n",
      "\n    def as_sql(self, compiler, connection):\n        \"\"\"\n        Return the SQL version of the where clause and the value to be\n        substituted in. Return '', [] if this node matches everything and\n        '1=0', [] if this node is empty.\n\n        The 'split_subq' tells the caller if the current branch contains a\n        subquery that needs splitting. The split_subq will be used by OR\n        branches to determine if they contain a subquery which needs special\n        handling (see split_exclude).\n        \"\"\"\n        result = []\n        result_params = []\n        if self.connector == AND:\n            full_needed, empty_needed = len(self.children), 1\n        else:\n            full_needed, empty_needed = 1, len(self.children)\n\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                return '', []\n\n        if full_needed == 0:\n            if self.negated:\n                return '', []\n            else:\n                return '1=0', []\n\n        for child in self.children:\n            try:\n                sql, params = compiler.compile(child)\n            except EmptyResultSet:\n                empty_needed -= 1\n            else:\n                if sql:\n                    result.append(sql)\n                    result_params.extend(params)\n                else:\n                    full_needed -= 1\n            # Check if this node matches nothing or everything.\n            # First check the amount of full nodes and empty nodes\n            # to make this node empty/full.\n            # Now, check if this node is full/empty using the\n            # counts.\n            if empty_needed == 0:\n                if self.negated:\n                    return '1=1', []\n                else:\n                    return '', []\n            if full_needed == 0:\n                if self.negated:\n                    return '', []\n                else:\n                    return '1=0', []\n\n        conn = ' %s ' % self.connector\n        sql_string = conn.join(result)\n        if sql_string:\n            if self.negated:\n                # Some backends (Oracle at least) need parentheses\n                # around the inner SQL in the negated case, even if the\n                # inner SQL contains just a single expression.\n                sql_string = 'NOT (%s)' % sql_string\n            elif len(result) > 1 or self.resolved:\n                sql_string = '(%s)' % sql_string\n        return sql_string, result_params\n",
      "\n    def as_sql(self, compiler, connection):\n        \"\"\"\n        Return the SQL version of the where clause and the value to be\n        substituted in. Return '', [] if this node matches everything and\n        '1=0', [] if this node is empty.\n\n        Test for membership in a list, and special handling for an empty list.\n        \"\"\"\n        result = []\n        result_params = []\n        if self.connector == AND:\n            full_needed, empty_needed = len(self.children), 1\n        else:\n            full_needed, empty_needed = 1, len(self.children)\n\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                return '', []\n\n        if full_needed == 0:\n            if self.negated:\n                return '', []\n            else:\n                return '1=0', []\n\n        for child in self.children:\n            try:\n                sql, params = compiler.compile(child)\n            except EmptyResultSet:\n                empty_needed -= 1\n            except FullResultSet:\n                full_needed -= 1\n            else:\n                if sql:\n                    result.append(sql)\n                    result_params.extend(params)\n                else:\n                    full_needed -= 1\n\n        if empty_needed == 0:\n            if self.negated:\n                return '1=1', []\n            else:\n                return '', []\n\n        if full_needed == 0:\n            if self.negated:\n                return '', []\n            else:\n                return '1=0', []\n\n        conn = ' %s ' % self.connector\n        sql_string = conn.join(result)\n        if sql_string:\n            if self.negated:\n                # Some backends (Oracle at least) need parentheses\n                # around the inner SQL in the negated case, even if the\n                # inner SQL contains just a single expression.\n                sql_string = 'NOT (%s)' % sql_string\n            elif len(result) > 1 or self.resolved:\n                sql_string = '(%s)' % sql_string\n        return sql_string, result_params\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 8642e1f151..3dca85a374 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -966,6 +966,7 @@ class ExpressionWrapper(SQLiteNumericMixin, Expression):\n     def set_source_expressions(self, exprs):\n         self.expression = exprs[0]\n \n+\n     def get_source_expressions(self):\n         return [self.expression]\n \ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 9315ae8039..db73e74d94 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -413,6 +413,7 @@ class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n             except TypeError:  # Unhashable items in self.rhs\n                 rhs = [r for r in self.rhs if r is not None]\n \n+\n             if not rhs:\n                 raise EmptyResultSet\n \ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 188b640850..b6ade0afd3 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,6 +68,7 @@ class Q(tree.Node):\n         obj.negate()\n         return obj\n \n+\n     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n         # We must promote any new joins to left outer joins so that when Q is\n         # used as an expression, rows aren't filtered due to joins.\ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex 50ff13be75..d6d92e3b59 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -92,11 +92,13 @@ class WhereNode(tree.Node):\n             # to make this node empty/full.\n             # Now, check if this node is full/empty using the\n             # counts.\n+\n             if empty_needed == 0:\n                 if self.negated:\n-                    return '', []\n+                    return '1=1', []\n                 else:\n                     raise EmptyResultSet\n+\n             if full_needed == 0:\n                 if self.negated:\n                     raise EmptyResultSet\n",
    "variant_0": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 8642e1f151..60406dc238 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -966,10 +966,101 @@ class ExpressionWrapper(SQLiteNumericMixin, Expression):\n     def set_source_expressions(self, exprs):\n         self.expression = exprs[0]\n \n-    def get_source_expressions(self):\n-        return [self.expression]\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Return the SQL version of the where clause and the value to be\n+        substituted in. Return '', [] if this node matches everything and\n+        '1=0', [] if this node is empty.\n+\n+        The 'split_subq' tells the caller if the current branch contains a\n+        subquery that needs splitting. The split_subq is propagated by the\n+        caller all the way up to the query.split_exclude().\n+        \"\"\"\n+        result = []\n+        result_params = []\n+        empty = True\n+\n+        for child in self.children:\n+            try:\n+                sql, params = compiler.compile(child)\n+            except EmptyResultSet:\n+                empty = False\n+                continue\n+            if sql:\n+                result.append(sql)\n+                result_params.extend(params)\n+                empty = False\n+\n+        if empty:\n+            raise EmptyResultSet\n+\n+        conn = ' %s ' % self.connector\n+        sql_string = conn.join(result)\n+        if sql_string:\n+            if self.negated:\n+                # Some backends (Oracle at least) need parentheses\n+                # around the inner SQL in the negated case, even if the\n+                # inner SQL contains just a single expression.\n+                sql_string = 'NOT (%s)' % sql_string\n+            elif len(result) > 1 or self.resolved:\n+                sql_string = '(%s)' % sql_string\n+        return sql_string, result_params\n \n     def get_group_by_cols(self, alias=None):\n+        cols = []\n+        for child in self.children:\n+            cols.extend(child.get_group_by_cols(alias=alias))\n+        return cols\n+\n+    def get_source_expressions(self):\n+        return self.children[:]\n+\n+    def set_source_expressions(self, children):\n+        assert len(children) == len(self.children)\n+        self.children = children\n+\n+    def relabel_aliases(self, change_map):\n+        \"\"\"\n+        Relabel the alias values of any children. 'change_map' is a dictionary\n+        mapping old (current) alias values to the new values.\n+        \"\"\"\n+        for child in self.children:\n+            child.relabel_aliases(change_map)\n+\n+    def clone(self):\n+        \"\"\"\n+        Create a clone of the tree. Must only be called on root nodes (nodes\n+        with empty subtree_parents). Childs must be either (Constraint, lookup,\n+        value) tuples, or child WhereNodes.\n+        \"\"\"\n+        clone = self.__class__(children=[], connector=self.connector,\n+                               negated=self.negated)\n+        for child in self.children:\n+            if hasattr(child, 'clone'):\n+                clone.children.append(child.clone())\n+            else:\n+                clone.children.append(child)\n+        return clone\n+\n+    def relabeled_clone(self, change_map):\n+        clone = self.clone()\n+        clone.relabel_aliases(change_map)\n+        return clone\n+\n+    def copy(self):\n+        return self.clone()\n+\n+    def _contains_aggregate(self, existing_inner):\n+        for child in self.children:\n+            if child._contains_aggregate(existing_inner):\n+                return True\n+        return False\n+\n+    def _contains_over_clause(self):\n+        for child in self.children:\n+            if child._contains_over_clause():\n+                return True\n+        return False\n         if isinstance(self.expression, Expression):\n             expression = self.expression.copy()\n             expression.output_field = self.output_field\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 9315ae8039..23de1705d1 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -413,9 +413,19 @@ class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n             except TypeError:  # Unhashable items in self.rhs\n                 rhs = [r for r in self.rhs if r is not None]\n \n-            if not rhs:\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n                 raise EmptyResultSet\n \n+        if full_needed == 0:\n+            if self.negated:\n+                raise EmptyResultSet\n+            else:\n+                return '', []\n+\n             # rhs should be an iterable; use batch_process_rhs() to\n             # prepare/transform those values.\n             sqls, sqls_params = self.batch_process_rhs(compiler, connection, rhs)\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 188b640850..88d801abc4 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,14 +68,55 @@ class Q(tree.Node):\n         obj.negate()\n         return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n-        # We must promote any new joins to left outer joins so that when Q is\n-        # used as an expression, rows aren't filtered due to joins.\n-        clause, joins = query._add_q(\n-            self, reuse, allow_joins=allow_joins, split_subq=False,\n-            check_filterable=False,\n-        )\n-        query.promote_joins(joins)\n+\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Return the SQL version of the where clause and the value to be\n+        substituted in. Return '', [] if this node matches everything and\n+        '1=0', [] if this node is empty.\n+\n+        Test that the correct connector is AND:\n+        >>> w = WhereNode(children=[Q(c=1), Q(c=2)], connector='AND')\n+        >>> w.as_sql(compiler, connection) == ('(table.c = %s AND table.c = %s)', [1, 2])\n+        True\n+        \"\"\"\n+        result, result_params = [], []\n+        empty = True\n+        for child in self.children:\n+            try:\n+                sql, params = compiler.compile(child)\n+            except EmptyResultSet:\n+                empty_needed -= 1\n+            else:\n+                if sql:\n+                    result.append(sql)\n+                    result_params.extend(params)\n+                    empty = False\n+                else:\n+                    full_needed -= 1\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '', []\n+        if full_needed == 0:\n+            if self.negated:\n+                return '1=0', []\n+            else:\n+                return '', []\n+\n+        conn = ' %s ' % self.connector\n+        sql_string = conn.join(result)\n+        if sql_string:\n+            if self.negated:\n+                # Some backends (Oracle at least) need parentheses\n+                # around the inner SQL in the negated case, even if the\n+                # inner SQL contains just a single expression.\n+                sql_string = 'NOT (%s)' % sql_string\n+            elif len(result) > 1 or self.resolved:\n+                sql_string = '(%s)' % sql_string\n+        return sql_string, result_params\n         return clause\n \n     def deconstruct(self):\ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex 50ff13be75..12e32efc15 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -92,9 +92,21 @@ class WhereNode(tree.Node):\n             # to make this node empty/full.\n             # Now, check if this node is full/empty using the\n             # counts.\n+\n             if empty_needed == 0:\n                 if self.negated:\n-                    return '', []\n+                    return '1=1', []\n+                else:\n+                    raise EmptyResultSet\n+\n+            # Check if this node matches nothing or everything.\n+            # First check the amount of full nodes and empty nodes\n+            # to make this node empty/full.\n+            # Now, check if this node is full/empty using the\n+            # counts.\n+            if empty_needed == 0:\n+                if self.negated:\n+                    return '1=1', []\n                 else:\n                     raise EmptyResultSet\n             if full_needed == 0:\n",
    "variant_1": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 8642e1f151..90075a4409 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -966,10 +966,78 @@ class ExpressionWrapper(SQLiteNumericMixin, Expression):\n     def set_source_expressions(self, exprs):\n         self.expression = exprs[0]\n \n-    def get_source_expressions(self):\n-        return [self.expression]\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Return the SQL version of the where clause and the value to be\n+        substituted in. Return '', [] if this node matches everything and\n+        '1=0', [] if this node is empty.\n \n-    def get_group_by_cols(self, alias=None):\n+        The 'split_subq' tells the caller if the current branch contains a\n+        subquery that needs special handling. We currently do subquery\n+        special handling in the compiler.\n+        \"\"\"\n+        result = []\n+        result_params = []\n+        everything_childs, nothing_childs = 0, 0\n+        non_empty_childs = len(self.children)\n+\n+        for child in self.children:\n+            try:\n+                if hasattr(child, 'as_sql'):\n+                    sql, params = child.as_sql(compiler, connection)\n+                    if sql:\n+                        result.append(sql)\n+                        result_params.extend(params)\n+                    else:\n+                        if sql is None:\n+                            # Skip childs with empty results.\n+                            non_empty_childs -= 1\n+                            continue\n+                        else:\n+                            everything_childs += 1\n+                else:\n+                    # A leaf node in the tree.\n+                    sql, params = self.make_atom(child, compiler, connection)\n+                    if sql:\n+                        result.append(sql)\n+                        result_params.extend(params)\n+                    else:\n+                        if sql is None:\n+                            non_empty_childs -= 1\n+                            continue\n+                        else:\n+                            everything_childs += 1\n+            except EmptyResultSet:\n+                nothing_childs += 1\n+                non_empty_childs -= 1\n+\n+        if not result:\n+            if nothing_childs:\n+                # A subtree didn't match anything; this makes this subtree\n+                # match nothing too.\n+                if self.negated:\n+                    return '1=1', []\n+                else:\n+                    raise EmptyResultSet\n+            if everything_childs:\n+                # Everything in the subtree matched (got empty WHERE), and\n+                # nothing else matched, so this subtree matches everything.\n+                if self.negated:\n+                    return '1=0', []\n+                else:\n+                    return '', []\n+\n+        conn = ' %s ' % self.connector\n+        sql_string = conn.join(result)\n+        if sql_string:\n+            if self.negated:\n+                # Some backends (Oracle at least) need parentheses\n+                # around the inner SQL in the negated case, even if the\n+                # inner SQL contains just a single expression.\n+                sql_string = 'NOT (%s)' % sql_string\n+            elif len(result) > 1 or self.resolved:\n+                sql_string = '(%s)' % sql_string\n+        return sql_string, result_params\n         if isinstance(self.expression, Expression):\n             expression = self.expression.copy()\n             expression.output_field = self.output_field\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 9315ae8039..49190962c0 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -413,8 +413,12 @@ class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n             except TypeError:  # Unhashable items in self.rhs\n                 rhs = [r for r in self.rhs if r is not None]\n \n-            if not rhs:\n-                raise EmptyResultSet\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '', []\n \n             # rhs should be an iterable; use batch_process_rhs() to\n             # prepare/transform those values.\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 188b640850..36d5b114fd 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,14 +68,59 @@ class Q(tree.Node):\n         obj.negate()\n         return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n-        # We must promote any new joins to left outer joins so that when Q is\n-        # used as an expression, rows aren't filtered due to joins.\n-        clause, joins = query._add_q(\n-            self, reuse, allow_joins=allow_joins, split_subq=False,\n-            check_filterable=False,\n-        )\n-        query.promote_joins(joins)\n+\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Return the SQL version of the where clause and the value to be\n+        substituted in. Return '', [] if this node matches everything,\n+        None, [] if this node is empty, and raise EmptyResultSet if this\n+        node can't match anything.\n+        \"\"\"\n+        result = []\n+        result_params = []\n+        if self.connector == AND:\n+            full_needed, empty_needed = len(self.children), 1\n+        else:\n+            full_needed, empty_needed = 1, len(self.children)\n+\n+        for child in self.children:\n+            try:\n+                sql, params = compiler.compile(child)\n+            except EmptyResultSet:\n+                empty_needed -= 1\n+            else:\n+                if sql:\n+                    result.append(sql)\n+                    result_params.extend(params)\n+                else:\n+                    full_needed -= 1\n+            # Check if this node matches nothing or everything.\n+            # First check the amount of full nodes and empty nodes\n+            # to make this node empty/full.\n+            # Now, check if this node is full/empty using the\n+            # counts.\n+            if empty_needed == 0:\n+                if self.negated:\n+                    return '1=1', []\n+                else:\n+                    raise EmptyResultSet\n+            if full_needed == 0:\n+                if self.negated:\n+                    raise EmptyResultSet\n+                else:\n+                    return '', []\n+\n+        conn = ' %s ' % self.connector\n+        sql_string = conn.join(result)\n+        if sql_string:\n+            if self.negated:\n+                # Some backends (Oracle at least) need parentheses\n+                # around the inner SQL in the negated case, even if the\n+                # inner SQL contains just a single expression.\n+                sql_string = 'NOT (%s)' % sql_string\n+            elif len(result) > 1 or self.resolved:\n+                sql_string = '(%s)' % sql_string\n+        return sql_string, result_params\n         return clause\n \n     def deconstruct(self):\ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex 50ff13be75..12e32efc15 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -92,9 +92,21 @@ class WhereNode(tree.Node):\n             # to make this node empty/full.\n             # Now, check if this node is full/empty using the\n             # counts.\n+\n             if empty_needed == 0:\n                 if self.negated:\n-                    return '', []\n+                    return '1=1', []\n+                else:\n+                    raise EmptyResultSet\n+\n+            # Check if this node matches nothing or everything.\n+            # First check the amount of full nodes and empty nodes\n+            # to make this node empty/full.\n+            # Now, check if this node is full/empty using the\n+            # counts.\n+            if empty_needed == 0:\n+                if self.negated:\n+                    return '1=1', []\n                 else:\n                     raise EmptyResultSet\n             if full_needed == 0:\n",
    "variant_2": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 8642e1f151..b4e7a1b362 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -966,10 +966,64 @@ class ExpressionWrapper(SQLiteNumericMixin, Expression):\n     def set_source_expressions(self, exprs):\n         self.expression = exprs[0]\n \n-    def get_source_expressions(self):\n-        return [self.expression]\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Return the SQL version of the where clause and the value to be\n+        substituted in. Return '', [] if this node matches everything and\n+        '1=0', [] if this node is empty.\n \n-    def get_group_by_cols(self, alias=None):\n+        The 'split_subq' tells the caller if the current branch contains a\n+        subquery that needs split. The split_subq will be used by update and\n+        delete queries mostly.\n+        \"\"\"\n+        result = []\n+        result_params = []\n+        empty = True\n+\n+        for child in self.children:\n+            try:\n+                if hasattr(child, 'split_subq'):\n+                    sql, params = child.as_sql(compiler, connection)\n+                    split_subq = child.split_subq\n+                else:\n+                    sql, params = compiler.compile(child)\n+                    split_subq = False\n+            except EmptyResultSet:\n+                empty = False\n+                continue\n+            if sql:\n+                result.append(sql)\n+                result_params.extend(params)\n+                if split_subq:\n+                    self.split_subq = True\n+                empty = False\n+\n+        if empty:\n+            try:\n+                empty_needed, full_needed = self.connector_class.empty_result_set_value\n+            except AttributeError:\n+                empty_needed, full_needed = self.default_empty_result_set_value\n+            if empty_needed == 0:\n+                if self.negated:\n+                    return '1=1', []\n+                else:\n+                    return '', []\n+            elif full_needed == 0:\n+                return '', []\n+            else:\n+                return '1=0', []\n+\n+        conn = ' %s ' % self.connector\n+        sql = conn.join(result)\n+        if sql:\n+            if self.negated:\n+                # Some backends (Oracle at least) need parentheses around the\n+                # inner SQL in the negated case, even if the inner SQL contains\n+                # just a single expression.\n+                sql = 'NOT (%s)' % sql\n+            elif len(result) > 1 or self.resolved:\n+                sql = '(%s)' % sql\n+        return sql, result_params\n         if isinstance(self.expression, Expression):\n             expression = self.expression.copy()\n             expression.output_field = self.output_field\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 9315ae8039..2b57497c1e 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -413,7 +413,11 @@ class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n             except TypeError:  # Unhashable items in self.rhs\n                 rhs = [r for r in self.rhs if r is not None]\n \n-            if not rhs:\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n                 raise EmptyResultSet\n \n             # rhs should be an iterable; use batch_process_rhs() to\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 188b640850..8ff30bdd4b 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,14 +68,73 @@ class Q(tree.Node):\n         obj.negate()\n         return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n-        # We must promote any new joins to left outer joins so that when Q is\n-        # used as an expression, rows aren't filtered due to joins.\n-        clause, joins = query._add_q(\n-            self, reuse, allow_joins=allow_joins, split_subq=False,\n-            check_filterable=False,\n-        )\n-        query.promote_joins(joins)\n+\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Return the SQL version of the where clause and the value to be\n+        substituted in. Return '', [] if this node matches everything and\n+        '1=0', [] if this node is empty.\n+\n+        The 'split_subq' tells the caller if the current branch contains a\n+        LOUTER JOIN that might need special treatment.\n+        \"\"\"\n+        result = []\n+        result_params = []\n+        if self.connector == AND:\n+            full_needed, empty_needed = len(self.children), 1\n+        else:\n+            full_needed, empty_needed = 1, len(self.children)\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '', []\n+        if full_needed == 0:\n+            if self.negated:\n+                return '1=0', []\n+            else:\n+                return '', []\n+\n+        for child in self.children:\n+            try:\n+                if hasattr(child, 'split_subq'):\n+                    # This is a subquery that might need special treatment\n+                    sql, params = child.as_sql(compiler, connection)\n+                    self.split_subq = self.split_subq or child.split_subq\n+                else:\n+                    sql, params = compiler.compile(child)\n+            except EmptyResultSet:\n+                empty_needed -= 1\n+            else:\n+                if sql:\n+                    result.append(sql)\n+                    result_params.extend(params)\n+                else:\n+                    full_needed -= 1\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '', []\n+        if full_needed == 0:\n+            if self.negated:\n+                return '1=0', []\n+            else:\n+                return '', []\n+\n+        conn = ' %s ' % self.connector\n+        sql_string = conn.join(result)\n+        if sql_string:\n+            if self.negated:\n+                # Some backends (Oracle at least) need parentheses\n+                # around the inner SQL in the negated case, even if the\n+                # inner SQL contains just a single expression.\n+                sql_string = 'NOT (%s)' % sql_string\n+            elif len(result) > 1 or self.resolved:\n+                sql_string = '(%s)' % sql_string\n+        return sql_string, result_params\n         return clause\n \n     def deconstruct(self):\ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex 50ff13be75..12e32efc15 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -92,9 +92,21 @@ class WhereNode(tree.Node):\n             # to make this node empty/full.\n             # Now, check if this node is full/empty using the\n             # counts.\n+\n             if empty_needed == 0:\n                 if self.negated:\n-                    return '', []\n+                    return '1=1', []\n+                else:\n+                    raise EmptyResultSet\n+\n+            # Check if this node matches nothing or everything.\n+            # First check the amount of full nodes and empty nodes\n+            # to make this node empty/full.\n+            # Now, check if this node is full/empty using the\n+            # counts.\n+            if empty_needed == 0:\n+                if self.negated:\n+                    return '1=1', []\n                 else:\n                     raise EmptyResultSet\n             if full_needed == 0:\n",
    "variant_3": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 8642e1f151..bffb47d556 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -966,10 +966,58 @@ class ExpressionWrapper(SQLiteNumericMixin, Expression):\n     def set_source_expressions(self, exprs):\n         self.expression = exprs[0]\n \n-    def get_source_expressions(self):\n-        return [self.expression]\n+def as_sql(self, compiler, connection):\n+    \"\"\"\n+    Return the SQL version of the where clause and the value to be\n+    substituted in. Return '', [] if this node matches everything,\n+    None, [] if this node is empty, and raise EmptyResultSet if this\n+    node can't match anything.\n+    \"\"\"\n+    result = []\n+    result_params = []\n+    if self.connector == AND:\n+        full_needed, empty_needed = len(self.children), 1\n+    else:\n+        full_needed, empty_needed = 1, len(self.children)\n+\n+    for child in self.children:\n+        try:\n+            sql, params = compiler.compile(child)\n+        except EmptyResultSet:\n+            empty_needed -= 1\n+        else:\n+            if sql:\n+                result.append(sql)\n+                result_params.extend(params)\n+            else:\n+                full_needed -= 1\n+        # Check if this node matches nothing or everything.\n+        # First check the amount of full nodes and empty nodes\n+        # to make this node empty/full.\n+        # Now, check if this node is full/empty using the\n+        # counts.\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                raise EmptyResultSet\n+        if full_needed == 0:\n+            if self.negated:\n+                raise EmptyResultSet\n+            else:\n+                return '', []\n \n-    def get_group_by_cols(self, alias=None):\n+    conn = ' %s ' % self.connector\n+    sql_string = conn.join(result)\n+    if sql_string:\n+        if self.negated:\n+            # Some backends (Oracle at least) need parentheses\n+            # around the inner SQL in the negated case, even if the\n+            # inner SQL contains just a single expression.\n+            sql_string = 'NOT (%s)' % sql_string\n+        elif len(result) > 1 or self.resolved:\n+            sql_string = '(%s)' % sql_string\n+    return sql_string, result_params\n         if isinstance(self.expression, Expression):\n             expression = self.expression.copy()\n             expression.output_field = self.output_field\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 9315ae8039..23de1705d1 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -413,9 +413,19 @@ class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n             except TypeError:  # Unhashable items in self.rhs\n                 rhs = [r for r in self.rhs if r is not None]\n \n-            if not rhs:\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n                 raise EmptyResultSet\n \n+        if full_needed == 0:\n+            if self.negated:\n+                raise EmptyResultSet\n+            else:\n+                return '', []\n+\n             # rhs should be an iterable; use batch_process_rhs() to\n             # prepare/transform those values.\n             sqls, sqls_params = self.batch_process_rhs(compiler, connection, rhs)\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 188b640850..cc1f520830 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,14 +68,92 @@ class Q(tree.Node):\n         obj.negate()\n         return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n-        # We must promote any new joins to left outer joins so that when Q is\n-        # used as an expression, rows aren't filtered due to joins.\n-        clause, joins = query._add_q(\n-            self, reuse, allow_joins=allow_joins, split_subq=False,\n-            check_filterable=False,\n-        )\n-        query.promote_joins(joins)\n+\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Return the SQL version of the where clause and the value to be\n+        substituted in. Return '', [] if this node matches everything and\n+        '1=0', [] if this node is empty.\n+\n+        The 'split_subq' tells the caller if the current branch contains a\n+        subquery that needs special treatment. The split_subq is initially\n+        None, then it is set to True whenever there is a subquery, unless the\n+        subquery is in a NOT branch, in which case it is set to False.\n+        \"\"\"\n+        result = []\n+        result_params = []\n+        everything_childs, nothing_childs = 0, 0\n+        non_empty_childs = len(self.children)\n+\n+        for child in self.children:\n+            try:\n+                if hasattr(child, 'split_subq'):\n+                    # This is a subquery, we need to be careful.\n+                    child_sql, child_params = child.as_sql(compiler, connection)\n+                    if child.split_subq and self.negated:\n+                        split_subq = False\n+                    elif child.split_subq:\n+                        split_subq = True\n+                else:\n+                    child_sql, child_params = compiler.compile(child)\n+            except EmptyResultSet:\n+                empty_needed -= 1\n+                if self.connector == self.AND:\n+                    # We can bail out early - if one child is empty, everything\n+                    # is empty.\n+                    raise\n+                empty_needed -= 1\n+            except FullResultSet:\n+                full_needed -= 1\n+                if self.connector == self.OR:\n+                    # We can bail out early - if one child matches everything,\n+                    # everything matches.\n+                    raise\n+                full_needed -= 1\n+            else:\n+                if child_sql:\n+                    result.append(child_sql)\n+                    result_params.extend(child_params)\n+                else:\n+                    if child_sql == '':\n+                        everything_childs += 1\n+                    else:\n+                        nothing_childs += 1\n+                    non_empty_childs -= 1\n+\n+        try:\n+            conn_type = self.AND if self.connector == self.AND else self.OR\n+            sql_string = conn_type.join(result)\n+        except EmptyResultSet:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '1=0', []\n+        except FullResultSet:\n+            if self.negated:\n+                return '1=0', []\n+            else:\n+                return '1=1', []\n+\n+        if not result:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '1=0', []\n+\n+        if not non_empty_childs:\n+            # All children were empty, so this node is empty.\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '1=0', []\n+\n+        result_sql = '(%s)' % sql_string if len(result) > 1 else sql_string\n+        if self.negated:\n+            # Some backends (Oracle at least) need parentheses around the\n+            # inner query.\n+            result_sql = 'NOT (%s)' % result_sql\n+        return result_sql, result_params\n         return clause\n \n     def deconstruct(self):\ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex 50ff13be75..f1530a3413 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -92,16 +92,18 @@ class WhereNode(tree.Node):\n             # to make this node empty/full.\n             # Now, check if this node is full/empty using the\n             # counts.\n+\n             if empty_needed == 0:\n                 if self.negated:\n-                    return '', []\n+                    return '1=1', []\n                 else:\n                     raise EmptyResultSet\n-            if full_needed == 0:\n+\n+            if empty_needed == 0:\n                 if self.negated:\n-                    raise EmptyResultSet\n+                    return '1=1', []\n                 else:\n-                    return '', []\n+                    raise EmptyResultSet\n         conn = ' %s ' % self.connector\n         sql_string = conn.join(result)\n         if sql_string:\n",
    "variant_4": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 8642e1f151..2256a4678b 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -966,10 +966,59 @@ class ExpressionWrapper(SQLiteNumericMixin, Expression):\n     def set_source_expressions(self, exprs):\n         self.expression = exprs[0]\n \n-    def get_source_expressions(self):\n-        return [self.expression]\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Return the SQL version of the where clause and the value to be\n+        substituted in. Return '', [] if this node matches everything,\n+        raise EmptyResultSet if this node is empty, and raise\n+        FullResultSet if this node is full.\n+        \"\"\"\n+        result = []\n+        result_params = []\n+        if self.connector == AND:\n+            full_needed, empty_needed = len(self.children), 1\n+        else:\n+            full_needed, empty_needed = 1, len(self.children)\n \n-    def get_group_by_cols(self, alias=None):\n+        for child in self.children:\n+            try:\n+                sql, params = compiler.compile(child)\n+            except EmptyResultSet:\n+                empty_needed -= 1\n+            except FullResultSet:\n+                full_needed -= 1\n+            else:\n+                if sql:\n+                    result.append(sql)\n+                    result_params.extend(params)\n+                else:\n+                    full_needed -= 1\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                raise EmptyResultSet\n+\n+        if full_needed == 0:\n+            if self.negated:\n+                raise EmptyResultSet\n+            else:\n+                return '', []\n+\n+        if not result:\n+            raise FullResultSet\n+\n+        conn = ' %s ' % self.connector\n+        sql_string = conn.join(result)\n+        if len(result) > 1:\n+            sql_string = '(%s)' % sql_string\n+        if self.negated:\n+            # Some backends (Oracle at least) need parentheses\n+            # around the inner SQL in the negated case, even if the\n+            # inner SQL contains just a single expression.\n+            sql_string = 'NOT (%s)' % sql_string\n+        return sql_string, result_params\n         if isinstance(self.expression, Expression):\n             expression = self.expression.copy()\n             expression.output_field = self.output_field\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 9315ae8039..aaff9d3523 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -413,8 +413,11 @@ class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n             except TypeError:  # Unhashable items in self.rhs\n                 rhs = [r for r in self.rhs if r is not None]\n \n-            if not rhs:\n-                raise EmptyResultSet\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            return '', []\n \n             # rhs should be an iterable; use batch_process_rhs() to\n             # prepare/transform those values.\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 188b640850..a6ba762a44 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,14 +68,72 @@ class Q(tree.Node):\n         obj.negate()\n         return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n-        # We must promote any new joins to left outer joins so that when Q is\n-        # used as an expression, rows aren't filtered due to joins.\n-        clause, joins = query._add_q(\n-            self, reuse, allow_joins=allow_joins, split_subq=False,\n-            check_filterable=False,\n-        )\n-        query.promote_joins(joins)\n+\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Return the SQL version of the where clause and the value to be\n+        substituted in. Return '', [] if this node matches everything and\n+        '1=0', [] if this node is empty.\n+\n+        The 'split_subq' tells the caller if the current branch contains\n+        references to table aliases that are changing in the outer query (for\n+        example, as a result of a subquery, that in SQL Server requires each\n+        part of a query to be executed separately).\n+        \"\"\"\n+        result = []\n+        result_params = []\n+        everything_childs, nothing_childs = 0, 0\n+        non_empty_childs = len(self.children)\n+\n+        for child in self.children:\n+            try:\n+                if hasattr(child, 'split_exclude'):\n+                    split_subq = child.split_exclude(compiler, connection, child.alias)\n+                    if split_subq:\n+                        # If the child references a table alias that's being\n+                        # changed, we need to compile the child separately.\n+                        sql, params = child.as_sql(compiler, connection)\n+                        result.append(sql)\n+                        result_params.extend(params)\n+                        continue\n+                sql, params = compiler.compile(child)\n+            except EmptyResultSet:\n+                empty_needed -= 1\n+                nothing_childs += 1\n+            except FullResultSet:\n+                full_needed -= 1\n+                everything_childs += 1\n+            else:\n+                if sql:\n+                    result.append(sql)\n+                    result_params.extend(params)\n+                else:\n+                    full_needed -= 1\n+                    everything_childs += 1\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '', []\n+\n+        if full_needed == 0:\n+            if self.negated:\n+                return '1=0', []\n+            else:\n+                return '', []\n+\n+        conn = ' %s ' % self.connector\n+        sql_string = conn.join(result)\n+        if sql_string:\n+            if self.negated:\n+                # Some backends (Oracle at least) need parentheses\n+                # around the inner SQL in the negated case, even if the\n+                # inner SQL contains just a single expression.\n+                sql_string = 'NOT (%s)' % sql_string\n+            elif len(result) > 1 or self.resolved:\n+                sql_string = '(%s)' % sql_string\n+        return sql_string, result_params\n         return clause\n \n     def deconstruct(self):\ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex 50ff13be75..9a87ae3aa1 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -92,16 +92,28 @@ class WhereNode(tree.Node):\n             # to make this node empty/full.\n             # Now, check if this node is full/empty using the\n             # counts.\n+\n             if empty_needed == 0:\n                 if self.negated:\n-                    return '', []\n+                    return '1=1', []\n                 else:\n                     raise EmptyResultSet\n-            if full_needed == 0:\n-                if self.negated:\n-                    raise EmptyResultSet\n-                else:\n-                    return '', []\n+\n+        # Check if this node matches nothing or everything.\n+        # First check the amount of full nodes and empty nodes\n+        # to make this node empty/full.\n+        # Now, check if this node is full/empty using the\n+        # counts.\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                raise EmptyResultSet\n+        if full_needed == 0:\n+            if self.negated:\n+                raise EmptyResultSet\n+            else:\n+                return '', []\n         conn = ' %s ' % self.connector\n         sql_string = conn.join(result)\n         if sql_string:\n",
    "variant_5": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 8642e1f151..cb42ab35c9 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -966,10 +966,67 @@ class ExpressionWrapper(SQLiteNumericMixin, Expression):\n     def set_source_expressions(self, exprs):\n         self.expression = exprs[0]\n \n-    def get_source_expressions(self):\n-        return [self.expression]\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Return the SQL version of the where clause and the value to be\n+        substituted in. Return '', [] if this node matches everything and\n+        '1=0', [] if this node is empty.\n \n-    def get_group_by_cols(self, alias=None):\n+        The 'split_subq' tells the caller whether or not all the condition\n+        children can be safely split across a join. It is always True for\n+        LeafNode children.\n+        \"\"\"\n+        result = []\n+        result_params = []\n+        if self.connector == AND:\n+            full_needed, empty_needed = len(self.children), 1\n+        else:\n+            full_needed, empty_needed = 1, len(self.children)\n+\n+        if self.children:\n+            for child in self.children:\n+                try:\n+                    sql, params = compiler.compile(child)\n+                except EmptyResultSet:\n+                    empty_needed -= 1\n+                else:\n+                    if sql:\n+                        result.append(sql)\n+                        result_params.extend(params)\n+                    else:\n+                        full_needed -= 1\n+                # Check if this node matches nothing or everything.\n+                # First check the amount of full nodes and empty nodes\n+                # to make this node empty/full.\n+                # Now, check if this node is full/empty using the\n+                # counts.\n+                if empty_needed == 0:\n+                    if self.negated:\n+                        return '1=1', []\n+                    else:\n+                        return '', []\n+                if full_needed == 0:\n+                    if self.negated:\n+                        return '', []\n+                    else:\n+                        return '1=0', []\n+        if not result:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '1=0', []\n+\n+        conn = ' %s ' % self.connector\n+        sql_string = conn.join(result)\n+        if sql_string:\n+            if self.negated:\n+                # Some backends (Oracle at least) need parentheses\n+                # around the inner SQL in the negated case, even if the\n+                # inner SQL contains just a single expression.\n+                sql_string = 'NOT (%s)' % sql_string\n+            elif len(result) > 1 or self.resolved:\n+                sql_string = '(%s)' % sql_string\n+        return sql_string, result_params\n         if isinstance(self.expression, Expression):\n             expression = self.expression.copy()\n             expression.output_field = self.output_field\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 9315ae8039..41738afded 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -413,8 +413,18 @@ class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n             except TypeError:  # Unhashable items in self.rhs\n                 rhs = [r for r in self.rhs if r is not None]\n \n-            if not rhs:\n-                raise EmptyResultSet\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '', []\n+        \n+        if full_needed == 0:\n+            if self.negated:\n+                return '', []\n+            else:\n+                return '1=1', []\n \n             # rhs should be an iterable; use batch_process_rhs() to\n             # prepare/transform those values.\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 188b640850..072c636730 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,14 +68,27 @@ class Q(tree.Node):\n         obj.negate()\n         return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n-        # We must promote any new joins to left outer joins so that when Q is\n-        # used as an expression, rows aren't filtered due to joins.\n-        clause, joins = query._add_q(\n-            self, reuse, allow_joins=allow_joins, split_subq=False,\n-            check_filterable=False,\n-        )\n-        query.promote_joins(joins)\n+\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Return the SQL version of the where clause and the value to be\n+        substituted in. Return '', [] if this node matches everything and\n+        '1=0', [] if this node is empty.\n+\n+        Test that the node is empty by seeing if the two sets of available\n+        choices given by self.lhs and self.rhs are disjoint. Lazy evaluation\n+        would be nice, but is tricky with combine().\n+        \"\"\"\n+        result, result_params = super().as_sql(compiler, connection)\n+        if result:\n+            return result, result_params\n+        # When the query is empty, return '1=0' or '1=1' depending on negation.\n+        # For negated empty conditions (like ~Q(pk__in=[])), we want True (1=1).\n+        # For non-negated empty conditions (like Q(pk__in=[])), we want False (1=0).\n+        if self.negated:\n+            return '1=1', []\n+        else:\n+            return '1=0', []\n         return clause\n \n     def deconstruct(self):\ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex 50ff13be75..12e32efc15 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -92,9 +92,21 @@ class WhereNode(tree.Node):\n             # to make this node empty/full.\n             # Now, check if this node is full/empty using the\n             # counts.\n+\n             if empty_needed == 0:\n                 if self.negated:\n-                    return '', []\n+                    return '1=1', []\n+                else:\n+                    raise EmptyResultSet\n+\n+            # Check if this node matches nothing or everything.\n+            # First check the amount of full nodes and empty nodes\n+            # to make this node empty/full.\n+            # Now, check if this node is full/empty using the\n+            # counts.\n+            if empty_needed == 0:\n+                if self.negated:\n+                    return '1=1', []\n                 else:\n                     raise EmptyResultSet\n             if full_needed == 0:\n",
    "variant_6": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 8642e1f151..f039fe9d98 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -966,10 +966,82 @@ class ExpressionWrapper(SQLiteNumericMixin, Expression):\n     def set_source_expressions(self, exprs):\n         self.expression = exprs[0]\n \n-    def get_source_expressions(self):\n-        return [self.expression]\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Return the SQL version of the where clause and the value to be\n+        substituted in. Return '', [] if this node matches everything and\n+        '1=0', [] if this node is empty.\n \n-    def get_group_by_cols(self, alias=None):\n+        The 'node' parameter allows the caller to designate which node is the\n+        root of the constructed SQL.\n+        \"\"\"\n+        result = []\n+        result_params = []\n+        everything_childs, nothing_childs = 0, 0\n+        non_empty_childs = len(self.children)\n+\n+        for child in self.children:\n+            try:\n+                if hasattr(child, 'as_sql'):\n+                    sql, params = child.as_sql(compiler, connection)\n+                    format_string = '(%s)'\n+                    if sql:\n+                        result.append(sql)\n+                        result_params.extend(params)\n+                    else:\n+                        if sql == '':\n+                            everything_childs += 1\n+                        else:\n+                            nothing_childs += 1\n+                        non_empty_childs -= 1\n+                else:\n+                    # This branch is reached when the child is a leaf node\n+                    format_string = '%s'\n+                    sql, params = self.make_atom(child, compiler, connection)\n+                    if sql:\n+                        result.append(format_string % sql)\n+                        result_params.extend(params)\n+                    else:\n+                        if sql == '':\n+                            everything_childs += 1\n+                        else:\n+                            nothing_childs += 1\n+                        non_empty_childs -= 1\n+            except EmptyResultSet:\n+                nothing_childs += 1\n+                non_empty_childs -= 1\n+\n+        if self.connector == AND:\n+            full_needed, empty_needed = nothing_childs, everything_childs\n+        else:\n+            full_needed, empty_needed = everything_childs, nothing_childs\n+\n+        if self.negated:\n+            full_needed, empty_needed = empty_needed, full_needed\n+\n+        if full_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '', []\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '1=0', []\n+\n+        conn = ' %s ' % self.connector\n+        sql_string = conn.join(result)\n+        if sql_string:\n+            if self.negated:\n+                # Some backends (Oracle at least) need parentheses\n+                # around the inner SQL in the negated case, even if the\n+                # inner SQL contains just a single expression.\n+                sql_string = 'NOT (%s)' % sql_string\n+            elif len(result) > 1 or self.resolved:\n+                sql_string = '(%s)' % sql_string\n+        return sql_string, result_params\n         if isinstance(self.expression, Expression):\n             expression = self.expression.copy()\n             expression.output_field = self.output_field\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 9315ae8039..49190962c0 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -413,8 +413,12 @@ class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n             except TypeError:  # Unhashable items in self.rhs\n                 rhs = [r for r in self.rhs if r is not None]\n \n-            if not rhs:\n-                raise EmptyResultSet\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '', []\n \n             # rhs should be an iterable; use batch_process_rhs() to\n             # prepare/transform those values.\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 188b640850..36d5b114fd 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,14 +68,59 @@ class Q(tree.Node):\n         obj.negate()\n         return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n-        # We must promote any new joins to left outer joins so that when Q is\n-        # used as an expression, rows aren't filtered due to joins.\n-        clause, joins = query._add_q(\n-            self, reuse, allow_joins=allow_joins, split_subq=False,\n-            check_filterable=False,\n-        )\n-        query.promote_joins(joins)\n+\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Return the SQL version of the where clause and the value to be\n+        substituted in. Return '', [] if this node matches everything,\n+        None, [] if this node is empty, and raise EmptyResultSet if this\n+        node can't match anything.\n+        \"\"\"\n+        result = []\n+        result_params = []\n+        if self.connector == AND:\n+            full_needed, empty_needed = len(self.children), 1\n+        else:\n+            full_needed, empty_needed = 1, len(self.children)\n+\n+        for child in self.children:\n+            try:\n+                sql, params = compiler.compile(child)\n+            except EmptyResultSet:\n+                empty_needed -= 1\n+            else:\n+                if sql:\n+                    result.append(sql)\n+                    result_params.extend(params)\n+                else:\n+                    full_needed -= 1\n+            # Check if this node matches nothing or everything.\n+            # First check the amount of full nodes and empty nodes\n+            # to make this node empty/full.\n+            # Now, check if this node is full/empty using the\n+            # counts.\n+            if empty_needed == 0:\n+                if self.negated:\n+                    return '1=1', []\n+                else:\n+                    raise EmptyResultSet\n+            if full_needed == 0:\n+                if self.negated:\n+                    raise EmptyResultSet\n+                else:\n+                    return '', []\n+\n+        conn = ' %s ' % self.connector\n+        sql_string = conn.join(result)\n+        if sql_string:\n+            if self.negated:\n+                # Some backends (Oracle at least) need parentheses\n+                # around the inner SQL in the negated case, even if the\n+                # inner SQL contains just a single expression.\n+                sql_string = 'NOT (%s)' % sql_string\n+            elif len(result) > 1 or self.resolved:\n+                sql_string = '(%s)' % sql_string\n+        return sql_string, result_params\n         return clause\n \n     def deconstruct(self):\ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex 50ff13be75..12e32efc15 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -92,9 +92,21 @@ class WhereNode(tree.Node):\n             # to make this node empty/full.\n             # Now, check if this node is full/empty using the\n             # counts.\n+\n             if empty_needed == 0:\n                 if self.negated:\n-                    return '', []\n+                    return '1=1', []\n+                else:\n+                    raise EmptyResultSet\n+\n+            # Check if this node matches nothing or everything.\n+            # First check the amount of full nodes and empty nodes\n+            # to make this node empty/full.\n+            # Now, check if this node is full/empty using the\n+            # counts.\n+            if empty_needed == 0:\n+                if self.negated:\n+                    return '1=1', []\n                 else:\n                     raise EmptyResultSet\n             if full_needed == 0:\n",
    "variant_7": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 8642e1f151..68d3eb9ea8 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -966,10 +966,58 @@ class ExpressionWrapper(SQLiteNumericMixin, Expression):\n     def set_source_expressions(self, exprs):\n         self.expression = exprs[0]\n \n-    def get_source_expressions(self):\n-        return [self.expression]\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Return the SQL version of the where clause and the value to be\n+        substituted in. Return '', [] if this node matches everything,\n+        raise EmptyResultSet if this node is empty, and raise\n+        FullResultSet if this node matches nothing.\n+        \"\"\"\n+        result = []\n+        result_params = []\n+        if self.connector == AND:\n+            full_needed, empty_needed = len(self.children), 1\n+        else:\n+            full_needed, empty_needed = 1, len(self.children)\n \n-    def get_group_by_cols(self, alias=None):\n+        for child in self.children:\n+            try:\n+                sql, params = compiler.compile(child)\n+            except EmptyResultSet:\n+                empty_needed -= 1\n+            except FullResultSet:\n+                full_needed -= 1\n+            else:\n+                if sql:\n+                    result.append(sql)\n+                    result_params.extend(params)\n+                else:\n+                    full_needed -= 1\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                raise FullResultSet\n+\n+        if full_needed == 0:\n+            if self.negated:\n+                raise FullResultSet\n+            else:\n+                return '', []\n+\n+        if not result:\n+            return '', []\n+        conn = ' %s ' % self.connector\n+        sql_string = conn.join(result)\n+        if len(result) > 1:\n+            sql_string = '(%s)' % sql_string\n+        if self.negated:\n+            # Some backends (Oracle at least) need parentheses\n+            # around the inner SQL in the negated case, even if the\n+            # inner SQL contains just a single expression.\n+            sql_string = 'NOT (%s)' % sql_string\n+        return sql_string, result_params\n         if isinstance(self.expression, Expression):\n             expression = self.expression.copy()\n             expression.output_field = self.output_field\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 9315ae8039..49190962c0 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -413,8 +413,12 @@ class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n             except TypeError:  # Unhashable items in self.rhs\n                 rhs = [r for r in self.rhs if r is not None]\n \n-            if not rhs:\n-                raise EmptyResultSet\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '', []\n \n             # rhs should be an iterable; use batch_process_rhs() to\n             # prepare/transform those values.\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 188b640850..cda07c4e1c 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,14 +68,75 @@ class Q(tree.Node):\n         obj.negate()\n         return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n-        # We must promote any new joins to left outer joins so that when Q is\n-        # used as an expression, rows aren't filtered due to joins.\n-        clause, joins = query._add_q(\n-            self, reuse, allow_joins=allow_joins, split_subq=False,\n-            check_filterable=False,\n-        )\n-        query.promote_joins(joins)\n+\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Return the SQL version of the where clause and the value to be\n+        substituted in. Return '', [] if this node matches everything and\n+        '1=0', [] if this node is empty.\n+\n+        The 'split_subq' tells the caller if the current branch contains a\n+        subquery that needs splitting. The split_subq will be used by OR\n+        branches to determine if they contain a subquery which needs special\n+        handling (see split_exclude).\n+        \"\"\"\n+        result = []\n+        result_params = []\n+        if self.connector == AND:\n+            full_needed, empty_needed = len(self.children), 1\n+        else:\n+            full_needed, empty_needed = 1, len(self.children)\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '', []\n+\n+        if full_needed == 0:\n+            if self.negated:\n+                return '', []\n+            else:\n+                return '1=0', []\n+\n+        for child in self.children:\n+            try:\n+                sql, params = compiler.compile(child)\n+            except EmptyResultSet:\n+                empty_needed -= 1\n+            else:\n+                if sql:\n+                    result.append(sql)\n+                    result_params.extend(params)\n+                else:\n+                    full_needed -= 1\n+            # Check if this node matches nothing or everything.\n+            # First check the amount of full nodes and empty nodes\n+            # to make this node empty/full.\n+            # Now, check if this node is full/empty using the\n+            # counts.\n+            if empty_needed == 0:\n+                if self.negated:\n+                    return '1=1', []\n+                else:\n+                    return '', []\n+            if full_needed == 0:\n+                if self.negated:\n+                    return '', []\n+                else:\n+                    return '1=0', []\n+\n+        conn = ' %s ' % self.connector\n+        sql_string = conn.join(result)\n+        if sql_string:\n+            if self.negated:\n+                # Some backends (Oracle at least) need parentheses\n+                # around the inner SQL in the negated case, even if the\n+                # inner SQL contains just a single expression.\n+                sql_string = 'NOT (%s)' % sql_string\n+            elif len(result) > 1 or self.resolved:\n+                sql_string = '(%s)' % sql_string\n+        return sql_string, result_params\n         return clause\n \n     def deconstruct(self):\ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex 50ff13be75..f1530a3413 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -92,16 +92,18 @@ class WhereNode(tree.Node):\n             # to make this node empty/full.\n             # Now, check if this node is full/empty using the\n             # counts.\n+\n             if empty_needed == 0:\n                 if self.negated:\n-                    return '', []\n+                    return '1=1', []\n                 else:\n                     raise EmptyResultSet\n-            if full_needed == 0:\n+\n+            if empty_needed == 0:\n                 if self.negated:\n-                    raise EmptyResultSet\n+                    return '1=1', []\n                 else:\n-                    return '', []\n+                    raise EmptyResultSet\n         conn = ' %s ' % self.connector\n         sql_string = conn.join(result)\n         if sql_string:\n",
    "variant_8": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 8642e1f151..de60d2510d 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -966,10 +966,57 @@ class ExpressionWrapper(SQLiteNumericMixin, Expression):\n     def set_source_expressions(self, exprs):\n         self.expression = exprs[0]\n \n-    def get_source_expressions(self):\n-        return [self.expression]\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Return the SQL version of the where clause and the value to be\n+        substituted in. Return '', [] if this node matches everything,\n+        raise EmptyResultSet if this node is empty, and raise\n+        FullResultSet if this node matches nothing.\n+        \"\"\"\n+        result = []\n+        result_params = []\n+        if self.connector == AND:\n+            full_needed, empty_needed = len(self.children), 1\n+        else:\n+            full_needed, empty_needed = 1, len(self.children)\n \n-    def get_group_by_cols(self, alias=None):\n+        for child in self.children:\n+            try:\n+                sql, params = compiler.compile(child)\n+            except EmptyResultSet:\n+                empty_needed -= 1\n+            except FullResultSet:\n+                full_needed -= 1\n+            else:\n+                if sql:\n+                    result.append(sql)\n+                    result_params.extend(params)\n+                else:\n+                    full_needed -= 1\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            raise FullResultSet\n+\n+        if full_needed == 0:\n+            if self.negated:\n+                raise FullResultSet\n+            return '', []\n+\n+        if not result:\n+            raise FullResultSet\n+\n+        conn = ' %s ' % self.connector\n+        sql_string = conn.join(result)\n+        if len(result) > 1:\n+            sql_string = '(%s)' % sql_string\n+        if self.negated:\n+            # Some backends (Oracle at least) need parentheses\n+            # around the inner SQL in the negated case, even if the\n+            # inner SQL contains just a single expression.\n+            sql_string = 'NOT (%s)' % sql_string\n+        return sql_string, result_params\n         if isinstance(self.expression, Expression):\n             expression = self.expression.copy()\n             expression.output_field = self.output_field\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 9315ae8039..71657d3c8b 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -413,8 +413,17 @@ class In(FieldGetDbPrepValueIterableMixin, BuiltinLookup):\n             except TypeError:  # Unhashable items in self.rhs\n                 rhs = [r for r in self.rhs if r is not None]\n \n-            if not rhs:\n-                raise EmptyResultSet\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '', []\n+        if full_needed == 0:\n+            if self.negated:\n+                return '', []\n+            else:\n+                return '1=1', []\n \n             # rhs should be an iterable; use batch_process_rhs() to\n             # prepare/transform those values.\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex 188b640850..273ab54d21 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -68,14 +68,71 @@ class Q(tree.Node):\n         obj.negate()\n         return obj\n \n-    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n-        # We must promote any new joins to left outer joins so that when Q is\n-        # used as an expression, rows aren't filtered due to joins.\n-        clause, joins = query._add_q(\n-            self, reuse, allow_joins=allow_joins, split_subq=False,\n-            check_filterable=False,\n-        )\n-        query.promote_joins(joins)\n+\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Return the SQL version of the where clause and the value to be\n+        substituted in. Return '', [] if this node matches everything and\n+        '1=0', [] if this node is empty.\n+\n+        Test for membership in a list, and special handling for an empty list.\n+        \"\"\"\n+        result = []\n+        result_params = []\n+        if self.connector == AND:\n+            full_needed, empty_needed = len(self.children), 1\n+        else:\n+            full_needed, empty_needed = 1, len(self.children)\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '', []\n+\n+        if full_needed == 0:\n+            if self.negated:\n+                return '', []\n+            else:\n+                return '1=0', []\n+\n+        for child in self.children:\n+            try:\n+                sql, params = compiler.compile(child)\n+            except EmptyResultSet:\n+                empty_needed -= 1\n+            except FullResultSet:\n+                full_needed -= 1\n+            else:\n+                if sql:\n+                    result.append(sql)\n+                    result_params.extend(params)\n+                else:\n+                    full_needed -= 1\n+\n+        if empty_needed == 0:\n+            if self.negated:\n+                return '1=1', []\n+            else:\n+                return '', []\n+\n+        if full_needed == 0:\n+            if self.negated:\n+                return '', []\n+            else:\n+                return '1=0', []\n+\n+        conn = ' %s ' % self.connector\n+        sql_string = conn.join(result)\n+        if sql_string:\n+            if self.negated:\n+                # Some backends (Oracle at least) need parentheses\n+                # around the inner SQL in the negated case, even if the\n+                # inner SQL contains just a single expression.\n+                sql_string = 'NOT (%s)' % sql_string\n+            elif len(result) > 1 or self.resolved:\n+                sql_string = '(%s)' % sql_string\n+        return sql_string, result_params\n         return clause\n \n     def deconstruct(self):\ndiff --git a/django/db/models/sql/where.py b/django/db/models/sql/where.py\nindex 50ff13be75..12e32efc15 100644\n--- a/django/db/models/sql/where.py\n+++ b/django/db/models/sql/where.py\n@@ -92,9 +92,21 @@ class WhereNode(tree.Node):\n             # to make this node empty/full.\n             # Now, check if this node is full/empty using the\n             # counts.\n+\n             if empty_needed == 0:\n                 if self.negated:\n-                    return '', []\n+                    return '1=1', []\n+                else:\n+                    raise EmptyResultSet\n+\n+            # Check if this node matches nothing or everything.\n+            # First check the amount of full nodes and empty nodes\n+            # to make this node empty/full.\n+            # Now, check if this node is full/empty using the\n+            # counts.\n+            if empty_needed == 0:\n+                if self.negated:\n+                    return '1=1', []\n                 else:\n                     raise EmptyResultSet\n             if full_needed == 0:\n"
  }
}