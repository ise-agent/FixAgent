{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/scikit-learn/sklearn/neighbors/base.py lines 106-118)": "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (int, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n",
    "Location 2 (/root/hy/projects_4/scikit-learn/sklearn/neighbors/base.py lines 328-340)": "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n\n        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                            \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n",
    "Location 3 (/root/hy/projects_4/scikit-learn/sklearn/neighbors/base.py lines 255-261)": "\n        if self.n_neighbors is not None:\n            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n            if self.n_neighbors <= 0:\n                raise ValueError(\n                    \"Expected n_neighbors > 0. Got %d\" %\n                    self.n_neighbors\n                )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/scikit-learn/sklearn/neighbors/base.py lines 106-118)": [
      "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (int, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n",
      "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (int, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n",
      "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (int, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n",
      "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (int, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n",
      "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (int, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n",
      "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (int, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n",
      "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (int, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n",
      "\n    @abstractmethod\n    def __init__(self, n_neighbors=None, radius=None,\n                 algorithm='auto', leaf_size=30, metric='minkowski',\n                 p=2, metric_params=None, n_jobs=1):\n\n        self.n_neighbors = n_neighbors\n        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n        self.radius = radius\n        self.algorithm = algorithm\n        self.leaf_size = leaf_size\n        self.metric = metric\n        self.metric_params = metric_params\n        self.p = p\n        self.n_jobs = n_jobs\n        self._check_algorithm_metric()\n"
    ],
    "Location 2 (/root/hy/projects_4/scikit-learn/sklearn/neighbors/base.py lines 328-340)": [
      "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n\n        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                            \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n",
      "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n\n        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                            \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n",
      "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n\n        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                            \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n",
      "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n\n        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                            \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n",
      "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n\n        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                            \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n",
      "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n\n        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                           \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n",
      "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n\n        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                            \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n",
      "\n        check_is_fitted(self, \"_fit_method\")\n\n        if n_neighbors is None:\n            n_neighbors = self.n_neighbors\n\n        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                            \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n\n        if X is not None:\n            query_is_train = False\n            X = check_array(X, accept_sparse='csr')\n        else:\n            query_is_train = True\n            X = self._fit_X\n            # Include an extra neighbor to account for the sample itself being\n            # returned, which is removed later\n            n_neighbors += 1\n"
    ],
    "Location 3 (/root/hy/projects_4/scikit-learn/sklearn/neighbors/base.py lines 255-261)": [
      "\n        if self.n_neighbors is not None:\n            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n            if self.n_neighbors <= 0:\n                raise ValueError(\n                    \"Expected n_neighbors > 0. Got %d\" %\n                    self.n_neighbors\n                )\n",
      "\n        if self.n_neighbors is not None:\n            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n            if self.n_neighbors <= 0:\n                raise ValueError(\n                    \"Expected n_neighbors > 0. Got %d\" %\n                    self.n_neighbors\n                )\n",
      "\n        if self.n_neighbors is not None:\n            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n            if self.n_neighbors <= 0:\n                raise ValueError(\"Expected n_neighbors > 0. Got %d\" % self.n_neighbors)\n",
      "\n        if self.n_neighbors is not None:\n            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n            if self.n_neighbors <= 0:\n                raise ValueError(\n                    \"Expected n_neighbors > 0. Got %d\" %\n                    self.n_neighbors\n                )\n",
      "\n        if self.n_neighbors is not None:\n            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n            if self.n_neighbors <= 0:\n                raise ValueError(\n                    \"Expected n_neighbors > 0. Got %d\" %\n                    self.n_neighbors\n                )\n",
      "\n        if self.n_neighbors is not None:\n            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n            if self.n_neighbors <= 0:\n                raise ValueError(\n                    \"Expected n_neighbors > 0. Got %d\" %\n                    self.n_neighbors\n                )\n",
      "\n        if self.n_neighbors is not None:\n            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n            if self.n_neighbors <= 0:\n                raise ValueError(\n                    \"Expected n_neighbors > 0. Got %d\" %\n                    self.n_neighbors\n                )\n",
      "\n        if self.n_neighbors is not None:\n            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n            if self.n_neighbors <= 0:\n                raise ValueError(\"Expected n_neighbors > 0. Got %d\" % self.n_neighbors)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..8515ff92d 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -103,11 +103,34 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n     @abstractmethod\n+\n+import warnings\n+from abc import ABCMeta, abstractmethod\n+import numbers\n+import numpy as np\n+from scipy.sparse import csr_matrix, issparse\n+from .ball_tree import BallTree\n+from .kd_tree import KDTree\n+from ..base import BaseEstimator\n+from ..metrics import pairwise_distances\n+from ..metrics.pairwise import PAIRWISE_DISTANCE_FUNCTIONS\n+from ..utils import check_X_y, check_array, _get_n_jobs, gen_even_slices\n+from ..utils.multiclass import check_classification_targets\n+from ..utils.validation import check_is_fitted\n+from ..externals import six\n+from ..externals.joblib import Parallel, delayed\n+from ..exceptions import NotFittedError\n+from ..exceptions import DataConversionWarning\n+\n+    @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -252,13 +275,16 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n             raise ValueError(\"algorithm = '%s' not recognized\"\n                              % self.algorithm)\n \n+\n         if self.n_neighbors is not None:\n+            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n+                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n             if self.n_neighbors <= 0:\n                 raise ValueError(\n                     \"Expected n_neighbors > 0. Got %d\" %\n                     self.n_neighbors\n                 )\n-\n         return self\n \n     @property\n@@ -325,9 +351,14 @@ class KNeighborsMixin(object):\n         \"\"\"\n         check_is_fitted(self, \"_fit_method\")\n \n+\n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n@@ -337,7 +368,6 @@ class KNeighborsMixin(object):\n             # Include an extra neighbor to account for the sample itself being\n             # returned, which is removed later\n             n_neighbors += 1\n-\n         train_size = self._fit_X.shape[0]\n         if n_neighbors > train_size:\n             raise ValueError(\n",
    "variant_0": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..9de9e29c5 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,17 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (int, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -252,13 +257,16 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n             raise ValueError(\"algorithm = '%s' not recognized\"\n                              % self.algorithm)\n \n+\n         if self.n_neighbors is not None:\n+            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n+                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n             if self.n_neighbors <= 0:\n                 raise ValueError(\n                     \"Expected n_neighbors > 0. Got %d\" %\n                     self.n_neighbors\n                 )\n-\n         return self\n \n     @property\n@@ -325,9 +333,16 @@ class KNeighborsMixin(object):\n         \"\"\"\n         check_is_fitted(self, \"_fit_method\")\n \n+\n+        check_is_fitted(self, \"_fit_method\")\n+\n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n@@ -337,7 +352,6 @@ class KNeighborsMixin(object):\n             # Include an extra neighbor to account for the sample itself being\n             # returned, which is removed later\n             n_neighbors += 1\n-\n         train_size = self._fit_X.shape[0]\n         if n_neighbors > train_size:\n             raise ValueError(\n",
    "variant_1": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..9de9e29c5 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,17 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (int, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -252,13 +257,16 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n             raise ValueError(\"algorithm = '%s' not recognized\"\n                              % self.algorithm)\n \n+\n         if self.n_neighbors is not None:\n+            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n+                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n             if self.n_neighbors <= 0:\n                 raise ValueError(\n                     \"Expected n_neighbors > 0. Got %d\" %\n                     self.n_neighbors\n                 )\n-\n         return self\n \n     @property\n@@ -325,9 +333,16 @@ class KNeighborsMixin(object):\n         \"\"\"\n         check_is_fitted(self, \"_fit_method\")\n \n+\n+        check_is_fitted(self, \"_fit_method\")\n+\n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n@@ -337,7 +352,6 @@ class KNeighborsMixin(object):\n             # Include an extra neighbor to account for the sample itself being\n             # returned, which is removed later\n             n_neighbors += 1\n-\n         train_size = self._fit_X.shape[0]\n         if n_neighbors > train_size:\n             raise ValueError(\n",
    "variant_2": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..9de9e29c5 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,17 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (int, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -252,13 +257,16 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n             raise ValueError(\"algorithm = '%s' not recognized\"\n                              % self.algorithm)\n \n+\n         if self.n_neighbors is not None:\n+            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n+                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n             if self.n_neighbors <= 0:\n                 raise ValueError(\n                     \"Expected n_neighbors > 0. Got %d\" %\n                     self.n_neighbors\n                 )\n-\n         return self\n \n     @property\n@@ -325,9 +333,16 @@ class KNeighborsMixin(object):\n         \"\"\"\n         check_is_fitted(self, \"_fit_method\")\n \n+\n+        check_is_fitted(self, \"_fit_method\")\n+\n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n@@ -337,7 +352,6 @@ class KNeighborsMixin(object):\n             # Include an extra neighbor to account for the sample itself being\n             # returned, which is removed later\n             n_neighbors += 1\n-\n         train_size = self._fit_X.shape[0]\n         if n_neighbors > train_size:\n             raise ValueError(\n",
    "variant_3": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..140614ea4 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,17 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (int, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -252,13 +257,13 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n             raise ValueError(\"algorithm = '%s' not recognized\"\n                              % self.algorithm)\n \n+\n         if self.n_neighbors is not None:\n+            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n+                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n             if self.n_neighbors <= 0:\n-                raise ValueError(\n-                    \"Expected n_neighbors > 0. Got %d\" %\n-                    self.n_neighbors\n-                )\n-\n+                raise ValueError(\"Expected n_neighbors > 0. Got %d\" % self.n_neighbors)\n         return self\n \n     @property\n@@ -325,9 +330,16 @@ class KNeighborsMixin(object):\n         \"\"\"\n         check_is_fitted(self, \"_fit_method\")\n \n+\n+        check_is_fitted(self, \"_fit_method\")\n+\n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n@@ -337,7 +349,6 @@ class KNeighborsMixin(object):\n             # Include an extra neighbor to account for the sample itself being\n             # returned, which is removed later\n             n_neighbors += 1\n-\n         train_size = self._fit_X.shape[0]\n         if n_neighbors > train_size:\n             raise ValueError(\n",
    "variant_4": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..9de9e29c5 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,17 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (int, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -252,13 +257,16 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n             raise ValueError(\"algorithm = '%s' not recognized\"\n                              % self.algorithm)\n \n+\n         if self.n_neighbors is not None:\n+            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n+                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n             if self.n_neighbors <= 0:\n                 raise ValueError(\n                     \"Expected n_neighbors > 0. Got %d\" %\n                     self.n_neighbors\n                 )\n-\n         return self\n \n     @property\n@@ -325,9 +333,16 @@ class KNeighborsMixin(object):\n         \"\"\"\n         check_is_fitted(self, \"_fit_method\")\n \n+\n+        check_is_fitted(self, \"_fit_method\")\n+\n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n@@ -337,7 +352,6 @@ class KNeighborsMixin(object):\n             # Include an extra neighbor to account for the sample itself being\n             # returned, which is removed later\n             n_neighbors += 1\n-\n         train_size = self._fit_X.shape[0]\n         if n_neighbors > train_size:\n             raise ValueError(\n",
    "variant_5": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..9de9e29c5 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,17 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (int, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -252,13 +257,16 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n             raise ValueError(\"algorithm = '%s' not recognized\"\n                              % self.algorithm)\n \n+\n         if self.n_neighbors is not None:\n+            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n+                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n             if self.n_neighbors <= 0:\n                 raise ValueError(\n                     \"Expected n_neighbors > 0. Got %d\" %\n                     self.n_neighbors\n                 )\n-\n         return self\n \n     @property\n@@ -325,9 +333,16 @@ class KNeighborsMixin(object):\n         \"\"\"\n         check_is_fitted(self, \"_fit_method\")\n \n+\n+        check_is_fitted(self, \"_fit_method\")\n+\n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n@@ -337,7 +352,6 @@ class KNeighborsMixin(object):\n             # Include an extra neighbor to account for the sample itself being\n             # returned, which is removed later\n             n_neighbors += 1\n-\n         train_size = self._fit_X.shape[0]\n         if n_neighbors > train_size:\n             raise ValueError(\n",
    "variant_6": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..09d2b63be 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,17 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (int, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -252,13 +257,16 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n             raise ValueError(\"algorithm = '%s' not recognized\"\n                              % self.algorithm)\n \n+\n         if self.n_neighbors is not None:\n+            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n+                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n             if self.n_neighbors <= 0:\n                 raise ValueError(\n                     \"Expected n_neighbors > 0. Got %d\" %\n                     self.n_neighbors\n                 )\n-\n         return self\n \n     @property\n@@ -325,9 +333,16 @@ class KNeighborsMixin(object):\n         \"\"\"\n         check_is_fitted(self, \"_fit_method\")\n \n+\n+        check_is_fitted(self, \"_fit_method\")\n+\n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                           \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n@@ -337,7 +352,6 @@ class KNeighborsMixin(object):\n             # Include an extra neighbor to account for the sample itself being\n             # returned, which is removed later\n             n_neighbors += 1\n-\n         train_size = self._fit_X.shape[0]\n         if n_neighbors > train_size:\n             raise ValueError(\n",
    "variant_7": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..9de9e29c5 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,17 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (int, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -252,13 +257,16 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n             raise ValueError(\"algorithm = '%s' not recognized\"\n                              % self.algorithm)\n \n+\n         if self.n_neighbors is not None:\n+            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n+                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n             if self.n_neighbors <= 0:\n                 raise ValueError(\n                     \"Expected n_neighbors > 0. Got %d\" %\n                     self.n_neighbors\n                 )\n-\n         return self\n \n     @property\n@@ -325,9 +333,16 @@ class KNeighborsMixin(object):\n         \"\"\"\n         check_is_fitted(self, \"_fit_method\")\n \n+\n+        check_is_fitted(self, \"_fit_method\")\n+\n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n@@ -337,7 +352,6 @@ class KNeighborsMixin(object):\n             # Include an extra neighbor to account for the sample itself being\n             # returned, which is removed later\n             n_neighbors += 1\n-\n         train_size = self._fit_X.shape[0]\n         if n_neighbors > train_size:\n             raise ValueError(\n",
    "variant_8": "diff --git a/sklearn/neighbors/base.py b/sklearn/neighbors/base.py\nindex 3e5e729c2..ff6209170 100644\n--- a/sklearn/neighbors/base.py\n+++ b/sklearn/neighbors/base.py\n@@ -102,12 +102,17 @@ def _get_weights(dist, weights):\n class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n     \"\"\"Base class for nearest neighbors estimators.\"\"\"\n \n+    @abstractmethod\n+\n     @abstractmethod\n     def __init__(self, n_neighbors=None, radius=None,\n                  algorithm='auto', leaf_size=30, metric='minkowski',\n                  p=2, metric_params=None, n_jobs=1):\n \n         self.n_neighbors = n_neighbors\n+        if self.n_neighbors is not None and not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n         self.radius = radius\n         self.algorithm = algorithm\n         self.leaf_size = leaf_size\n@@ -252,13 +257,13 @@ class NeighborsBase(six.with_metaclass(ABCMeta, BaseEstimator)):\n             raise ValueError(\"algorithm = '%s' not recognized\"\n                              % self.algorithm)\n \n+\n         if self.n_neighbors is not None:\n+            if not isinstance(self.n_neighbors, (numbers.Integral, np.integer)):\n+                raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                                \"was of type=%r\" % (self.n_neighbors, type(self.n_neighbors)))\n             if self.n_neighbors <= 0:\n-                raise ValueError(\n-                    \"Expected n_neighbors > 0. Got %d\" %\n-                    self.n_neighbors\n-                )\n-\n+                raise ValueError(\"Expected n_neighbors > 0. Got %d\" % self.n_neighbors)\n         return self\n \n     @property\n@@ -325,9 +330,16 @@ class KNeighborsMixin(object):\n         \"\"\"\n         check_is_fitted(self, \"_fit_method\")\n \n+\n+        check_is_fitted(self, \"_fit_method\")\n+\n         if n_neighbors is None:\n             n_neighbors = self.n_neighbors\n \n+        if n_neighbors is not None and not isinstance(n_neighbors, (numbers.Integral, np.integer)):\n+            raise ValueError(\"n_neighbors=%r must be of type int when greater than or equal to 1, \"\n+                            \"was of type=%r\" % (n_neighbors, type(n_neighbors)))\n+\n         if X is not None:\n             query_is_train = False\n             X = check_array(X, accept_sparse='csr')\n@@ -337,7 +349,6 @@ class KNeighborsMixin(object):\n             # Include an extra neighbor to account for the sample itself being\n             # returned, which is removed later\n             n_neighbors += 1\n-\n         train_size = self._fit_X.shape[0]\n         if n_neighbors > train_size:\n             raise ValueError(\n"
  }
}