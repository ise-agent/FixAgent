{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/utils/decorators.py lines 40-42)": "\n        # Create a proper wrapper function instead of using partial\n        # This ensures decorators receive a function-like object with proper attributes\n        def bound_method(*args, **kwargs):\n            return method.__get__(self, type(self))(*args, **kwargs)\n        \n        # Copy essential function attributes that decorators expect\n        bound_method.__name__ = getattr(method, '__name__', 'wrapped_method')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n",
    "Location 2 (/root/hy/projects_4/django/django/utils/decorators.py lines 13-20)": "\ndef _update_method_wrapper(_wrapper, decorator):\n    # _multi_decorate()'s wrapper_func isn't available in this scope. Cheat by\n    # using it on a dummy function.\n    @decorator\n    def dummy(*args, **kwargs):\n        pass\n    # Copy any additional attributes that the decorator may have added\n    for attr in ('__wrapped__', '__qualname__', '__annotations__'):\n        if hasattr(dummy, attr) and not hasattr(_wrapper, attr):\n            try:\n                setattr(_wrapper, attr, getattr(dummy, attr))\n            except (TypeError, AttributeError):\n                pass\n    update_wrapper(_wrapper, dummy)\n",
    "Location 3 (/root/hy/projects_4/django/django/utils/decorators.py lines 46-47)": "\n    # Create a proper wrapper function with necessary attributes before decoration\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Create a proper function wrapper instead of partial.\n        def bound_method(*args, **kwargs):\n            return method(self, *args, **kwargs)\n        \n        # Copy essential function attributes that decorators expect\n        bound_method.__name__ = getattr(method, '__name__', 'method')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/utils/decorators.py lines 40-42)": [
      "\n    def _wrapper(self, *args, **kwargs):\n        # Create a proper wrapper function instead of using partial\n        # This ensures decorators receive a function-like object with proper attributes\n        def bound_method(*args, **kwargs):\n            return method(self, *args, **kwargs)\n        \n        # Copy essential function attributes that decorators expect\n        bound_method.__name__ = getattr(method, '__name__', '<unknown>')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n",
      "\n        # Create a proper wrapper function instead of using partial\n        def bound_method(*args, **kwargs):\n            return method.__get__(self, type(self))(*args, **kwargs)\n        \n        # Copy essential function attributes that decorators expect\n        bound_method.__name__ = getattr(method, '__name__', 'method')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n",
      "\n    def _wrapper(self, *args, **kwargs):\n        # Create a proper wrapper function instead of using partial\n        # This ensures decorators can access __name__ and other attributes\n        def bound_method(*args, **kwargs):\n            return method(self, *args, **kwargs)\n        \n        # Copy essential function attributes that decorators expect\n        bound_method.__name__ = getattr(method, '__name__', 'method')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__qualname__ = getattr(method, '__qualname__', 'method')\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n",
      "\ndef _wrapper(self, *args, **kwargs):\n    # Create a proper function wrapper instead of using partial\n    # This ensures decorators can access __name__ and other attributes\n    def bound_method(*args, **kwargs):\n        return method.__get__(self, type(self))(*args, **kwargs)\n    \n    # Copy essential attributes from the original method\n    bound_method.__name__ = getattr(method, '__name__', 'unknown')\n    bound_method.__module__ = getattr(method, '__module__', None)\n    bound_method.__doc__ = getattr(method, '__doc__', None)\n    bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n    \n    for dec in decorators:\n        bound_method = dec(bound_method)\n    return bound_method(*args, **kwargs)\n",
      "\n    def _wrapper(self, *args, **kwargs):\n        # Create a proper wrapper function instead of using partial\n        # This ensures decorators can access __name__ and other attributes\n        def bound_method(*args, **kwargs):\n            return method.__get__(self, type(self))(*args, **kwargs)\n        \n        # Copy essential function attributes that decorators expect\n        bound_method.__name__ = getattr(method, '__name__', 'unknown')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n",
      "\n        # Create a proper wrapper function instead of using partial\n        def bound_method(*args, **kwargs):\n            return method.__get__(self, type(self))(*args, **kwargs)\n        \n        # Copy essential attributes from the original method\n        bound_method.__name__ = getattr(method, '__name__', '<unknown>')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n",
      "\ndef _wrapper(self, *args, **kwargs):\n    # Create a proper wrapper function instead of using partial\n    # This ensures decorators can access __name__ and other attributes\n    def bound_method(*args, **kwargs):\n        return method(self, *args, **kwargs)\n    \n    # Copy essential attributes from the original method\n    bound_method.__name__ = getattr(method, '__name__', 'unknown')\n    bound_method.__module__ = getattr(method, '__module__', None)\n    bound_method.__doc__ = getattr(method, '__doc__', None)\n    bound_method.__dict__.update(getattr(method, '__dict__', {}))\n    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n    \n    for dec in decorators:\n        bound_method = dec(bound_method)\n    return bound_method(*args, **kwargs)\n",
      "\ndef _wrapper(self, *args, **kwargs):\n    # Create a proper wrapper function instead of using partial\n    # This ensures decorators can access __name__ and other attributes\n    def bound_method(*args, **kwargs):\n        return method(self, *args, **kwargs)\n    \n    # Copy essential attributes that decorators expect\n    bound_method.__name__ = getattr(method, '__name__', 'unknown')\n    bound_method.__module__ = getattr(method, '__module__', None)\n    bound_method.__doc__ = getattr(method, '__doc__', None)\n    bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n    \n    for dec in decorators:\n        bound_method = dec(bound_method)\n    return bound_method(*args, **kwargs)\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/utils/decorators.py lines 13-20)": [
      "\ndef _update_method_wrapper(_wrapper, decorator):\n    # _multi_decorate()'s wrapper function isn't available in this scope. Cheat by\n    # using it on a dummy function.\n    @decorator\n    def dummy(*args, **kwargs):\n        pass\n    update_wrapper(_wrapper, dummy)\n",
      "\ndef _update_method_wrapper(_wrapper, decorator):\n    # Since we now provide proper function objects to decorators,\n    # this function focuses on preserving any additional attributes\n    # that decorators might have added to the wrapper.\n    @decorator\n    def dummy(*args, **kwargs):\n        pass\n    # Copy any decorator-specific attributes that weren't in the original\n    for attr in dir(dummy):\n        if not attr.startswith('_') and not hasattr(_wrapper, attr):\n            try:\n                setattr(_wrapper, attr, getattr(dummy, attr))\n            except (AttributeError, TypeError):\n                pass\n    update_wrapper(_wrapper, dummy)\n",
      "\ndef _update_method_wrapper(_wrapper, decorator):\n    # _multi_decorate()'s wrapper function isn't available in this scope. Cheat by\n    # using it on a dummy function.\n    @decorator\n    def dummy(*args, **kwargs):\n        pass\n    update_wrapper(_wrapper, dummy)\n",
      "\ndef _update_method_wrapper(_wrapper, decorator):\n    # Since we now provide proper function objects to decorators,\n    # this function focuses on preserving any additional attributes\n    # that decorators might have added to the wrapper.\n    @decorator\n    def dummy(*args, **kwargs):\n        pass\n    # Copy any decorator-specific attributes that aren't already present\n    for attr in ('__name__', '__module__', '__doc__', '__qualname__', '__annotations__'):\n        if hasattr(dummy, attr) and not hasattr(_wrapper, attr):\n            try:\n                setattr(_wrapper, attr, getattr(dummy, attr))\n            except (TypeError, AttributeError):\n                pass\n    # Copy any other attributes the decorator might have added\n    for attr in dir(dummy):\n        if not attr.startswith('_') and hasattr(dummy, attr) and not hasattr(_wrapper, attr):\n            try:\n                setattr(_wrapper, attr, getattr(dummy, attr))\n            except (TypeError, AttributeError):\n                pass\n",
      "\ndef _update_method_wrapper(_wrapper, decorator):\n    # _multi_decorate()'s wrapper function isn't available in this scope. Cheat by\n    # using it on a dummy function.\n    @decorator\n    def dummy(*args, **kwargs):\n        pass\n    update_wrapper(_wrapper, dummy)\n",
      "\ndef _update_method_wrapper(_wrapper, decorator):\n    # Since we now provide proper function objects to decorators,\n    # this function focuses on preserving any additional attributes\n    # that decorators might have added to the wrapper.\n    @decorator\n    def dummy(*args, **kwargs):\n        pass\n    # Copy over any attributes the decorator might have added\n    for attr in dir(dummy):\n        if not attr.startswith('_') and hasattr(dummy, attr):\n            try:\n                setattr(_wrapper, attr, getattr(dummy, attr))\n            except (AttributeError, TypeError):\n                pass\n    update_wrapper(_wrapper, dummy)\n",
      "\ndef _update_method_wrapper(_wrapper, decorator):\n    # Create a proper function object with necessary attributes for the decorator\n    def dummy(*args, **kwargs):\n        pass\n    \n    # Apply the decorator to get its metadata\n    decorated_dummy = decorator(dummy)\n    \n    # Copy attributes from the decorated dummy to our wrapper\n    update_wrapper(_wrapper, decorated_dummy)\n",
      "\ndef _update_method_wrapper(_wrapper, decorator):\n    # _multi_decorate()'s wrapper function isn't available in this scope. Cheat by\n    # using it on a dummy function.\n    @decorator\n    def dummy(*args, **kwargs):\n        pass\n    update_wrapper(_wrapper, dummy)\n"
    ],
    "Location 3 (/root/hy/projects_4/django/django/utils/decorators.py lines 46-47)": [
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply decorators in reverse order so they're applied in the order\n        # they appear in the list.\n        decorators = tuple(reversed(decorators))\n    else:\n        decorators = (decorators,)\n\n    def _wrapper(self, *args, **kwargs):\n        # Create a proper function wrapper instead of using partial\n        bound_method = method.__get__(self, type(self))\n        \n        def wrapper_func(*args, **kwargs):\n            return bound_method(*args, **kwargs)\n        \n        # Copy essential function attributes before decoration\n        wrapper_func.__name__ = getattr(method, '__name__', 'wrapped_method')\n        wrapper_func.__module__ = getattr(method, '__module__', None)\n        wrapper_func.__doc__ = getattr(method, '__doc__', None)\n        wrapper_func.__dict__.update(getattr(method, '__dict__', {}))\n        wrapper_func.__annotations__ = getattr(method, '__annotations__', {})\n        wrapper_func.__qualname__ = getattr(method, '__qualname__', wrapper_func.__name__)\n        \n        # Apply decorators to the properly attributed function\n        for dec in decorators:\n            wrapper_func = dec(wrapper_func)\n        return wrapper_func(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\n    # Create a proper wrapper function with necessary attributes instead of using partial\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Also, wrap method.__get__() in a function because new\n        # attributes can't be set on bound method objects, only on functions.\n        \n        # Create a closure function that has proper function attributes\n        def bound_method(*args, **kwargs):\n            return method.__get__(self, type(self))(*args, **kwargs)\n        \n        # Copy essential attributes that decorators expect\n        bound_method.__name__ = getattr(method, '__name__', 'method')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__dict__ = getattr(method, '__dict__', {}).copy()\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply decorators in reverse order so they end up in the expected order.\n        decorators = tuple(reversed(tuple(decorators)))\n    else:\n        decorators = (decorators,)\n\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Create a proper function wrapper instead of using partial.\n        def bound_method(*args, **kwargs):\n            return method(self, *args, **kwargs)\n        \n        # Copy essential attributes from method to bound_method\n        bound_method.__name__ = getattr(method, '__name__', 'method')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply decorators in reverse order so they end up in the expected order.\n        decorators = tuple(reversed(decorators))\n    else:\n        decorators = (decorators,)\n\n    def _wrapper(self, *args, **kwargs):\n        # bound_method has the signature that 'decorator' expects i.e. no\n        # 'self' argument, but it's a closure over self so it can call\n        # 'func'. Also, wrap method.__get__() in a function because new\n        # attributes can't be set on bound method objects, only on functions.\n        \n        # Create a proper function wrapper instead of using partial\n        def bound_method(*args, **kwargs):\n            return method.__get__(self, type(self))(*args, **kwargs)\n        \n        # Copy essential attributes that decorators expect\n        bound_method.__name__ = getattr(method, '__name__', 'unknown')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        \n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n",
      "\n    # Create a proper wrapper function instead of using partial\n    def _wrapper(self, *args, **kwargs):\n        bound_method = method.__get__(self, type(self))\n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n    \n    # Copy method attributes to the wrapper before decoration\n    update_wrapper(_wrapper, method)\n    \n    # Copy any attributes that decorators add to the function they decorate\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n",
      "\n    # Create a proper wrapper function instead of using partial\n    def _wrapper(*args, **kwargs):\n        return method(self, *args, **kwargs)\n    \n    # Copy essential function attributes before applying decorators\n    _wrapper.__name__ = method.__name__\n    _wrapper.__module__ = getattr(method, '__module__', None)\n    _wrapper.__doc__ = method.__doc__\n    _wrapper.__dict__.update(getattr(method, '__dict__', {}))\n    _wrapper.__annotations__ = getattr(method, '__annotations__', {})\n    \n    # Apply decorators to the properly attributed wrapper\n    for dec in decorators:\n        _wrapper = dec(_wrapper)\n        \n    # Copy any attributes that decorators added to the function\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n",
      "\n    # Create a proper wrapper function instead of using partial\n    def _wrapper(self, *args, **kwargs):\n        bound_method = method.__get__(self, type(self))\n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n    \n    # Copy method attributes to the wrapper before decoration\n    update_wrapper(_wrapper, method)\n    \n    # Copy any attributes that decorators might add to the function\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n",
      "\ndef _multi_decorate(decorators, method):\n    \"\"\"\n    Decorate `method` with one or more function decorators. `decorators` can be\n    a single decorator or an iterable of decorators.\n    \"\"\"\n    if hasattr(decorators, '__iter__'):\n        # Apply decorators in reverse order so @a @b @c becomes\n        # _multi_decorate((a, b, c), f) and not the other way around.\n        decorators = tuple(reversed(tuple(decorators)))\n    else:\n        decorators = (decorators,)\n\n    def _wrapper(self, *args, **kwargs):\n        # Create a proper function wrapper instead of using partial\n        def bound_method(*args, **kwargs):\n            return method(self, *args, **kwargs)\n        \n        # Copy essential attributes from the original method to make it decorator-friendly\n        bound_method.__name__ = getattr(method, '__name__', '<lambda>')\n        bound_method.__module__ = getattr(method, '__module__', None)\n        bound_method.__doc__ = getattr(method, '__doc__', None)\n        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n        bound_method.__qualname__ = getattr(method, '__qualname__', None)\n        \n        # Apply decorators to the properly attributed function\n        for dec in decorators:\n            bound_method = dec(bound_method)\n        return bound_method(*args, **kwargs)\n\n    # Copy any attributes that a decorator adds to the function it decorates.\n    for dec in decorators:\n        _update_method_wrapper(_wrapper, dec)\n    # Preserve any existing attributes of 'method', including the name.\n    update_wrapper(_wrapper, method)\n    return _wrapper\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..db0553f35c 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,14 +10,21 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n-    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n-    # using it on a dummy function.\n+    # Since we now provide proper function objects to decorators,\n+    # we can simplify this to just copy any additional attributes\n+    # that the decorator might have added to the function.\n     @decorator\n     def dummy(*args, **kwargs):\n         pass\n-    update_wrapper(_wrapper, dummy)\n-\n+    # Copy any new attributes the decorator added\n+    for attr in dir(dummy):\n+        if not attr.startswith('_') and not hasattr(_wrapper, attr):\n+            try:\n+                setattr(_wrapper, attr, getattr(dummy, attr))\n+            except (AttributeError, TypeError):\n+                pass\n \n def _multi_decorate(decorators, method):\n     \"\"\"\n@@ -37,11 +44,22 @@ def _multi_decorate(decorators, method):\n         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+\n+        # Create a proper function wrapper instead of using partial\n+        # This ensures decorators receive an object with function attributes\n+        bound_method_func = method.__get__(self, type(self))\n+        def bound_method(*args, **kwargs):\n+            return bound_method_func(*args, **kwargs)\n+        \n+        # Copy essential function attributes from the original method\n+        update_wrapper(bound_method, method)\n+        \n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n \n+    # Copy any attributes that a decorator adds to the function it decorates.\n+\n     # Copy any attributes that a decorator adds to the function it decorates.\n     for dec in decorators:\n         _update_method_wrapper(_wrapper, dec)\n",
    "variant_0": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..9a5bca13e0 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,15 +10,22 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n-    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n+    # _multi_decorate()'s wrapper_func isn't available in this scope. Cheat by\n     # using it on a dummy function.\n     @decorator\n     def dummy(*args, **kwargs):\n         pass\n+    # Copy any additional attributes that the decorator may have added\n+    for attr in ('__wrapped__', '__qualname__', '__annotations__'):\n+        if hasattr(dummy, attr) and not hasattr(_wrapper, attr):\n+            try:\n+                setattr(_wrapper, attr, getattr(dummy, attr))\n+            except (TypeError, AttributeError):\n+                pass\n     update_wrapper(_wrapper, dummy)\n \n-\n def _multi_decorate(decorators, method):\n     \"\"\"\n     Decorate `method` with one or more function decorators. `decorators` can be\n@@ -37,7 +44,40 @@ def _multi_decorate(decorators, method):\n         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+\n+        # Create a proper wrapper function instead of using partial\n+        # This ensures decorators receive a function-like object with proper attributes\n+        def bound_method(*args, **kwargs):\n+            return method.__get__(self, type(self))(*args, **kwargs)\n+        \n+        # Copy essential function attributes that decorators expect\n+        bound_method.__name__ = getattr(method, '__name__', 'wrapped_method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        \n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+\n+    # Create a proper wrapper function with necessary attributes before decoration\n+    def _wrapper(self, *args, **kwargs):\n+        # bound_method has the signature that 'decorator' expects i.e. no\n+        # 'self' argument, but it's a closure over self so it can call\n+        # 'func'. Create a proper function wrapper instead of partial.\n+        def bound_method(*args, **kwargs):\n+            return method(self, *args, **kwargs)\n+        \n+        # Copy essential function attributes that decorators expect\n+        bound_method.__name__ = getattr(method, '__name__', 'method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n+        \n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n",
    "variant_1": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..03f5eb5a30 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,15 +10,15 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n-    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n+    # _multi_decorate()'s wrapper function isn't available in this scope. Cheat by\n     # using it on a dummy function.\n     @decorator\n     def dummy(*args, **kwargs):\n         pass\n     update_wrapper(_wrapper, dummy)\n \n-\n def _multi_decorate(decorators, method):\n     \"\"\"\n     Decorate `method` with one or more function decorators. `decorators` can be\n@@ -37,10 +37,58 @@ def _multi_decorate(decorators, method):\n         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # Create a proper wrapper function instead of using partial\n+        # This ensures decorators receive a function-like object with proper attributes\n+        def bound_method(*args, **kwargs):\n+            return method(self, *args, **kwargs)\n+        \n+        # Copy essential function attributes that decorators expect\n+        bound_method.__name__ = getattr(method, '__name__', '<unknown>')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n+        \n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+\n+def _multi_decorate(decorators, method):\n+    \"\"\"\n+    Decorate `method` with one or more function decorators. `decorators` can be\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply decorators in reverse order so they're applied in the order\n+        # they appear in the list.\n+        decorators = tuple(reversed(decorators))\n+    else:\n+        decorators = (decorators,)\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # Create a proper function wrapper instead of using partial\n+        bound_method = method.__get__(self, type(self))\n+        \n+        def wrapper_func(*args, **kwargs):\n+            return bound_method(*args, **kwargs)\n+        \n+        # Copy essential function attributes before decoration\n+        wrapper_func.__name__ = getattr(method, '__name__', 'wrapped_method')\n+        wrapper_func.__module__ = getattr(method, '__module__', None)\n+        wrapper_func.__doc__ = getattr(method, '__doc__', None)\n+        wrapper_func.__dict__.update(getattr(method, '__dict__', {}))\n+        wrapper_func.__annotations__ = getattr(method, '__annotations__', {})\n+        wrapper_func.__qualname__ = getattr(method, '__qualname__', wrapper_func.__name__)\n+        \n+        # Apply decorators to the properly attributed function\n+        for dec in decorators:\n+            wrapper_func = dec(wrapper_func)\n+        return wrapper_func(*args, **kwargs)\n \n     # Copy any attributes that a decorator adds to the function it decorates.\n     for dec in decorators:\n@@ -48,6 +96,9 @@ def _multi_decorate(decorators, method):\n     # Preserve any existing attributes of 'method', including the name.\n     update_wrapper(_wrapper, method)\n     return _wrapper\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n \n \n def method_decorator(decorator, name=''):\n",
    "variant_2": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..6c9a431476 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,15 +10,23 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n-    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n-    # using it on a dummy function.\n+    # Since we now provide proper function objects to decorators,\n+    # this function focuses on preserving any additional attributes\n+    # that decorators might have added to the wrapper.\n     @decorator\n     def dummy(*args, **kwargs):\n         pass\n+    # Copy any decorator-specific attributes that weren't in the original\n+    for attr in dir(dummy):\n+        if not attr.startswith('_') and not hasattr(_wrapper, attr):\n+            try:\n+                setattr(_wrapper, attr, getattr(dummy, attr))\n+            except (AttributeError, TypeError):\n+                pass\n     update_wrapper(_wrapper, dummy)\n \n-\n def _multi_decorate(decorators, method):\n     \"\"\"\n     Decorate `method` with one or more function decorators. `decorators` can be\n@@ -37,7 +45,42 @@ def _multi_decorate(decorators, method):\n         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+\n+        # Create a proper wrapper function instead of using partial\n+        def bound_method(*args, **kwargs):\n+            return method.__get__(self, type(self))(*args, **kwargs)\n+        \n+        # Copy essential function attributes that decorators expect\n+        bound_method.__name__ = getattr(method, '__name__', 'method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        \n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+\n+    # Create a proper wrapper function with necessary attributes instead of using partial\n+    def _wrapper(self, *args, **kwargs):\n+        # bound_method has the signature that 'decorator' expects i.e. no\n+        # 'self' argument, but it's a closure over self so it can call\n+        # 'func'. Also, wrap method.__get__() in a function because new\n+        # attributes can't be set on bound method objects, only on functions.\n+        \n+        # Create a closure function that has proper function attributes\n+        def bound_method(*args, **kwargs):\n+            return method.__get__(self, type(self))(*args, **kwargs)\n+        \n+        # Copy essential attributes that decorators expect\n+        bound_method.__name__ = getattr(method, '__name__', 'method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__dict__ = getattr(method, '__dict__', {}).copy()\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        \n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n",
    "variant_3": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..2ea6dd7839 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,15 +10,15 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n-    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n+    # _multi_decorate()'s wrapper function isn't available in this scope. Cheat by\n     # using it on a dummy function.\n     @decorator\n     def dummy(*args, **kwargs):\n         pass\n     update_wrapper(_wrapper, dummy)\n \n-\n def _multi_decorate(decorators, method):\n     \"\"\"\n     Decorate `method` with one or more function decorators. `decorators` can be\n@@ -37,7 +37,52 @@ def _multi_decorate(decorators, method):\n         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # Create a proper wrapper function instead of using partial\n+        # This ensures decorators can access __name__ and other attributes\n+        def bound_method(*args, **kwargs):\n+            return method(self, *args, **kwargs)\n+        \n+        # Copy essential function attributes that decorators expect\n+        bound_method.__name__ = getattr(method, '__name__', 'method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__qualname__ = getattr(method, '__qualname__', 'method')\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        \n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+\n+def _multi_decorate(decorators, method):\n+    \"\"\"\n+    Decorate `method` with one or more function decorators. `decorators` can be\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply decorators in reverse order so they end up in the expected order.\n+        decorators = tuple(reversed(tuple(decorators)))\n+    else:\n+        decorators = (decorators,)\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # bound_method has the signature that 'decorator' expects i.e. no\n+        # 'self' argument, but it's a closure over self so it can call\n+        # 'func'. Create a proper function wrapper instead of using partial.\n+        def bound_method(*args, **kwargs):\n+            return method(self, *args, **kwargs)\n+        \n+        # Copy essential attributes from method to bound_method\n+        bound_method.__name__ = getattr(method, '__name__', 'method')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        \n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n@@ -48,6 +93,9 @@ def _multi_decorate(decorators, method):\n     # Preserve any existing attributes of 'method', including the name.\n     update_wrapper(_wrapper, method)\n     return _wrapper\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n \n \n def method_decorator(decorator, name=''):\n",
    "variant_4": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..e218e87231 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,14 +10,28 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n-    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n-    # using it on a dummy function.\n+    # Since we now provide proper function objects to decorators,\n+    # this function focuses on preserving any additional attributes\n+    # that decorators might have added to the wrapper.\n     @decorator\n     def dummy(*args, **kwargs):\n         pass\n-    update_wrapper(_wrapper, dummy)\n-\n+    # Copy any decorator-specific attributes that aren't already present\n+    for attr in ('__name__', '__module__', '__doc__', '__qualname__', '__annotations__'):\n+        if hasattr(dummy, attr) and not hasattr(_wrapper, attr):\n+            try:\n+                setattr(_wrapper, attr, getattr(dummy, attr))\n+            except (TypeError, AttributeError):\n+                pass\n+    # Copy any other attributes the decorator might have added\n+    for attr in dir(dummy):\n+        if not attr.startswith('_') and hasattr(dummy, attr) and not hasattr(_wrapper, attr):\n+            try:\n+                setattr(_wrapper, attr, getattr(dummy, attr))\n+            except (TypeError, AttributeError):\n+                pass\n \n def _multi_decorate(decorators, method):\n     \"\"\"\n@@ -37,7 +51,55 @@ def _multi_decorate(decorators, method):\n         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+\n+def _wrapper(self, *args, **kwargs):\n+    # Create a proper function wrapper instead of using partial\n+    # This ensures decorators can access __name__ and other attributes\n+    def bound_method(*args, **kwargs):\n+        return method.__get__(self, type(self))(*args, **kwargs)\n+    \n+    # Copy essential attributes from the original method\n+    bound_method.__name__ = getattr(method, '__name__', 'unknown')\n+    bound_method.__module__ = getattr(method, '__module__', None)\n+    bound_method.__doc__ = getattr(method, '__doc__', None)\n+    bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n+    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+    \n+    for dec in decorators:\n+        bound_method = dec(bound_method)\n+    return bound_method(*args, **kwargs)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+\n+def _multi_decorate(decorators, method):\n+    \"\"\"\n+    Decorate `method` with one or more function decorators. `decorators` can be\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply decorators in reverse order so they end up in the expected order.\n+        decorators = tuple(reversed(decorators))\n+    else:\n+        decorators = (decorators,)\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # bound_method has the signature that 'decorator' expects i.e. no\n+        # 'self' argument, but it's a closure over self so it can call\n+        # 'func'. Also, wrap method.__get__() in a function because new\n+        # attributes can't be set on bound method objects, only on functions.\n+        \n+        # Create a proper function wrapper instead of using partial\n+        def bound_method(*args, **kwargs):\n+            return method.__get__(self, type(self))(*args, **kwargs)\n+        \n+        # Copy essential attributes that decorators expect\n+        bound_method.__name__ = getattr(method, '__name__', 'unknown')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        \n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n@@ -48,6 +110,9 @@ def _multi_decorate(decorators, method):\n     # Preserve any existing attributes of 'method', including the name.\n     update_wrapper(_wrapper, method)\n     return _wrapper\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n \n \n def method_decorator(decorator, name=''):\n",
    "variant_5": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..9853ecb01f 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,15 +10,15 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n-    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n+    # _multi_decorate()'s wrapper function isn't available in this scope. Cheat by\n     # using it on a dummy function.\n     @decorator\n     def dummy(*args, **kwargs):\n         pass\n     update_wrapper(_wrapper, dummy)\n \n-\n def _multi_decorate(decorators, method):\n     \"\"\"\n     Decorate `method` with one or more function decorators. `decorators` can be\n@@ -37,12 +37,38 @@ def _multi_decorate(decorators, method):\n         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # Create a proper wrapper function instead of using partial\n+        # This ensures decorators can access __name__ and other attributes\n+        def bound_method(*args, **kwargs):\n+            return method.__get__(self, type(self))(*args, **kwargs)\n+        \n+        # Copy essential function attributes that decorators expect\n+        bound_method.__name__ = getattr(method, '__name__', 'unknown')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        \n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n+        return bound_method(*args, **kwargs)\n \n     # Copy any attributes that a decorator adds to the function it decorates.\n+\n+    # Create a proper wrapper function instead of using partial\n+    def _wrapper(self, *args, **kwargs):\n+        bound_method = method.__get__(self, type(self))\n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+    \n+    # Copy method attributes to the wrapper before decoration\n+    update_wrapper(_wrapper, method)\n+    \n+    # Copy any attributes that decorators add to the function they decorate\n     for dec in decorators:\n         _update_method_wrapper(_wrapper, dec)\n     # Preserve any existing attributes of 'method', including the name.\n",
    "variant_6": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..1c77e12d60 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,15 +10,23 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n-    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n-    # using it on a dummy function.\n+    # Since we now provide proper function objects to decorators,\n+    # this function focuses on preserving any additional attributes\n+    # that decorators might have added to the wrapper.\n     @decorator\n     def dummy(*args, **kwargs):\n         pass\n+    # Copy over any attributes the decorator might have added\n+    for attr in dir(dummy):\n+        if not attr.startswith('_') and hasattr(dummy, attr):\n+            try:\n+                setattr(_wrapper, attr, getattr(dummy, attr))\n+            except (AttributeError, TypeError):\n+                pass\n     update_wrapper(_wrapper, dummy)\n \n-\n def _multi_decorate(decorators, method):\n     \"\"\"\n     Decorate `method` with one or more function decorators. `decorators` can be\n@@ -37,12 +45,40 @@ def _multi_decorate(decorators, method):\n         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+\n+        # Create a proper wrapper function instead of using partial\n+        def bound_method(*args, **kwargs):\n+            return method.__get__(self, type(self))(*args, **kwargs)\n+        \n+        # Copy essential attributes from the original method\n+        bound_method.__name__ = getattr(method, '__name__', '<unknown>')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        \n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n \n     # Copy any attributes that a decorator adds to the function it decorates.\n+\n+    # Create a proper wrapper function instead of using partial\n+    def _wrapper(*args, **kwargs):\n+        return method(self, *args, **kwargs)\n+    \n+    # Copy essential function attributes before applying decorators\n+    _wrapper.__name__ = method.__name__\n+    _wrapper.__module__ = getattr(method, '__module__', None)\n+    _wrapper.__doc__ = method.__doc__\n+    _wrapper.__dict__.update(getattr(method, '__dict__', {}))\n+    _wrapper.__annotations__ = getattr(method, '__annotations__', {})\n+    \n+    # Apply decorators to the properly attributed wrapper\n+    for dec in decorators:\n+        _wrapper = dec(_wrapper)\n+        \n+    # Copy any attributes that decorators added to the function\n     for dec in decorators:\n         _update_method_wrapper(_wrapper, dec)\n     # Preserve any existing attributes of 'method', including the name.\n",
    "variant_7": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..900771df3c 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,14 +10,17 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n-    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n-    # using it on a dummy function.\n-    @decorator\n+    # Create a proper function object with necessary attributes for the decorator\n     def dummy(*args, **kwargs):\n         pass\n-    update_wrapper(_wrapper, dummy)\n-\n+    \n+    # Apply the decorator to get its metadata\n+    decorated_dummy = decorator(dummy)\n+    \n+    # Copy attributes from the decorated dummy to our wrapper\n+    update_wrapper(_wrapper, decorated_dummy)\n \n def _multi_decorate(decorators, method):\n     \"\"\"\n@@ -37,12 +40,38 @@ def _multi_decorate(decorators, method):\n         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n-        for dec in decorators:\n-            bound_method = dec(bound_method)\n+\n+def _wrapper(self, *args, **kwargs):\n+    # Create a proper wrapper function instead of using partial\n+    # This ensures decorators can access __name__ and other attributes\n+    def bound_method(*args, **kwargs):\n+        return method(self, *args, **kwargs)\n+    \n+    # Copy essential attributes from the original method\n+    bound_method.__name__ = getattr(method, '__name__', 'unknown')\n+    bound_method.__module__ = getattr(method, '__module__', None)\n+    bound_method.__doc__ = getattr(method, '__doc__', None)\n+    bound_method.__dict__.update(getattr(method, '__dict__', {}))\n+    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+    \n+    for dec in decorators:\n+        bound_method = dec(bound_method)\n+    return bound_method(*args, **kwargs)\n         return bound_method(*args, **kwargs)\n \n     # Copy any attributes that a decorator adds to the function it decorates.\n+\n+    # Create a proper wrapper function instead of using partial\n+    def _wrapper(self, *args, **kwargs):\n+        bound_method = method.__get__(self, type(self))\n+        for dec in decorators:\n+            bound_method = dec(bound_method)\n+        return bound_method(*args, **kwargs)\n+    \n+    # Copy method attributes to the wrapper before decoration\n+    update_wrapper(_wrapper, method)\n+    \n+    # Copy any attributes that decorators might add to the function\n     for dec in decorators:\n         _update_method_wrapper(_wrapper, dec)\n     # Preserve any existing attributes of 'method', including the name.\n",
    "variant_8": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..0b1c1b0ed2 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -10,15 +10,15 @@ class classonlymethod(classmethod):\n         return super().__get__(instance, cls)\n \n \n+\n def _update_method_wrapper(_wrapper, decorator):\n-    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n+    # _multi_decorate()'s wrapper function isn't available in this scope. Cheat by\n     # using it on a dummy function.\n     @decorator\n     def dummy(*args, **kwargs):\n         pass\n     update_wrapper(_wrapper, dummy)\n \n-\n def _multi_decorate(decorators, method):\n     \"\"\"\n     Decorate `method` with one or more function decorators. `decorators` can be\n@@ -37,7 +37,53 @@ def _multi_decorate(decorators, method):\n         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+\n+def _wrapper(self, *args, **kwargs):\n+    # Create a proper wrapper function instead of using partial\n+    # This ensures decorators can access __name__ and other attributes\n+    def bound_method(*args, **kwargs):\n+        return method(self, *args, **kwargs)\n+    \n+    # Copy essential attributes that decorators expect\n+    bound_method.__name__ = getattr(method, '__name__', 'unknown')\n+    bound_method.__module__ = getattr(method, '__module__', None)\n+    bound_method.__doc__ = getattr(method, '__doc__', None)\n+    bound_method.__qualname__ = getattr(method, '__qualname__', bound_method.__name__)\n+    bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+    \n+    for dec in decorators:\n+        bound_method = dec(bound_method)\n+    return bound_method(*args, **kwargs)\n+        return bound_method(*args, **kwargs)\n+\n+    # Copy any attributes that a decorator adds to the function it decorates.\n+\n+def _multi_decorate(decorators, method):\n+    \"\"\"\n+    Decorate `method` with one or more function decorators. `decorators` can be\n+    a single decorator or an iterable of decorators.\n+    \"\"\"\n+    if hasattr(decorators, '__iter__'):\n+        # Apply decorators in reverse order so @a @b @c becomes\n+        # _multi_decorate((a, b, c), f) and not the other way around.\n+        decorators = tuple(reversed(tuple(decorators)))\n+    else:\n+        decorators = (decorators,)\n+\n+    def _wrapper(self, *args, **kwargs):\n+        # Create a proper function wrapper instead of using partial\n+        def bound_method(*args, **kwargs):\n+            return method(self, *args, **kwargs)\n+        \n+        # Copy essential attributes from the original method to make it decorator-friendly\n+        bound_method.__name__ = getattr(method, '__name__', '<lambda>')\n+        bound_method.__module__ = getattr(method, '__module__', None)\n+        bound_method.__doc__ = getattr(method, '__doc__', None)\n+        bound_method.__dict__.update(getattr(method, '__dict__', {}))\n+        bound_method.__annotations__ = getattr(method, '__annotations__', {})\n+        bound_method.__qualname__ = getattr(method, '__qualname__', None)\n+        \n+        # Apply decorators to the properly attributed function\n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n@@ -48,6 +94,9 @@ def _multi_decorate(decorators, method):\n     # Preserve any existing attributes of 'method', including the name.\n     update_wrapper(_wrapper, method)\n     return _wrapper\n+    # Preserve any existing attributes of 'method', including the name.\n+    update_wrapper(_wrapper, method)\n+    return _wrapper\n \n \n def method_decorator(decorator, name=''):\n"
  }
}