{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/seaborn/seaborn/axisgrid.py lines 1475-1475)": "\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
    "Location 2 (/root/hy/projects_4/seaborn/seaborn/axisgrid.py lines 1490-1490)": "\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n            else:\n                hue = None\n\n            if self._dropna:\n                not_na = vector.notna()\n                if hue is not None:\n                    not_na &= hue.notna()\n                vector = vector[not_na]\n",
    "Location 3 (/root/hy/projects_4/seaborn/seaborn/axisgrid.py lines 1482-1482)": "\n        if \"hue\" not in signature(func).parameters:\n            return self._map_diag_iter_hue(func, **kwargs)\n\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n",
    "Location 4 (/root/hy/projects_4/seaborn/seaborn/axisgrid.py lines 1444-1451)": "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        diag_vars.append(x_var)\n                        ax = self.axes[i, j]\n                        diag_ax = ax.twinx()\n                        diag_ax.set_axis_off()\n                        diag_axes.append(diag_ax)\n\n                        # Work around matplotlib bug\n                        # https://github.com/matplotlib/matplotlib/issues/15188\n                        if not plt.rcParams.get(\"ytick.left\", True):\n                            for tick in ax.yaxis.majorTicks:\n                                tick.tick1line.set_visible(False)\n\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
    "Location 5 (/root/hy/projects_4/seaborn/seaborn/axisgrid.py lines 1476-1476)": "\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/seaborn/seaborn/axisgrid.py lines 1475-1475)": [
      "\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n            self.diag_vars = diag_vars\n",
      "\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n"
    ],
    "Location 2 (/root/hy/projects_4/seaborn/seaborn/axisgrid.py lines 1490-1490)": [
      "\n        self.diag_vars = diag_vars\n        self.diag_axes = diag_axes\n",
      "\n        # Store diagonal variables and axes for later use\n        self.diag_vars = diag_vars\n        self.diag_axes = diag_axes\n",
      "\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n            else:\n                hue = None\n\n            if self._dropna:\n                not_na = vector.notna()\n                if hue is not None:\n                    not_na &= hue.notna()\n                vector = vector[not_na]\n",
      "\n        # Store the diagonal variables and axes for later use\n        self.diag_vars = diag_vars\n        self.diag_axes = diag_axes\n",
      "\n        # Keep track of what we've plotted to handle duplicates\n        diag_vars = []\n        diag_axes = []\n        if self.square_grid:\n            for i, (y_var, ax) in enumerate(zip(self.y_vars, self.axes.flat)):\n                if ax.rowspan.start == ax.colspan.start:\n                    diag_vars.append(y_var)\n                    diag_axes.append(ax)\n\n        if not diag_vars:\n            return self\n\n        # Preserve MultiIndex tuple column names as list instead of numpy array\n        self.diag_vars = diag_vars\n        self.diag_axes = diag_axes\n",
      "\n        # Store the diagonal variables and axes for later use\n        self.diag_vars = diag_vars\n        self.diag_axes = diag_axes\n",
      "\n        # Convert list of diagonal variables to array for indexing\n        self.diag_vars = diag_vars\n        self.diag_axes = diag_axes\n",
      "\n        # Store the diagonal variables and axes for later use\n        self.diag_vars = diag_vars\n        self.diag_axes = diag_axes\n"
    ],
    "Location 3 (/root/hy/projects_4/seaborn/seaborn/axisgrid.py lines 1482-1482)": [
      "\n        if \"hue\" not in signature(func).parameters:\n            return self._map_diag_iter_hue(func, **kwargs)\n\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n",
      "\n        if \"hue\" not in signature(func).parameters:\n            return self._map_diag_iter_hue(func, **kwargs)\n\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n",
      "\n        if \"hue\" not in signature(func).parameters:\n            return self._map_diag_iter_hue(func, **kwargs)\n\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n",
      "\n        if diag_vars is not None:\n\n            # Add new axes along the diagonal to show the marginal distributions\n            diag_axes = []\n            for i, (x_var, y_var) in enumerate(zip(diag_vars, diag_vars)):\n\n                # Make the density axes\n                ax = self.fig.add_subplot(n_vars, n_vars, (i * n_vars) + i + 1)\n                diag_axes.append(ax)\n\n                # Remove the axis labels from the density axes\n                ax.set_xlabel(\"\")\n                ax.set_ylabel(\"\")\n\n                # Remove the ticks from the density axes\n                if not self._despine:\n                    ax.tick_params(\n                        which=\"both\",\n                        bottom=False, top=False, left=False, right=False,\n                        labelbottom=False, labeltop=False,\n                        labelleft=False, labelright=False,\n                    )\n\n                # Possibly share the y axis across columns\n                if self._share_y:\n                    if i == 0:\n                        self.axes[0, 0].sharey(ax)\n                    else:\n                        diag_axes[0].sharey(ax)\n\n                # Possibly share the x axis across rows\n                if self._share_x:\n                    if i == 0:\n                        self.axes[0, 0].sharex(ax)\n                    else:\n                        diag_axes[0].sharex(ax)\n\n                # Work around matplotlib bug\n                # https://github.com/matplotlib/matplotlib/issues/15188\n                if self._share_x and self._share_y:\n                    for ax in diag_axes[1:]:\n                        share_axis(diag_axes[0], ax, \"y\")\n\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n\n        if \"hue\" not in signature(func).parameters:\n            return self._map_diag_iter_hue(func, **kwargs)\n\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n",
      "\n        if \"hue\" not in signature(func).parameters:\n            return self._map_diag_iter_hue(func, **kwargs)\n\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n",
      "\n        if \"hue\" not in signature(func).parameters:\n            return self._map_diag_iter_hue(func, **kwargs)\n\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n",
      "\n        if \"hue\" not in signature(func).parameters:\n            return self._map_diag_iter_hue(func, **kwargs)\n\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n",
      "\n        if \"hue\" not in signature(func).parameters:\n            return self._map_diag_iter_hue(func, **kwargs)\n\n        # Loop over diagonal variables and axes, making one plot in each\n        for var, ax in zip(self.diag_vars, self.diag_axes):\n\n            plot_kwargs = kwargs.copy()\n            if str(func.__module__).startswith(\"seaborn\"):\n                plot_kwargs[\"ax\"] = ax\n            else:\n                plt.sca(ax)\n\n            vector = self.data[var]\n            if self._hue_var is not None:\n                hue = self.data[self._hue_var]\n"
    ],
    "Location 4 (/root/hy/projects_4/seaborn/seaborn/axisgrid.py lines 1444-1451)": [
      "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        diag_vars.append(x_var)\n                        ax = self.axes[i, j]\n                        diag_ax = ax.twinx()\n                        diag_ax.set_axis_off()\n                        diag_axes.append(diag_ax)\n\n                        # Work around matplotlib bug\n                        # https://github.com/matplotlib/matplotlib/issues/15188\n                        if not plt.rcParams.get(\"ytick.left\", True):\n                            for tick in ax.yaxis.majorTicks:\n                                tick.tick1line.set_visible(False)\n\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        diag_vars.append(x_var)\n                        ax = self.axes[i, j]\n                        diag_ax = ax.twinx()\n                        diag_ax.set_axis_off()\n                        diag_axes.append(diag_ax)\n\n                        # Work around matplotlib bug\n                        # https://github.com/matplotlib/matplotlib/issues/15188\n                        if not plt.rcParams.get(\"ytick.left\", True):\n                            for tick in ax.yaxis.majorTicks:\n                                tick.tick1line.set_visible(False)\n\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        diag_vars.append(x_var)\n                        ax = self.axes[i, j]\n                        diag_ax = ax.twinx()\n                        diag_ax.set_axis_off()\n                        diag_axes.append(diag_ax)\n\n                        # Work around matplotlib bug\n                        # https://github.com/matplotlib/matplotlib/issues/15188\n                        if not plt.rcParams.get(\"ytick.left\", True):\n                            for tick in ax.yaxis.majorTicks:\n                                tick.tick1line.set_visible(False)\n\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        diag_vars.append(x_var)\n",
      "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        diag_vars.append(x_var)\n",
      "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        diag_vars.append(x_var)\n                        ax = self.axes[i, j]\n                        diag_ax = ax.twinx()\n                        diag_ax.set_axis_off()\n                        diag_axes.append(diag_ax)\n\n                        # Work around matplotlib bug\n                        # https://github.com/matplotlib/matplotlib/issues/15188\n                        if not plt.rcParams.get(\"ytick.left\", True):\n                            for tick in ax.yaxis.majorTicks:\n                                tick.tick1line.set_visible(False)\n                                tick.tick2line.set_visible(False)\n\n            # Keep as lists to preserve MultiIndex tuple column names\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        diag_vars.append(x_var)\n                        ax = self.axes[i, j]\n                        diag_ax = ax.twinx()\n                        diag_ax.set_axis_off()\n                        diag_axes.append(diag_ax)\n\n                        # Work around matplotlib bug\n                        # https://github.com/matplotlib/matplotlib/issues/15188\n                        if not plt.rcParams.get(\"ytick.left\", True):\n                            for tick in ax.yaxis.majorTicks:\n                                tick.tick1line.set_visible(False)\n\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n        # Add special diagonal axes for the univariate plot\n        if self.diag_axes is None:\n            diag_vars = []\n            diag_axes = []\n            for i, y_var in enumerate(self.y_vars):\n                for j, x_var in enumerate(self.x_vars):\n                    if x_var == y_var:\n\n                        # Make the density axes\n                        diag_vars.append(x_var)\n"
    ],
    "Location 5 (/root/hy/projects_4/seaborn/seaborn/axisgrid.py lines 1476-1476)": [
      "\n            if self.diag_sharey and diag_axes:\n                for ax in diag_axes[1:]:\n                    share_axis(diag_axes[0], ax, \"y\")\n\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n            if self.diag_sharey and diag_axes:\n                for ax in diag_axes[1:]:\n                    share_axis(diag_axes[0], ax, \"y\")\n\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n            if self.diag_sharey and diag_axes:\n                for ax in diag_axes[1:]:\n                    share_axis(diag_axes[0], ax, \"y\")\n\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n",
      "\n            self.diag_vars = diag_vars\n            self.diag_axes = diag_axes\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..9a727bb5 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1441,6 +1441,7 @@ class PairGrid(Grid):\n         \"\"\"\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n+\n             diag_vars = []\n             diag_axes = []\n             for i, y_var in enumerate(self.y_vars):\n@@ -1472,13 +1473,16 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n-            self.diag_axes = np.array(diag_axes, np.object_)\n+\n+            self.diag_vars = diag_vars\n+\n+            self.diag_axes = diag_axes\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n \n         # Loop over diagonal variables and axes, making one plot in each\n+\n         for var, ax in zip(self.diag_vars, self.diag_axes):\n \n             plot_kwargs = kwargs.copy()\n@@ -1487,6 +1491,7 @@ class PairGrid(Grid):\n             else:\n                 plt.sca(ax)\n \n+\n             vector = self.data[var]\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n",
    "variant_0": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..124b9703 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1439,6 +1439,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1460,6 +1463,19 @@ class PairGrid(Grid):\n                             for tick in ax.yaxis.majorTicks:\n                                 tick.tick1line.set_visible(False)\n \n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+                        ax = self.axes[i, j]\n+                        diag_ax = ax.twinx()\n+                        diag_ax.set_axis_off()\n+                        diag_axes.append(diag_ax)\n+\n+                        # Work around matplotlib bug\n+                        # https://github.com/matplotlib/matplotlib/issues/15188\n+                        if not plt.rcParams.get(\"ytick.left\", True):\n+                            for tick in ax.yaxis.majorTicks:\n+                                tick.tick1line.set_visible(False)\n+\n                         # Remove main y axis from density axes in a corner plot\n                         if self._corner:\n                             ax.yaxis.set_visible(False)\n@@ -1472,8 +1488,17 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n-            self.diag_axes = np.array(diag_axes, np.object_)\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+\n+        if \"hue\" not in signature(func).parameters:\n+            return self._map_diag_iter_hue(func, **kwargs)\n+\n+        # Loop over diagonal variables and axes, making one plot in each\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n@@ -1490,6 +1515,36 @@ class PairGrid(Grid):\n             vector = self.data[var]\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+                plt.sca(ax)\n+\n+\n+        # Loop over diagonal variables and axes, making one plot in each\n+        for var, ax in zip(self.diag_vars, self.diag_axes):\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+                plt.sca(ax)\n+\n+            vector = self.data[var]\n+            if self._hue_var is not None:\n+                hue = self.data[self._hue_var]\n+            else:\n+                hue = None\n+\n+            if self._dropna:\n+                not_na = vector.notna()\n+                if hue is not None:\n+                    not_na &= hue.notna()\n+                vector = vector[not_na]\n+            if self._hue_var is not None:\n+                hue = self.data[self._hue_var]\n             else:\n                 hue = None\n \n",
    "variant_1": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..6abe8cc9 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1439,6 +1439,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1460,6 +1463,19 @@ class PairGrid(Grid):\n                             for tick in ax.yaxis.majorTicks:\n                                 tick.tick1line.set_visible(False)\n \n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+                        ax = self.axes[i, j]\n+                        diag_ax = ax.twinx()\n+                        diag_ax.set_axis_off()\n+                        diag_axes.append(diag_ax)\n+\n+                        # Work around matplotlib bug\n+                        # https://github.com/matplotlib/matplotlib/issues/15188\n+                        if not plt.rcParams.get(\"ytick.left\", True):\n+                            for tick in ax.yaxis.majorTicks:\n+                                tick.tick1line.set_visible(False)\n+\n                         # Remove main y axis from density axes in a corner plot\n                         if self._corner:\n                             ax.yaxis.set_visible(False)\n@@ -1472,8 +1488,21 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n-            self.diag_axes = np.array(diag_axes, np.object_)\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+\n+            if self.diag_sharey and diag_axes:\n+                for ax in diag_axes[1:]:\n+                    share_axis(diag_axes[0], ax, \"y\")\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+\n+        if \"hue\" not in signature(func).parameters:\n+            return self._map_diag_iter_hue(func, **kwargs)\n+\n+        # Loop over diagonal variables and axes, making one plot in each\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n@@ -1488,6 +1517,18 @@ class PairGrid(Grid):\n                 plt.sca(ax)\n \n             vector = self.data[var]\n+            if self._hue_var is not None:\n+                hue = self.data[self._hue_var]\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+                plt.sca(ax)\n+\n+\n+        self.diag_vars = diag_vars\n+        self.diag_axes = diag_axes\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n             else:\n",
    "variant_2": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..f58b4906 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1439,6 +1439,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1460,6 +1463,19 @@ class PairGrid(Grid):\n                             for tick in ax.yaxis.majorTicks:\n                                 tick.tick1line.set_visible(False)\n \n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+                        ax = self.axes[i, j]\n+                        diag_ax = ax.twinx()\n+                        diag_ax.set_axis_off()\n+                        diag_axes.append(diag_ax)\n+\n+                        # Work around matplotlib bug\n+                        # https://github.com/matplotlib/matplotlib/issues/15188\n+                        if not plt.rcParams.get(\"ytick.left\", True):\n+                            for tick in ax.yaxis.majorTicks:\n+                                tick.tick1line.set_visible(False)\n+\n                         # Remove main y axis from density axes in a corner plot\n                         if self._corner:\n                             ax.yaxis.set_visible(False)\n@@ -1472,8 +1488,17 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n-            self.diag_axes = np.array(diag_axes, np.object_)\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+\n+        if \"hue\" not in signature(func).parameters:\n+            return self._map_diag_iter_hue(func, **kwargs)\n+\n+        # Loop over diagonal variables and axes, making one plot in each\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n@@ -1488,6 +1513,19 @@ class PairGrid(Grid):\n                 plt.sca(ax)\n \n             vector = self.data[var]\n+            if self._hue_var is not None:\n+                hue = self.data[self._hue_var]\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+                plt.sca(ax)\n+\n+\n+        # Store diagonal variables and axes for later use\n+        self.diag_vars = diag_vars\n+        self.diag_axes = diag_axes\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n             else:\n",
    "variant_3": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..d319f9b0 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1439,6 +1439,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1460,6 +1463,19 @@ class PairGrid(Grid):\n                             for tick in ax.yaxis.majorTicks:\n                                 tick.tick1line.set_visible(False)\n \n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+                        ax = self.axes[i, j]\n+                        diag_ax = ax.twinx()\n+                        diag_ax.set_axis_off()\n+                        diag_axes.append(diag_ax)\n+\n+                        # Work around matplotlib bug\n+                        # https://github.com/matplotlib/matplotlib/issues/15188\n+                        if not plt.rcParams.get(\"ytick.left\", True):\n+                            for tick in ax.yaxis.majorTicks:\n+                                tick.tick1line.set_visible(False)\n+\n                         # Remove main y axis from density axes in a corner plot\n                         if self._corner:\n                             ax.yaxis.set_visible(False)\n@@ -1472,8 +1488,21 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n-            self.diag_axes = np.array(diag_axes, np.object_)\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+\n+            if self.diag_sharey and diag_axes:\n+                for ax in diag_axes[1:]:\n+                    share_axis(diag_axes[0], ax, \"y\")\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+\n+        if \"hue\" not in signature(func).parameters:\n+            return self._map_diag_iter_hue(func, **kwargs)\n+\n+        # Loop over diagonal variables and axes, making one plot in each\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n@@ -1490,6 +1519,36 @@ class PairGrid(Grid):\n             vector = self.data[var]\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+                plt.sca(ax)\n+\n+\n+        # Loop over diagonal variables and axes, making one plot in each\n+        for var, ax in zip(self.diag_vars, self.diag_axes):\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+                plt.sca(ax)\n+\n+            vector = self.data[var]\n+            if self._hue_var is not None:\n+                hue = self.data[self._hue_var]\n+            else:\n+                hue = None\n+\n+            if self._dropna:\n+                not_na = vector.notna()\n+                if hue is not None:\n+                    not_na &= hue.notna()\n+                vector = vector[not_na]\n+            if self._hue_var is not None:\n+                hue = self.data[self._hue_var]\n             else:\n                 hue = None\n \n",
    "variant_4": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..a8483452 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1439,6 +1439,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1472,8 +1475,63 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n-            self.diag_axes = np.array(diag_axes, np.object_)\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+\n+        if \"hue\" not in signature(func).parameters:\n+            return self._map_diag_iter_hue(func, **kwargs)\n+\n+        # Loop over diagonal variables and axes, making one plot in each\n+\n+        if diag_vars is not None:\n+\n+            # Add new axes along the diagonal to show the marginal distributions\n+            diag_axes = []\n+            for i, (x_var, y_var) in enumerate(zip(diag_vars, diag_vars)):\n+\n+                # Make the density axes\n+                ax = self.fig.add_subplot(n_vars, n_vars, (i * n_vars) + i + 1)\n+                diag_axes.append(ax)\n+\n+                # Remove the axis labels from the density axes\n+                ax.set_xlabel(\"\")\n+                ax.set_ylabel(\"\")\n+\n+                # Remove the ticks from the density axes\n+                if not self._despine:\n+                    ax.tick_params(\n+                        which=\"both\",\n+                        bottom=False, top=False, left=False, right=False,\n+                        labelbottom=False, labeltop=False,\n+                        labelleft=False, labelright=False,\n+                    )\n+\n+                # Possibly share the y axis across columns\n+                if self._share_y:\n+                    if i == 0:\n+                        self.axes[0, 0].sharey(ax)\n+                    else:\n+                        diag_axes[0].sharey(ax)\n+\n+                # Possibly share the x axis across rows\n+                if self._share_x:\n+                    if i == 0:\n+                        self.axes[0, 0].sharex(ax)\n+                    else:\n+                        diag_axes[0].sharex(ax)\n+\n+                # Work around matplotlib bug\n+                # https://github.com/matplotlib/matplotlib/issues/15188\n+                if self._share_x and self._share_y:\n+                    for ax in diag_axes[1:]:\n+                        share_axis(diag_axes[0], ax, \"y\")\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n@@ -1488,6 +1546,19 @@ class PairGrid(Grid):\n                 plt.sca(ax)\n \n             vector = self.data[var]\n+            if self._hue_var is not None:\n+                hue = self.data[self._hue_var]\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+                plt.sca(ax)\n+\n+\n+        # Store the diagonal variables and axes for later use\n+        self.diag_vars = diag_vars\n+        self.diag_axes = diag_axes\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n             else:\n",
    "variant_5": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..1152bdf4 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1439,6 +1439,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1472,8 +1475,17 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n-            self.diag_axes = np.array(diag_axes, np.object_)\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+\n+        if \"hue\" not in signature(func).parameters:\n+            return self._map_diag_iter_hue(func, **kwargs)\n+\n+        # Loop over diagonal variables and axes, making one plot in each\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n@@ -1488,6 +1500,31 @@ class PairGrid(Grid):\n                 plt.sca(ax)\n \n             vector = self.data[var]\n+            if self._hue_var is not None:\n+                hue = self.data[self._hue_var]\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+                plt.sca(ax)\n+\n+\n+        # Keep track of what we've plotted to handle duplicates\n+        diag_vars = []\n+        diag_axes = []\n+        if self.square_grid:\n+            for i, (y_var, ax) in enumerate(zip(self.y_vars, self.axes.flat)):\n+                if ax.rowspan.start == ax.colspan.start:\n+                    diag_vars.append(y_var)\n+                    diag_axes.append(ax)\n+\n+        if not diag_vars:\n+            return self\n+\n+        # Preserve MultiIndex tuple column names as list instead of numpy array\n+        self.diag_vars = diag_vars\n+        self.diag_axes = diag_axes\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n             else:\n",
    "variant_6": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..78e5514b 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1439,6 +1439,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1454,6 +1457,21 @@ class PairGrid(Grid):\n                         diag_ax.set_axis_off()\n                         diag_axes.append(diag_ax)\n \n+                        # Work around matplotlib bug\n+                        # https://github.com/matplotlib/matplotlib/issues/15188\n+                        if not plt.rcParams.get(\"ytick.left\", True):\n+                            for tick in ax.yaxis.majorTicks:\n+                                tick.tick1line.set_visible(False)\n+                                tick.tick2line.set_visible(False)\n+\n+            # Keep as lists to preserve MultiIndex tuple column names\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+                        ax = self.axes[i, j]\n+                        diag_ax = ax.twinx()\n+                        diag_ax.set_axis_off()\n+                        diag_axes.append(diag_ax)\n+\n                         # Work around matplotlib bug\n                         # https://github.com/matplotlib/matplotlib/issues/15188\n                         if not plt.rcParams.get(\"ytick.left\", True):\n@@ -1472,8 +1490,20 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n-            self.diag_axes = np.array(diag_axes, np.object_)\n+\n+            self.diag_vars = diag_vars\n+\n+            if self.diag_sharey and diag_axes:\n+                for ax in diag_axes[1:]:\n+                    share_axis(diag_axes[0], ax, \"y\")\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+\n+        if \"hue\" not in signature(func).parameters:\n+            return self._map_diag_iter_hue(func, **kwargs)\n+\n+        # Loop over diagonal variables and axes, making one plot in each\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n@@ -1488,6 +1518,19 @@ class PairGrid(Grid):\n                 plt.sca(ax)\n \n             vector = self.data[var]\n+            if self._hue_var is not None:\n+                hue = self.data[self._hue_var]\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+                plt.sca(ax)\n+\n+\n+        # Store the diagonal variables and axes for later use\n+        self.diag_vars = diag_vars\n+        self.diag_axes = diag_axes\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n             else:\n",
    "variant_7": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..87d4479c 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1439,6 +1439,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1460,6 +1463,19 @@ class PairGrid(Grid):\n                             for tick in ax.yaxis.majorTicks:\n                                 tick.tick1line.set_visible(False)\n \n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+                        ax = self.axes[i, j]\n+                        diag_ax = ax.twinx()\n+                        diag_ax.set_axis_off()\n+                        diag_axes.append(diag_ax)\n+\n+                        # Work around matplotlib bug\n+                        # https://github.com/matplotlib/matplotlib/issues/15188\n+                        if not plt.rcParams.get(\"ytick.left\", True):\n+                            for tick in ax.yaxis.majorTicks:\n+                                tick.tick1line.set_visible(False)\n+\n                         # Remove main y axis from density axes in a corner plot\n                         if self._corner:\n                             ax.yaxis.set_visible(False)\n@@ -1472,8 +1488,17 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n-            self.diag_axes = np.array(diag_axes, np.object_)\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+\n+        if \"hue\" not in signature(func).parameters:\n+            return self._map_diag_iter_hue(func, **kwargs)\n+\n+        # Loop over diagonal variables and axes, making one plot in each\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n@@ -1488,6 +1513,19 @@ class PairGrid(Grid):\n                 plt.sca(ax)\n \n             vector = self.data[var]\n+            if self._hue_var is not None:\n+                hue = self.data[self._hue_var]\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+                plt.sca(ax)\n+\n+\n+        # Convert list of diagonal variables to array for indexing\n+        self.diag_vars = diag_vars\n+        self.diag_axes = diag_axes\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n             else:\n",
    "variant_8": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..e9735c5b 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1439,6 +1439,9 @@ class PairGrid(Grid):\n             called ``color`` and  ``label``.\n \n         \"\"\"\n+        # Add special diagonal axes for the univariate plot\n+        if self.diag_axes is None:\n+\n         # Add special diagonal axes for the univariate plot\n         if self.diag_axes is None:\n             diag_vars = []\n@@ -1472,8 +1475,17 @@ class PairGrid(Grid):\n                 for ax in diag_axes[1:]:\n                     share_axis(diag_axes[0], ax, \"y\")\n \n-            self.diag_vars = np.array(diag_vars, np.object_)\n-            self.diag_axes = np.array(diag_axes, np.object_)\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+\n+            self.diag_vars = diag_vars\n+            self.diag_axes = diag_axes\n+\n+        if \"hue\" not in signature(func).parameters:\n+            return self._map_diag_iter_hue(func, **kwargs)\n+\n+        # Loop over diagonal variables and axes, making one plot in each\n \n         if \"hue\" not in signature(func).parameters:\n             return self._map_diag_iter_hue(func, **kwargs)\n@@ -1488,6 +1500,19 @@ class PairGrid(Grid):\n                 plt.sca(ax)\n \n             vector = self.data[var]\n+            if self._hue_var is not None:\n+                hue = self.data[self._hue_var]\n+\n+            plot_kwargs = kwargs.copy()\n+            if str(func.__module__).startswith(\"seaborn\"):\n+                plot_kwargs[\"ax\"] = ax\n+            else:\n+                plt.sca(ax)\n+\n+\n+        # Store the diagonal variables and axes for later use\n+        self.diag_vars = diag_vars\n+        self.diag_axes = diag_axes\n             if self._hue_var is not None:\n                 hue = self.data[self._hue_var]\n             else:\n"
  }
}