{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/migrations/serializer.py lines 124-131)": "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        \n        # Handle combined enum flags (when name is None)\n        if self.value.name is None:\n            # Use enum._decompose to get individual flag components\n            decomposed = enum._decompose(enum_class, self.value)\n            if decomposed:\n                flag_parts = []\n                for flag in decomposed:\n                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n                return \" | \".join(flag_parts), {\"import %s\" % module}\n        \n        # Handle single enum values (original behavior)\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/db/migrations/serializer.py lines 124-131)": [
      "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        \n        # Handle combined enum flags where name is None\n        if self.value.name is None:\n            # Use enum._decompose to get individual flag components\n            decomposed = enum._decompose(enum_class, self.value)\n            if decomposed:\n                # Reconstruct as FLAG1 | FLAG2 | ... format\n                flag_parts = []\n                for flag_value in decomposed:\n                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag_value.name))\n                return \" | \".join(flag_parts), {\"import %s\" % module}\n        \n        # Handle regular single enum values\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n",
      "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        \n        # Handle combined enum flags (where .name is None)\n        if self.value.name is None:\n            # Use enum._decompose to get individual flag components\n            decomposed = enum._decompose(enum_class, self.value)\n            if decomposed[1]:  # If there are valid components\n                flag_parts = []\n                for flag in decomposed[1]:\n                    flag_parts.append(f\"{module}.{enum_class.__qualname__}.{flag.name}\")\n                return \" | \".join(flag_parts), {\"import %s\" % module}\n        \n        # Handle regular enum values (single flags or named values)\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n",
      "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        if self.value.name is None:\n            # Handle combined flags by decomposing them\n            decomposed = enum._decompose(enum_class, self.value)\n            flag_names = [flag.name for flag in decomposed[1]]\n            if flag_names:\n                flag_string = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n                return flag_string, {\"import %s\" % module}\n            else:\n                # Fallback for edge cases\n                return repr(self.value), set()\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n",
      "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        \n        # Handle combined enum flags (when name is None)\n        if self.value.name is None:\n            # Use enum._decompose to get individual flag components\n            decomposed = enum._decompose(enum_class, self.value)\n            if decomposed:\n                # Reconstruct as module.EnumClass.FLAG1 | module.EnumClass.FLAG2\n                flag_parts = []\n                for flag in decomposed:\n                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n                return \" | \".join(flag_parts), {\"import %s\" % module}\n        \n        # Handle single enum values (original logic)\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n",
      "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        \n        # Handle combined enum flags (when name is None)\n        if self.value.name is None:\n            # Use enum._decompose to get individual flag components\n            decomposed_flags = enum._decompose(enum_class, self.value)\n            if decomposed_flags:\n                # Create serialization like \"module.EnumClass.FLAG1 | module.EnumClass.FLAG2\"\n                flag_parts = []\n                for flag in decomposed_flags:\n                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n                return \" | \".join(flag_parts), {\"import %s\" % module}\n        \n        # Handle single enum values (existing behavior)\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n",
      "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        \n        # Handle combined enum flags (when name is None)\n        if self.value.name is None:\n            # Use enum._decompose to get individual flag components\n            decomposed = enum._decompose(enum_class, self.value)\n            if decomposed[1]:  # If there are individual flags\n                flag_parts = []\n                for flag in decomposed[1]:\n                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n                return (\" | \".join(flag_parts), {\"import %s\" % module})\n        \n        # Handle single enum values (original behavior)\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n",
      "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        \n        # Handle combined enum flags where .name is None\n        if self.value.name is None:\n            # Use enum._decompose to get individual flag components\n            decomposed = enum._decompose(enum_class, self.value)\n            if decomposed:\n                # Reconstruct as module.EnumClass.FLAG1 | module.EnumClass.FLAG2\n                flag_parts = []\n                for flag in decomposed:\n                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n                return (\" | \".join(flag_parts), {\"import %s\" % module})\n        \n        # Handle regular single enum values\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n",
      "\nclass EnumSerializer(BaseSerializer):\n    def serialize(self):\n        enum_class = self.value.__class__\n        module = enum_class.__module__\n        \n        # Handle combined enum flags (when name is None)\n        if self.value.name is None:\n            # Use enum._decompose to get individual flag components\n            decomposed = enum._decompose(enum_class, self.value)\n            if decomposed[1]:  # If there are individual flags\n                flag_parts = []\n                for flag in decomposed[1]:\n                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n                return \" | \".join(flag_parts), {\"import %s\" % module}\n        \n        # Handle regular enum values (single values with names)\n        return (\n            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n            {\"import %s\" % module},\n        )\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..5d37db4d37 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,12 +121,31 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        \n+        # Handle combined enum flags (when .name is None)\n+        if self.value.name is None:\n+            # Use enum._decompose to get individual flag components\n+            decomposed_flags = enum._decompose(enum_class, self.value)\n+            if decomposed_flags:\n+                # Reconstruct as module.EnumClass.FLAG1 | module.EnumClass.FLAG2\n+                flag_parts = []\n+                for flag in decomposed_flags:\n+                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n+                serialized_value = \" | \".join(flag_parts)\n+            else:\n+                # Fallback to original behavior if decomposition fails\n+                serialized_value = \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name)\n+        else:\n+            # Original behavior for single enum values\n+            serialized_value = \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name)\n+        \n         return (\n-            \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n+            serialized_value,\n             {\"import %s\" % module},\n         )\n \n",
    "variant_0": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..b28b0f2ec2 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,10 +121,23 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        \n+        # Handle combined enum flags (when name is None)\n+        if self.value.name is None:\n+            # Use enum._decompose to get individual flag components\n+            decomposed = enum._decompose(enum_class, self.value)\n+            if decomposed:\n+                flag_parts = []\n+                for flag in decomposed:\n+                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n+                return \" | \".join(flag_parts), {\"import %s\" % module}\n+        \n+        # Handle single enum values (original behavior)\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n",
    "variant_1": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..619e986b0b 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,10 +121,24 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        \n+        # Handle combined enum flags where name is None\n+        if self.value.name is None:\n+            # Use enum._decompose to get individual flag components\n+            decomposed = enum._decompose(enum_class, self.value)\n+            if decomposed:\n+                # Reconstruct as FLAG1 | FLAG2 | ... format\n+                flag_parts = []\n+                for flag_value in decomposed:\n+                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag_value.name))\n+                return \" | \".join(flag_parts), {\"import %s\" % module}\n+        \n+        # Handle regular single enum values\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n",
    "variant_2": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..81c8ee05c8 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,10 +121,23 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        \n+        # Handle combined enum flags (where .name is None)\n+        if self.value.name is None:\n+            # Use enum._decompose to get individual flag components\n+            decomposed = enum._decompose(enum_class, self.value)\n+            if decomposed[1]:  # If there are valid components\n+                flag_parts = []\n+                for flag in decomposed[1]:\n+                    flag_parts.append(f\"{module}.{enum_class.__qualname__}.{flag.name}\")\n+                return \" | \".join(flag_parts), {\"import %s\" % module}\n+        \n+        # Handle regular enum values (single flags or named values)\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n",
    "variant_3": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..056cadc2ba 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,10 +121,21 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        if self.value.name is None:\n+            # Handle combined flags by decomposing them\n+            decomposed = enum._decompose(enum_class, self.value)\n+            flag_names = [flag.name for flag in decomposed[1]]\n+            if flag_names:\n+                flag_string = \" | \".join(f\"{module}.{enum_class.__qualname__}.{name}\" for name in flag_names)\n+                return flag_string, {\"import %s\" % module}\n+            else:\n+                # Fallback for edge cases\n+                return repr(self.value), set()\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n",
    "variant_4": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..b1c66bf0c3 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,10 +121,24 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        \n+        # Handle combined enum flags (when name is None)\n+        if self.value.name is None:\n+            # Use enum._decompose to get individual flag components\n+            decomposed = enum._decompose(enum_class, self.value)\n+            if decomposed:\n+                # Reconstruct as module.EnumClass.FLAG1 | module.EnumClass.FLAG2\n+                flag_parts = []\n+                for flag in decomposed:\n+                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n+                return \" | \".join(flag_parts), {\"import %s\" % module}\n+        \n+        # Handle single enum values (original logic)\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n",
    "variant_5": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..b36f7828f3 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,10 +121,24 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        \n+        # Handle combined enum flags (when name is None)\n+        if self.value.name is None:\n+            # Use enum._decompose to get individual flag components\n+            decomposed_flags = enum._decompose(enum_class, self.value)\n+            if decomposed_flags:\n+                # Create serialization like \"module.EnumClass.FLAG1 | module.EnumClass.FLAG2\"\n+                flag_parts = []\n+                for flag in decomposed_flags:\n+                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n+                return \" | \".join(flag_parts), {\"import %s\" % module}\n+        \n+        # Handle single enum values (existing behavior)\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n",
    "variant_6": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..7cb1cf4413 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,10 +121,23 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        \n+        # Handle combined enum flags (when name is None)\n+        if self.value.name is None:\n+            # Use enum._decompose to get individual flag components\n+            decomposed = enum._decompose(enum_class, self.value)\n+            if decomposed[1]:  # If there are individual flags\n+                flag_parts = []\n+                for flag in decomposed[1]:\n+                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n+                return (\" | \".join(flag_parts), {\"import %s\" % module})\n+        \n+        # Handle single enum values (original behavior)\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n",
    "variant_7": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..57d613ca49 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,10 +121,24 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        \n+        # Handle combined enum flags where .name is None\n+        if self.value.name is None:\n+            # Use enum._decompose to get individual flag components\n+            decomposed = enum._decompose(enum_class, self.value)\n+            if decomposed:\n+                # Reconstruct as module.EnumClass.FLAG1 | module.EnumClass.FLAG2\n+                flag_parts = []\n+                for flag in decomposed:\n+                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n+                return (\" | \".join(flag_parts), {\"import %s\" % module})\n+        \n+        # Handle regular single enum values\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n",
    "variant_8": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 38da1e6ecc..03cca51a1e 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -121,10 +121,23 @@ class DictionarySerializer(BaseSerializer):\n         return \"{%s}\" % (\", \".join(\"%s: %s\" % (k, v) for k, v in strings)), imports\n \n \n+\n class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n+        \n+        # Handle combined enum flags (when name is None)\n+        if self.value.name is None:\n+            # Use enum._decompose to get individual flag components\n+            decomposed = enum._decompose(enum_class, self.value)\n+            if decomposed[1]:  # If there are individual flags\n+                flag_parts = []\n+                for flag in decomposed[1]:\n+                    flag_parts.append(\"%s.%s.%s\" % (module, enum_class.__qualname__, flag.name))\n+                return \" | \".join(flag_parts), {\"import %s\" % module}\n+        \n+        # Handle regular enum values (single values with names)\n         return (\n             \"%s.%s[%r]\" % (module, enum_class.__qualname__, self.value.name),\n             {\"import %s\" % module},\n"
  }
}