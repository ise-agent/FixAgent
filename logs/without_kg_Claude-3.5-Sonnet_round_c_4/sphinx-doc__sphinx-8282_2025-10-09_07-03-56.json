{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/__init__.py lines 1263-1272)": "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                # Check autodoc_typehints setting and suppress annotations if needed\n                if self.env.config.autodoc_typehints == 'none':\n                    kwargs.update({\n                        'show_annotation': False,\n                        'show_return_annotation': False\n                    })\n                \n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
    "Location 2 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/__init__.py lines 1475-1495)": "\n    def format_signature(self, **kwargs: Any) -> str:\n        if self.doc_as_attr:\n            return ''\n\n        sig = super().format_signature()\n        sigs = []\n\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use signatures for overloaded methods instead of the implementation method.\n            method = safe_getattr(self._signature_class, self._signature_method_name, None)\n            __globals__ = safe_getattr(method, '__globals__', {})\n            for overload in overloads:\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                parameters = list(overload.parameters.values())\n                overload = overload.replace(parameters=parameters[1:],\n                                            return_annotation=Parameter.empty)\n                \n                # Check autodoc_typehints config and suppress annotations if needed\n                if self.env.config.autodoc_typehints == 'none':\n                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n                \n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n        else:\n            sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
    "Location 3 (/root/hy/projects_4/sphinx/sphinx/util/inspect.py lines 549-598)": "\ndef _get_overloaded_signatures(self) -> List[inspect.Signature]:\n    if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n        # Use signatures from static analysis if available\n        return self.analyzer.overloads['.'.join(self.objpath)]\n\n    overloads = self.get_overloaded_signatures()\n    if overloads:\n        # create signature from first overload\n        overload = overloads[0]\n        parameters = list(overload.parameters.values())\n        return_annotation = overload.return_annotation\n        if self.parent and inspect.isclass(self.parent.object):\n            # remove first argument from overload\n            parameters.pop(0)\n        overload = overload.replace(parameters=parameters,\n                                    return_annotation=return_annotation)\n        return [overload]\n    else:\n        return []\n\ndef format_signature(self, **kwargs: Any) -> str:\n    if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n        # Use signatures from static analysis if available\n        overloads = self.analyzer.overloads['.'.join(self.objpath)]\n        if overloads:\n            sig = overloads[0]\n            return format_args_and_retann(sig, self.env.config)\n\n    overloads = self.get_overloaded_signatures()\n    if overloads:\n        # show overloaded signatures\n        overload_sigs = []\n        for overload in overloads:\n            # Check autodoc_typehints configuration\n            if self.env.config.autodoc_typehints == 'none':\n                overload_sig = stringify_signature(overload, show_annotation=False, \n                                                 show_return_annotation=False, **kwargs)\n            else:\n                overload_sig = stringify_signature(overload, **kwargs)\n            overload_sigs.append(overload_sig)\n\n        return \"\\n\".join(overload_sigs)\n    else:\n        return super().format_signature(**kwargs)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/__init__.py lines 1263-1272)": [
      "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                # Check autodoc_typehints configuration to suppress type hints if needed\n                if self.env.config.autodoc_typehints == 'none':\n                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n                \n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                # Check autodoc_typehints configuration for overloads\n                if self.env.config.autodoc_typehints == 'none':\n                    kwargs['show_annotation'] = False\n                    kwargs['show_return_annotation'] = False\n                \n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                # Check if typehints should be suppressed\n                if self.env.config.autodoc_typehints == 'none':\n                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n                \n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                # Check autodoc_typehints setting and suppress typehints if set to 'none'\n                if self.env.config.autodoc_typehints == 'none':\n                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n                \n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                # Check autodoc_typehints configuration for overloads\n                if self.env.config.autodoc_typehints == 'none':\n                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n                \n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                # Check if typehints should be suppressed\n                if self.env.config.autodoc_typehints == 'none':\n                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n                \n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                # Check if typehints should be suppressed\n                if self.env.config.autodoc_typehints == 'none':\n                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n                \n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n        if overloaded:\n            __globals__ = safe_getattr(self.object, '__globals__', {})\n            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                # Check autodoc_typehints setting and suppress annotations if needed\n                if self.env.config.autodoc_typehints == 'none':\n                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n                \n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n"
    ],
    "Location 2 (/root/hy/projects_4/sphinx/sphinx/ext/autodoc/__init__.py lines 1475-1495)": [
      "\n    def format_signature(self, **kwargs: Any) -> str:\n        if self.doc_as_attr:\n            return ''\n\n        sig = super().format_signature()\n        sigs = []\n\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use signatures for overloaded methods instead of the implementation method.\n            method = safe_getattr(self._signature_class, self._signature_method_name, None)\n            __globals__ = safe_getattr(method, '__globals__', {})\n            for overload in overloads:\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                parameters = list(overload.parameters.values())\n                overload = overload.replace(parameters=parameters[1:],\n                                            return_annotation=Parameter.empty)\n                # Check autodoc_typehints configuration and suppress type hints if needed\n                if self.env.config.autodoc_typehints == 'none':\n                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n        else:\n            sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n    def format_signature(self, **kwargs: Any) -> str:\n        if self.doc_as_attr:\n            return ''\n\n        sig = super().format_signature()\n        sigs = []\n\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use signatures for overloaded methods instead of the implementation method.\n            method = safe_getattr(self._signature_class, self._signature_method_name, None)\n            __globals__ = safe_getattr(method, '__globals__', {})\n            for overload in overloads:\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                parameters = list(overload.parameters.values())\n                overload = overload.replace(parameters=parameters[1:],\n                                            return_annotation=Parameter.empty)\n                # Check autodoc_typehints config to suppress type hints if set to 'none'\n                if self.env.config.autodoc_typehints == 'none':\n                    sig = stringify_signature(overload, show_annotation=False, \n                                            show_return_annotation=False, **kwargs)\n                else:\n                    sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n        else:\n            sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n    def format_signature(self, **kwargs: Any) -> str:\n        if self.doc_as_attr:\n            return ''\n\n        sig = super().format_signature()\n        sigs = []\n\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use signatures for overloaded methods instead of the implementation method.\n            method = safe_getattr(self._signature_class, self._signature_method_name, None)\n            __globals__ = safe_getattr(method, '__globals__', {})\n            for overload in overloads:\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                parameters = list(overload.parameters.values())\n                overload = overload.replace(parameters=parameters[1:],\n                                            return_annotation=Parameter.empty)\n                \n                # Check autodoc_typehints config and suppress annotations if set to 'none'\n                if self.env.config.autodoc_typehints == 'none':\n                    sig = stringify_signature(overload, show_annotation=False, \n                                            show_return_annotation=False, **kwargs)\n                else:\n                    sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n        else:\n            sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n    def format_signature(self, **kwargs: Any) -> str:\n        if self.doc_as_attr:\n            return ''\n\n        sig = super().format_signature()\n        sigs = []\n\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use signatures for overloaded methods instead of the implementation method.\n            method = safe_getattr(self._signature_class, self._signature_method_name, None)\n            __globals__ = safe_getattr(method, '__globals__', {})\n            for overload in overloads:\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                parameters = list(overload.parameters.values())\n                overload = overload.replace(parameters=parameters[1:],\n                                            return_annotation=Parameter.empty)\n                \n                # Check autodoc_typehints configuration\n                if self.env.config.autodoc_typehints == 'none':\n                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n                \n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n        else:\n            sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n    def format_signature(self, **kwargs: Any) -> str:\n        if self.doc_as_attr:\n            return ''\n\n        sig = super().format_signature()\n        sigs = []\n\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use signatures for overloaded methods instead of the implementation method.\n            method = safe_getattr(self._signature_class, self._signature_method_name, None)\n            __globals__ = safe_getattr(method, '__globals__', {})\n            for overload in overloads:\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                parameters = list(overload.parameters.values())\n                overload = overload.replace(parameters=parameters[1:],\n                                            return_annotation=Parameter.empty)\n                \n                # Check autodoc_typehints config to suppress type hints if needed\n                if self.env.config.autodoc_typehints == 'none':\n                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n                \n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n        else:\n            sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n    def format_signature(self, **kwargs: Any) -> str:\n        if self.doc_as_attr:\n            return ''\n\n        sig = super().format_signature()\n        sigs = []\n\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use signatures for overloaded methods instead of the implementation method.\n            method = safe_getattr(self._signature_class, self._signature_method_name, None)\n            __globals__ = safe_getattr(method, '__globals__', {})\n            for overload in overloads:\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                parameters = list(overload.parameters.values())\n                overload = overload.replace(parameters=parameters[1:],\n                                            return_annotation=Parameter.empty)\n                # Check if typehints should be suppressed\n                if self.env.config.autodoc_typehints == 'none':\n                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n                sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n        else:\n            sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n    def format_signature(self, **kwargs: Any) -> str:\n        if self.doc_as_attr:\n            return ''\n\n        sig = super().format_signature()\n        sigs = []\n\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use signatures for overloaded methods instead of the implementation method.\n            method = safe_getattr(self._signature_class, self._signature_method_name, None)\n            __globals__ = safe_getattr(method, '__globals__', {})\n            for overload in overloads:\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                parameters = list(overload.parameters.values())\n                overload = overload.replace(parameters=parameters[1:],\n                                            return_annotation=Parameter.empty)\n                # Check autodoc_typehints config and suppress annotations if needed\n                if self.env.config.autodoc_typehints == 'none':\n                    sig = stringify_signature(overload, show_annotation=False, \n                                            show_return_annotation=False, **kwargs)\n                else:\n                    sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n        else:\n            sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n",
      "\n    def format_signature(self, **kwargs: Any) -> str:\n        if self.doc_as_attr:\n            return ''\n\n        sig = super().format_signature()\n        sigs = []\n\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            # Use signatures for overloaded methods instead of the implementation method.\n            method = safe_getattr(self._signature_class, self._signature_method_name, None)\n            __globals__ = safe_getattr(method, '__globals__', {})\n            for overload in overloads:\n                overload = evaluate_signature(overload, __globals__,\n                                              self.env.config.autodoc_type_aliases)\n\n                parameters = list(overload.parameters.values())\n                overload = overload.replace(parameters=parameters[1:],\n                                            return_annotation=Parameter.empty)\n                \n                # Check autodoc_typehints configuration for overloaded methods\n                if self.env.config.autodoc_typehints == 'none':\n                    sig = stringify_signature(overload, show_annotation=False, \n                                            show_return_annotation=False, **kwargs)\n                else:\n                    sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n        else:\n            sigs.append(sig)\n\n        return \"\\n\".join(sigs)\n"
    ],
    "Location 3 (/root/hy/projects_4/sphinx/sphinx/util/inspect.py lines 549-598)": [
      "\ndef _get_overloaded_signatures(self) -> List[inspect.Signature]:\n    if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n        # Use signatures from static analysis if available\n        return self.analyzer.overloads['.'.join(self.objpath)]\n\n    overloads = get_overloaded_signatures(self.object)\n    if overloads:\n        # Filter out the implementation signature\n        overloads = [sig for sig in overloads if sig != inspect.signature(self.object)]\n\n    return overloads\n\ndef get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n    \"\"\"Decode and return lines of the docstring(s) for the object.\"\"\"\n    if encoding is not None:\n        warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n                      % self.__class__.__name__,\n                      RemovedInSphinx40Warning, stacklevel=2)\n    docstring = getdoc(self.object, self.get_attr,\n                       self.env.config.autodoc_inherit_docstrings,\n                       self.parent, self.object_name)\n    if docstring:\n        tab_width = self.directive.state.document.settings.tab_width\n        return [prepare_docstring(docstring, ignore, tab_width)]\n    return []\n\n# data descriptors\ndef add_directive_header(self, sig: str) -> None:\n    sourcename = self.get_sourcename()\n    if not self.options.annotation:\n        # obtain type annotation for this data\n        try:\n            annotations = get_type_hints(self.parent)\n        except NameError:\n            # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)\n            annotations = safe_getattr(self.parent, '__annotations__', {})\n        except TypeError:\n            annotations = {}\n        except KeyError:\n            # a broken class\n            annotations = {}\n        except AttributeError:\n            # AttributeError is raised on 3.5.2 (fixed by 3.5.3)\n            annotations = {}\n\n        if self.objpath[-1] in annotations:\n            objrepr = stringify_annotation(annotations[self.objpath[-1]])\n            self.add_line('   :type: ' + objrepr, sourcename)\n\n    # Determine if type hints should be shown based on config\n    show_typehints = self.env.config.autodoc_typehints != 'none'\n    \n    overloads = self._get_overloaded_signatures()\n    if overloads:\n        # Use signatures from overloads\n        for overload in overloads:\n            kwargs = {}\n            if not show_typehints:\n                kwargs['show_annotation'] = False\n                kwargs['show_return_annotation'] = False\n            overload_sig = stringify_signature(overload, **kwargs)\n            self.add_line(\"   @overload\", sourcename)\n            self.add_line(\"   def %s%s: ...\" % (self.object_name, overload_sig), sourcename)\n        self.add_line(\"\", sourcename)\n\n    # add signature\n    try:\n        sig = self.format_signature()\n    except TypeError as exc:\n        logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n                       self.fullname, exc)\n        return\n    if sig:\n        self.add_line('   ' + sig, sourcename)\n",
      "\ndef _get_overloads_union_signature(self, overloads: List[Signature], display_name: str) -> Optional[Signature]:\n    # Check if all overloads have the same signature\n    signatures = [stringify_signature(overload, **self._get_signature_kwargs()) for overload in overloads]\n    if len(set(signatures)) == 1:\n        return overloads[0]\n\n    # Check if we should show typehints based on autodoc_typehints config\n    show_typehints = self.env.config.autodoc_typehints != 'none'\n    \n    overloads_display = [stringify_signature(overload, \n                                           show_annotation=show_typehints,\n                                           show_return_annotation=show_typehints) \n                        for overload in overloads]\n    parameters = list(overloads[0].parameters.values())\n    return_type = \" | \".join(stringify_annotation(overload.return_annotation)\n                           for overload in overloads)\n\n    # Combine all the overloads as a Union\n    overloads_display = [stringify_signature(overload, \n                                           show_annotation=show_typehints,\n                                           show_return_annotation=show_typehints) \n                        for overload in overloads]\n    return None\n",
      "\ndef add_line(self, line: str, source: str, *lineno: int) -> None:\n    \"\"\"Append one line of generated reST to the output.\"\"\"\n    if line.strip():  # not a blank line\n        self.directive.result.append(self.indent + line, source, *lineno)\n    else:\n        self.directive.result.append('', source, *lineno)\n\ndef add_lines(self, lines: List[str], source: str, *lineno: int) -> None:\n    \"\"\"Append multiple lines of generated reST to the output.\"\"\"\n    for line in lines:\n        self.add_line(line, source, *lineno)\n\ndef format_args(self, **kwargs: Any) -> str:\n    \"\"\"Format the argument signature of a callable.\n\n    Should return a string to be used as the argument signature.\n    This function should return None if the object does not have a\n    signature.\n    \"\"\"\n    if self.args is None and self.env.config.autodoc_docstring_signature:\n        # only act if a signature is not explicitly given already, and if\n        # the feature is enabled\n        result = self._find_signature()\n        if result is not None:\n            self.args, self.retann = result\n    if self.args is not None:\n        try:\n            return stringify_signature(self.args, **kwargs)\n        except TypeError:\n            # stringify_signature() failed\n            return None\n    else:\n        return None\n\ndef format_signature(self, **kwargs: Any) -> str:\n    \"\"\"Format the signature (arguments and return annotation) of the object.\n\n    Let the user process it via the ``autodoc-process-signature`` event.\n    \"\"\"\n    if self.args is not None:\n        # signature given explicitly\n        args = stringify_signature(self.args, **kwargs)\n    else:\n        # try to introspect the signature\n        try:\n            retann = None\n            args = self._format_args(**kwargs)\n            if args:\n                matched = re.match(r'^(\\(.+\\))\\s+->\\s+(.+)$', args)\n                if matched:\n                    args = matched.group(1)\n                    retann = matched.group(2)\n        except Exception as exc:\n            logger.warning(__('error while formatting arguments for %s: %s'),\n                           self.fullname, exc, type='autodoc')\n            args = None\n\n        if args:\n            # re-process the signature with the ``autodoc-process-signature`` event\n            app = self.env.app\n            try:\n                result = app.emit('autodoc-process-signature',\n                                  self.objtype, self.fullname,\n                                  self.object, self.options, args, retann)\n                if result:\n                    args, retann = result\n            except Exception as exc:\n                logger.warning(__('error while formatting signature for %s: %s'),\n                               self.fullname, exc, type='autodoc')\n                return None\n\n    result = args\n    if self.env.config.autodoc_typehints in ('both', 'description'):\n        if retann:\n            result += ' -> ' + retann\n\n    return result\n\ndef add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n                ) -> None:\n    \"\"\"Add content from docstrings, attribute documentation and user.\"\"\"\n    # set sourcename and add content from attribute documentation\n    sourcename = self.get_sourcename()\n    if self.analyzer:\n        attr_docs = self.analyzer.find_attr_docs()\n        if self.objpath:\n            key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n            if key in attr_docs:\n                no_docstring = True\n                # make a copy of docstring for attributes to avoid cache\n                # the change of autodoc-process-docstring event.\n                docstrings = [list(attr_docs[key])]\n\n                for i, line in enumerate(self.process_doc(docstrings)):\n                    self.add_line(line, sourcename, i)\n\n    # add content from docstrings\n    if not no_docstring:\n        docstrings = self.get_doc() or []\n        if not docstrings:\n            # append at least a dummy docstring, so that the event\n            # autodoc-process-docstring is fired and can add some content\n            # if desired\n            docstrings.append([])\n        for i, line in enumerate(self.process_doc(docstrings)):\n            self.add_line(line, sourcename, i)\n\n    # add additional content (e.g. from document), if present\n    if more_content:\n        for line, src in zip(more_content.data, more_content.items):\n            self.add_line(line, src[0], src[1])\n\ndef get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n    \"\"\"Return `(members_check_module, members)` where `members` is a\n    list of `(membername, member)` pairs of the members of *self.object*.\n\n    If *want_all* is True, return all members.  Else, only return those\n    members given by *self.options.members* (which may also be None).\n    \"\"\"\n    members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)\n    if not want_all:\n        if not self.options.members:\n            return False, []\n        # specific members given\n        selected = []\n        for name in self.options.members:\n            if name in members:\n                selected.append((name, members[name].value))\n            else:\n                logger.warning(__('missing attribute %s in object %s') %\n                               (name, self.fullname), type='autodoc')\n        return False, selected\n    elif self.options.inherited_members:\n        return False, [(m.name, m.value) for m in members.values()]\n    else:\n        return False, [(m.name, m.value) for m in members.values()\n                       if not m.directly_defined]\n\ndef filter_members(self, members: ObjectMembers, want_all: bool\n                   ) -> List[Tuple[str, Any, bool]]:\n    \"\"\"Filter the given member list.\n\n    Members are skipped if\n\n    - they are private (except if given explicitly or the private-members\n      option is set)\n    - they are special methods (except if given explicitly or the\n      special-members option is set)\n    - they are undocumented (except if the undoc-members option is set)\n\n    The user can override the skipping decision by connecting to the\n    ``autodoc-skip-member`` event.\n    \"\"\"\n    def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n        if inspect.isclass(self.object):\n            for cls in self.object.__mro__:\n                if cls.__name__ == self.options.inherited_members and cls != self.object:\n                    # given member is a member of specified *super class*\n                    return True\n                elif name in cls.__dict__:\n                    return False\n                elif name in self.get_attr(cls, '__annotations__', {}):\n                    return False\n                elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                    return False\n\n        return False\n\n    ret = []\n\n    # search for members in source code too\n    namespace = '.'.join(self.objpath)  # will be empty for modules\n\n    if self.analyzer:\n        attr_docs = self.analyzer.find_attr_docs()\n    else:\n        attr_docs = {}\n\n    # process members and determine which to skip\n    for (membername, member) in members:\n        # if isattr is True, the member is documented as an attribute\n        if member is INSTANCEATTR:\n            isattr = True\n            member = INSTANCEATTR\n        elif (namespace, membername) in attr_docs:\n            isattr = True\n        else:\n            isattr = False\n\n        doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,\n                     self.object, membername)\n        if not isinstance(doc, str):\n            # Ignore non-string __doc__\n            doc = None\n\n        # if the member __doc__ is the same as self's __doc__, it's just\n        # inherited and therefore not the member's doc\n        cls = self.get_attr(member, '__objclass__', None)\n        if cls:\n            cls_doc = self.get_attr(cls, '__doc__', None)\n            if cls_doc == doc:\n                doc = None\n\n        if isinstance(obj, ObjectMember) and obj.skipped:\n            pass\n\n        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n            if inspect.isclass(self.object):\n                for cls in self.object.__mro__:\n                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n                        # given member is a member of specified *super class*\n                        return True\n                    elif name in cls.__dict__:\n                        return False\n                    elif name in self.get_attr(cls, '__annotations__', {}):\n                        return False\n                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n                        return False\n\n            return False\n\n        has_doc = getdoc(member, self.get_attr,\n                         self.env.config.autodoc_inherit_docstrings,\n                         self.object, membername) is not None\n\n        def isfunc(obj: Any) -> bool:\n            return inspect.isfunction(obj) or inspect.ismethod(obj)\n\n        def isclass(obj: Any) -> bool:\n            return inspect.isclass(obj)\n\n        def isexception(obj: Any) -> bool:\n            return inspect.isclass(obj) and issubclass(obj, BaseException)\n\n        def isattribute(obj: Any) -> bool:\n            return not isfunc(obj) and not isclass(obj) and not inspect.ismodule(obj)\n\n        # give the user a chance to decide whether this member\n        # should be skipped\n        if self.env.app:\n            # let extensions preprocess docstrings\n            try:\n                skip_user = self.env.app.emit_firstresult('autodoc-skip-member',\n                                                          self.objtype, membername,\n                                                          member, not has_doc, self.options)\n                if skip_user is not None:\n                    if skip_user:\n                        continue\n            except Exception as exc:\n                logger.warning(__('autodoc: failed to determine %r to be documented, '\n                                  'the following exception was raised:\\n%s'),\n                               member, exc, type='autodoc')\n                continue\n\n        # check various conditions and decide whether to add the member\n        def check_private(name: str, obj: Any) -> bool:\n            if name.startswith('_'):\n                if name.startswith('__') and name.endswith('__') and len(name) > 4:\n                    # special method\n                    if self.options.special_members and name in self.options.special_members:\n                        return False\n                    elif self.options.special_members is not ALL:\n                        return True\n                elif self.options.private_members and name in self.options.private_members:\n                    return False\n                elif self.options.private_members is not ALL:\n                    return True\n            return False\n\n        def check_module(obj: Any) -> bool:\n            return not (self.options.ignore_module_all and\n                        '__all__' in dir(self.object) and\n                        membername not in self.object.__all__)\n\n        if check_private(membername, member):\n            continue\n\n        if not check_module(member):\n            continue\n\n        if self.options.inherited_members is not None:\n            if is_filtered_inherited_member(membername, member):\n                continue\n\n        if not has_doc:\n            if self.options.undoc_members:\n                # show the member without a docstring\n                pass\n            else:\n                continue\n\n        ret.append((membername, member, isattr))\n\n    return ret\n\ndef document_members(self, all_members: bool = False) -> None:\n    \"\"\"Generate reST for member documentation.\n\n    If *all_members* is True, do all members. Else, only do non-private\n    members.\n    \"\"\"\n    # set current namespace for finding members\n    self.env.temp_data['autodoc:module'] = self.modname\n    if self.objpath:\n        self.env.temp_data['autodoc:class'] = self.objpath[0]\n\n    want_all = all_members or self.options.inherited_members or \\\n        self.options.members is ALL\n    # find out which members are documentable\n    members_check_module, members = self.get_object_members(want_all)\n\n    # document non-skipped members\n    memberdocumenters = []\n    for (mname, member, isattr) in self.filter_members(members, want_all):\n        classes = [cls for cls in self.documenters.values()\n                   if cls.can_document_member(member, mname, isattr, self)]\n        if not classes:\n            # don't know how to document this member\n            continue\n        # prefer the documenter with the highest priority\n        classes.sort(key=lambda cls: cls.priority)\n        # give explicitly separated module name, so that members\n        # of inner classes can be documented\n        full_mname = self.modname + '::' + \\\n            '.'.join(self.objpath + [mname])\n        documenter = classes[-1](self.directive, full_mname, self.indent)\n        memberdocumenters.append((documenter, isattr))\n\n    member_order = self.options.member_order or self.env.config.autodoc_member_order\n    memberdocumenters = self.sort_members(memberdocumenters, member_order)\n\n    for documenter, isattr in memberdocumenters:\n        documenter.generate(\n            all_members=True, real_modname=self.real_modname,\n            check_module=members_check_module and not isattr)\n\ndef generate(self, more_content: Optional[StringList] = None,\n             real_modname: str = None,\n             check_module: bool = False,\n             all_members: bool = False) -> None:\n    \"\"\"Generate reST for the object given by *self.name*, and possibly for\n    its members.\n\n    If *more_content* is given, include that content. If *real_modname* is\n    given, use that module name to find attribute docs. If *check_module* is\n    True, only generate if the object is defined in the module name it is\n    imported from. If *all_members* is True, document all members.\n    \"\"\"\n    if not self.parse_name():\n        # need a module to import\n        logger.warning(\n            __('don\\'t know which module to import for autodocumenting '\n               '%r (try placing a \"module\" or \"currentmodule\" directive '\n               'in the document, or giving an explicit module name)') %\n            self.name, type='autodoc')\n        return\n\n    # now, import the module and get object to document\n    if not self.import_object():\n        return\n\n    # If there is no real module defined, figure out which to use.\n    # The real module is used in the module analyzer to look up the module\n    # where the attribute documentation would actually be found in.\n    # This is used for situations where you have a module that collects the\n    # functions and classes of internal submodules.\n    guess_modname = self.get_real_modname()\n    self.real_modname = real_modname or guess_modname\n\n    # try to also get a source code analyzer for attribute docs\n    try:\n        self.analyzer = ModuleAnalyzer.for_module(self.real_modname)\n        # parse right now, to get PycodeErrors on parsing (results will\n        # be cached anyway)\n        self.analyzer.find_attr_docs()\n    except PycodeError as exc:\n        logger.debug('[autodoc] module analyzer failed: %s', exc)\n        # no source file -- e.g. for builtin and C modules\n        self.analyzer = None\n        # at least add the module.__file__ as a dependency\n        if hasattr(self.object, '__file__') and self.object.__file__:\n            self.directive.filename_set.add(self.object.__file__)\n    else:\n        self.directive.filename_set.add(self.analyzer.srcname)\n\n    if self.real_modname != guess_modname:\n        # Add module to dependency list if target object is defined in other module.\n        try:\n            analyzer = ModuleAnalyzer.for_module(guess_modname)\n            self.directive.filename_set.add(analyzer.srcname)\n        except PycodeError:\n            pass\n\n    # check __module__ of object (for members not given explicitly)\n    if check_module:\n        if not self.check_module():\n            return\n\n    sourcename = self.get_sourcename()\n\n    # make sure that the result starts with an empty line.  This is\n    # necessary for some situations where another directive preprocesses\n    # reST and no starting newline is present\n    self.add_line('', sourcename)\n\n    # format the object's signature, if any\n    try:\n        sig = self.format_signature()\n    except Exception as exc:\n        logger.warning(__('error while formatting signature for %s: %s'),\n                       self.fullname, exc, type='autodoc')\n        return\n\n    # generate the directive header and options, if applicable\n    self.add_directive_header(sig)\n    self.add_line('', sourcename)\n\n    # e.g. the module directive doesn't have content\n    self.indent += self.content_indent\n\n    # add all content (from docstrings, attribute docs etc.)\n    self.add_content(more_content)\n\n    # document members, if possible\n    self.document_members(all_members)\n\n\nclass FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):\n    \"\"\"\n    Specialized Documenter subclass for functions.\n    \"\"\"\n    objtype = 'function'\n    member_order = 30\n\n    @classmethod\n    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                            ) -> bool:\n        # supports functions, builtins and bound methods exported at the module level\n        try:\n            return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n                    (inspect.ismethod(member) and member.__self__ is not None and\n                     # unbound methods on classes are just functions in Python 3, so\n                     # make sure we don't document them\n                     not inspect.isclass(member.__self__)))\n        except AttributeError:\n            return False\n\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n            kwargs.setdefault('show_return_annotation', False)\n\n        if self.config.autodoc_typehints_format == \"short\":\n            kwargs.setdefault('unqualified_typehints', True)\n\n        try:\n            self._signature_arguments, self._signature_return_annotation = \\\n                stringify_signature(inspect.signature(self.object), **kwargs).split(' -> ')\n        except ValueError:\n            self._signature_arguments = \\\n                stringify_signature(inspect.signature(self.object), **kwargs)\n            self._signature_return_annotation = None\n\n        # escape asterisks; `foo(*, bar)` should not become `foo(*, bar)`\n        args = self._signature_arguments.replace('\\\\*', r'\\*')\n        return args\n\n    def document_members(self, all_members: bool = False) -> None:\n        pass\n\n    def add_directive_header(self, sig: str) -> None:\n        sourcename = self.get_sourcename()\n        super().add_directive_header(sig)\n\n        if inspect.iscoroutinefunction(self.object):\n            self.add_line('   :async:', sourcename)\n\n    def format_signature(self, **kwargs: Any) -> str:\n        if self.doc_as_attr:\n            return ''\n\n        sigs = []\n        if (self.analyzer and\n                '.'.join(self.objpath) in self.analyzer.overloads):\n            # Use signatures for overloaded functions instead of the implementation function.\n            overloaded = True\n        else:\n            overloaded = False\n            sig = inspect.signature(self.object)\n            sigs.append(sig)\n\n        if overloaded:\n            actual = inspect.signature(self.object)\n            for overload in self.analyzer.overloads['.'.join(self.objpath)]:\n                if self.env.config.autodoc_typehints == 'none':\n                    sig = stringify_signature(overload, show_annotation=False, show_return_annotation=False, **kwargs)\n                else:\n                    sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n\n            if not any(type_sig == actual for type_sig in sigs):\n                sigs.append(actual)\n\n        return_annotation = None\n        if sigs:\n            if self.env.config.autodoc_typehints in ('both', 'description'):\n                if hasattr(sigs[0], 'return_annotation') and sigs[0].return_annotation:\n                    return_annotation = stringify_annotation(sigs[0].return_annotation)\n\n        if self.env.config.autodoc_typehints == 'none':\n            # Remove type hints from all signatures\n            formatted_sigs = []\n            for sig in sigs:\n                if isinstance(sig, str):\n                    # Already formatted signature string\n                    formatted_sigs.append(sig)\n                else:\n                    # Signature object - format without annotations\n                    formatted_sigs.append(stringify_signature(sig, show_annotation=False, show_return_annotation=False, **kwargs))\n            sigs = formatted_sigs\n\n        if len(sigs) == 1:\n            return stringify_signature(sigs[0], **kwargs)\n        else:\n            return \"\\n\".join([stringify_signature(sig, **kwargs) for sig in sigs])\n\n\nclass SingledispatchFunctionDocumenter(FunctionDocumenter):\n    \"\"\"\n    Used to be a specialized Documenter subclass for singledispatch'ed functions.\n\n    Retained for backwards compatibility, now does the same as the FunctionDocumenter\n    \"\"\"\n\n    def document_members(self, all_members: bool = False) -> None:\n        pass\n\n\nclass MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):\n    \"\"\"\n    Specialized Documenter subclass for methods (normal, static and class).\n    \"\"\"\n    objtype = 'method'\n    member_order = 50\n    priority = 1  # must be more than FunctionDocumenter\n\n    @classmethod\n    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                            ) -> bool:\n        try:\n            return inspect.ismethod(member) or inspect.isfunction(member)\n        except AttributeError:\n            return False\n\n    def import_object(self, raiseerror: bool = False) -> bool:\n        ret = super().import_object(raiseerror)\n        if not ret:\n            return ret\n\n        # to distinguish classmethod/staticmethod from instancemethod,\n        # we have to import the module and inspect the class directly.\n        if inspect.isfunction(self.object):\n            self.directivetype = 'method'\n            if isinstance(self.parent, ClassDocumenter):\n                if self.name in self.parent.object.__dict__:\n                    obj = self.parent.object.__dict__[self.name]\n                    if isinstance(obj, staticmethod):\n                        self.directivetype = 'staticmethod'\n                    elif isinstance(obj, classmethod):\n                        self.directivetype = 'classmethod'\n        elif inspect.ismethod(self.object):\n            if self.object.__self__ is not None and \\\n               (inspect.isclass(self.object.__self__) or\n                inspect.ismodule(self.object.__self__)):\n                # method is bound to a class or module\n                self.directivetype = 'method'\n            else:\n                # method is bound to an instance\n                self.directivetype = 'method'\n\n        return ret\n\n    def format_args(self, **kwargs: Any) -> str:\n        if self.env.config.autodoc_typehints in ('none', 'description'):\n            kwargs.setdefault('show_annotation', False)\n            kwargs.setdefault('show_return_annotation', False)\n\n        if self.config.autodoc_typehints_format == \"short\":\n            kwargs.setdefault('unqualified_typehints', True)\n\n        try:\n            if self.object == object.__init__ and self.parent != object:\n                # Classes not having own __init__ method are shown as no arguments.\n                #\n                # Note: The signature of object.__init__ is (self, /, *args, **kwargs).\n                #       This will be appeared when the class does not have __init__ method.\n                #       So we need to avoid this.\n                args = '()'\n                return args\n            else:\n                if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n                    self._signature_arguments, self._signature_return_annotation = \\\n                        stringify_signature(inspect.signature(self.object), **kwargs).split(' -> ')\n                else:\n                    if inspect.ismethod(self.object):\n                        # strip off the first argument: bound methods provide the binding\n                        # automatically, and we always document a method as if it is a bound method,\n                        # even if accessed through the class.\n                        args = stringify_signature(inspect.signature(self.object), **kwargs)\n                        args = args.replace('(self, ', '(').replace('(self)', '()')\n                    else:\n                        args = stringify_signature(inspect.signature(self.object), **kwargs)\n\n                try:\n                    self._signature_arguments, self._signature_return_annotation = \\\n                        args.split(' -> ')\n                except ValueError:\n                    self._signature_arguments = args\n                    self._signature_return_annotation = None\n\n        except (TypeError, ValueError):\n            args = ''\n\n        return self._signature_arguments\n\n    def document_members(self, all_members: bool = False) -> None:\n        pass\n\n    def format_signature(self, **kwargs: Any) -> str:\n        if self.doc_as_attr:\n            return ''\n\n        sigs = []\n        if (self.analyzer and\n                '.'.join(self.objpath) in self.analyzer.overloads):\n            # Use signatures for overloaded functions instead of the implementation function.\n            overloaded = True\n        else:\n            overloaded = False\n\n        if overloaded:\n            for overload in self.analyzer.overloads['.'.join(self.objpath)]:\n                if self.env.config.autodoc_typehints == 'none':\n                    sig = stringify_signature(overload, show_annotation=False, show_return_annotation=False, **kwargs)\n                else:\n                    sig = stringify_signature(overload, **kwargs)\n                sigs.append(sig)\n        else:\n            sig = inspect.signature(self.object)\n            sigs.append(sig)\n\n        if self.env.config.autodoc_typehints == 'none':\n            # Remove type hints from all signatures\n            formatted_sigs = []\n            for sig in sigs:\n                if isinstance(sig, str):\n                    # Already formatted signature string\n                    formatted_sigs.append(sig)\n                else:\n                    # Signature object - format without annotations\n                    formatted_sigs.append(stringify_signature(sig, show_annotation=False, show_return_annotation=False, **kwargs))\n            sigs = formatted_sigs\n\n        if len(sigs) == 1:\n            return stringify_signature(sigs[0], **kwargs)\n        else:\n            return \"\\n\".join([stringify_signature(sig, **kwargs) for sig in sigs])\n\n    def add_directive_header(self, sig: str) -> None:\n        sourcename = self.get_sourcename()\n        super().add_directive_header(sig)\n\n        if inspect.iscoroutinefunction(self.object):\n            self.add_line('   :async:', sourcename)\n",
      "\ndef _get_overloaded_signatures(self) -> List[inspect.Signature]:\n    if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n        # Use signatures from the analyzer if available\n        return self.analyzer.overloads['.'.join(self.objpath)]\n\n    if self.object:\n        # Check for @overload decorations in the same module\n        qualname = self.object.__qualname__\n        overloads = []\n        for name, obj in inspect.getmembers(inspect.getmodule(self.object)):\n            if (inspect.isfunction(obj) and\n                hasattr(obj, '__qualname__') and\n                obj.__qualname__ == qualname and\n                self._is_overload(obj)):\n                overloads.append(inspect.signature(obj))\n        return overloads\n\n    return []\n\ndef format_signature(self, **kwargs: Any) -> str:\n    def process_signature(sig: inspect.Signature) -> str:\n        show_annotations = self.env.config.autodoc_typehints != 'none'\n        return stringify_signature(sig, show_annotation=show_annotations, \n                                 show_return_annotation=show_annotations, **kwargs)\n\n    overloaded_sigs = self._get_overloaded_signatures()\n    if overloaded_sigs:\n        # show overloaded signatures\n        sigs = []\n        for overload in overloaded_sigs:\n            sigs.append(process_signature(overload))\n        return \"\\n\".join(sigs)\n\n    return process_signature(self.format_args(**kwargs))\n",
      "\ndef add_directive_header(self, sig: str) -> None:\n    sourcename = self.get_sourcename()\n    if self.doc_as_attr:\n        self.add_line('   :module: %s' % self.modname, sourcename)\n    if self.objpath:\n        # Be explicit about the type, this is necessary since the\n        # 'show-inheritance' flag may not be set on the directive\n        self.add_line('   :type: %s' % type(self.object).__name__, sourcename)\n\n    # add inheritance info, if wanted\n    if not self.doc_as_attr and self.options.show_inheritance:\n        self.add_inheritance_info()\n\n    # add overloads info, if exists\n    if inspect.isfunction(self.object):\n        overloads = self.get_overloaded_signatures()\n        if overloads:\n            __globals = safe_getattr(self.object, '__globals__', {})\n            for overload in overloads:\n                overload = evaluate_signature(overload, __globals,\n                                              self.env.config.autodoc_type_aliases)\n\n                if not self.env.config.autodoc_typehints or self.env.config.autodoc_typehints == 'none':\n                    sig = stringify_signature(overload, show_annotation=False, show_return_annotation=False)\n                else:\n                    sig = stringify_signature(overload, **kwargs)\n                self.add_line(\"   :type %s: %s\" % (self.objpath[-1], sig), sourcename)\n\n    # add signature\n    if self.options.show_inheritance or self.doc_as_attr:\n        self.add_line('', sourcename)\n",
      "\ndef add_directive_header(self, sig: str) -> None:\n    sourcename = self.get_sourcename()\n    if self.objpath:\n        # Be explicit about the module, this is necessary since .. class::\n        # etc. don't support a prepended module name\n        self.add_line('.. %s:: %s.%s%s' % (self.directivetype, self.modname,\n                                           '.'.join(self.objpath), sig),\n                      sourcename)\n    else:\n        self.add_line('.. %s:: %s%s' % (self.directivetype, self.fullname, sig),\n                      sourcename)\n    if self.options.noindex:\n        self.add_line('   :noindex:', sourcename)\n    if self.objpath:\n        # Be explicit about the module, this is necessary since .. class::\n        # etc. don't support a prepended module name\n        self.add_line('', sourcename)\n\n    # add inheritance info, if wanted\n    if not self.doc_as_attr and self.options.show_inheritance:\n        self.add_inheritance_info()\n\n    # add overloads info\n    if self.analyzer and hasattr(self.analyzer, 'overloads'):\n        overloads = self.analyzer.overloads.get('.'.join(self.objpath))\n        if overloads:\n            self.add_line('', sourcename)\n            for overload in overloads:\n                kwargs = {}\n                if self.env.config.autodoc_typehints == 'none':\n                    kwargs['show_annotation'] = False\n                    kwargs['show_return_annotation'] = False\n                overload_sig = stringify_signature(overload, **kwargs)\n                self.add_line(\"   :overload: %s\" % overload_sig, sourcename)\n",
      "\ndef add_directive_header(self, sig: str) -> None:\n    sourcename = self.get_sourcename()\n    if self.doc_as_attr:\n        self.add_line('   .. %s:: %s' % (self.directivetype, sig),\n                      sourcename)\n    else:\n        if self.objtype in ('function', 'method', 'staticmethod', 'classmethod'):\n            overloads = self.get_overloaded_signatures()\n            if overloads:\n                # Use signatures of overloaded function instead of the implementation.\n                for overload in overloads:\n                    if self.env.config.autodoc_typehints == 'none':\n                        overload_sig = stringify_signature(overload, show_annotation=False, \n                                                         show_return_annotation=False)\n                    else:\n                        overload_sig = stringify_signature(overload, **kwargs)\n                    self.add_line('   .. %s:: %s%s' %\n                                  (self.directivetype, self.name, overload_sig),\n                                  sourcename)\n                continue\n\n        if sig:\n            self.add_line('   .. %s:: %s%s' % (self.directivetype, self.name, sig),\n                          sourcename)\n        else:\n            self.add_line('   .. %s:: %s' % (self.directivetype, self.name),\n                          sourcename)\n    if self.options.noindex:\n        self.add_line('   :noindex:', sourcename)\n    if self.objpath:\n        # Be explicit about the module, this is necessary since .. class::\n        # etc. don't support a prepended module name\n        self.add_line('   :module: %s' % self.modname, sourcename)\n",
      "\ndef _get_overloaded_signatures(self) -> List[inspect.Signature]:\n    if self.analyzer and self.analyzer.overloads.get(self.objpath):\n        # use signatures of overloaded function instead of the implementation\n        return self.analyzer.overloads.get(self.objpath)\n    else:\n        return []\n\ndef format_signature(self, **kwargs: Any) -> str:\n    if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore\n        # only act if a signature is not explicitly given already, and if\n        # the feature is enabled\n        result = self._find_signature()\n        if result is not None:\n            self.args, self.retann = result\n    sig = super().format_signature(**kwargs)  # type: ignore\n    if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n        # Use signatures of overloaded function instead of the implementation\n        overloaded_sigs = self._get_overloaded_signatures()\n        if overloaded_sigs:\n            # Determine if typehints should be shown based on config\n            show_typehints = self.env.config.autodoc_typehints != 'none'\n            \n            sig = self._stringify_signature(overloaded_sigs[0], **kwargs)\n            if len(overloaded_sigs) > 1:\n                sig += \"\\n\" + \"\\n\".join([self._stringify_signature(overload, \n                                                                  show_annotation=show_typehints,\n                                                                  show_return_annotation=show_typehints) \n                                        for overload in overloaded_sigs[1:]])\n    return sig\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..93c1891dc 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1260,13 +1260,18 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n-                sig = stringify_signature(overload, **kwargs)\n+                if self.env.config.autodoc_typehints == 'none':\n+                    sig = stringify_signature(overload, show_annotation=False, \n+                                            show_return_annotation=False, **kwargs)\n+                else:\n+                    sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n         return \"\\n\".join(sigs)\n@@ -1473,6 +1478,7 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n         sig = super().format_signature()\n         sigs = []\n \n+\n         overloads = self.get_overloaded_signatures()\n         if overloads:\n             # Use signatures for overloaded methods instead of the implementation method.\n@@ -1485,7 +1491,11 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                 parameters = list(overload.parameters.values())\n                 overload = overload.replace(parameters=parameters[1:],\n                                             return_annotation=Parameter.empty)\n-                sig = stringify_signature(overload, **kwargs)\n+                if self.env.config.autodoc_typehints == 'none':\n+                    sig = stringify_signature(overload, show_annotation=False, \n+                                            show_return_annotation=False, **kwargs)\n+                else:\n+                    sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n         else:\n             sigs.append(sig)\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..fbf4b89f0 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,6 +546,7 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n+\n def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n                         show_return_annotation: bool = True) -> str:\n     \"\"\"Stringify a Signature object.\n",
    "variant_0": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..756e1cd50 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1260,12 +1260,20 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                # Check autodoc_typehints setting and suppress annotations if needed\n+                if self.env.config.autodoc_typehints == 'none':\n+                    kwargs.update({\n+                        'show_annotation': False,\n+                        'show_return_annotation': False\n+                    })\n+                \n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1466,6 +1474,13 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n \n         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n \n+    def format_signature(self, **kwargs: Any) -> str:\n+        if self.doc_as_attr:\n+            return ''\n+\n+        sig = super().format_signature()\n+        sigs = []\n+\n     def format_signature(self, **kwargs: Any) -> str:\n         if self.doc_as_attr:\n             return ''\n@@ -1485,14 +1500,17 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                 parameters = list(overload.parameters.values())\n                 overload = overload.replace(parameters=parameters[1:],\n                                             return_annotation=Parameter.empty)\n+                \n+                # Check autodoc_typehints config and suppress annotations if needed\n+                if self.env.config.autodoc_typehints == 'none':\n+                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n+                \n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n         else:\n             sigs.append(sig)\n \n         return \"\\n\".join(sigs)\n-\n-    def get_overloaded_signatures(self) -> List[Signature]:\n         if self._signature_class and self._signature_method_name:\n             for cls in self._signature_class.__mro__:\n                 try:\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..6676cbcf1 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,56 +546,51 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n-    \"\"\"Stringify a Signature object.\n \n-    :param show_annotation: Show annotation in result\n-    \"\"\"\n-    args = []\n-    last_kind = None\n-    for param in sig.parameters.values():\n-        if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:\n-            # PEP-570: Separator for Positional Only Parameter: /\n-            args.append('/')\n-        if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n-                                                              param.POSITIONAL_ONLY,\n-                                                              None):\n-            # PEP-3102: Separator for Keyword Only Parameter: *\n-            args.append('*')\n-\n-        arg = StringIO()\n-        if param.kind == param.VAR_POSITIONAL:\n-            arg.write('*' + param.name)\n-        elif param.kind == param.VAR_KEYWORD:\n-            arg.write('**' + param.name)\n-        else:\n-            arg.write(param.name)\n-\n-        if show_annotation and param.annotation is not param.empty:\n-            arg.write(': ')\n-            arg.write(stringify_annotation(param.annotation))\n-        if param.default is not param.empty:\n-            if show_annotation and param.annotation is not param.empty:\n-                arg.write(' = ')\n+def _get_overloaded_signatures(self) -> List[inspect.Signature]:\n+    if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n+        # Use signatures from static analysis if available\n+        return self.analyzer.overloads['.'.join(self.objpath)]\n+\n+    overloads = self.get_overloaded_signatures()\n+    if overloads:\n+        # create signature from first overload\n+        overload = overloads[0]\n+        parameters = list(overload.parameters.values())\n+        return_annotation = overload.return_annotation\n+        if self.parent and inspect.isclass(self.parent.object):\n+            # remove first argument from overload\n+            parameters.pop(0)\n+        overload = overload.replace(parameters=parameters,\n+                                    return_annotation=return_annotation)\n+        return [overload]\n+    else:\n+        return []\n+\n+def format_signature(self, **kwargs: Any) -> str:\n+    if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n+        # Use signatures from static analysis if available\n+        overloads = self.analyzer.overloads['.'.join(self.objpath)]\n+        if overloads:\n+            sig = overloads[0]\n+            return format_args_and_retann(sig, self.env.config)\n+\n+    overloads = self.get_overloaded_signatures()\n+    if overloads:\n+        # show overloaded signatures\n+        overload_sigs = []\n+        for overload in overloads:\n+            # Check autodoc_typehints configuration\n+            if self.env.config.autodoc_typehints == 'none':\n+                overload_sig = stringify_signature(overload, show_annotation=False, \n+                                                 show_return_annotation=False, **kwargs)\n             else:\n-                arg.write('=')\n-            arg.write(object_description(param.default))\n-\n-        args.append(arg.getvalue())\n-        last_kind = param.kind\n-\n-    if last_kind == Parameter.POSITIONAL_ONLY:\n-        # PEP-570: Separator for Positional Only Parameter: /\n-        args.append('/')\n+                overload_sig = stringify_signature(overload, **kwargs)\n+            overload_sigs.append(overload_sig)\n \n-    if (sig.return_annotation is Parameter.empty or\n-            show_annotation is False or\n-            show_return_annotation is False):\n-        return '(%s)' % ', '.join(args)\n+        return \"\\n\".join(overload_sigs)\n     else:\n-        annotation = stringify_annotation(sig.return_annotation)\n-        return '(%s) -> %s' % (', '.join(args), annotation)\n+        return super().format_signature(**kwargs)\n \n \n def signature_from_str(signature: str) -> inspect.Signature:\n",
    "variant_1": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..73525dd3b 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1260,12 +1260,17 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                # Check autodoc_typehints configuration to suppress type hints if needed\n+                if self.env.config.autodoc_typehints == 'none':\n+                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n+                \n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1466,6 +1471,13 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n \n         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n \n+    def format_signature(self, **kwargs: Any) -> str:\n+        if self.doc_as_attr:\n+            return ''\n+\n+        sig = super().format_signature()\n+        sigs = []\n+\n     def format_signature(self, **kwargs: Any) -> str:\n         if self.doc_as_attr:\n             return ''\n@@ -1485,14 +1497,15 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                 parameters = list(overload.parameters.values())\n                 overload = overload.replace(parameters=parameters[1:],\n                                             return_annotation=Parameter.empty)\n+                # Check autodoc_typehints configuration and suppress type hints if needed\n+                if self.env.config.autodoc_typehints == 'none':\n+                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n         else:\n             sigs.append(sig)\n \n         return \"\\n\".join(sigs)\n-\n-    def get_overloaded_signatures(self) -> List[Signature]:\n         if self._signature_class and self._signature_method_name:\n             for cls in self._signature_class.__mro__:\n                 try:\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..cca023f9d 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,56 +546,81 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n-    \"\"\"Stringify a Signature object.\n \n-    :param show_annotation: Show annotation in result\n-    \"\"\"\n-    args = []\n-    last_kind = None\n-    for param in sig.parameters.values():\n-        if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:\n-            # PEP-570: Separator for Positional Only Parameter: /\n-            args.append('/')\n-        if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n-                                                              param.POSITIONAL_ONLY,\n-                                                              None):\n-            # PEP-3102: Separator for Keyword Only Parameter: *\n-            args.append('*')\n-\n-        arg = StringIO()\n-        if param.kind == param.VAR_POSITIONAL:\n-            arg.write('*' + param.name)\n-        elif param.kind == param.VAR_KEYWORD:\n-            arg.write('**' + param.name)\n-        else:\n-            arg.write(param.name)\n-\n-        if show_annotation and param.annotation is not param.empty:\n-            arg.write(': ')\n-            arg.write(stringify_annotation(param.annotation))\n-        if param.default is not param.empty:\n-            if show_annotation and param.annotation is not param.empty:\n-                arg.write(' = ')\n-            else:\n-                arg.write('=')\n-            arg.write(object_description(param.default))\n+def _get_overloaded_signatures(self) -> List[inspect.Signature]:\n+    if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n+        # Use signatures from static analysis if available\n+        return self.analyzer.overloads['.'.join(self.objpath)]\n \n-        args.append(arg.getvalue())\n-        last_kind = param.kind\n+    overloads = get_overloaded_signatures(self.object)\n+    if overloads:\n+        # Filter out the implementation signature\n+        overloads = [sig for sig in overloads if sig != inspect.signature(self.object)]\n \n-    if last_kind == Parameter.POSITIONAL_ONLY:\n-        # PEP-570: Separator for Positional Only Parameter: /\n-        args.append('/')\n+    return overloads\n \n-    if (sig.return_annotation is Parameter.empty or\n-            show_annotation is False or\n-            show_return_annotation is False):\n-        return '(%s)' % ', '.join(args)\n-    else:\n-        annotation = stringify_annotation(sig.return_annotation)\n-        return '(%s) -> %s' % (', '.join(args), annotation)\n+def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n+    \"\"\"Decode and return lines of the docstring(s) for the object.\"\"\"\n+    if encoding is not None:\n+        warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n+                      % self.__class__.__name__,\n+                      RemovedInSphinx40Warning, stacklevel=2)\n+    docstring = getdoc(self.object, self.get_attr,\n+                       self.env.config.autodoc_inherit_docstrings,\n+                       self.parent, self.object_name)\n+    if docstring:\n+        tab_width = self.directive.state.document.settings.tab_width\n+        return [prepare_docstring(docstring, ignore, tab_width)]\n+    return []\n+\n+# data descriptors\n+def add_directive_header(self, sig: str) -> None:\n+    sourcename = self.get_sourcename()\n+    if not self.options.annotation:\n+        # obtain type annotation for this data\n+        try:\n+            annotations = get_type_hints(self.parent)\n+        except NameError:\n+            # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)\n+            annotations = safe_getattr(self.parent, '__annotations__', {})\n+        except TypeError:\n+            annotations = {}\n+        except KeyError:\n+            # a broken class\n+            annotations = {}\n+        except AttributeError:\n+            # AttributeError is raised on 3.5.2 (fixed by 3.5.3)\n+            annotations = {}\n+\n+        if self.objpath[-1] in annotations:\n+            objrepr = stringify_annotation(annotations[self.objpath[-1]])\n+            self.add_line('   :type: ' + objrepr, sourcename)\n+\n+    # Determine if type hints should be shown based on config\n+    show_typehints = self.env.config.autodoc_typehints != 'none'\n+    \n+    overloads = self._get_overloaded_signatures()\n+    if overloads:\n+        # Use signatures from overloads\n+        for overload in overloads:\n+            kwargs = {}\n+            if not show_typehints:\n+                kwargs['show_annotation'] = False\n+                kwargs['show_return_annotation'] = False\n+            overload_sig = stringify_signature(overload, **kwargs)\n+            self.add_line(\"   @overload\", sourcename)\n+            self.add_line(\"   def %s%s: ...\" % (self.object_name, overload_sig), sourcename)\n+        self.add_line(\"\", sourcename)\n+\n+    # add signature\n+    try:\n+        sig = self.format_signature()\n+    except TypeError as exc:\n+        logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n+                       self.fullname, exc)\n+        return\n+    if sig:\n+        self.add_line('   ' + sig, sourcename)\n \n \n def signature_from_str(signature: str) -> inspect.Signature:\n",
    "variant_2": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..cc5d0f3dd 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1260,12 +1260,18 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                # Check autodoc_typehints configuration for overloads\n+                if self.env.config.autodoc_typehints == 'none':\n+                    kwargs['show_annotation'] = False\n+                    kwargs['show_return_annotation'] = False\n+                \n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1466,6 +1472,13 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n \n         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n \n+    def format_signature(self, **kwargs: Any) -> str:\n+        if self.doc_as_attr:\n+            return ''\n+\n+        sig = super().format_signature()\n+        sigs = []\n+\n     def format_signature(self, **kwargs: Any) -> str:\n         if self.doc_as_attr:\n             return ''\n@@ -1485,14 +1498,17 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                 parameters = list(overload.parameters.values())\n                 overload = overload.replace(parameters=parameters[1:],\n                                             return_annotation=Parameter.empty)\n-                sig = stringify_signature(overload, **kwargs)\n+                # Check autodoc_typehints config to suppress type hints if set to 'none'\n+                if self.env.config.autodoc_typehints == 'none':\n+                    sig = stringify_signature(overload, show_annotation=False, \n+                                            show_return_annotation=False, **kwargs)\n+                else:\n+                    sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n         else:\n             sigs.append(sig)\n \n         return \"\\n\".join(sigs)\n-\n-    def get_overloaded_signatures(self) -> List[Signature]:\n         if self._signature_class and self._signature_method_name:\n             for cls in self._signature_class.__mro__:\n                 try:\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..39179d943 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,56 +546,30 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n-    \"\"\"Stringify a Signature object.\n \n-    :param show_annotation: Show annotation in result\n-    \"\"\"\n-    args = []\n-    last_kind = None\n-    for param in sig.parameters.values():\n-        if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:\n-            # PEP-570: Separator for Positional Only Parameter: /\n-            args.append('/')\n-        if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n-                                                              param.POSITIONAL_ONLY,\n-                                                              None):\n-            # PEP-3102: Separator for Keyword Only Parameter: *\n-            args.append('*')\n-\n-        arg = StringIO()\n-        if param.kind == param.VAR_POSITIONAL:\n-            arg.write('*' + param.name)\n-        elif param.kind == param.VAR_KEYWORD:\n-            arg.write('**' + param.name)\n-        else:\n-            arg.write(param.name)\n-\n-        if show_annotation and param.annotation is not param.empty:\n-            arg.write(': ')\n-            arg.write(stringify_annotation(param.annotation))\n-        if param.default is not param.empty:\n-            if show_annotation and param.annotation is not param.empty:\n-                arg.write(' = ')\n-            else:\n-                arg.write('=')\n-            arg.write(object_description(param.default))\n-\n-        args.append(arg.getvalue())\n-        last_kind = param.kind\n-\n-    if last_kind == Parameter.POSITIONAL_ONLY:\n-        # PEP-570: Separator for Positional Only Parameter: /\n-        args.append('/')\n-\n-    if (sig.return_annotation is Parameter.empty or\n-            show_annotation is False or\n-            show_return_annotation is False):\n-        return '(%s)' % ', '.join(args)\n-    else:\n-        annotation = stringify_annotation(sig.return_annotation)\n-        return '(%s) -> %s' % (', '.join(args), annotation)\n+def _get_overloads_union_signature(self, overloads: List[Signature], display_name: str) -> Optional[Signature]:\n+    # Check if all overloads have the same signature\n+    signatures = [stringify_signature(overload, **self._get_signature_kwargs()) for overload in overloads]\n+    if len(set(signatures)) == 1:\n+        return overloads[0]\n+\n+    # Check if we should show typehints based on autodoc_typehints config\n+    show_typehints = self.env.config.autodoc_typehints != 'none'\n+    \n+    overloads_display = [stringify_signature(overload, \n+                                           show_annotation=show_typehints,\n+                                           show_return_annotation=show_typehints) \n+                        for overload in overloads]\n+    parameters = list(overloads[0].parameters.values())\n+    return_type = \" | \".join(stringify_annotation(overload.return_annotation)\n+                           for overload in overloads)\n+\n+    # Combine all the overloads as a Union\n+    overloads_display = [stringify_signature(overload, \n+                                           show_annotation=show_typehints,\n+                                           show_return_annotation=show_typehints) \n+                        for overload in overloads]\n+    return None\n \n \n def signature_from_str(signature: str) -> inspect.Signature:\n",
    "variant_3": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..393ca5003 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1260,12 +1260,17 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                # Check if typehints should be suppressed\n+                if self.env.config.autodoc_typehints == 'none':\n+                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n+                \n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1466,6 +1471,13 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n \n         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n \n+    def format_signature(self, **kwargs: Any) -> str:\n+        if self.doc_as_attr:\n+            return ''\n+\n+        sig = super().format_signature()\n+        sigs = []\n+\n     def format_signature(self, **kwargs: Any) -> str:\n         if self.doc_as_attr:\n             return ''\n@@ -1485,14 +1497,18 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                 parameters = list(overload.parameters.values())\n                 overload = overload.replace(parameters=parameters[1:],\n                                             return_annotation=Parameter.empty)\n-                sig = stringify_signature(overload, **kwargs)\n+                \n+                # Check autodoc_typehints config and suppress annotations if set to 'none'\n+                if self.env.config.autodoc_typehints == 'none':\n+                    sig = stringify_signature(overload, show_annotation=False, \n+                                            show_return_annotation=False, **kwargs)\n+                else:\n+                    sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n         else:\n             sigs.append(sig)\n \n         return \"\\n\".join(sigs)\n-\n-    def get_overloaded_signatures(self) -> List[Signature]:\n         if self._signature_class and self._signature_method_name:\n             for cls in self._signature_class.__mro__:\n                 try:\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..30e46cedd 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,56 +546,681 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n-    \"\"\"Stringify a Signature object.\n \n-    :param show_annotation: Show annotation in result\n+def add_line(self, line: str, source: str, *lineno: int) -> None:\n+    \"\"\"Append one line of generated reST to the output.\"\"\"\n+    if line.strip():  # not a blank line\n+        self.directive.result.append(self.indent + line, source, *lineno)\n+    else:\n+        self.directive.result.append('', source, *lineno)\n+\n+def add_lines(self, lines: List[str], source: str, *lineno: int) -> None:\n+    \"\"\"Append multiple lines of generated reST to the output.\"\"\"\n+    for line in lines:\n+        self.add_line(line, source, *lineno)\n+\n+def format_args(self, **kwargs: Any) -> str:\n+    \"\"\"Format the argument signature of a callable.\n+\n+    Should return a string to be used as the argument signature.\n+    This function should return None if the object does not have a\n+    signature.\n     \"\"\"\n-    args = []\n-    last_kind = None\n-    for param in sig.parameters.values():\n-        if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:\n-            # PEP-570: Separator for Positional Only Parameter: /\n-            args.append('/')\n-        if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n-                                                              param.POSITIONAL_ONLY,\n-                                                              None):\n-            # PEP-3102: Separator for Keyword Only Parameter: *\n-            args.append('*')\n-\n-        arg = StringIO()\n-        if param.kind == param.VAR_POSITIONAL:\n-            arg.write('*' + param.name)\n-        elif param.kind == param.VAR_KEYWORD:\n-            arg.write('**' + param.name)\n+    if self.args is None and self.env.config.autodoc_docstring_signature:\n+        # only act if a signature is not explicitly given already, and if\n+        # the feature is enabled\n+        result = self._find_signature()\n+        if result is not None:\n+            self.args, self.retann = result\n+    if self.args is not None:\n+        try:\n+            return stringify_signature(self.args, **kwargs)\n+        except TypeError:\n+            # stringify_signature() failed\n+            return None\n+    else:\n+        return None\n+\n+def format_signature(self, **kwargs: Any) -> str:\n+    \"\"\"Format the signature (arguments and return annotation) of the object.\n+\n+    Let the user process it via the ``autodoc-process-signature`` event.\n+    \"\"\"\n+    if self.args is not None:\n+        # signature given explicitly\n+        args = stringify_signature(self.args, **kwargs)\n+    else:\n+        # try to introspect the signature\n+        try:\n+            retann = None\n+            args = self._format_args(**kwargs)\n+            if args:\n+                matched = re.match(r'^(\\(.+\\))\\s+->\\s+(.+)$', args)\n+                if matched:\n+                    args = matched.group(1)\n+                    retann = matched.group(2)\n+        except Exception as exc:\n+            logger.warning(__('error while formatting arguments for %s: %s'),\n+                           self.fullname, exc, type='autodoc')\n+            args = None\n+\n+        if args:\n+            # re-process the signature with the ``autodoc-process-signature`` event\n+            app = self.env.app\n+            try:\n+                result = app.emit('autodoc-process-signature',\n+                                  self.objtype, self.fullname,\n+                                  self.object, self.options, args, retann)\n+                if result:\n+                    args, retann = result\n+            except Exception as exc:\n+                logger.warning(__('error while formatting signature for %s: %s'),\n+                               self.fullname, exc, type='autodoc')\n+                return None\n+\n+    result = args\n+    if self.env.config.autodoc_typehints in ('both', 'description'):\n+        if retann:\n+            result += ' -> ' + retann\n+\n+    return result\n+\n+def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n+                ) -> None:\n+    \"\"\"Add content from docstrings, attribute documentation and user.\"\"\"\n+    # set sourcename and add content from attribute documentation\n+    sourcename = self.get_sourcename()\n+    if self.analyzer:\n+        attr_docs = self.analyzer.find_attr_docs()\n+        if self.objpath:\n+            key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n+            if key in attr_docs:\n+                no_docstring = True\n+                # make a copy of docstring for attributes to avoid cache\n+                # the change of autodoc-process-docstring event.\n+                docstrings = [list(attr_docs[key])]\n+\n+                for i, line in enumerate(self.process_doc(docstrings)):\n+                    self.add_line(line, sourcename, i)\n+\n+    # add content from docstrings\n+    if not no_docstring:\n+        docstrings = self.get_doc() or []\n+        if not docstrings:\n+            # append at least a dummy docstring, so that the event\n+            # autodoc-process-docstring is fired and can add some content\n+            # if desired\n+            docstrings.append([])\n+        for i, line in enumerate(self.process_doc(docstrings)):\n+            self.add_line(line, sourcename, i)\n+\n+    # add additional content (e.g. from document), if present\n+    if more_content:\n+        for line, src in zip(more_content.data, more_content.items):\n+            self.add_line(line, src[0], src[1])\n+\n+def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n+    \"\"\"Return `(members_check_module, members)` where `members` is a\n+    list of `(membername, member)` pairs of the members of *self.object*.\n+\n+    If *want_all* is True, return all members.  Else, only return those\n+    members given by *self.options.members* (which may also be None).\n+    \"\"\"\n+    members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)\n+    if not want_all:\n+        if not self.options.members:\n+            return False, []\n+        # specific members given\n+        selected = []\n+        for name in self.options.members:\n+            if name in members:\n+                selected.append((name, members[name].value))\n+            else:\n+                logger.warning(__('missing attribute %s in object %s') %\n+                               (name, self.fullname), type='autodoc')\n+        return False, selected\n+    elif self.options.inherited_members:\n+        return False, [(m.name, m.value) for m in members.values()]\n+    else:\n+        return False, [(m.name, m.value) for m in members.values()\n+                       if not m.directly_defined]\n+\n+def filter_members(self, members: ObjectMembers, want_all: bool\n+                   ) -> List[Tuple[str, Any, bool]]:\n+    \"\"\"Filter the given member list.\n+\n+    Members are skipped if\n+\n+    - they are private (except if given explicitly or the private-members\n+      option is set)\n+    - they are special methods (except if given explicitly or the\n+      special-members option is set)\n+    - they are undocumented (except if the undoc-members option is set)\n+\n+    The user can override the skipping decision by connecting to the\n+    ``autodoc-skip-member`` event.\n+    \"\"\"\n+    def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+        if inspect.isclass(self.object):\n+            for cls in self.object.__mro__:\n+                if cls.__name__ == self.options.inherited_members and cls != self.object:\n+                    # given member is a member of specified *super class*\n+                    return True\n+                elif name in cls.__dict__:\n+                    return False\n+                elif name in self.get_attr(cls, '__annotations__', {}):\n+                    return False\n+                elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n+                    return False\n+\n+        return False\n+\n+    ret = []\n+\n+    # search for members in source code too\n+    namespace = '.'.join(self.objpath)  # will be empty for modules\n+\n+    if self.analyzer:\n+        attr_docs = self.analyzer.find_attr_docs()\n+    else:\n+        attr_docs = {}\n+\n+    # process members and determine which to skip\n+    for (membername, member) in members:\n+        # if isattr is True, the member is documented as an attribute\n+        if member is INSTANCEATTR:\n+            isattr = True\n+            member = INSTANCEATTR\n+        elif (namespace, membername) in attr_docs:\n+            isattr = True\n         else:\n-            arg.write(param.name)\n-\n-        if show_annotation and param.annotation is not param.empty:\n-            arg.write(': ')\n-            arg.write(stringify_annotation(param.annotation))\n-        if param.default is not param.empty:\n-            if show_annotation and param.annotation is not param.empty:\n-                arg.write(' = ')\n+            isattr = False\n+\n+        doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,\n+                     self.object, membername)\n+        if not isinstance(doc, str):\n+            # Ignore non-string __doc__\n+            doc = None\n+\n+        # if the member __doc__ is the same as self's __doc__, it's just\n+        # inherited and therefore not the member's doc\n+        cls = self.get_attr(member, '__objclass__', None)\n+        if cls:\n+            cls_doc = self.get_attr(cls, '__doc__', None)\n+            if cls_doc == doc:\n+                doc = None\n+\n+        if isinstance(obj, ObjectMember) and obj.skipped:\n+            pass\n+\n+        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+            if inspect.isclass(self.object):\n+                for cls in self.object.__mro__:\n+                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n+                        # given member is a member of specified *super class*\n+                        return True\n+                    elif name in cls.__dict__:\n+                        return False\n+                    elif name in self.get_attr(cls, '__annotations__', {}):\n+                        return False\n+                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n+                        return False\n+\n+            return False\n+\n+        has_doc = getdoc(member, self.get_attr,\n+                         self.env.config.autodoc_inherit_docstrings,\n+                         self.object, membername) is not None\n+\n+        def isfunc(obj: Any) -> bool:\n+            return inspect.isfunction(obj) or inspect.ismethod(obj)\n+\n+        def isclass(obj: Any) -> bool:\n+            return inspect.isclass(obj)\n+\n+        def isexception(obj: Any) -> bool:\n+            return inspect.isclass(obj) and issubclass(obj, BaseException)\n+\n+        def isattribute(obj: Any) -> bool:\n+            return not isfunc(obj) and not isclass(obj) and not inspect.ismodule(obj)\n+\n+        # give the user a chance to decide whether this member\n+        # should be skipped\n+        if self.env.app:\n+            # let extensions preprocess docstrings\n+            try:\n+                skip_user = self.env.app.emit_firstresult('autodoc-skip-member',\n+                                                          self.objtype, membername,\n+                                                          member, not has_doc, self.options)\n+                if skip_user is not None:\n+                    if skip_user:\n+                        continue\n+            except Exception as exc:\n+                logger.warning(__('autodoc: failed to determine %r to be documented, '\n+                                  'the following exception was raised:\\n%s'),\n+                               member, exc, type='autodoc')\n+                continue\n+\n+        # check various conditions and decide whether to add the member\n+        def check_private(name: str, obj: Any) -> bool:\n+            if name.startswith('_'):\n+                if name.startswith('__') and name.endswith('__') and len(name) > 4:\n+                    # special method\n+                    if self.options.special_members and name in self.options.special_members:\n+                        return False\n+                    elif self.options.special_members is not ALL:\n+                        return True\n+                elif self.options.private_members and name in self.options.private_members:\n+                    return False\n+                elif self.options.private_members is not ALL:\n+                    return True\n+            return False\n+\n+        def check_module(obj: Any) -> bool:\n+            return not (self.options.ignore_module_all and\n+                        '__all__' in dir(self.object) and\n+                        membername not in self.object.__all__)\n+\n+        if check_private(membername, member):\n+            continue\n+\n+        if not check_module(member):\n+            continue\n+\n+        if self.options.inherited_members is not None:\n+            if is_filtered_inherited_member(membername, member):\n+                continue\n+\n+        if not has_doc:\n+            if self.options.undoc_members:\n+                # show the member without a docstring\n+                pass\n             else:\n-                arg.write('=')\n-            arg.write(object_description(param.default))\n+                continue\n+\n+        ret.append((membername, member, isattr))\n \n-        args.append(arg.getvalue())\n-        last_kind = param.kind\n+    return ret\n \n-    if last_kind == Parameter.POSITIONAL_ONLY:\n-        # PEP-570: Separator for Positional Only Parameter: /\n-        args.append('/')\n+def document_members(self, all_members: bool = False) -> None:\n+    \"\"\"Generate reST for member documentation.\n \n-    if (sig.return_annotation is Parameter.empty or\n-            show_annotation is False or\n-            show_return_annotation is False):\n-        return '(%s)' % ', '.join(args)\n+    If *all_members* is True, do all members. Else, only do non-private\n+    members.\n+    \"\"\"\n+    # set current namespace for finding members\n+    self.env.temp_data['autodoc:module'] = self.modname\n+    if self.objpath:\n+        self.env.temp_data['autodoc:class'] = self.objpath[0]\n+\n+    want_all = all_members or self.options.inherited_members or \\\n+        self.options.members is ALL\n+    # find out which members are documentable\n+    members_check_module, members = self.get_object_members(want_all)\n+\n+    # document non-skipped members\n+    memberdocumenters = []\n+    for (mname, member, isattr) in self.filter_members(members, want_all):\n+        classes = [cls for cls in self.documenters.values()\n+                   if cls.can_document_member(member, mname, isattr, self)]\n+        if not classes:\n+            # don't know how to document this member\n+            continue\n+        # prefer the documenter with the highest priority\n+        classes.sort(key=lambda cls: cls.priority)\n+        # give explicitly separated module name, so that members\n+        # of inner classes can be documented\n+        full_mname = self.modname + '::' + \\\n+            '.'.join(self.objpath + [mname])\n+        documenter = classes[-1](self.directive, full_mname, self.indent)\n+        memberdocumenters.append((documenter, isattr))\n+\n+    member_order = self.options.member_order or self.env.config.autodoc_member_order\n+    memberdocumenters = self.sort_members(memberdocumenters, member_order)\n+\n+    for documenter, isattr in memberdocumenters:\n+        documenter.generate(\n+            all_members=True, real_modname=self.real_modname,\n+            check_module=members_check_module and not isattr)\n+\n+def generate(self, more_content: Optional[StringList] = None,\n+             real_modname: str = None,\n+             check_module: bool = False,\n+             all_members: bool = False) -> None:\n+    \"\"\"Generate reST for the object given by *self.name*, and possibly for\n+    its members.\n+\n+    If *more_content* is given, include that content. If *real_modname* is\n+    given, use that module name to find attribute docs. If *check_module* is\n+    True, only generate if the object is defined in the module name it is\n+    imported from. If *all_members* is True, document all members.\n+    \"\"\"\n+    if not self.parse_name():\n+        # need a module to import\n+        logger.warning(\n+            __('don\\'t know which module to import for autodocumenting '\n+               '%r (try placing a \"module\" or \"currentmodule\" directive '\n+               'in the document, or giving an explicit module name)') %\n+            self.name, type='autodoc')\n+        return\n+\n+    # now, import the module and get object to document\n+    if not self.import_object():\n+        return\n+\n+    # If there is no real module defined, figure out which to use.\n+    # The real module is used in the module analyzer to look up the module\n+    # where the attribute documentation would actually be found in.\n+    # This is used for situations where you have a module that collects the\n+    # functions and classes of internal submodules.\n+    guess_modname = self.get_real_modname()\n+    self.real_modname = real_modname or guess_modname\n+\n+    # try to also get a source code analyzer for attribute docs\n+    try:\n+        self.analyzer = ModuleAnalyzer.for_module(self.real_modname)\n+        # parse right now, to get PycodeErrors on parsing (results will\n+        # be cached anyway)\n+        self.analyzer.find_attr_docs()\n+    except PycodeError as exc:\n+        logger.debug('[autodoc] module analyzer failed: %s', exc)\n+        # no source file -- e.g. for builtin and C modules\n+        self.analyzer = None\n+        # at least add the module.__file__ as a dependency\n+        if hasattr(self.object, '__file__') and self.object.__file__:\n+            self.directive.filename_set.add(self.object.__file__)\n     else:\n-        annotation = stringify_annotation(sig.return_annotation)\n-        return '(%s) -> %s' % (', '.join(args), annotation)\n+        self.directive.filename_set.add(self.analyzer.srcname)\n+\n+    if self.real_modname != guess_modname:\n+        # Add module to dependency list if target object is defined in other module.\n+        try:\n+            analyzer = ModuleAnalyzer.for_module(guess_modname)\n+            self.directive.filename_set.add(analyzer.srcname)\n+        except PycodeError:\n+            pass\n+\n+    # check __module__ of object (for members not given explicitly)\n+    if check_module:\n+        if not self.check_module():\n+            return\n+\n+    sourcename = self.get_sourcename()\n+\n+    # make sure that the result starts with an empty line.  This is\n+    # necessary for some situations where another directive preprocesses\n+    # reST and no starting newline is present\n+    self.add_line('', sourcename)\n+\n+    # format the object's signature, if any\n+    try:\n+        sig = self.format_signature()\n+    except Exception as exc:\n+        logger.warning(__('error while formatting signature for %s: %s'),\n+                       self.fullname, exc, type='autodoc')\n+        return\n+\n+    # generate the directive header and options, if applicable\n+    self.add_directive_header(sig)\n+    self.add_line('', sourcename)\n+\n+    # e.g. the module directive doesn't have content\n+    self.indent += self.content_indent\n+\n+    # add all content (from docstrings, attribute docs etc.)\n+    self.add_content(more_content)\n+\n+    # document members, if possible\n+    self.document_members(all_members)\n+\n+\n+class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):\n+    \"\"\"\n+    Specialized Documenter subclass for functions.\n+    \"\"\"\n+    objtype = 'function'\n+    member_order = 30\n+\n+    @classmethod\n+    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n+                            ) -> bool:\n+        # supports functions, builtins and bound methods exported at the module level\n+        try:\n+            return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n+                    (inspect.ismethod(member) and member.__self__ is not None and\n+                     # unbound methods on classes are just functions in Python 3, so\n+                     # make sure we don't document them\n+                     not inspect.isclass(member.__self__)))\n+        except AttributeError:\n+            return False\n+\n+    def format_args(self, **kwargs: Any) -> str:\n+        if self.env.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n+            kwargs.setdefault('show_return_annotation', False)\n+\n+        if self.config.autodoc_typehints_format == \"short\":\n+            kwargs.setdefault('unqualified_typehints', True)\n+\n+        try:\n+            self._signature_arguments, self._signature_return_annotation = \\\n+                stringify_signature(inspect.signature(self.object), **kwargs).split(' -> ')\n+        except ValueError:\n+            self._signature_arguments = \\\n+                stringify_signature(inspect.signature(self.object), **kwargs)\n+            self._signature_return_annotation = None\n+\n+        # escape asterisks; `foo(*, bar)` should not become `foo(*, bar)`\n+        args = self._signature_arguments.replace('\\\\*', r'\\*')\n+        return args\n+\n+    def document_members(self, all_members: bool = False) -> None:\n+        pass\n+\n+    def add_directive_header(self, sig: str) -> None:\n+        sourcename = self.get_sourcename()\n+        super().add_directive_header(sig)\n+\n+        if inspect.iscoroutinefunction(self.object):\n+            self.add_line('   :async:', sourcename)\n+\n+    def format_signature(self, **kwargs: Any) -> str:\n+        if self.doc_as_attr:\n+            return ''\n+\n+        sigs = []\n+        if (self.analyzer and\n+                '.'.join(self.objpath) in self.analyzer.overloads):\n+            # Use signatures for overloaded functions instead of the implementation function.\n+            overloaded = True\n+        else:\n+            overloaded = False\n+            sig = inspect.signature(self.object)\n+            sigs.append(sig)\n+\n+        if overloaded:\n+            actual = inspect.signature(self.object)\n+            for overload in self.analyzer.overloads['.'.join(self.objpath)]:\n+                if self.env.config.autodoc_typehints == 'none':\n+                    sig = stringify_signature(overload, show_annotation=False, show_return_annotation=False, **kwargs)\n+                else:\n+                    sig = stringify_signature(overload, **kwargs)\n+                sigs.append(sig)\n+\n+            if not any(type_sig == actual for type_sig in sigs):\n+                sigs.append(actual)\n+\n+        return_annotation = None\n+        if sigs:\n+            if self.env.config.autodoc_typehints in ('both', 'description'):\n+                if hasattr(sigs[0], 'return_annotation') and sigs[0].return_annotation:\n+                    return_annotation = stringify_annotation(sigs[0].return_annotation)\n+\n+        if self.env.config.autodoc_typehints == 'none':\n+            # Remove type hints from all signatures\n+            formatted_sigs = []\n+            for sig in sigs:\n+                if isinstance(sig, str):\n+                    # Already formatted signature string\n+                    formatted_sigs.append(sig)\n+                else:\n+                    # Signature object - format without annotations\n+                    formatted_sigs.append(stringify_signature(sig, show_annotation=False, show_return_annotation=False, **kwargs))\n+            sigs = formatted_sigs\n+\n+        if len(sigs) == 1:\n+            return stringify_signature(sigs[0], **kwargs)\n+        else:\n+            return \"\\n\".join([stringify_signature(sig, **kwargs) for sig in sigs])\n+\n+\n+class SingledispatchFunctionDocumenter(FunctionDocumenter):\n+    \"\"\"\n+    Used to be a specialized Documenter subclass for singledispatch'ed functions.\n+\n+    Retained for backwards compatibility, now does the same as the FunctionDocumenter\n+    \"\"\"\n+\n+    def document_members(self, all_members: bool = False) -> None:\n+        pass\n+\n+\n+class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):\n+    \"\"\"\n+    Specialized Documenter subclass for methods (normal, static and class).\n+    \"\"\"\n+    objtype = 'method'\n+    member_order = 50\n+    priority = 1  # must be more than FunctionDocumenter\n+\n+    @classmethod\n+    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n+                            ) -> bool:\n+        try:\n+            return inspect.ismethod(member) or inspect.isfunction(member)\n+        except AttributeError:\n+            return False\n+\n+    def import_object(self, raiseerror: bool = False) -> bool:\n+        ret = super().import_object(raiseerror)\n+        if not ret:\n+            return ret\n+\n+        # to distinguish classmethod/staticmethod from instancemethod,\n+        # we have to import the module and inspect the class directly.\n+        if inspect.isfunction(self.object):\n+            self.directivetype = 'method'\n+            if isinstance(self.parent, ClassDocumenter):\n+                if self.name in self.parent.object.__dict__:\n+                    obj = self.parent.object.__dict__[self.name]\n+                    if isinstance(obj, staticmethod):\n+                        self.directivetype = 'staticmethod'\n+                    elif isinstance(obj, classmethod):\n+                        self.directivetype = 'classmethod'\n+        elif inspect.ismethod(self.object):\n+            if self.object.__self__ is not None and \\\n+               (inspect.isclass(self.object.__self__) or\n+                inspect.ismodule(self.object.__self__)):\n+                # method is bound to a class or module\n+                self.directivetype = 'method'\n+            else:\n+                # method is bound to an instance\n+                self.directivetype = 'method'\n+\n+        return ret\n+\n+    def format_args(self, **kwargs: Any) -> str:\n+        if self.env.config.autodoc_typehints in ('none', 'description'):\n+            kwargs.setdefault('show_annotation', False)\n+            kwargs.setdefault('show_return_annotation', False)\n+\n+        if self.config.autodoc_typehints_format == \"short\":\n+            kwargs.setdefault('unqualified_typehints', True)\n+\n+        try:\n+            if self.object == object.__init__ and self.parent != object:\n+                # Classes not having own __init__ method are shown as no arguments.\n+                #\n+                # Note: The signature of object.__init__ is (self, /, *args, **kwargs).\n+                #       This will be appeared when the class does not have __init__ method.\n+                #       So we need to avoid this.\n+                args = '()'\n+                return args\n+            else:\n+                if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n+                    self._signature_arguments, self._signature_return_annotation = \\\n+                        stringify_signature(inspect.signature(self.object), **kwargs).split(' -> ')\n+                else:\n+                    if inspect.ismethod(self.object):\n+                        # strip off the first argument: bound methods provide the binding\n+                        # automatically, and we always document a method as if it is a bound method,\n+                        # even if accessed through the class.\n+                        args = stringify_signature(inspect.signature(self.object), **kwargs)\n+                        args = args.replace('(self, ', '(').replace('(self)', '()')\n+                    else:\n+                        args = stringify_signature(inspect.signature(self.object), **kwargs)\n+\n+                try:\n+                    self._signature_arguments, self._signature_return_annotation = \\\n+                        args.split(' -> ')\n+                except ValueError:\n+                    self._signature_arguments = args\n+                    self._signature_return_annotation = None\n+\n+        except (TypeError, ValueError):\n+            args = ''\n+\n+        return self._signature_arguments\n+\n+    def document_members(self, all_members: bool = False) -> None:\n+        pass\n+\n+    def format_signature(self, **kwargs: Any) -> str:\n+        if self.doc_as_attr:\n+            return ''\n+\n+        sigs = []\n+        if (self.analyzer and\n+                '.'.join(self.objpath) in self.analyzer.overloads):\n+            # Use signatures for overloaded functions instead of the implementation function.\n+            overloaded = True\n+        else:\n+            overloaded = False\n+\n+        if overloaded:\n+            for overload in self.analyzer.overloads['.'.join(self.objpath)]:\n+                if self.env.config.autodoc_typehints == 'none':\n+                    sig = stringify_signature(overload, show_annotation=False, show_return_annotation=False, **kwargs)\n+                else:\n+                    sig = stringify_signature(overload, **kwargs)\n+                sigs.append(sig)\n+        else:\n+            sig = inspect.signature(self.object)\n+            sigs.append(sig)\n+\n+        if self.env.config.autodoc_typehints == 'none':\n+            # Remove type hints from all signatures\n+            formatted_sigs = []\n+            for sig in sigs:\n+                if isinstance(sig, str):\n+                    # Already formatted signature string\n+                    formatted_sigs.append(sig)\n+                else:\n+                    # Signature object - format without annotations\n+                    formatted_sigs.append(stringify_signature(sig, show_annotation=False, show_return_annotation=False, **kwargs))\n+            sigs = formatted_sigs\n+\n+        if len(sigs) == 1:\n+            return stringify_signature(sigs[0], **kwargs)\n+        else:\n+            return \"\\n\".join([stringify_signature(sig, **kwargs) for sig in sigs])\n+\n+    def add_directive_header(self, sig: str) -> None:\n+        sourcename = self.get_sourcename()\n+        super().add_directive_header(sig)\n+\n+        if inspect.iscoroutinefunction(self.object):\n+            self.add_line('   :async:', sourcename)\n \n \n def signature_from_str(signature: str) -> inspect.Signature:\n",
    "variant_4": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..3e655d7c8 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1260,12 +1260,17 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                # Check autodoc_typehints setting and suppress typehints if set to 'none'\n+                if self.env.config.autodoc_typehints == 'none':\n+                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n+                \n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1466,6 +1471,13 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n \n         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n \n+    def format_signature(self, **kwargs: Any) -> str:\n+        if self.doc_as_attr:\n+            return ''\n+\n+        sig = super().format_signature()\n+        sigs = []\n+\n     def format_signature(self, **kwargs: Any) -> str:\n         if self.doc_as_attr:\n             return ''\n@@ -1485,14 +1497,17 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                 parameters = list(overload.parameters.values())\n                 overload = overload.replace(parameters=parameters[1:],\n                                             return_annotation=Parameter.empty)\n+                \n+                # Check autodoc_typehints configuration\n+                if self.env.config.autodoc_typehints == 'none':\n+                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n+                \n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n         else:\n             sigs.append(sig)\n \n         return \"\\n\".join(sigs)\n-\n-    def get_overloaded_signatures(self) -> List[Signature]:\n         if self._signature_class and self._signature_method_name:\n             for cls in self._signature_class.__mro__:\n                 try:\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..56300cd4b 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,56 +546,41 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n-    \"\"\"Stringify a Signature object.\n \n-    :param show_annotation: Show annotation in result\n-    \"\"\"\n-    args = []\n-    last_kind = None\n-    for param in sig.parameters.values():\n-        if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:\n-            # PEP-570: Separator for Positional Only Parameter: /\n-            args.append('/')\n-        if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n-                                                              param.POSITIONAL_ONLY,\n-                                                              None):\n-            # PEP-3102: Separator for Keyword Only Parameter: *\n-            args.append('*')\n-\n-        arg = StringIO()\n-        if param.kind == param.VAR_POSITIONAL:\n-            arg.write('*' + param.name)\n-        elif param.kind == param.VAR_KEYWORD:\n-            arg.write('**' + param.name)\n-        else:\n-            arg.write(param.name)\n-\n-        if show_annotation and param.annotation is not param.empty:\n-            arg.write(': ')\n-            arg.write(stringify_annotation(param.annotation))\n-        if param.default is not param.empty:\n-            if show_annotation and param.annotation is not param.empty:\n-                arg.write(' = ')\n-            else:\n-                arg.write('=')\n-            arg.write(object_description(param.default))\n-\n-        args.append(arg.getvalue())\n-        last_kind = param.kind\n-\n-    if last_kind == Parameter.POSITIONAL_ONLY:\n-        # PEP-570: Separator for Positional Only Parameter: /\n-        args.append('/')\n-\n-    if (sig.return_annotation is Parameter.empty or\n-            show_annotation is False or\n-            show_return_annotation is False):\n-        return '(%s)' % ', '.join(args)\n-    else:\n-        annotation = stringify_annotation(sig.return_annotation)\n-        return '(%s) -> %s' % (', '.join(args), annotation)\n+def _get_overloaded_signatures(self) -> List[inspect.Signature]:\n+    if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n+        # Use signatures from the analyzer if available\n+        return self.analyzer.overloads['.'.join(self.objpath)]\n+\n+    if self.object:\n+        # Check for @overload decorations in the same module\n+        qualname = self.object.__qualname__\n+        overloads = []\n+        for name, obj in inspect.getmembers(inspect.getmodule(self.object)):\n+            if (inspect.isfunction(obj) and\n+                hasattr(obj, '__qualname__') and\n+                obj.__qualname__ == qualname and\n+                self._is_overload(obj)):\n+                overloads.append(inspect.signature(obj))\n+        return overloads\n+\n+    return []\n+\n+def format_signature(self, **kwargs: Any) -> str:\n+    def process_signature(sig: inspect.Signature) -> str:\n+        show_annotations = self.env.config.autodoc_typehints != 'none'\n+        return stringify_signature(sig, show_annotation=show_annotations, \n+                                 show_return_annotation=show_annotations, **kwargs)\n+\n+    overloaded_sigs = self._get_overloaded_signatures()\n+    if overloaded_sigs:\n+        # show overloaded signatures\n+        sigs = []\n+        for overload in overloaded_sigs:\n+            sigs.append(process_signature(overload))\n+        return \"\\n\".join(sigs)\n+\n+    return process_signature(self.format_args(**kwargs))\n \n \n def signature_from_str(signature: str) -> inspect.Signature:\n",
    "variant_5": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..795aae6fd 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1260,12 +1260,17 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                # Check autodoc_typehints configuration for overloads\n+                if self.env.config.autodoc_typehints == 'none':\n+                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n+                \n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1466,6 +1471,13 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n \n         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n \n+    def format_signature(self, **kwargs: Any) -> str:\n+        if self.doc_as_attr:\n+            return ''\n+\n+        sig = super().format_signature()\n+        sigs = []\n+\n     def format_signature(self, **kwargs: Any) -> str:\n         if self.doc_as_attr:\n             return ''\n@@ -1485,14 +1497,17 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                 parameters = list(overload.parameters.values())\n                 overload = overload.replace(parameters=parameters[1:],\n                                             return_annotation=Parameter.empty)\n+                \n+                # Check autodoc_typehints config to suppress type hints if needed\n+                if self.env.config.autodoc_typehints == 'none':\n+                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n+                \n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n         else:\n             sigs.append(sig)\n \n         return \"\\n\".join(sigs)\n-\n-    def get_overloaded_signatures(self) -> List[Signature]:\n         if self._signature_class and self._signature_method_name:\n             for cls in self._signature_class.__mro__:\n                 try:\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..9184bb9cb 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,56 +546,38 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n-    \"\"\"Stringify a Signature object.\n \n-    :param show_annotation: Show annotation in result\n-    \"\"\"\n-    args = []\n-    last_kind = None\n-    for param in sig.parameters.values():\n-        if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:\n-            # PEP-570: Separator for Positional Only Parameter: /\n-            args.append('/')\n-        if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n-                                                              param.POSITIONAL_ONLY,\n-                                                              None):\n-            # PEP-3102: Separator for Keyword Only Parameter: *\n-            args.append('*')\n-\n-        arg = StringIO()\n-        if param.kind == param.VAR_POSITIONAL:\n-            arg.write('*' + param.name)\n-        elif param.kind == param.VAR_KEYWORD:\n-            arg.write('**' + param.name)\n-        else:\n-            arg.write(param.name)\n-\n-        if show_annotation and param.annotation is not param.empty:\n-            arg.write(': ')\n-            arg.write(stringify_annotation(param.annotation))\n-        if param.default is not param.empty:\n-            if show_annotation and param.annotation is not param.empty:\n-                arg.write(' = ')\n-            else:\n-                arg.write('=')\n-            arg.write(object_description(param.default))\n-\n-        args.append(arg.getvalue())\n-        last_kind = param.kind\n-\n-    if last_kind == Parameter.POSITIONAL_ONLY:\n-        # PEP-570: Separator for Positional Only Parameter: /\n-        args.append('/')\n+def add_directive_header(self, sig: str) -> None:\n+    sourcename = self.get_sourcename()\n+    if self.doc_as_attr:\n+        self.add_line('   :module: %s' % self.modname, sourcename)\n+    if self.objpath:\n+        # Be explicit about the type, this is necessary since the\n+        # 'show-inheritance' flag may not be set on the directive\n+        self.add_line('   :type: %s' % type(self.object).__name__, sourcename)\n+\n+    # add inheritance info, if wanted\n+    if not self.doc_as_attr and self.options.show_inheritance:\n+        self.add_inheritance_info()\n+\n+    # add overloads info, if exists\n+    if inspect.isfunction(self.object):\n+        overloads = self.get_overloaded_signatures()\n+        if overloads:\n+            __globals = safe_getattr(self.object, '__globals__', {})\n+            for overload in overloads:\n+                overload = evaluate_signature(overload, __globals,\n+                                              self.env.config.autodoc_type_aliases)\n+\n+                if not self.env.config.autodoc_typehints or self.env.config.autodoc_typehints == 'none':\n+                    sig = stringify_signature(overload, show_annotation=False, show_return_annotation=False)\n+                else:\n+                    sig = stringify_signature(overload, **kwargs)\n+                self.add_line(\"   :type %s: %s\" % (self.objpath[-1], sig), sourcename)\n \n-    if (sig.return_annotation is Parameter.empty or\n-            show_annotation is False or\n-            show_return_annotation is False):\n-        return '(%s)' % ', '.join(args)\n-    else:\n-        annotation = stringify_annotation(sig.return_annotation)\n-        return '(%s) -> %s' % (', '.join(args), annotation)\n+    # add signature\n+    if self.options.show_inheritance or self.doc_as_attr:\n+        self.add_line('', sourcename)\n \n \n def signature_from_str(signature: str) -> inspect.Signature:\n",
    "variant_6": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..8a1016bfb 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1260,12 +1260,17 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                # Check if typehints should be suppressed\n+                if self.env.config.autodoc_typehints == 'none':\n+                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n+                \n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1466,6 +1471,13 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n \n         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n \n+    def format_signature(self, **kwargs: Any) -> str:\n+        if self.doc_as_attr:\n+            return ''\n+\n+        sig = super().format_signature()\n+        sigs = []\n+\n     def format_signature(self, **kwargs: Any) -> str:\n         if self.doc_as_attr:\n             return ''\n@@ -1485,14 +1497,15 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                 parameters = list(overload.parameters.values())\n                 overload = overload.replace(parameters=parameters[1:],\n                                             return_annotation=Parameter.empty)\n+                # Check if typehints should be suppressed\n+                if self.env.config.autodoc_typehints == 'none':\n+                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n         else:\n             sigs.append(sig)\n \n         return \"\\n\".join(sigs)\n-\n-    def get_overloaded_signatures(self) -> List[Signature]:\n         if self._signature_class and self._signature_method_name:\n             for cls in self._signature_class.__mro__:\n                 try:\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..b9520a9ad 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,56 +546,41 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n-    \"\"\"Stringify a Signature object.\n \n-    :param show_annotation: Show annotation in result\n-    \"\"\"\n-    args = []\n-    last_kind = None\n-    for param in sig.parameters.values():\n-        if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:\n-            # PEP-570: Separator for Positional Only Parameter: /\n-            args.append('/')\n-        if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n-                                                              param.POSITIONAL_ONLY,\n-                                                              None):\n-            # PEP-3102: Separator for Keyword Only Parameter: *\n-            args.append('*')\n-\n-        arg = StringIO()\n-        if param.kind == param.VAR_POSITIONAL:\n-            arg.write('*' + param.name)\n-        elif param.kind == param.VAR_KEYWORD:\n-            arg.write('**' + param.name)\n-        else:\n-            arg.write(param.name)\n-\n-        if show_annotation and param.annotation is not param.empty:\n-            arg.write(': ')\n-            arg.write(stringify_annotation(param.annotation))\n-        if param.default is not param.empty:\n-            if show_annotation and param.annotation is not param.empty:\n-                arg.write(' = ')\n-            else:\n-                arg.write('=')\n-            arg.write(object_description(param.default))\n-\n-        args.append(arg.getvalue())\n-        last_kind = param.kind\n-\n-    if last_kind == Parameter.POSITIONAL_ONLY:\n-        # PEP-570: Separator for Positional Only Parameter: /\n-        args.append('/')\n-\n-    if (sig.return_annotation is Parameter.empty or\n-            show_annotation is False or\n-            show_return_annotation is False):\n-        return '(%s)' % ', '.join(args)\n+def add_directive_header(self, sig: str) -> None:\n+    sourcename = self.get_sourcename()\n+    if self.objpath:\n+        # Be explicit about the module, this is necessary since .. class::\n+        # etc. don't support a prepended module name\n+        self.add_line('.. %s:: %s.%s%s' % (self.directivetype, self.modname,\n+                                           '.'.join(self.objpath), sig),\n+                      sourcename)\n     else:\n-        annotation = stringify_annotation(sig.return_annotation)\n-        return '(%s) -> %s' % (', '.join(args), annotation)\n+        self.add_line('.. %s:: %s%s' % (self.directivetype, self.fullname, sig),\n+                      sourcename)\n+    if self.options.noindex:\n+        self.add_line('   :noindex:', sourcename)\n+    if self.objpath:\n+        # Be explicit about the module, this is necessary since .. class::\n+        # etc. don't support a prepended module name\n+        self.add_line('', sourcename)\n+\n+    # add inheritance info, if wanted\n+    if not self.doc_as_attr and self.options.show_inheritance:\n+        self.add_inheritance_info()\n+\n+    # add overloads info\n+    if self.analyzer and hasattr(self.analyzer, 'overloads'):\n+        overloads = self.analyzer.overloads.get('.'.join(self.objpath))\n+        if overloads:\n+            self.add_line('', sourcename)\n+            for overload in overloads:\n+                kwargs = {}\n+                if self.env.config.autodoc_typehints == 'none':\n+                    kwargs['show_annotation'] = False\n+                    kwargs['show_return_annotation'] = False\n+                overload_sig = stringify_signature(overload, **kwargs)\n+                self.add_line(\"   :overload: %s\" % overload_sig, sourcename)\n \n \n def signature_from_str(signature: str) -> inspect.Signature:\n",
    "variant_7": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..f27ce02af 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1260,12 +1260,17 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                # Check if typehints should be suppressed\n+                if self.env.config.autodoc_typehints == 'none':\n+                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n+                \n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1466,6 +1471,13 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n \n         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n \n+    def format_signature(self, **kwargs: Any) -> str:\n+        if self.doc_as_attr:\n+            return ''\n+\n+        sig = super().format_signature()\n+        sigs = []\n+\n     def format_signature(self, **kwargs: Any) -> str:\n         if self.doc_as_attr:\n             return ''\n@@ -1485,14 +1497,17 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                 parameters = list(overload.parameters.values())\n                 overload = overload.replace(parameters=parameters[1:],\n                                             return_annotation=Parameter.empty)\n-                sig = stringify_signature(overload, **kwargs)\n+                # Check autodoc_typehints config and suppress annotations if needed\n+                if self.env.config.autodoc_typehints == 'none':\n+                    sig = stringify_signature(overload, show_annotation=False, \n+                                            show_return_annotation=False, **kwargs)\n+                else:\n+                    sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n         else:\n             sigs.append(sig)\n \n         return \"\\n\".join(sigs)\n-\n-    def get_overloaded_signatures(self) -> List[Signature]:\n         if self._signature_class and self._signature_method_name:\n             for cls in self._signature_class.__mro__:\n                 try:\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..76cefbf4c 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,56 +546,40 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n-    \"\"\"Stringify a Signature object.\n \n-    :param show_annotation: Show annotation in result\n-    \"\"\"\n-    args = []\n-    last_kind = None\n-    for param in sig.parameters.values():\n-        if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:\n-            # PEP-570: Separator for Positional Only Parameter: /\n-            args.append('/')\n-        if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n-                                                              param.POSITIONAL_ONLY,\n-                                                              None):\n-            # PEP-3102: Separator for Keyword Only Parameter: *\n-            args.append('*')\n-\n-        arg = StringIO()\n-        if param.kind == param.VAR_POSITIONAL:\n-            arg.write('*' + param.name)\n-        elif param.kind == param.VAR_KEYWORD:\n-            arg.write('**' + param.name)\n-        else:\n-            arg.write(param.name)\n-\n-        if show_annotation and param.annotation is not param.empty:\n-            arg.write(': ')\n-            arg.write(stringify_annotation(param.annotation))\n-        if param.default is not param.empty:\n-            if show_annotation and param.annotation is not param.empty:\n-                arg.write(' = ')\n-            else:\n-                arg.write('=')\n-            arg.write(object_description(param.default))\n-\n-        args.append(arg.getvalue())\n-        last_kind = param.kind\n-\n-    if last_kind == Parameter.POSITIONAL_ONLY:\n-        # PEP-570: Separator for Positional Only Parameter: /\n-        args.append('/')\n-\n-    if (sig.return_annotation is Parameter.empty or\n-            show_annotation is False or\n-            show_return_annotation is False):\n-        return '(%s)' % ', '.join(args)\n+def add_directive_header(self, sig: str) -> None:\n+    sourcename = self.get_sourcename()\n+    if self.doc_as_attr:\n+        self.add_line('   .. %s:: %s' % (self.directivetype, sig),\n+                      sourcename)\n     else:\n-        annotation = stringify_annotation(sig.return_annotation)\n-        return '(%s) -> %s' % (', '.join(args), annotation)\n+        if self.objtype in ('function', 'method', 'staticmethod', 'classmethod'):\n+            overloads = self.get_overloaded_signatures()\n+            if overloads:\n+                # Use signatures of overloaded function instead of the implementation.\n+                for overload in overloads:\n+                    if self.env.config.autodoc_typehints == 'none':\n+                        overload_sig = stringify_signature(overload, show_annotation=False, \n+                                                         show_return_annotation=False)\n+                    else:\n+                        overload_sig = stringify_signature(overload, **kwargs)\n+                    self.add_line('   .. %s:: %s%s' %\n+                                  (self.directivetype, self.name, overload_sig),\n+                                  sourcename)\n+                continue\n+\n+        if sig:\n+            self.add_line('   .. %s:: %s%s' % (self.directivetype, self.name, sig),\n+                          sourcename)\n+        else:\n+            self.add_line('   .. %s:: %s' % (self.directivetype, self.name),\n+                          sourcename)\n+    if self.options.noindex:\n+        self.add_line('   :noindex:', sourcename)\n+    if self.objpath:\n+        # Be explicit about the module, this is necessary since .. class::\n+        # etc. don't support a prepended module name\n+        self.add_line('   :module: %s' % self.modname, sourcename)\n \n \n def signature_from_str(signature: str) -> inspect.Signature:\n",
    "variant_8": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 978fd5df8..59a9a0773 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1260,12 +1260,17 @@ class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # typ\n                     documenter.object = func\n                     documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n+\n         if overloaded:\n             __globals__ = safe_getattr(self.object, '__globals__', {})\n             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n                 overload = evaluate_signature(overload, __globals__,\n                                               self.env.config.autodoc_type_aliases)\n \n+                # Check autodoc_typehints setting and suppress annotations if needed\n+                if self.env.config.autodoc_typehints == 'none':\n+                    kwargs.update({'show_annotation': False, 'show_return_annotation': False})\n+                \n                 sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n \n@@ -1466,6 +1471,13 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n \n         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n \n+    def format_signature(self, **kwargs: Any) -> str:\n+        if self.doc_as_attr:\n+            return ''\n+\n+        sig = super().format_signature()\n+        sigs = []\n+\n     def format_signature(self, **kwargs: Any) -> str:\n         if self.doc_as_attr:\n             return ''\n@@ -1485,14 +1497,18 @@ class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type:\n                 parameters = list(overload.parameters.values())\n                 overload = overload.replace(parameters=parameters[1:],\n                                             return_annotation=Parameter.empty)\n-                sig = stringify_signature(overload, **kwargs)\n+                \n+                # Check autodoc_typehints configuration for overloaded methods\n+                if self.env.config.autodoc_typehints == 'none':\n+                    sig = stringify_signature(overload, show_annotation=False, \n+                                            show_return_annotation=False, **kwargs)\n+                else:\n+                    sig = stringify_signature(overload, **kwargs)\n                 sigs.append(sig)\n         else:\n             sigs.append(sig)\n \n         return \"\\n\".join(sigs)\n-\n-    def get_overloaded_signatures(self) -> List[Signature]:\n         if self._signature_class and self._signature_method_name:\n             for cls in self._signature_class.__mro__:\n                 try:\ndiff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py\nindex f2cd8070b..26816341b 100644\n--- a/sphinx/util/inspect.py\n+++ b/sphinx/util/inspect.py\n@@ -546,56 +546,36 @@ def evaluate_signature(sig: inspect.Signature, globalns: Dict = None, localns: D\n     return sig.replace(parameters=parameters, return_annotation=return_annotation)\n \n \n-def stringify_signature(sig: inspect.Signature, show_annotation: bool = True,\n-                        show_return_annotation: bool = True) -> str:\n-    \"\"\"Stringify a Signature object.\n \n-    :param show_annotation: Show annotation in result\n-    \"\"\"\n-    args = []\n-    last_kind = None\n-    for param in sig.parameters.values():\n-        if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:\n-            # PEP-570: Separator for Positional Only Parameter: /\n-            args.append('/')\n-        if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n-                                                              param.POSITIONAL_ONLY,\n-                                                              None):\n-            # PEP-3102: Separator for Keyword Only Parameter: *\n-            args.append('*')\n-\n-        arg = StringIO()\n-        if param.kind == param.VAR_POSITIONAL:\n-            arg.write('*' + param.name)\n-        elif param.kind == param.VAR_KEYWORD:\n-            arg.write('**' + param.name)\n-        else:\n-            arg.write(param.name)\n-\n-        if show_annotation and param.annotation is not param.empty:\n-            arg.write(': ')\n-            arg.write(stringify_annotation(param.annotation))\n-        if param.default is not param.empty:\n-            if show_annotation and param.annotation is not param.empty:\n-                arg.write(' = ')\n-            else:\n-                arg.write('=')\n-            arg.write(object_description(param.default))\n-\n-        args.append(arg.getvalue())\n-        last_kind = param.kind\n-\n-    if last_kind == Parameter.POSITIONAL_ONLY:\n-        # PEP-570: Separator for Positional Only Parameter: /\n-        args.append('/')\n-\n-    if (sig.return_annotation is Parameter.empty or\n-            show_annotation is False or\n-            show_return_annotation is False):\n-        return '(%s)' % ', '.join(args)\n+def _get_overloaded_signatures(self) -> List[inspect.Signature]:\n+    if self.analyzer and self.analyzer.overloads.get(self.objpath):\n+        # use signatures of overloaded function instead of the implementation\n+        return self.analyzer.overloads.get(self.objpath)\n     else:\n-        annotation = stringify_annotation(sig.return_annotation)\n-        return '(%s) -> %s' % (', '.join(args), annotation)\n+        return []\n+\n+def format_signature(self, **kwargs: Any) -> str:\n+    if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore\n+        # only act if a signature is not explicitly given already, and if\n+        # the feature is enabled\n+        result = self._find_signature()\n+        if result is not None:\n+            self.args, self.retann = result\n+    sig = super().format_signature(**kwargs)  # type: ignore\n+    if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n+        # Use signatures of overloaded function instead of the implementation\n+        overloaded_sigs = self._get_overloaded_signatures()\n+        if overloaded_sigs:\n+            # Determine if typehints should be shown based on config\n+            show_typehints = self.env.config.autodoc_typehints != 'none'\n+            \n+            sig = self._stringify_signature(overloaded_sigs[0], **kwargs)\n+            if len(overloaded_sigs) > 1:\n+                sig += \"\\n\" + \"\\n\".join([self._stringify_signature(overload, \n+                                                                  show_annotation=show_typehints,\n+                                                                  show_return_annotation=show_typehints) \n+                                        for overload in overloaded_sigs[1:]])\n+    return sig\n \n \n def signature_from_str(signature: str) -> inspect.Signature:\n"
  }
}