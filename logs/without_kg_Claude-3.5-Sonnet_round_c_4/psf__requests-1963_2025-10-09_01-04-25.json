{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/requests/requests/sessions.py lines 91-91)": "\nclass SessionRedirectMixin(object):\n    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n",
    "Location 2 (/root/hy/projects_4/requests/requests/sessions.py lines 88-92)": "\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/requests/requests/sessions.py lines 91-91)": [
      "\nclass SessionRedirectMixin(object):\n    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n",
      "\nclass SessionRedirectMixin(object):\n    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n",
      "\nclass SessionRedirectMixin(object):\n    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n",
      "\nclass SessionRedirectMixin(object):\n    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n",
      "\nclass SessionRedirectMixin(object):\n    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n",
      "\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n",
      "\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n",
      "\nclass SessionRedirectMixin(object):\n    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                          verify=True, cert=None, proxies=None):\n        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n\n            resp.content  # Consume socket so it can be released\n\n            if i >= self.max_redirects:\n                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n\n            # Release the connection back into the pool.\n            resp.close()\n\n            url = resp.headers['location']\n"
    ],
    "Location 2 (/root/hy/projects_4/requests/requests/sessions.py lines 88-92)": [
      "\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n",
      "\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n",
      "\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n",
      "\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n",
      "\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n",
      "\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n",
      "\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n",
      "\n        i = 0\n\n        while resp.is_redirect:\n            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n            if i == 0:\n                prepared_request = req.copy()\n            else:\n                prepared_request = prepared_request.copy()\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..d0814067 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,17 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_0": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..fa3f1357 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,37 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n+        i = 0\n+\n+        while resp.is_redirect:\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n+                          verify=True, cert=None, proxies=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_1": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..fa3f1357 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,37 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n+        i = 0\n+\n+        while resp.is_redirect:\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n+                          verify=True, cert=None, proxies=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_2": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..fa3f1357 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,37 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n+        i = 0\n+\n+        while resp.is_redirect:\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n+                          verify=True, cert=None, proxies=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_3": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..fa3f1357 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,37 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n+        i = 0\n+\n+        while resp.is_redirect:\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n+                          verify=True, cert=None, proxies=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_4": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..fa3f1357 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,37 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n+        i = 0\n+\n+        while resp.is_redirect:\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n+                          verify=True, cert=None, proxies=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_5": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..fa3f1357 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,37 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n+        i = 0\n+\n+        while resp.is_redirect:\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n+                          verify=True, cert=None, proxies=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_6": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..2031b096 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,22 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+\n+        while resp.is_redirect:\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_7": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..144bf325 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,32 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+\n+        while resp.is_redirect:\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n \n             resp.content  # Consume socket so it can be released\n \n",
    "variant_8": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 425db22c..fa3f1357 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -85,10 +85,37 @@ class SessionRedirectMixin(object):\n                           verify=True, cert=None, proxies=None):\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n+\n+        i = 0\n+\n+        while resp.is_redirect:\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n+                          verify=True, cert=None, proxies=None):\n+        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+\n         i = 0\n \n         while resp.is_redirect:\n-            prepared_request = req.copy()\n+            # Fix: Copy original request only on first iteration, preserve changes on subsequent iterations\n+            if i == 0:\n+                prepared_request = req.copy()\n+            else:\n+                prepared_request = prepared_request.copy()\n+\n+            resp.content  # Consume socket so it can be released\n+\n+            if i >= self.max_redirects:\n+                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n+\n+            # Release the connection back into the pool.\n+            resp.close()\n+\n+            url = resp.headers['location']\n \n             resp.content  # Consume socket so it can be released\n \n"
  }
}