{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/django/django/contrib/auth/tokens.py lines 97-97)": "\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n",
    "Location 2 (/root/hy/projects_4/django/django/contrib/auth/tokens.py lines 79-93)": "\n    def _make_hash_value(self, user, timestamp):\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change upon an email change, invalidating\n           existing tokens.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n",
    "Location 3 (/root/hy/projects_4/django/tests/auth_tests/test_tokens.py lines 112-112)": "\n        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n\n    def test_token_invalidated_on_email_change(self):\n        \"\"\"Test that password reset tokens are invalidated when user email changes.\"\"\"\n        user = User.objects.create_user('emailchangeuser', 'original@example.com', 'testpw')\n        generator = PasswordResetTokenGenerator()\n        \n        # Generate token with original email\n        original_token = generator.make_token(user)\n        self.assertIs(generator.check_token(user, original_token), True)\n        \n        # Change user email\n        user.email = 'changed@example.com'\n        user.save()\n        \n        # Token should now be invalid\n        self.assertIs(generator.check_token(user, original_token), False)\n\n    def test_token_valid_when_email_unchanged(self):\n        \"\"\"Test that password reset tokens remain valid when email is unchanged.\"\"\"\n        user = User.objects.create_user('unchangedemailuser', 'unchanged@example.com', 'testpw')\n        generator = PasswordResetTokenGenerator()\n        \n        # Generate token\n        token = generator.make_token(user)\n        self.assertIs(generator.check_token(user, token), True)\n        \n        # Change something else (like last_login) but not email\n        user.last_login = datetime.now()\n        user.save()\n        \n        # Token should still be valid\n        self.assertIs(generator.check_token(user, token), True)\n\n    def test_token_with_empty_email(self):\n        \"\"\"Test that tokens work correctly for users without email addresses.\"\"\"\n        user = User.objects.create_user('noemailuser', '', 'testpw')\n        generator = PasswordResetTokenGenerator()\n        \n        # Generate token for user with empty email\n        token = generator.make_token(user)\n        self.assertIs(generator.check_token(user, token), True)\n        \n        # Set email to None and verify token still works\n        user.email = None\n        user.save()\n        self.assertIs(generator.check_token(user, token), True)\n        \n        # Now set an actual email - token should become invalid\n        user.email = 'newemail@example.com'\n        user.save()\n        self.assertIs(generator.check_token(user, token), False)\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/django/django/contrib/auth/tokens.py lines 97-97)": [
      "\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n",
      "\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n",
      "\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n",
      "\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n",
      "\nreturn str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n",
      "\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n",
      "\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n",
      "\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n"
    ],
    "Location 2 (/root/hy/projects_4/django/django/contrib/auth/tokens.py lines 79-93)": [
      "\n    def _make_hash_value(self, user, timestamp):\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change when the user's email is updated,\n           invalidating existing tokens.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n",
      "\n    def _make_hash_value(self, user, timestamp):\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change upon an email change, invalidating\n           existing tokens.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n",
      "\n    def _make_hash_value(self, user, timestamp):\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change when the user's email is updated.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n",
      "\n    def _make_hash_value(self, user, timestamp):\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change upon an email address update, ensuring\n           tokens become invalid when the user's email changes.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n",
      "\n    def _make_hash_value(self, user, timestamp):\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change when the user's email is updated,\n           invalidating existing tokens.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n",
      "\n    def _make_hash_value(self, user, timestamp):\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change if the user updates their email address.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n",
      "\n    def _make_hash_value(self, user, timestamp):\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change if the user's email address is modified.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n",
      "\n    def _make_hash_value(self, user, timestamp):\n        \"\"\"\n        Hash the user's primary key and some user state that's sure to change\n        after a password reset to produce a token that invalidated when it's\n        used:\n        1. The password field will change upon a password reset (even if the\n           same password is chosen, due to password salting).\n        2. The last_login field will usually be updated very shortly after\n           a password reset.\n        3. The email field will change when the user updates their email\n           address, invalidating existing tokens.\n        Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n        invalidates the token.\n\n        Running this data through salted_hmac() prevents password cracking\n        attempts using the reset token, provided the secret isn't compromised.\n        \"\"\"\n        # Truncate microseconds so that tokens are consistent even if the\n        # database doesn't support microseconds.\n        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n"
    ],
    "Location 3 (/root/hy/projects_4/django/tests/auth_tests/test_tokens.py lines 112-112)": [
      "\n        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n\n    def test_token_invalidated_on_email_change(self):\n        \"\"\"Test that password reset tokens are invalidated when user email changes.\"\"\"\n        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n        p_generator = PasswordResetTokenGenerator()\n        \n        # Generate token with original email\n        token = p_generator.make_token(user)\n        self.assertIs(p_generator.check_token(user, token), True)\n        \n        # Change user's email\n        user.email = 'changed@example.com'\n        user.save()\n        \n        # Token should now be invalid\n        self.assertIs(p_generator.check_token(user, token), False)\n\n    def test_token_valid_when_email_unchanged(self):\n        \"\"\"Test that password reset tokens remain valid when email is unchanged.\"\"\"\n        user = User.objects.create_user('emailtestuser2', 'test@example.com', 'testpw')\n        p_generator = PasswordResetTokenGenerator()\n        \n        # Generate token\n        token = p_generator.make_token(user)\n        self.assertIs(p_generator.check_token(user, token), True)\n        \n        # Change something else (like last_login) but not email\n        user.last_login = datetime.now()\n        user.save()\n        \n        # Token should still be valid\n        self.assertIs(p_generator.check_token(user, token), True)\n\n    def test_token_with_empty_email(self):\n        \"\"\"Test that password reset tokens work correctly for users without email.\"\"\"\n        user = User.objects.create_user('noemailuser', '', 'testpw')\n        p_generator = PasswordResetTokenGenerator()\n        \n        # Generate token for user without email\n        token = p_generator.make_token(user)\n        self.assertIs(p_generator.check_token(user, token), True)\n        \n        # Setting email should invalidate token\n        user.email = 'newemail@example.com'\n        user.save()\n        \n        # Token should now be invalid\n        self.assertIs(p_generator.check_token(user, token), False)\n",
      "\n        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n\n    def test_token_invalidated_on_email_change(self):\n        \"\"\"Test that password reset tokens are invalidated when user email changes.\"\"\"\n        user = User.objects.create_user('emailuser', 'original@example.com', 'testpw')\n        generator = PasswordResetTokenGenerator()\n        \n        # Generate token with original email\n        token = generator.make_token(user)\n        self.assertTrue(generator.check_token(user, token))\n        \n        # Change email and verify token is now invalid\n        user.email = 'changed@example.com'\n        user.save()\n        self.assertFalse(generator.check_token(user, token))\n\n    def test_token_valid_when_email_unchanged(self):\n        \"\"\"Test that password reset tokens remain valid when email doesn't change.\"\"\"\n        user = User.objects.create_user('stableuser', 'stable@example.com', 'testpw')\n        generator = PasswordResetTokenGenerator()\n        \n        # Generate token\n        token = generator.make_token(user)\n        self.assertTrue(generator.check_token(user, token))\n        \n        # Save user without changing email\n        user.save()\n        self.assertTrue(generator.check_token(user, token))\n\n    def test_token_with_empty_email(self):\n        \"\"\"Test that password reset tokens work for users without email addresses.\"\"\"\n        user = User.objects.create_user('noemailuser', '', 'testpw')\n        generator = PasswordResetTokenGenerator()\n        \n        # Generate token for user with empty email\n        token = generator.make_token(user)\n        self.assertTrue(generator.check_token(user, token))\n        \n        # Change to non-empty email should invalidate token\n        user.email = 'newemail@example.com'\n        user.save()\n        self.assertFalse(generator.check_token(user, token))\n",
      "\n        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n\n    def test_token_invalidated_on_email_change(self):\n        \"\"\"Test that tokens become invalid when user email changes.\"\"\"\n        user = User.objects.create_user('tokentestuser', 'test@example.com', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        self.assertIs(p0.check_token(user, tk1), True)\n        \n        # Change email and verify token becomes invalid\n        user.email = 'newemail@example.com'\n        user.save()\n        self.assertIs(p0.check_token(user, tk1), False)\n\n    def test_token_valid_when_email_unchanged(self):\n        \"\"\"Test that tokens remain valid when email stays the same.\"\"\"\n        user = User.objects.create_user('tokentestuser', 'test@example.com', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        self.assertIs(p0.check_token(user, tk1), True)\n        \n        # Save user without changing email - token should remain valid\n        user.save()\n        self.assertIs(p0.check_token(user, tk1), True)\n\n    def test_token_with_empty_email(self):\n        \"\"\"Test token behavior for users without email addresses.\"\"\"\n        user = User.objects.create_user('tokentestuser', '', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        self.assertIs(p0.check_token(user, tk1), True)\n        \n        # Token should remain valid for user with empty email\n        user.save()\n        self.assertIs(p0.check_token(user, tk1), True)\n        \n        # Setting email should invalidate token\n        user.email = 'newemail@example.com'\n        user.save()\n        self.assertIs(p0.check_token(user, tk1), False)\n",
      "\n        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n\n    def test_token_invalidated_on_email_change(self):\n        \"\"\"Test that tokens become invalid when user email changes.\"\"\"\n        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        \n        # Token should be valid with original email\n        self.assertIs(p0.check_token(user, tk1), True)\n        \n        # Change user's email\n        user.email = 'changed@example.com'\n        user.save()\n        \n        # Token should now be invalid\n        self.assertIs(p0.check_token(user, tk1), False)\n\n    def test_token_valid_when_email_unchanged(self):\n        \"\"\"Test that tokens remain valid when email doesn't change.\"\"\"\n        user = User.objects.create_user('emailtestuser2', 'test@example.com', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        \n        # Token should be valid\n        self.assertIs(p0.check_token(user, tk1), True)\n        \n        # Update user without changing email\n        user.first_name = 'Updated'\n        user.save()\n        \n        # Token should still be valid\n        self.assertIs(p0.check_token(user, tk1), True)\n\n    def test_token_with_empty_email(self):\n        \"\"\"Test token behavior for users without email addresses.\"\"\"\n        user = User.objects.create_user('noemailuser', '', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        tk1 = p0.make_token(user)\n        \n        # Token should be valid with empty email\n        self.assertIs(p0.check_token(user, tk1), True)\n        \n        # Set email to None and verify token still works\n        user.email = None\n        user.save()\n        \n        # Token should still be valid (both empty string and None should work)\n        self.assertIs(p0.check_token(user, tk1), True)\n",
      "\n        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n\n    def test_token_invalidated_on_email_change(self):\n        \"\"\"Test that tokens are invalidated when user's email address changes.\"\"\"\n        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n        generator = PasswordResetTokenGenerator()\n        \n        # Generate token with original email\n        token = generator.make_token(user)\n        self.assertTrue(generator.check_token(user, token))\n        \n        # Change user's email\n        user.email = 'changed@example.com'\n        user.save()\n        \n        # Token should now be invalid\n        self.assertFalse(generator.check_token(user, token))\n\n    def test_token_valid_when_email_unchanged(self):\n        \"\"\"Test that tokens remain valid when email doesn't change.\"\"\"\n        user = User.objects.create_user('emailtestuser2', 'unchanged@example.com', 'testpw')\n        generator = PasswordResetTokenGenerator()\n        \n        # Generate token\n        token = generator.make_token(user)\n        self.assertTrue(generator.check_token(user, token))\n        \n        # Make other changes but keep email the same\n        user.first_name = 'Changed'\n        user.save()\n        \n        # Token should still be valid\n        self.assertTrue(generator.check_token(user, token))\n\n    def test_token_with_empty_email(self):\n        \"\"\"Test token generation and validation for users without email.\"\"\"\n        user = User.objects.create_user('noemailuser', '', 'testpw')\n        generator = PasswordResetTokenGenerator()\n        \n        # Should work with empty email\n        token = generator.make_token(user)\n        self.assertTrue(generator.check_token(user, token))\n        \n        # Setting email should invalidate token\n        user.email = 'new@example.com'\n        user.save()\n        self.assertFalse(generator.check_token(user, token))\n        \n        # New token should work\n        new_token = generator.make_token(user)\n        self.assertTrue(generator.check_token(user, new_token))\n",
      "\n        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n\n    def test_token_invalidated_on_email_change(self):\n        \"\"\"Test that tokens become invalid when user email changes.\"\"\"\n        user = User.objects.create_user('emailtestuser', 'test@example.com', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        \n        # Generate token with original email\n        tk1 = p0.make_token(user)\n        self.assertIs(p0.check_token(user, tk1), True)\n        \n        # Change email and verify token becomes invalid\n        user.email = 'newemail@example.com'\n        user.save()\n        self.assertIs(p0.check_token(user, tk1), False)\n\n    def test_token_valid_when_email_unchanged(self):\n        \"\"\"Test that tokens remain valid when email doesn't change.\"\"\"\n        user = User.objects.create_user('emailtestuser2', 'test@example.com', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        \n        # Generate token\n        tk1 = p0.make_token(user)\n        self.assertIs(p0.check_token(user, tk1), True)\n        \n        # Change something else (like password) but not email\n        user.set_password('newpassword')\n        user.save()\n        # Token should be invalid due to password change, not email\n        self.assertIs(p0.check_token(user, tk1), False)\n        \n        # Generate new token with same email\n        tk2 = p0.make_token(user)\n        self.assertIs(p0.check_token(user, tk2), True)\n\n    def test_token_with_empty_email(self):\n        \"\"\"Test token behavior for users without email addresses.\"\"\"\n        user = User.objects.create_user('noemailuser', '', 'testpw')\n        p0 = PasswordResetTokenGenerator()\n        \n        # Generate token for user with empty email\n        tk1 = p0.make_token(user)\n        self.assertIs(p0.check_token(user, tk1), True)\n        \n        # Set email to non-empty value and verify token becomes invalid\n        user.email = 'newemail@example.com'\n        user.save()\n        self.assertIs(p0.check_token(user, tk1), False)\n        \n        # Generate new token and verify it works\n        tk2 = p0.make_token(user)\n        self.assertIs(p0.check_token(user, tk2), True)\n",
      "\n        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n\n    def test_token_invalidated_on_email_change(self):\n        \"\"\"Test that tokens become invalid when user email changes.\"\"\"\n        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n        generator = PasswordResetTokenGenerator()\n        \n        # Generate token with original email\n        token = generator.make_token(user)\n        self.assertTrue(generator.check_token(user, token))\n        \n        # Change email and verify token is now invalid\n        user.email = 'changed@example.com'\n        user.save()\n        self.assertFalse(generator.check_token(user, token))\n\n    def test_token_valid_when_email_unchanged(self):\n        \"\"\"Test that tokens remain valid when email stays the same.\"\"\"\n        user = User.objects.create_user('emailtestuser2', 'same@example.com', 'testpw')\n        generator = PasswordResetTokenGenerator()\n        \n        token = generator.make_token(user)\n        self.assertTrue(generator.check_token(user, token))\n        \n        # Save user without changing email\n        user.save()\n        self.assertTrue(generator.check_token(user, token))\n\n    def test_token_with_empty_email(self):\n        \"\"\"Test token generation and validation for users without email.\"\"\"\n        user = User.objects.create_user('noemailuser', '', 'testpw')\n        generator = PasswordResetTokenGenerator()\n        \n        # Should work with empty email\n        token = generator.make_token(user)\n        self.assertTrue(generator.check_token(user, token))\n        \n        # Should become invalid when email is added\n        user.email = 'newemail@example.com'\n        user.save()\n        self.assertFalse(generator.check_token(user, token))\n",
      "\n        self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n\n    def test_token_invalidated_on_email_change(self):\n        \"\"\"Test that password reset tokens are invalidated when user email changes.\"\"\"\n        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n        generator = PasswordResetTokenGenerator()\n        \n        # Generate token with original email\n        token = generator.make_token(user)\n        self.assertIs(generator.check_token(user, token), True)\n        \n        # Change email and verify token is now invalid\n        user.email = 'changed@example.com'\n        user.save()\n        self.assertIs(generator.check_token(user, token), False)\n        \n    def test_token_valid_when_email_unchanged(self):\n        \"\"\"Test that password reset tokens remain valid when email is unchanged.\"\"\"\n        user = User.objects.create_user('emailtestuser2', 'test@example.com', 'testpw')\n        generator = PasswordResetTokenGenerator()\n        \n        token = generator.make_token(user)\n        self.assertIs(generator.check_token(user, token), True)\n        \n        # Token should still be valid with same email\n        self.assertIs(generator.check_token(user, token), True)\n        \n    def test_token_with_empty_email(self):\n        \"\"\"Test that password reset tokens work for users without email addresses.\"\"\"\n        user = User.objects.create_user('noemailuser', '', 'testpw')\n        generator = PasswordResetTokenGenerator()\n        \n        # Should work with empty email\n        token = generator.make_token(user)\n        self.assertIs(generator.check_token(user, token), True)\n        \n        # Setting email to None should not break token generation\n        user.email = None\n        user.save()\n        token2 = generator.make_token(user)\n        self.assertIs(generator.check_token(user, token2), True)\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..1c5b05900e 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,7 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +86,8 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change when the user's email address is updated,\n+           invalidating existing tokens.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +97,8 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..8f13159b45 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,58 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+    def test_token_invalidated_on_email_change(self):\n+        \"\"\"\n+        Tokens should be invalidated when the user's email address changes.\n+        \"\"\"\n+        user = User.objects.create_user('emailchangeuser', 'original@example.com', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        \n+        # Verify token is valid before email change\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Change user's email address\n+        user.email = 'changed@example.com'\n+        user.save()\n+        \n+        # Token should now be invalid\n+        self.assertIs(p0.check_token(user, tk1), False)\n+\n+    def test_token_valid_when_email_unchanged(self):\n+        \"\"\"\n+        Tokens should remain valid when the user's email address doesn't change.\n+        \"\"\"\n+        user = User.objects.create_user('emailunchangeduser', 'unchanged@example.com', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        \n+        # Verify token is valid\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Reload user without changing email\n+        user = User.objects.get(username='emailunchangeduser')\n+        \n+        # Token should still be valid\n+        self.assertIs(p0.check_token(user, tk1), True)\n+\n+    def test_token_with_empty_email(self):\n+        \"\"\"\n+        Tokens should work correctly for users with empty email addresses.\n+        \"\"\"\n+        user = User.objects.create_user('noemailuser', '', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        \n+        # Token should be valid for user with empty email\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Change to non-empty email\n+        user.email = 'newemail@example.com'\n+        user.save()\n+        \n+        # Token should now be invalid\n+        self.assertIs(p0.check_token(user, tk1), False)\n",
    "variant_0": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..a770a6f725 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,7 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +86,8 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change upon an email change, invalidating\n+           existing tokens.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +97,12 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..f17d60e04d 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,56 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+    def test_token_invalidated_on_email_change(self):\n+        \"\"\"Test that password reset tokens are invalidated when user email changes.\"\"\"\n+        user = User.objects.create_user('emailchangeuser', 'original@example.com', 'testpw')\n+        generator = PasswordResetTokenGenerator()\n+        \n+        # Generate token with original email\n+        original_token = generator.make_token(user)\n+        self.assertIs(generator.check_token(user, original_token), True)\n+        \n+        # Change user email\n+        user.email = 'changed@example.com'\n+        user.save()\n+        \n+        # Token should now be invalid\n+        self.assertIs(generator.check_token(user, original_token), False)\n+\n+    def test_token_valid_when_email_unchanged(self):\n+        \"\"\"Test that password reset tokens remain valid when email is unchanged.\"\"\"\n+        user = User.objects.create_user('unchangedemailuser', 'unchanged@example.com', 'testpw')\n+        generator = PasswordResetTokenGenerator()\n+        \n+        # Generate token\n+        token = generator.make_token(user)\n+        self.assertIs(generator.check_token(user, token), True)\n+        \n+        # Change something else (like last_login) but not email\n+        user.last_login = datetime.now()\n+        user.save()\n+        \n+        # Token should still be valid\n+        self.assertIs(generator.check_token(user, token), True)\n+\n+    def test_token_with_empty_email(self):\n+        \"\"\"Test that tokens work correctly for users without email addresses.\"\"\"\n+        user = User.objects.create_user('noemailuser', '', 'testpw')\n+        generator = PasswordResetTokenGenerator()\n+        \n+        # Generate token for user with empty email\n+        token = generator.make_token(user)\n+        self.assertIs(generator.check_token(user, token), True)\n+        \n+        # Set email to None and verify token still works\n+        user.email = None\n+        user.save()\n+        self.assertIs(generator.check_token(user, token), True)\n+        \n+        # Now set an actual email - token should become invalid\n+        user.email = 'newemail@example.com'\n+        user.save()\n+        self.assertIs(generator.check_token(user, token), False)\n",
    "variant_1": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..5263d52eca 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,7 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +86,8 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change when the user's email is updated,\n+           invalidating existing tokens.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +97,12 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..ec68f2f061 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,53 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+    def test_token_invalidated_on_email_change(self):\n+        \"\"\"Test that password reset tokens are invalidated when user email changes.\"\"\"\n+        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n+        p_generator = PasswordResetTokenGenerator()\n+        \n+        # Generate token with original email\n+        token = p_generator.make_token(user)\n+        self.assertIs(p_generator.check_token(user, token), True)\n+        \n+        # Change user's email\n+        user.email = 'changed@example.com'\n+        user.save()\n+        \n+        # Token should now be invalid\n+        self.assertIs(p_generator.check_token(user, token), False)\n+\n+    def test_token_valid_when_email_unchanged(self):\n+        \"\"\"Test that password reset tokens remain valid when email is unchanged.\"\"\"\n+        user = User.objects.create_user('emailtestuser2', 'test@example.com', 'testpw')\n+        p_generator = PasswordResetTokenGenerator()\n+        \n+        # Generate token\n+        token = p_generator.make_token(user)\n+        self.assertIs(p_generator.check_token(user, token), True)\n+        \n+        # Change something else (like last_login) but not email\n+        user.last_login = datetime.now()\n+        user.save()\n+        \n+        # Token should still be valid\n+        self.assertIs(p_generator.check_token(user, token), True)\n+\n+    def test_token_with_empty_email(self):\n+        \"\"\"Test that password reset tokens work correctly for users without email.\"\"\"\n+        user = User.objects.create_user('noemailuser', '', 'testpw')\n+        p_generator = PasswordResetTokenGenerator()\n+        \n+        # Generate token for user without email\n+        token = p_generator.make_token(user)\n+        self.assertIs(p_generator.check_token(user, token), True)\n+        \n+        # Setting email should invalidate token\n+        user.email = 'newemail@example.com'\n+        user.save()\n+        \n+        # Token should now be invalid\n+        self.assertIs(p_generator.check_token(user, token), False)\n",
    "variant_2": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..a770a6f725 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,7 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +86,8 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change upon an email change, invalidating\n+           existing tokens.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +97,12 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..ebc9f7c452 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,46 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+    def test_token_invalidated_on_email_change(self):\n+        \"\"\"Test that password reset tokens are invalidated when user email changes.\"\"\"\n+        user = User.objects.create_user('emailuser', 'original@example.com', 'testpw')\n+        generator = PasswordResetTokenGenerator()\n+        \n+        # Generate token with original email\n+        token = generator.make_token(user)\n+        self.assertTrue(generator.check_token(user, token))\n+        \n+        # Change email and verify token is now invalid\n+        user.email = 'changed@example.com'\n+        user.save()\n+        self.assertFalse(generator.check_token(user, token))\n+\n+    def test_token_valid_when_email_unchanged(self):\n+        \"\"\"Test that password reset tokens remain valid when email doesn't change.\"\"\"\n+        user = User.objects.create_user('stableuser', 'stable@example.com', 'testpw')\n+        generator = PasswordResetTokenGenerator()\n+        \n+        # Generate token\n+        token = generator.make_token(user)\n+        self.assertTrue(generator.check_token(user, token))\n+        \n+        # Save user without changing email\n+        user.save()\n+        self.assertTrue(generator.check_token(user, token))\n+\n+    def test_token_with_empty_email(self):\n+        \"\"\"Test that password reset tokens work for users without email addresses.\"\"\"\n+        user = User.objects.create_user('noemailuser', '', 'testpw')\n+        generator = PasswordResetTokenGenerator()\n+        \n+        # Generate token for user with empty email\n+        token = generator.make_token(user)\n+        self.assertTrue(generator.check_token(user, token))\n+        \n+        # Change to non-empty email should invalidate token\n+        user.email = 'newemail@example.com'\n+        user.save()\n+        self.assertFalse(generator.check_token(user, token))\n",
    "variant_3": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..1887a09d16 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,7 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +86,7 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change when the user's email is updated.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +96,12 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..69fc35cb5e 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,44 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+    def test_token_invalidated_on_email_change(self):\n+        \"\"\"Test that tokens become invalid when user email changes.\"\"\"\n+        user = User.objects.create_user('tokentestuser', 'test@example.com', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Change email and verify token becomes invalid\n+        user.email = 'newemail@example.com'\n+        user.save()\n+        self.assertIs(p0.check_token(user, tk1), False)\n+\n+    def test_token_valid_when_email_unchanged(self):\n+        \"\"\"Test that tokens remain valid when email stays the same.\"\"\"\n+        user = User.objects.create_user('tokentestuser', 'test@example.com', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Save user without changing email - token should remain valid\n+        user.save()\n+        self.assertIs(p0.check_token(user, tk1), True)\n+\n+    def test_token_with_empty_email(self):\n+        \"\"\"Test token behavior for users without email addresses.\"\"\"\n+        user = User.objects.create_user('tokentestuser', '', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Token should remain valid for user with empty email\n+        user.save()\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Setting email should invalidate token\n+        user.email = 'newemail@example.com'\n+        user.save()\n+        self.assertIs(p0.check_token(user, tk1), False)\n",
    "variant_4": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..e653bd73ab 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,7 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +86,8 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change upon an email address update, ensuring\n+           tokens become invalid when the user's email changes.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +97,12 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..d3d9b6cd13 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,53 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+    def test_token_invalidated_on_email_change(self):\n+        \"\"\"Test that tokens become invalid when user email changes.\"\"\"\n+        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        \n+        # Token should be valid with original email\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Change user's email\n+        user.email = 'changed@example.com'\n+        user.save()\n+        \n+        # Token should now be invalid\n+        self.assertIs(p0.check_token(user, tk1), False)\n+\n+    def test_token_valid_when_email_unchanged(self):\n+        \"\"\"Test that tokens remain valid when email doesn't change.\"\"\"\n+        user = User.objects.create_user('emailtestuser2', 'test@example.com', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        \n+        # Token should be valid\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Update user without changing email\n+        user.first_name = 'Updated'\n+        user.save()\n+        \n+        # Token should still be valid\n+        self.assertIs(p0.check_token(user, tk1), True)\n+\n+    def test_token_with_empty_email(self):\n+        \"\"\"Test token behavior for users without email addresses.\"\"\"\n+        user = User.objects.create_user('noemailuser', '', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        \n+        # Token should be valid with empty email\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Set email to None and verify token still works\n+        user.email = None\n+        user.save()\n+        \n+        # Token should still be valid (both empty string and None should work)\n+        self.assertIs(p0.check_token(user, tk1), True)\n",
    "variant_5": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..ab1e718001 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,7 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +86,8 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change when the user's email is updated,\n+           invalidating existing tokens.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +97,12 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+\n+return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..9e3e4c4578 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,55 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+    def test_token_invalidated_on_email_change(self):\n+        \"\"\"Test that tokens are invalidated when user's email address changes.\"\"\"\n+        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n+        generator = PasswordResetTokenGenerator()\n+        \n+        # Generate token with original email\n+        token = generator.make_token(user)\n+        self.assertTrue(generator.check_token(user, token))\n+        \n+        # Change user's email\n+        user.email = 'changed@example.com'\n+        user.save()\n+        \n+        # Token should now be invalid\n+        self.assertFalse(generator.check_token(user, token))\n+\n+    def test_token_valid_when_email_unchanged(self):\n+        \"\"\"Test that tokens remain valid when email doesn't change.\"\"\"\n+        user = User.objects.create_user('emailtestuser2', 'unchanged@example.com', 'testpw')\n+        generator = PasswordResetTokenGenerator()\n+        \n+        # Generate token\n+        token = generator.make_token(user)\n+        self.assertTrue(generator.check_token(user, token))\n+        \n+        # Make other changes but keep email the same\n+        user.first_name = 'Changed'\n+        user.save()\n+        \n+        # Token should still be valid\n+        self.assertTrue(generator.check_token(user, token))\n+\n+    def test_token_with_empty_email(self):\n+        \"\"\"Test token generation and validation for users without email.\"\"\"\n+        user = User.objects.create_user('noemailuser', '', 'testpw')\n+        generator = PasswordResetTokenGenerator()\n+        \n+        # Should work with empty email\n+        token = generator.make_token(user)\n+        self.assertTrue(generator.check_token(user, token))\n+        \n+        # Setting email should invalidate token\n+        user.email = 'new@example.com'\n+        user.save()\n+        self.assertFalse(generator.check_token(user, token))\n+        \n+        # New token should work\n+        new_token = generator.make_token(user)\n+        self.assertTrue(generator.check_token(user, new_token))\n",
    "variant_6": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..a5f5358b86 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,7 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +86,7 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change if the user updates their email address.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +96,12 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..e3d57c7662 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,56 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+    def test_token_invalidated_on_email_change(self):\n+        \"\"\"Test that tokens become invalid when user email changes.\"\"\"\n+        user = User.objects.create_user('emailtestuser', 'test@example.com', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        \n+        # Generate token with original email\n+        tk1 = p0.make_token(user)\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Change email and verify token becomes invalid\n+        user.email = 'newemail@example.com'\n+        user.save()\n+        self.assertIs(p0.check_token(user, tk1), False)\n+\n+    def test_token_valid_when_email_unchanged(self):\n+        \"\"\"Test that tokens remain valid when email doesn't change.\"\"\"\n+        user = User.objects.create_user('emailtestuser2', 'test@example.com', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        \n+        # Generate token\n+        tk1 = p0.make_token(user)\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Change something else (like password) but not email\n+        user.set_password('newpassword')\n+        user.save()\n+        # Token should be invalid due to password change, not email\n+        self.assertIs(p0.check_token(user, tk1), False)\n+        \n+        # Generate new token with same email\n+        tk2 = p0.make_token(user)\n+        self.assertIs(p0.check_token(user, tk2), True)\n+\n+    def test_token_with_empty_email(self):\n+        \"\"\"Test token behavior for users without email addresses.\"\"\"\n+        user = User.objects.create_user('noemailuser', '', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        \n+        # Generate token for user with empty email\n+        tk1 = p0.make_token(user)\n+        self.assertIs(p0.check_token(user, tk1), True)\n+        \n+        # Set email to non-empty value and verify token becomes invalid\n+        user.email = 'newemail@example.com'\n+        user.save()\n+        self.assertIs(p0.check_token(user, tk1), False)\n+        \n+        # Generate new token and verify it works\n+        tk2 = p0.make_token(user)\n+        self.assertIs(p0.check_token(user, tk2), True)\n",
    "variant_7": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..c2b8154cc2 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,7 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +86,7 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change if the user's email address is modified.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +96,12 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..1f63b993a2 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,45 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+    def test_token_invalidated_on_email_change(self):\n+        \"\"\"Test that tokens become invalid when user email changes.\"\"\"\n+        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n+        generator = PasswordResetTokenGenerator()\n+        \n+        # Generate token with original email\n+        token = generator.make_token(user)\n+        self.assertTrue(generator.check_token(user, token))\n+        \n+        # Change email and verify token is now invalid\n+        user.email = 'changed@example.com'\n+        user.save()\n+        self.assertFalse(generator.check_token(user, token))\n+\n+    def test_token_valid_when_email_unchanged(self):\n+        \"\"\"Test that tokens remain valid when email stays the same.\"\"\"\n+        user = User.objects.create_user('emailtestuser2', 'same@example.com', 'testpw')\n+        generator = PasswordResetTokenGenerator()\n+        \n+        token = generator.make_token(user)\n+        self.assertTrue(generator.check_token(user, token))\n+        \n+        # Save user without changing email\n+        user.save()\n+        self.assertTrue(generator.check_token(user, token))\n+\n+    def test_token_with_empty_email(self):\n+        \"\"\"Test token generation and validation for users without email.\"\"\"\n+        user = User.objects.create_user('noemailuser', '', 'testpw')\n+        generator = PasswordResetTokenGenerator()\n+        \n+        # Should work with empty email\n+        token = generator.make_token(user)\n+        self.assertTrue(generator.check_token(user, token))\n+        \n+        # Should become invalid when email is added\n+        user.email = 'newemail@example.com'\n+        user.save()\n+        self.assertFalse(generator.check_token(user, token))\n",
    "variant_8": "diff --git a/django/contrib/auth/tokens.py b/django/contrib/auth/tokens.py\nindex 93e2d71af2..799a3ecb1c 100644\n--- a/django/contrib/auth/tokens.py\n+++ b/django/contrib/auth/tokens.py\n@@ -76,6 +76,7 @@ class PasswordResetTokenGenerator:\n         ).hexdigest()[::2]  # Limit to shorten the URL.\n         return \"%s-%s\" % (ts_b36, hash_string)\n \n+\n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\n         Hash the user's primary key and some user state that's sure to change\n@@ -85,6 +86,8 @@ class PasswordResetTokenGenerator:\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n+        3. The email field will change when the user updates their email\n+           address, invalidating existing tokens.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n@@ -94,7 +97,12 @@ class PasswordResetTokenGenerator:\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n+        # Truncate microseconds so that tokens are consistent even if the\n+        # database doesn't support microseconds.\n+        login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n+\n+        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + (user.email or '')\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\ndiff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex bba435be84..44371882f0 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -109,4 +109,45 @@ class TokenGeneratorTest(TestCase):\n \n         legacy_token = p_old_generator.make_token(user)\n         self.assertIs(p_old_generator.check_token(user, legacy_token), True)\n+\n         self.assertIs(p_new_generator.check_token(user, legacy_token), True)\n+\n+    def test_token_invalidated_on_email_change(self):\n+        \"\"\"Test that password reset tokens are invalidated when user email changes.\"\"\"\n+        user = User.objects.create_user('emailtestuser', 'original@example.com', 'testpw')\n+        generator = PasswordResetTokenGenerator()\n+        \n+        # Generate token with original email\n+        token = generator.make_token(user)\n+        self.assertIs(generator.check_token(user, token), True)\n+        \n+        # Change email and verify token is now invalid\n+        user.email = 'changed@example.com'\n+        user.save()\n+        self.assertIs(generator.check_token(user, token), False)\n+        \n+    def test_token_valid_when_email_unchanged(self):\n+        \"\"\"Test that password reset tokens remain valid when email is unchanged.\"\"\"\n+        user = User.objects.create_user('emailtestuser2', 'test@example.com', 'testpw')\n+        generator = PasswordResetTokenGenerator()\n+        \n+        token = generator.make_token(user)\n+        self.assertIs(generator.check_token(user, token), True)\n+        \n+        # Token should still be valid with same email\n+        self.assertIs(generator.check_token(user, token), True)\n+        \n+    def test_token_with_empty_email(self):\n+        \"\"\"Test that password reset tokens work for users without email addresses.\"\"\"\n+        user = User.objects.create_user('noemailuser', '', 'testpw')\n+        generator = PasswordResetTokenGenerator()\n+        \n+        # Should work with empty email\n+        token = generator.make_token(user)\n+        self.assertIs(generator.check_token(user, token), True)\n+        \n+        # Setting email to None should not break token generation\n+        user.email = None\n+        user.save()\n+        token2 = generator.make_token(user)\n+        self.assertIs(generator.check_token(user, token2), True)\n"
  }
}