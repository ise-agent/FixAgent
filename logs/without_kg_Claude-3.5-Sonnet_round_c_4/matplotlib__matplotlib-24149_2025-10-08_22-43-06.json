{
  "zero_patches": {
    "Location 1 (/root/hy/projects_4/matplotlib/lib/matplotlib/cbook/__init__.py lines 1749-1749)": "\ndef _safe_first_finite(obj, *, skip_nonfinite=True):\n    \"\"\"\n    Return the first finite value in the given object.\n\n    If *skip_nonfinite* is False, return the first value.\n    \"\"\"\n    def safe_isfinite(val):\n        if skip_nonfinite:\n            try:\n                return math.isfinite(val)\n            except (TypeError, ValueError):\n                pass\n        return True\n\n    if isinstance(obj, collections.abc.Generator):\n        # Generators can't be restarted, so consume it into a list.\n        obj = list(obj)\n    if len(obj) == 0:\n        raise StopIteration\n    # For numpy scalars, we always want the item itself, not the array form.\n    if not np.iterable(obj):\n        return obj\n    elif isinstance(obj, np.matrix):\n        # In case we come across a matrix, which is still iterable.\n        obj = np.asarray(obj).flatten()\n    elif isinstance(obj, np.ndarray):\n        # flat is safe for subclasses (generators and other iterables are\n        # not).\n        obj = obj.flat\n\n    elif isinstance(obj, collections.abc.Iterable):\n        # Some other iterable; object[0] is the natural choice, but we\n        # should avoid that if the object does not support indexing.\n        # So we explicitly check for types that are known to be problematic\n        # and use an alternative approach.\n        if isinstance(obj, collections.abc.Sequence):\n            # indexable, so we can just grab the first element\n            obj = obj[0]\n        elif isinstance(obj, collections.abc.Set):\n            obj = next(iter(obj))\n        else:\n            # Fall back to the next() of the iterator, but this may\n            # not be safe if there are multiple iterators (i.e. this\n            # will consume items).\n            obj = next(iter(obj))\n    if isinstance(obj, collections.abc.Iterator):\n        if isinstance(obj, types.GeneratorType):\n            raise RuntimeError(\"matplotlib does not support generators \"\n                               \"as input\")\n        return next(iter(obj))\n    elif isinstance(obj, np.flatiter):\n        # TODO do the finite filtering on this\n        return obj[0]\n    elif isinstance(obj, collections.abc.Iterator):\n        raise RuntimeError(\"matplotlib does not \"\n                           \"support generators as input\")\n    else:\n        try:\n            return next(val for val in obj if safe_isfinite(val))\n        except StopIteration:\n            # Return the first element if no finite values found, maintaining backward compatibility\n            return next(iter(obj))\n",
    "Location 2 (/root/hy/projects_4/matplotlib/lib/matplotlib/axes/_axes.py lines 2182-2184)": "\n            try:\n                x0 = cbook._safe_first_finite(x0)\n            except (TypeError, IndexError, KeyError, StopIteration):\n                pass\n"
  },
  "variant_patches": {
    "Location 1 (/root/hy/projects_4/matplotlib/lib/matplotlib/cbook/__init__.py lines 1749-1749)": [
      "\ndef _safe_first_finite(obj, *, skip_nonfinite=True):\n    \"\"\"\n    Return the first finite value in the given array.\n\n    If *skip_nonfinite* is False, return the first value.\n    \"\"\"\n    if skip_nonfinite is False:\n        if isinstance(obj, collections.abc.Iterator):\n            raise RuntimeError(\"matplotlib does not support generators \"\n                               \"as input\")\n        return next(iter(obj))\n    elif isinstance(obj, np.flatiter):\n        # TODO do the finite filtering on this\n        return obj[0]\n    elif isinstance(obj, collections.abc.Iterator):\n        raise RuntimeError(\"matplotlib does not \"\n                           \"support generators as input\")\n    else:\n        try:\n            return next(val for val in obj if safe_isfinite(val))\n        except StopIteration:\n            # Return the first element if no finite values found, maintaining backward compatibility\n            return next(iter(obj))\n",
      "\ndef _safe_first_finite(obj, skip_nonfinite=True):\n    \"\"\"\n    Return the first finite value in the given array.\n\n    If *skip_nonfinite* is False, return the first value.\n    \"\"\"\n    def safe_isfinite(val):\n        if skip_nonfinite:\n            try:\n                return np.isfinite(val)\n            except TypeError:\n                return True\n        else:\n            return True\n\n    if obj.ndim == 0:\n        raise RuntimeError(\"matplotlib does not support generators \"\n                           \"as input\")\n    elif obj.size == 0:\n        raise RuntimeError(\"matplotlib does not support generators \"\n                           \"as input\")\n    elif obj.ndim > 0:\n        if isinstance(obj, collections.abc.Iterator):\n            raise RuntimeError(\"matplotlib does not support generators \"\n                               \"as input\")\n        return next(iter(obj))\n    elif isinstance(obj, np.flatiter):\n        # TODO do the finite filtering on this\n        return obj[0]\n    elif isinstance(obj, collections.abc.Iterator):\n        raise RuntimeError(\"matplotlib does not \"\n                           \"support generators as input\")\n    else:\n        try:\n            return next(val for val in obj if safe_isfinite(val))\n        except StopIteration:\n            # Return the first element if no finite values found, maintaining backward compatibility\n            return next(iter(obj))\n",
      "\ndef _safe_first_finite(obj, skip_nonfinite=True):\n    \"\"\"\n    Return the first finite value in the given array.\n\n    If *skip_nonfinite* is False, return the first value.\n    \"\"\"\n    if skip_nonfinite is False:\n        if isinstance(obj, collections.abc.Iterator):\n            # needed to accept `array.flat` as input.\n            # np.flatiter reports as an instance of collections.Iterator\n            # but can still be indexed via []\n            # This has the side effect of re-setting the iterator, but\n            # that is acceptable.\n            try:\n                return obj[0]\n            except TypeError:\n                pass\n        try:\n            return obj[0]\n        except (TypeError, IndexError, KeyError):\n            pass\n        raise RuntimeError(\"matplotlib does not support generators \"\n                           \"as input\")\n        return next(iter(obj))\n    elif isinstance(obj, np.flatiter):\n        # TODO do the finite filtering on this\n        return obj[0]\n    elif isinstance(obj, collections.abc.Iterator):\n        raise RuntimeError(\"matplotlib does not \"\n                           \"support generators as input\")\n    else:\n        try:\n            return next(val for val in obj if safe_isfinite(val))\n        except StopIteration:\n            # Return the first element if no finite values found, maintaining backward compatibility\n            return next(iter(obj))\n",
      "\ndef _safe_first_finite(obj, skip_nonfinite=True):\n    \"\"\"\n    Return the first non-None and finite value in the given sequence.\n\n    If such a value does not exist (i.e., all values are None or nonfinite),\n    a ValueError is raised.\n\n    Parameters\n    ----------\n    obj : iterable\n    skip_nonfinite : bool, default: True\n        If True (default), skip over entries that are not finite numbers.\n        If False, return the first entry, finite or not.\n    \"\"\"\n    if skip_nonfinite is False:\n        return safe_first_element(obj)\n\n    def safe_isfinite(val):\n        if val is None:\n            return False\n        try:\n            return math.isfinite(val)\n        except (TypeError, ValueError):\n            return False\n\n    if isinstance(obj, collections.abc.Mapping):\n        raise RuntimeError(\"matplotlib does not support generators \"\n                           \"as input\")\n    elif isinstance(obj, np.flatiter):\n        # TODO do the finite filtering on this\n        return obj[0]\n    elif isinstance(obj, collections.abc.Iterator):\n        raise RuntimeError(\"matplotlib does not \"\n                           \"support generators as input\")\n    else:\n        try:\n            return next(val for val in obj if safe_isfinite(val))\n        except StopIteration:\n            # Return the first element if no finite values found, maintaining backward compatibility\n            return next(iter(obj))\n",
      "\ndef _safe_first_finite(obj, skip_nonfinite=True):\n    \"\"\"\n    Return the first finite value in the given object.\n\n    If *skip_nonfinite* is False, return the first value.\n    \"\"\"\n    def safe_isfinite(val):\n        if skip_nonfinite:\n            try:\n                return np.isfinite(val)\n            except (TypeError, ValueError):\n                pass\n        return True\n\n    if isinstance(obj, collections.abc.Generator):\n        # Consume the first value; we can't just call next(obj) on a\n        # generator because that would consume it.\n        raise RuntimeError(\"matplotlib does not support generators \"\n                           \"as input\")\n        return next(iter(obj))\n    elif isinstance(obj, np.flatiter):\n        # TODO do the finite filtering on this\n        return obj[0]\n    elif isinstance(obj, collections.abc.Iterator):\n        raise RuntimeError(\"matplotlib does not \"\n                           \"support generators as input\")\n    else:\n        try:\n            return next(val for val in obj if safe_isfinite(val))\n        except StopIteration:\n            # Return the first element if no finite values found, maintaining backward compatibility\n            return next(iter(obj))\n",
      "\ndef _safe_first_finite(obj, skip_nonfinite=True):\n    \"\"\"\n    Return the first non-None, non-NaN, non-inf value in obj.\n\n    This is a method for internal use.\n\n    This is effectively a method to get a sample element from an array-like\n    object, that can be used for auto-scaling. It is meant to be used for\n    arrays that are not expected to have all NaN/inf values.\n\n    If all values are non-finite, the first value is returned.\n\n    Parameters\n    ----------\n    obj : array-like\n        The array to get the first finite value from.\n    skip_nonfinite : bool, default: True\n        Whether to skip non-finite values.\n\n    Returns\n    -------\n    The first finite value or the first value if all values are non-finite.\n    \"\"\"\n    if skip_nonfinite is False:\n        # Return the first value without any filtering.\n        return next(iter(obj))\n    if isinstance(obj, types.GeneratorType):\n        # Generators are not handled because they consume the\n        # iterator, and we want to keep the generator for\n        # being processed by the registered listeners.\n        raise RuntimeError(\"matplotlib does not support generators \"\n                           \"as input\")\n    elif isinstance(obj, np.flatiter):\n        # TODO do the finite filtering on this\n        return obj[0]\n    elif isinstance(obj, collections.abc.Iterator):\n        raise RuntimeError(\"matplotlib does not \"\n                           \"support generators as input\")\n    else:\n        try:\n            return next(val for val in obj if safe_isfinite(val))\n        except StopIteration:\n            # Return the first element if no finite values found, maintaining backward compatibility\n            return next(iter(obj))\n",
      "\ndef _safe_first_finite(obj, *, skip_nonfinite=True):\n    \"\"\"\n    Return the first finite value in the given array.\n\n    If *skip_nonfinite* is False, return the first value.\n    \"\"\"\n    def safe_isfinite(val):\n        if skip_nonfinite:\n            try:\n                return math.isfinite(val)\n            except (TypeError, ValueError):\n                pass\n        return True\n\n    if isinstance(obj, collections.abc.Generator):\n        # Generators can't be restarted, so check for finite values first.\n        # If we find at least one, return the first finite one. If we don't\n        # find any, raise a RuntimeError instead of letting it continue.\n        obj = list(obj)\n        if not obj:\n            raise RuntimeError(\"matplotlib does not support generators \"\n                               \"as input\")\n        return next(iter(obj))\n    elif isinstance(obj, np.flatiter):\n        # TODO do the finite filtering on this\n        return obj[0]\n    elif isinstance(obj, collections.abc.Iterator):\n        raise RuntimeError(\"matplotlib does not \"\n                           \"support generators as input\")\n    else:\n        try:\n            return next(val for val in obj if safe_isfinite(val))\n        except StopIteration:\n            # Return the first element if no finite values found, maintaining backward compatibility\n            return next(iter(obj))\n",
      "\ndef _safe_first_finite(obj, *, skip_nonfinite=True):\n    \"\"\"\n    Return the first finite value in the given object.\n\n    If *skip_nonfinite* is False, return the first value.\n    \"\"\"\n    def safe_isfinite(val):\n        return np.isscalar(val) and np.isfinite(val)\n    def safe_isnan(val):\n        return np.isscalar(val) and np.isnan(val)\n\n    if skip_nonfinite is False:\n        if isinstance(obj, collections.abc.Iterator):\n            # needed to accept `array.flat` as input.\n            # np.flatiter reports as an instance of collections.Iterator\n            # but can still be indexed via [].\n            # This has the side effect of re-setting the iterator, but\n            # that is acceptable.\n            try:\n                return obj[0]\n            except TypeError:\n                pass\n            raise RuntimeError(\"matplotlib does not support generators \"\n                               \"as input\")\n        return next(iter(obj))\n    elif isinstance(obj, np.flatiter):\n        # TODO do the finite filtering on this\n        return obj[0]\n    elif isinstance(obj, collections.abc.Iterator):\n        raise RuntimeError(\"matplotlib does not \"\n                           \"support generators as input\")\n    else:\n        try:\n            return next(val for val in obj if safe_isfinite(val))\n        except StopIteration:\n            # Return the first element if no finite values found, maintaining backward compatibility\n            return next(iter(obj))\n"
    ],
    "Location 2 (/root/hy/projects_4/matplotlib/lib/matplotlib/axes/_axes.py lines 2182-2184)": [
      "\n            try:\n                x0 = cbook._safe_first_finite(x0)\n            except (TypeError, IndexError, KeyError, StopIteration):\n                pass\n",
      "\n            try:\n                x0 = cbook._safe_first_finite(x0)\n            except (TypeError, IndexError, KeyError, StopIteration):\n                pass\n",
      "\n            try:\n                x0 = cbook._safe_first_finite(x0)\n            except (TypeError, IndexError, KeyError, StopIteration):\n                pass\n",
      "\n        try:\n            return next(val for val in obj if safe_isfinite(val))\n        except StopIteration:\n            # Return the first element if no finite values found, maintaining backward compatibility\n            return next(iter(obj))\n",
      "\n            try:\n                try:\n                    x0 = cbook._safe_first_finite(x0)\n                except StopIteration:\n                    # If no finite values found, use the first element to maintain backward compatibility\n                    x0 = next(iter(x0)) if hasattr(x0, '__iter__') else x0\n            except (TypeError, IndexError, KeyError):\n                pass\n",
      "\n            try:\n                x0 = cbook._safe_first_finite(x0)\n            except (TypeError, IndexError, KeyError, StopIteration):\n                pass\n",
      "\n            try:\n                x0 = cbook._safe_first_finite(x0)\n            except (TypeError, IndexError, KeyError, StopIteration):\n                pass\n",
      "\n        try:\n            return next(val for val in obj if safe_isfinite(val))\n        except StopIteration:\n            # Return the first element if no finite values found, maintaining backward compatibility\n            return next(iter(obj))\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex fdac0f3560..43a96b3272 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -2179,8 +2179,9 @@ class Axes(_AxesBase):\n             # removes the units from unit packages like `pint` that\n             # wrap numpy arrays.\n             try:\n+\n                 x0 = cbook._safe_first_finite(x0)\n-            except (TypeError, IndexError, KeyError):\n+            except (TypeError, IndexError, KeyError, StopIteration):\n                 pass\n \n             try:\ndiff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex 34c6ddb861..a50697d71d 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -1746,7 +1746,12 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n         raise RuntimeError(\"matplotlib does not \"\n                            \"support generators as input\")\n     else:\n-        return next(val for val in obj if safe_isfinite(val))\n+\n+        try:\n+            return next(val for val in obj if safe_isfinite(val))\n+        except StopIteration:\n+            # Return the first element if no finite values found, maintaining backward compatibility\n+            return next(iter(obj))\n \n \n def sanitize_sequence(data):\n",
    "variant_0": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex fdac0f3560..cfea3634b4 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -2178,9 +2178,11 @@ class Axes(_AxesBase):\n             # We can't just cast x0 and dx to numpy arrays because that\n             # removes the units from unit packages like `pint` that\n             # wrap numpy arrays.\n+            try:\n+\n             try:\n                 x0 = cbook._safe_first_finite(x0)\n-            except (TypeError, IndexError, KeyError):\n+            except (TypeError, IndexError, KeyError, StopIteration):\n                 pass\n \n             try:\ndiff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex 34c6ddb861..3ba3b9d3e4 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -1746,7 +1746,69 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n         raise RuntimeError(\"matplotlib does not \"\n                            \"support generators as input\")\n     else:\n-        return next(val for val in obj if safe_isfinite(val))\n+\n+def _safe_first_finite(obj, *, skip_nonfinite=True):\n+    \"\"\"\n+    Return the first finite value in the given object.\n+\n+    If *skip_nonfinite* is False, return the first value.\n+    \"\"\"\n+    def safe_isfinite(val):\n+        if skip_nonfinite:\n+            try:\n+                return math.isfinite(val)\n+            except (TypeError, ValueError):\n+                pass\n+        return True\n+\n+    if isinstance(obj, collections.abc.Generator):\n+        # Generators can't be restarted, so consume it into a list.\n+        obj = list(obj)\n+    if len(obj) == 0:\n+        raise StopIteration\n+    # For numpy scalars, we always want the item itself, not the array form.\n+    if not np.iterable(obj):\n+        return obj\n+    elif isinstance(obj, np.matrix):\n+        # In case we come across a matrix, which is still iterable.\n+        obj = np.asarray(obj).flatten()\n+    elif isinstance(obj, np.ndarray):\n+        # flat is safe for subclasses (generators and other iterables are\n+        # not).\n+        obj = obj.flat\n+\n+    elif isinstance(obj, collections.abc.Iterable):\n+        # Some other iterable; object[0] is the natural choice, but we\n+        # should avoid that if the object does not support indexing.\n+        # So we explicitly check for types that are known to be problematic\n+        # and use an alternative approach.\n+        if isinstance(obj, collections.abc.Sequence):\n+            # indexable, so we can just grab the first element\n+            obj = obj[0]\n+        elif isinstance(obj, collections.abc.Set):\n+            obj = next(iter(obj))\n+        else:\n+            # Fall back to the next() of the iterator, but this may\n+            # not be safe if there are multiple iterators (i.e. this\n+            # will consume items).\n+            obj = next(iter(obj))\n+    if isinstance(obj, collections.abc.Iterator):\n+        if isinstance(obj, types.GeneratorType):\n+            raise RuntimeError(\"matplotlib does not support generators \"\n+                               \"as input\")\n+        return next(iter(obj))\n+    elif isinstance(obj, np.flatiter):\n+        # TODO do the finite filtering on this\n+        return obj[0]\n+    elif isinstance(obj, collections.abc.Iterator):\n+        raise RuntimeError(\"matplotlib does not \"\n+                           \"support generators as input\")\n+    else:\n+        try:\n+            return next(val for val in obj if safe_isfinite(val))\n+        except StopIteration:\n+            # Return the first element if no finite values found, maintaining backward compatibility\n+            return next(iter(obj))\n \n \n def sanitize_sequence(data):\n",
    "variant_1": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex fdac0f3560..cfea3634b4 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -2178,9 +2178,11 @@ class Axes(_AxesBase):\n             # We can't just cast x0 and dx to numpy arrays because that\n             # removes the units from unit packages like `pint` that\n             # wrap numpy arrays.\n+            try:\n+\n             try:\n                 x0 = cbook._safe_first_finite(x0)\n-            except (TypeError, IndexError, KeyError):\n+            except (TypeError, IndexError, KeyError, StopIteration):\n                 pass\n \n             try:\ndiff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex 34c6ddb861..e7243cc8fe 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -1746,7 +1746,30 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n         raise RuntimeError(\"matplotlib does not \"\n                            \"support generators as input\")\n     else:\n-        return next(val for val in obj if safe_isfinite(val))\n+\n+def _safe_first_finite(obj, *, skip_nonfinite=True):\n+    \"\"\"\n+    Return the first finite value in the given array.\n+\n+    If *skip_nonfinite* is False, return the first value.\n+    \"\"\"\n+    if skip_nonfinite is False:\n+        if isinstance(obj, collections.abc.Iterator):\n+            raise RuntimeError(\"matplotlib does not support generators \"\n+                               \"as input\")\n+        return next(iter(obj))\n+    elif isinstance(obj, np.flatiter):\n+        # TODO do the finite filtering on this\n+        return obj[0]\n+    elif isinstance(obj, collections.abc.Iterator):\n+        raise RuntimeError(\"matplotlib does not \"\n+                           \"support generators as input\")\n+    else:\n+        try:\n+            return next(val for val in obj if safe_isfinite(val))\n+        except StopIteration:\n+            # Return the first element if no finite values found, maintaining backward compatibility\n+            return next(iter(obj))\n \n \n def sanitize_sequence(data):\n",
    "variant_2": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex fdac0f3560..cfea3634b4 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -2178,9 +2178,11 @@ class Axes(_AxesBase):\n             # We can't just cast x0 and dx to numpy arrays because that\n             # removes the units from unit packages like `pint` that\n             # wrap numpy arrays.\n+            try:\n+\n             try:\n                 x0 = cbook._safe_first_finite(x0)\n-            except (TypeError, IndexError, KeyError):\n+            except (TypeError, IndexError, KeyError, StopIteration):\n                 pass\n \n             try:\ndiff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex 34c6ddb861..aa5d7f3017 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -1746,7 +1746,45 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n         raise RuntimeError(\"matplotlib does not \"\n                            \"support generators as input\")\n     else:\n-        return next(val for val in obj if safe_isfinite(val))\n+\n+def _safe_first_finite(obj, skip_nonfinite=True):\n+    \"\"\"\n+    Return the first finite value in the given array.\n+\n+    If *skip_nonfinite* is False, return the first value.\n+    \"\"\"\n+    def safe_isfinite(val):\n+        if skip_nonfinite:\n+            try:\n+                return np.isfinite(val)\n+            except TypeError:\n+                return True\n+        else:\n+            return True\n+\n+    if obj.ndim == 0:\n+        raise RuntimeError(\"matplotlib does not support generators \"\n+                           \"as input\")\n+    elif obj.size == 0:\n+        raise RuntimeError(\"matplotlib does not support generators \"\n+                           \"as input\")\n+    elif obj.ndim > 0:\n+        if isinstance(obj, collections.abc.Iterator):\n+            raise RuntimeError(\"matplotlib does not support generators \"\n+                               \"as input\")\n+        return next(iter(obj))\n+    elif isinstance(obj, np.flatiter):\n+        # TODO do the finite filtering on this\n+        return obj[0]\n+    elif isinstance(obj, collections.abc.Iterator):\n+        raise RuntimeError(\"matplotlib does not \"\n+                           \"support generators as input\")\n+    else:\n+        try:\n+            return next(val for val in obj if safe_isfinite(val))\n+        except StopIteration:\n+            # Return the first element if no finite values found, maintaining backward compatibility\n+            return next(iter(obj))\n \n \n def sanitize_sequence(data):\n",
    "variant_3": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex fdac0f3560..cfea3634b4 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -2178,9 +2178,11 @@ class Axes(_AxesBase):\n             # We can't just cast x0 and dx to numpy arrays because that\n             # removes the units from unit packages like `pint` that\n             # wrap numpy arrays.\n+            try:\n+\n             try:\n                 x0 = cbook._safe_first_finite(x0)\n-            except (TypeError, IndexError, KeyError):\n+            except (TypeError, IndexError, KeyError, StopIteration):\n                 pass\n \n             try:\ndiff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex 34c6ddb861..0ed4d238c3 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -1746,7 +1746,43 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n         raise RuntimeError(\"matplotlib does not \"\n                            \"support generators as input\")\n     else:\n-        return next(val for val in obj if safe_isfinite(val))\n+\n+def _safe_first_finite(obj, skip_nonfinite=True):\n+    \"\"\"\n+    Return the first finite value in the given array.\n+\n+    If *skip_nonfinite* is False, return the first value.\n+    \"\"\"\n+    if skip_nonfinite is False:\n+        if isinstance(obj, collections.abc.Iterator):\n+            # needed to accept `array.flat` as input.\n+            # np.flatiter reports as an instance of collections.Iterator\n+            # but can still be indexed via []\n+            # This has the side effect of re-setting the iterator, but\n+            # that is acceptable.\n+            try:\n+                return obj[0]\n+            except TypeError:\n+                pass\n+        try:\n+            return obj[0]\n+        except (TypeError, IndexError, KeyError):\n+            pass\n+        raise RuntimeError(\"matplotlib does not support generators \"\n+                           \"as input\")\n+        return next(iter(obj))\n+    elif isinstance(obj, np.flatiter):\n+        # TODO do the finite filtering on this\n+        return obj[0]\n+    elif isinstance(obj, collections.abc.Iterator):\n+        raise RuntimeError(\"matplotlib does not \"\n+                           \"support generators as input\")\n+    else:\n+        try:\n+            return next(val for val in obj if safe_isfinite(val))\n+        except StopIteration:\n+            # Return the first element if no finite values found, maintaining backward compatibility\n+            return next(iter(obj))\n \n \n def sanitize_sequence(data):\n",
    "variant_4": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex fdac0f3560..3e1036896f 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -2179,9 +2179,12 @@ class Axes(_AxesBase):\n             # removes the units from unit packages like `pint` that\n             # wrap numpy arrays.\n             try:\n-                x0 = cbook._safe_first_finite(x0)\n-            except (TypeError, IndexError, KeyError):\n-                pass\n+\n+        try:\n+            return next(val for val in obj if safe_isfinite(val))\n+        except StopIteration:\n+            # Return the first element if no finite values found, maintaining backward compatibility\n+            return next(iter(obj))\n \n             try:\n                 x = cbook._safe_first_finite(xconv)\ndiff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex 34c6ddb861..3bb39ba900 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -1746,7 +1746,47 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n         raise RuntimeError(\"matplotlib does not \"\n                            \"support generators as input\")\n     else:\n-        return next(val for val in obj if safe_isfinite(val))\n+\n+def _safe_first_finite(obj, skip_nonfinite=True):\n+    \"\"\"\n+    Return the first non-None and finite value in the given sequence.\n+\n+    If such a value does not exist (i.e., all values are None or nonfinite),\n+    a ValueError is raised.\n+\n+    Parameters\n+    ----------\n+    obj : iterable\n+    skip_nonfinite : bool, default: True\n+        If True (default), skip over entries that are not finite numbers.\n+        If False, return the first entry, finite or not.\n+    \"\"\"\n+    if skip_nonfinite is False:\n+        return safe_first_element(obj)\n+\n+    def safe_isfinite(val):\n+        if val is None:\n+            return False\n+        try:\n+            return math.isfinite(val)\n+        except (TypeError, ValueError):\n+            return False\n+\n+    if isinstance(obj, collections.abc.Mapping):\n+        raise RuntimeError(\"matplotlib does not support generators \"\n+                           \"as input\")\n+    elif isinstance(obj, np.flatiter):\n+        # TODO do the finite filtering on this\n+        return obj[0]\n+    elif isinstance(obj, collections.abc.Iterator):\n+        raise RuntimeError(\"matplotlib does not \"\n+                           \"support generators as input\")\n+    else:\n+        try:\n+            return next(val for val in obj if safe_isfinite(val))\n+        except StopIteration:\n+            # Return the first element if no finite values found, maintaining backward compatibility\n+            return next(iter(obj))\n \n \n def sanitize_sequence(data):\n",
    "variant_5": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex fdac0f3560..13e2c50bea 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -2179,7 +2179,13 @@ class Axes(_AxesBase):\n             # removes the units from unit packages like `pint` that\n             # wrap numpy arrays.\n             try:\n-                x0 = cbook._safe_first_finite(x0)\n+\n+            try:\n+                try:\n+                    x0 = cbook._safe_first_finite(x0)\n+                except StopIteration:\n+                    # If no finite values found, use the first element to maintain backward compatibility\n+                    x0 = next(iter(x0)) if hasattr(x0, '__iter__') else x0\n             except (TypeError, IndexError, KeyError):\n                 pass\n \ndiff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex 34c6ddb861..ac3d7a2b6b 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -1746,7 +1746,39 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n         raise RuntimeError(\"matplotlib does not \"\n                            \"support generators as input\")\n     else:\n-        return next(val for val in obj if safe_isfinite(val))\n+\n+def _safe_first_finite(obj, skip_nonfinite=True):\n+    \"\"\"\n+    Return the first finite value in the given object.\n+\n+    If *skip_nonfinite* is False, return the first value.\n+    \"\"\"\n+    def safe_isfinite(val):\n+        if skip_nonfinite:\n+            try:\n+                return np.isfinite(val)\n+            except (TypeError, ValueError):\n+                pass\n+        return True\n+\n+    if isinstance(obj, collections.abc.Generator):\n+        # Consume the first value; we can't just call next(obj) on a\n+        # generator because that would consume it.\n+        raise RuntimeError(\"matplotlib does not support generators \"\n+                           \"as input\")\n+        return next(iter(obj))\n+    elif isinstance(obj, np.flatiter):\n+        # TODO do the finite filtering on this\n+        return obj[0]\n+    elif isinstance(obj, collections.abc.Iterator):\n+        raise RuntimeError(\"matplotlib does not \"\n+                           \"support generators as input\")\n+    else:\n+        try:\n+            return next(val for val in obj if safe_isfinite(val))\n+        except StopIteration:\n+            # Return the first element if no finite values found, maintaining backward compatibility\n+            return next(iter(obj))\n \n \n def sanitize_sequence(data):\n",
    "variant_6": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex fdac0f3560..cfea3634b4 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -2178,9 +2178,11 @@ class Axes(_AxesBase):\n             # We can't just cast x0 and dx to numpy arrays because that\n             # removes the units from unit packages like `pint` that\n             # wrap numpy arrays.\n+            try:\n+\n             try:\n                 x0 = cbook._safe_first_finite(x0)\n-            except (TypeError, IndexError, KeyError):\n+            except (TypeError, IndexError, KeyError, StopIteration):\n                 pass\n \n             try:\ndiff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex 34c6ddb861..26ecf7b2bc 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -1746,7 +1746,51 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n         raise RuntimeError(\"matplotlib does not \"\n                            \"support generators as input\")\n     else:\n-        return next(val for val in obj if safe_isfinite(val))\n+\n+def _safe_first_finite(obj, skip_nonfinite=True):\n+    \"\"\"\n+    Return the first non-None, non-NaN, non-inf value in obj.\n+\n+    This is a method for internal use.\n+\n+    This is effectively a method to get a sample element from an array-like\n+    object, that can be used for auto-scaling. It is meant to be used for\n+    arrays that are not expected to have all NaN/inf values.\n+\n+    If all values are non-finite, the first value is returned.\n+\n+    Parameters\n+    ----------\n+    obj : array-like\n+        The array to get the first finite value from.\n+    skip_nonfinite : bool, default: True\n+        Whether to skip non-finite values.\n+\n+    Returns\n+    -------\n+    The first finite value or the first value if all values are non-finite.\n+    \"\"\"\n+    if skip_nonfinite is False:\n+        # Return the first value without any filtering.\n+        return next(iter(obj))\n+    if isinstance(obj, types.GeneratorType):\n+        # Generators are not handled because they consume the\n+        # iterator, and we want to keep the generator for\n+        # being processed by the registered listeners.\n+        raise RuntimeError(\"matplotlib does not support generators \"\n+                           \"as input\")\n+    elif isinstance(obj, np.flatiter):\n+        # TODO do the finite filtering on this\n+        return obj[0]\n+    elif isinstance(obj, collections.abc.Iterator):\n+        raise RuntimeError(\"matplotlib does not \"\n+                           \"support generators as input\")\n+    else:\n+        try:\n+            return next(val for val in obj if safe_isfinite(val))\n+        except StopIteration:\n+            # Return the first element if no finite values found, maintaining backward compatibility\n+            return next(iter(obj))\n \n \n def sanitize_sequence(data):\n",
    "variant_7": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex fdac0f3560..cfea3634b4 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -2178,9 +2178,11 @@ class Axes(_AxesBase):\n             # We can't just cast x0 and dx to numpy arrays because that\n             # removes the units from unit packages like `pint` that\n             # wrap numpy arrays.\n+            try:\n+\n             try:\n                 x0 = cbook._safe_first_finite(x0)\n-            except (TypeError, IndexError, KeyError):\n+            except (TypeError, IndexError, KeyError, StopIteration):\n                 pass\n \n             try:\ndiff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex 34c6ddb861..47183e3531 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -1746,7 +1746,42 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n         raise RuntimeError(\"matplotlib does not \"\n                            \"support generators as input\")\n     else:\n-        return next(val for val in obj if safe_isfinite(val))\n+\n+def _safe_first_finite(obj, *, skip_nonfinite=True):\n+    \"\"\"\n+    Return the first finite value in the given array.\n+\n+    If *skip_nonfinite* is False, return the first value.\n+    \"\"\"\n+    def safe_isfinite(val):\n+        if skip_nonfinite:\n+            try:\n+                return math.isfinite(val)\n+            except (TypeError, ValueError):\n+                pass\n+        return True\n+\n+    if isinstance(obj, collections.abc.Generator):\n+        # Generators can't be restarted, so check for finite values first.\n+        # If we find at least one, return the first finite one. If we don't\n+        # find any, raise a RuntimeError instead of letting it continue.\n+        obj = list(obj)\n+        if not obj:\n+            raise RuntimeError(\"matplotlib does not support generators \"\n+                               \"as input\")\n+        return next(iter(obj))\n+    elif isinstance(obj, np.flatiter):\n+        # TODO do the finite filtering on this\n+        return obj[0]\n+    elif isinstance(obj, collections.abc.Iterator):\n+        raise RuntimeError(\"matplotlib does not \"\n+                           \"support generators as input\")\n+    else:\n+        try:\n+            return next(val for val in obj if safe_isfinite(val))\n+        except StopIteration:\n+            # Return the first element if no finite values found, maintaining backward compatibility\n+            return next(iter(obj))\n \n \n def sanitize_sequence(data):\n",
    "variant_8": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex fdac0f3560..3e1036896f 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -2179,9 +2179,12 @@ class Axes(_AxesBase):\n             # removes the units from unit packages like `pint` that\n             # wrap numpy arrays.\n             try:\n-                x0 = cbook._safe_first_finite(x0)\n-            except (TypeError, IndexError, KeyError):\n-                pass\n+\n+        try:\n+            return next(val for val in obj if safe_isfinite(val))\n+        except StopIteration:\n+            # Return the first element if no finite values found, maintaining backward compatibility\n+            return next(iter(obj))\n \n             try:\n                 x = cbook._safe_first_finite(xconv)\ndiff --git a/lib/matplotlib/cbook/__init__.py b/lib/matplotlib/cbook/__init__.py\nindex 34c6ddb861..4e868dbadf 100644\n--- a/lib/matplotlib/cbook/__init__.py\n+++ b/lib/matplotlib/cbook/__init__.py\n@@ -1746,7 +1746,44 @@ def _safe_first_finite(obj, *, skip_nonfinite=True):\n         raise RuntimeError(\"matplotlib does not \"\n                            \"support generators as input\")\n     else:\n-        return next(val for val in obj if safe_isfinite(val))\n+\n+def _safe_first_finite(obj, *, skip_nonfinite=True):\n+    \"\"\"\n+    Return the first finite value in the given object.\n+\n+    If *skip_nonfinite* is False, return the first value.\n+    \"\"\"\n+    def safe_isfinite(val):\n+        return np.isscalar(val) and np.isfinite(val)\n+    def safe_isnan(val):\n+        return np.isscalar(val) and np.isnan(val)\n+\n+    if skip_nonfinite is False:\n+        if isinstance(obj, collections.abc.Iterator):\n+            # needed to accept `array.flat` as input.\n+            # np.flatiter reports as an instance of collections.Iterator\n+            # but can still be indexed via [].\n+            # This has the side effect of re-setting the iterator, but\n+            # that is acceptable.\n+            try:\n+                return obj[0]\n+            except TypeError:\n+                pass\n+            raise RuntimeError(\"matplotlib does not support generators \"\n+                               \"as input\")\n+        return next(iter(obj))\n+    elif isinstance(obj, np.flatiter):\n+        # TODO do the finite filtering on this\n+        return obj[0]\n+    elif isinstance(obj, collections.abc.Iterator):\n+        raise RuntimeError(\"matplotlib does not \"\n+                           \"support generators as input\")\n+    else:\n+        try:\n+            return next(val for val in obj if safe_isfinite(val))\n+        except StopIteration:\n+            # Return the first element if no finite values found, maintaining backward compatibility\n+            return next(iter(obj))\n \n \n def sanitize_sequence(data):\n"
  }
}