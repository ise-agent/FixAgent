{
  "zero_patches": {
    "Location 1 (/Users/hanyu/isea/projects_1/astropy/astropy/modeling/separable.py lines 219-247)": "\ndef _cstack(left, right):\n    \"\"\"\n    Function corresponding to '&' operation.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    Returns\n    -------\n    result : ndarray\n        Result from this operation.\n\n    \"\"\"\n    noutp = _compute_n_outputs(left, right)\n\n    if isinstance(left, Model):\n        cleft = _coord_matrix(left, 'left', noutp)\n    else:\n        cleft = np.zeros((noutp, left.shape[1]))\n        cleft[: left.shape[0], : left.shape[1]] = left\n    if isinstance(right, Model):\n        cright = _coord_matrix(right, 'right', noutp)\n    else:\n        cright = np.zeros((noutp, right.shape[1]))\n        cright[-right.shape[0]:, -right.shape[1]:] = right\n\n    return np.hstack([cleft, cright])\n",
    "Location 2 (/Users/hanyu/isea/projects_1/astropy/astropy/modeling/separable.py lines 171-216)": "\ndef _coord_matrix(model, pos, noutp):\n    \"\"\"\n    Create an array representing inputs and outputs of a simple model.\n\n    The array has a shape (noutp, model.n_inputs).\n\n    Parameters\n    ----------\n    model : `astropy.modeling.Model`\n        model\n    pos : str\n        Position of this model in the expression tree.\n        One of ['left', 'right'].\n    noutp : int\n        Number of outputs of the compound model of which the input model\n        is a left or right child.\n\n    \"\"\"\n    if isinstance(model, Mapping):\n        axes = []\n        for i in model.mapping:\n            axis = np.zeros((model.n_inputs,))\n            axis[i] = 1\n            axes.append(axis)\n        m = np.vstack(axes)\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[: model.n_outputs, :model.n_inputs] = m\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = m\n        return mat\n    if not model.separable:\n        # this does not work for more than 2 coordinates\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[:model.n_outputs, : model.n_inputs] = 1\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = 1\n    else:\n        mat = np.zeros((noutp, model.n_inputs))\n\n        for i in range(model.n_inputs):\n            mat[i, i] = 1\n        if pos == 'right':\n            mat = np.roll(mat, (noutp - model.n_outputs))\n    return mat\n",
    "Location 3 (/Users/hanyu/isea/projects_1/astropy/astropy/modeling/separable.py lines 105-127)": "\ndef _compute_n_outputs(left, right):\n    \"\"\"\n    Compute the number of outputs of two models.\n\n    The two models are the left and right model to an operation in\n    the expression tree of a compound model.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    \"\"\"\n    if isinstance(left, Model):\n        lnout = left.n_outputs\n    else:\n        lnout = left.shape[0]\n    if isinstance(right, Model):\n        rnout = right.n_outputs\n    else:\n        rnout = right.shape[0]\n    noutp = lnout + rnout\n    return noutp\n",
    "Location 4 (/Users/hanyu/isea/projects_1/astropy/astropy/modeling/functional_models.py lines 1-50)": "\n    def _cstack(left, right):\n        \"\"\"\n        Combine the separability matrices of two models.\n        \"\"\"\n        n_left = left.shape[0]\n        n_right = right.shape[0]\n        cstack = np.zeros((n_left + n_right, n_left + n_right), dtype=bool)\n        \n        # Top-left quadrant\n        cstack[:n_left, :n_left] = left\n        \n        # Bottom-right quadrant\n        cstack[-n_right:, -n_right:] = right\n        \n        return cstack\n",
    "Location 5 (/Users/hanyu/isea/projects_1/astropy/astropy/modeling/core.py lines 1-50)": "\ndef _model_oper(oper, **kwargs):\n    \"\"\"\n    Returns a function that evaluates a given Python arithmetic operator\n    between two models.  The operator should be given as a string, like ``'+'``\n    or ``'**'``.\n\n    Parameters\n    ----------\n    oper : str\n        The operator to use.\n    **kwargs : dict\n        Additional keyword arguments to pass to the CompoundModel.\n\n    Returns\n    -------\n    function\n        A function that takes two models and returns a CompoundModel.\n    \"\"\"\n    return lambda left, right: CompoundModel(oper, left, right, **kwargs)\n"
  },
  "variant_patches": {
    "Location 1 (/Users/hanyu/isea/projects_1/astropy/astropy/modeling/separable.py lines 219-247)": [
      "\ndef _cstack(left, right):\n    \"\"\"\n    Function corresponding to '&' operation.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    Returns\n    -------\n    result : ndarray\n        Result from this operation.\n\n    \"\"\"\n    noutp = _compute_n_outputs(left, right)\n\n    if isinstance(left, Model):\n        cleft = _coord_matrix(left, 'left', noutp)\n    else:\n        cleft = np.zeros((noutp, left.shape[1]))\n        cleft[: left.shape[0], : left.shape[1]] = left\n    if isinstance(right, Model):\n        cright = _coord_matrix(right, 'right', noutp)\n    else:\n        cright = np.zeros((noutp, right.shape[1]))\n        cright[-right.shape[0]:, -right.shape[1]:] = right\n\n    return np.hstack([cleft, cright])\n",
      "\ndef _cstack(left, right):\n    \"\"\"\n    Function corresponding to '&' operation.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    Returns\n    -------\n    result : ndarray\n        Result from this operation.\n\n    \"\"\"\n    noutp = _compute_n_outputs(left, right)\n\n    if isinstance(left, Model):\n        cleft = _coord_matrix(left, 'left', noutp)\n    else:\n        cleft = np.zeros((noutp, left.shape[1]))\n        cleft[: left.shape[0], : left.shape[1]] = left\n    if isinstance(right, Model):\n        cright = _coord_matrix(right, 'right', noutp)\n    else:\n        cright = np.zeros((noutp, right.shape[1]))\n        cright[-right.shape[0]:, -right.shape[1]:] = right\n\n    return np.hstack([cleft, cright])\n",
      "\ndef _cstack(left, right):\n    \"\"\"\n    Function corresponding to '&' operation.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    Returns\n    -------\n    result : ndarray\n        Result from this operation.\n\n    \"\"\"\n    noutp = _compute_n_outputs(left, right)\n\n    if isinstance(left, Model):\n        cleft = _coord_matrix(left, 'left', noutp)\n    else:\n        cleft = np.zeros((noutp, left.shape[1]))\n        cleft[: left.shape[0], : left.shape[1]] = left\n    if isinstance(right, Model):\n        cright = _coord_matrix(right, 'right', noutp)\n    else:\n        cright = np.zeros((noutp, right.shape[1]))\n        cright[-right.shape[0]:, -right.shape[1]:] = right\n\n    return np.hstack([cleft, cright])\n",
      "\ndef _cstack(left, right):\n    \"\"\"\n    Function corresponding to '&' operation.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    Returns\n    -------\n    result : ndarray\n        Result from this operation.\n\n    \"\"\"\n    noutp = _compute_n_outputs(left, right)\n\n    if isinstance(left, Model):\n        cleft = _coord_matrix(left, 'left', noutp)\n    else:\n        cleft = np.zeros((noutp, left.shape[1]))\n        cleft[: left.shape[0], : left.shape[1]] = left\n    if isinstance(right, Model):\n        cright = _coord_matrix(right, 'right', noutp)\n    else:\n        cright = np.zeros((noutp, right.shape[1]))\n        cright[-right.shape[0]:, -right.shape[1]:] = right\n\n    return np.hstack([cleft, cright])\n",
      "\ndef _cstack(left, right):\n    \"\"\"\n    Function corresponding to '&' operation.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    Returns\n    -------\n    result : ndarray\n        Result from this operation.\n\n    \"\"\"\n    noutp = _compute_n_outputs(left, right)\n\n    if isinstance(left, Model):\n        cleft = _coord_matrix(left, 'left', noutp)\n    else:\n        cleft = np.zeros((noutp, left.shape[1]))\n        cleft[: left.shape[0], : left.shape[1]] = left\n    if isinstance(right, Model):\n        cright = _coord_matrix(right, 'right', noutp)\n    else:\n        cright = np.zeros((noutp, right.shape[1]))\n        cright[-right.shape[0]:, -right.shape[1]:] = right\n\n    return np.hstack([cleft, cright])\n",
      "\ndef _cstack(left, right):\n    \"\"\"\n    Function corresponding to '&' operation.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    Returns\n    -------\n    result : ndarray\n        Result from this operation.\n\n    \"\"\"\n    noutp = _compute_n_outputs(left, right)\n\n    if isinstance(left, Model):\n        cleft = _coord_matrix(left, 'left', noutp)\n    else:\n        cleft = np.zeros((noutp, left.shape[1]))\n        cleft[: left.shape[0], : left.shape[1]] = left\n    if isinstance(right, Model):\n        cright = _coord_matrix(right, 'right', noutp)\n    else:\n        cright = np.zeros((noutp, right.shape[1]))\n        cright[-right.shape[0]:, -right.shape[1]:] = right\n\n    return np.hstack([cleft, cright])\n",
      "\ndef _cstack(left, right):\n    \"\"\"\n    Function corresponding to '&' operation.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    Returns\n    -------\n    result : ndarray\n        Result from this operation.\n\n    \"\"\"\n    noutp = _compute_n_outputs(left, right)\n\n    if isinstance(left, Model):\n        cleft = _coord_matrix(left, 'left', noutp)\n    else:\n        cleft = np.zeros((noutp, left.shape[1]))\n        cleft[: left.shape[0], : left.shape[1]] = left\n    if isinstance(right, Model):\n        cright = _coord_matrix(right, 'right', noutp)\n    else:\n        cright = np.zeros((noutp, right.shape[1]))\n        cright[-right.shape[0]:, -right.shape[1]:] = right\n\n    return np.hstack([cleft, cright])\n",
      "\ndef _cstack(left, right):\n    \"\"\"\n    Function corresponding to '&' operation.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    Returns\n    -------\n    result : ndarray\n        Result from this operation.\n\n    \"\"\"\n    noutp = _compute_n_outputs(left, right)\n\n    if isinstance(left, Model):\n        cleft = _coord_matrix(left, 'left', noutp)\n    else:\n        cleft = np.zeros((noutp, left.shape[1]))\n        cleft[: left.shape[0], : left.shape[1]] = left\n    if isinstance(right, Model):\n        cright = _coord_matrix(right, 'right', noutp)\n    else:\n        cright = np.zeros((noutp, right.shape[1]))\n        cright[-right.shape[0]:, -right.shape[1]:] = right\n\n    return np.hstack([cleft, cright])\n"
    ],
    "Location 2 (/Users/hanyu/isea/projects_1/astropy/astropy/modeling/separable.py lines 171-216)": [
      "\ndef _coord_matrix(model, pos, noutp):\n    \"\"\"\n    Create an array representing inputs and outputs of a simple model.\n\n    The array has a shape (noutp, model.n_inputs).\n\n    Parameters\n    ----------\n    model : `astropy.modeling.Model`\n        model\n    pos : str\n        Position of this model in the expression tree.\n        One of ['left', 'right'].\n    noutp : int\n        Number of outputs of the compound model of which the input model\n        is a left or right child.\n\n    \"\"\"\n    if isinstance(model, Mapping):\n        axes = []\n        for i in model.mapping:\n            axis = np.zeros((model.n_inputs,))\n            axis[i] = 1\n            axes.append(axis)\n        m = np.vstack(axes)\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[: model.n_outputs, :model.n_inputs] = m\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = m\n        return mat\n    if not model.separable:\n        # this does not work for more than 2 coordinates\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[:model.n_outputs, : model.n_inputs] = 1\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = 1\n    else:\n        mat = np.zeros((noutp, model.n_inputs))\n\n        for i in range(model.n_inputs):\n            mat[i, i] = 1\n        if pos == 'right':\n            mat = np.roll(mat, (noutp - model.n_outputs))\n    return mat\n",
      "\ndef _coord_matrix(model, pos, noutp):\n    \"\"\"\n    Create an array representing inputs and outputs of a simple model.\n\n    The array has a shape (noutp, model.n_inputs).\n\n    Parameters\n    ----------\n    model : `astropy.modeling.Model`\n        model\n    pos : str\n        Position of this model in the expression tree.\n        One of ['left', 'right'].\n    noutp : int\n        Number of outputs of the compound model of which the input model\n        is a left or right child.\n\n    \"\"\"\n    if isinstance(model, Mapping):\n        axes = []\n        for i in model.mapping:\n            axis = np.zeros((model.n_inputs,))\n            axis[i] = 1\n            axes.append(axis)\n        m = np.vstack(axes)\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[: model.n_outputs, :model.n_inputs] = m\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = m\n        return mat\n    if not model.separable:\n        # this does not work for more than 2 coordinates\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[:model.n_outputs, : model.n_inputs] = 1\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = 1\n    else:\n        mat = np.zeros((noutp, model.n_inputs))\n\n        for i in range(model.n_inputs):\n            mat[i, i] = 1\n        if pos == 'right':\n            mat = np.roll(mat, (noutp - model.n_outputs, 0))\n    return mat\n",
      "\ndef _coord_matrix(model, pos, noutp):\n    \"\"\"\n    Create an array representing inputs and outputs of a simple model.\n\n    The array has a shape (noutp, model.n_inputs).\n\n    Parameters\n    ----------\n    model : `astropy.modeling.Model`\n        model\n    pos : str\n        Position of this model in the expression tree.\n        One of ['left', 'right'].\n    noutp : int\n        Number of outputs of the compound model of which the input model\n        is a left or right child.\n\n    \"\"\"\n    if isinstance(model, Mapping):\n        axes = []\n        for i in model.mapping:\n            axis = np.zeros((model.n_inputs,))\n            axis[i] = 1\n            axes.append(axis)\n        m = np.vstack(axes)\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[: model.n_outputs, :model.n_inputs] = m\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = m\n        return mat\n    if not model.separable:\n        # this does not work for more than 2 coordinates\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[:model.n_outputs, : model.n_inputs] = 1\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = 1\n    else:\n        mat = np.zeros((noutp, model.n_inputs))\n\n        for i in range(model.n_inputs):\n            mat[i, i] = 1\n        if pos == 'right':\n            mat = np.roll(mat, noutp - model.n_outputs)\n    return mat\n",
      "\ndef _cstack(left, right):\n    \"\"\"\n    Function corresponding to '&' operation.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    Returns\n    -------\n    result : ndarray\n        Array with shape (left.shape[0] + right.shape[0], left.shape[1])\n    \"\"\"\n    if not isinstance(left, np.ndarray):\n        cleft = _coord_matrix(left, 'left', left.n_outputs + right.n_outputs)\n    else:\n        cleft = left\n    if not isinstance(right, np.ndarray):\n        cright = _coord_matrix(right, 'right', left.n_outputs + right.n_outputs)\n    else:\n        cright = right\n    result = np.zeros((cleft.shape[0] + cright.shape[0], cleft.shape[1]))\n    result[:cleft.shape[0], :cleft.shape[1]] = cleft\n    result[-cright.shape[0]:, -cright.shape[1]:] = cright\n    return result\n",
      "\ndef _coord_matrix(model, pos, noutp):\n    \"\"\"\n    Create an array representing inputs and outputs of a simple model.\n\n    The array has a shape (noutp, model.n_inputs).\n\n    Parameters\n    ----------\n    model : `astropy.modeling.Model`\n        model\n    pos : str\n        Position of this model in the expression tree.\n        One of ['left', 'right'].\n    noutp : int\n        Number of outputs of the compound model of which the input model\n        is a left or right child.\n\n    \"\"\"\n    if isinstance(model, Mapping):\n        axes = []\n        for i in model.mapping:\n            axis = np.zeros((model.n_inputs,))\n            axis[i] = 1\n            axes.append(axis)\n        m = np.vstack(axes)\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[: model.n_outputs, :model.n_inputs] = m\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = m\n        return mat\n    if not model.separable:\n        # this does not work for more than 2 coordinates\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[:model.n_outputs, : model.n_inputs] = 1\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = 1\n    else:\n        mat = np.zeros((noutp, model.n_inputs))\n\n        for i in range(model.n_inputs):\n            mat[i, i] = 1\n        if pos == 'right':\n            mat = np.roll(mat, (noutp - model.n_outputs))\n    return mat\n",
      "\ndef _coord_matrix(model, pos, noutp):\n    \"\"\"\n    Create an array representing inputs and outputs of a simple model.\n\n    The array has a shape (noutp, model.n_inputs).\n\n    Parameters\n    ----------\n    model : `astropy.modeling.Model`\n        model\n    pos : str\n        Position of this model in the expression tree.\n        One of ['left', 'right'].\n    noutp : int\n        Number of outputs of the compound model of which the input model\n        is a left or right child.\n\n    \"\"\"\n    if isinstance(model, Mapping):\n        axes = []\n        for i in model.mapping:\n            axis = np.zeros((model.n_inputs,))\n            axis[i] = 1\n            axes.append(axis)\n        m = np.vstack(axes)\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[: model.n_outputs, :model.n_inputs] = m\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = m\n        return mat\n    if not model.separable:\n        # this does not work for more than 2 coordinates\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[:model.n_outputs, : model.n_inputs] = 1\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = 1\n    else:\n        mat = np.zeros((noutp, model.n_inputs))\n\n        for i in range(model.n_inputs):\n            mat[i, i] = 1\n        if pos == 'right':\n            mat = np.roll(mat, (noutp - model.n_outputs))\n    return mat\n",
      "\ndef _coord_matrix(model, pos, noutp):\n    \"\"\"\n    Create an array representing inputs and outputs of a simple model.\n\n    The array has a shape (noutp, model.n_inputs).\n\n    Parameters\n    ----------\n    model : `astropy.modeling.Model`\n        model\n    pos : str\n        Position of this model in the expression tree.\n        One of ['left', 'right'].\n    noutp : int\n        Number of outputs of the compound model of which the input model\n        is a left or right child.\n\n    \"\"\"\n    if isinstance(model, Mapping):\n        axes = []\n        for i in model.mapping:\n            axis = np.zeros((model.n_inputs,))\n            axis[i] = 1\n            axes.append(axis)\n        m = np.vstack(axes)\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[: model.n_outputs, :model.n_inputs] = m\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = m\n        return mat\n    if not model.separable:\n        # this does not work for more than 2 coordinates\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[:model.n_outputs, : model.n_inputs] = 1\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = 1\n    else:\n        mat = np.zeros((noutp, model.n_inputs))\n\n        for i in range(model.n_inputs):\n            mat[i, i] = 1\n        if pos == 'right':\n            mat = np.roll(mat, (noutp - model.n_outputs))\n    return mat\n",
      "\ndef _coord_matrix(model, pos, noutp):\n    \"\"\"\n    Create an array representing inputs and outputs of a simple model.\n\n    The array has a shape (noutp, model.n_inputs).\n\n    Parameters\n    ----------\n    model : `astropy.modeling.Model`\n        model\n    pos : str\n        Position of this model in the expression tree.\n        One of ['left', 'right'].\n    noutp : int\n        Number of outputs of the compound model of which the input model\n        is a left or right child.\n\n    \"\"\"\n    if isinstance(model, Mapping):\n        axes = []\n        for i in model.mapping:\n            axis = np.zeros((model.n_inputs,))\n            axis[i] = 1\n            axes.append(axis)\n        m = np.vstack(axes)\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[: model.n_outputs, :model.n_inputs] = m\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = m\n        return mat\n    if not model.separable:\n        # this does not work for more than 2 coordinates\n        mat = np.zeros((noutp, model.n_inputs))\n        if pos == 'left':\n            mat[:model.n_outputs, : model.n_inputs] = 1\n        else:\n            mat[-model.n_outputs:, -model.n_inputs:] = 1\n    else:\n        mat = np.zeros((noutp, model.n_inputs))\n\n        for i in range(model.n_inputs):\n            mat[i, i] = 1\n        if pos == 'right':\n            mat = np.roll(mat, (noutp - model.n_outputs))\n    return mat\n"
    ],
    "Location 3 (/Users/hanyu/isea/projects_1/astropy/astropy/modeling/separable.py lines 105-127)": [
      "\ndef _compute_n_outputs(left, right):\n    \"\"\"\n    Compute the number of outputs of two models.\n\n    The two models are the left and right model to an operation in\n    the expression tree of a compound model.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    \"\"\"\n    if isinstance(left, Model):\n        lnout = left.n_outputs\n    else:\n        lnout = left.shape[0]\n    if isinstance(right, Model):\n        rnout = right.n_outputs\n    else:\n        rnout = right.shape[0]\n    noutp = lnout + rnout\n    return noutp\n",
      "\ndef _compute_n_outputs(left, right):\n    \"\"\"\n    Compute the number of outputs of two models.\n\n    The two models are the left and right model to an operation in\n    the expression tree of a compound model.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    \"\"\"\n    if isinstance(left, Model):\n        lnout = left.n_outputs\n    else:\n        lnout = left.shape[0]\n    if isinstance(right, Model):\n        rnout = right.n_outputs\n    else:\n        rnout = right.shape[0]\n    noutp = lnout + rnout\n    return noutp\n",
      "\ndef _compute_n_outputs(left, right):\n    \"\"\"\n    Compute the number of outputs of two models.\n\n    The two models are the left and right model to an operation in\n    the expression tree of a compound model.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    \"\"\"\n    if isinstance(left, Model):\n        lnout = left.n_outputs\n    else:\n        if left.shape[0] == 0:\n            lnout = 0\n        else:\n            lnout = left.shape[0]\n    if isinstance(right, Model):\n        rnout = right.n_outputs\n    else:\n        if right.shape[0] == 0:\n            rnout = 0\n        else:\n            rnout = right.shape[0]\n    noutp = lnout + rnout\n    return noutp\n",
      "\ndef _compute_n_outputs(left, right):\n    \"\"\"\n    Compute the number of outputs of two models.\n\n    The two models are the left and right model to an operation in\n    the expression tree of a compound model.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    \"\"\"\n    if isinstance(left, Model):\n        lnout = left.n_outputs\n    else:\n        lnout = left.shape[0]\n    if isinstance(right, Model):\n        rnout = right.n_outputs\n    else:\n        rnout = right.shape[0]\n    noutp = lnout + rnout\n    return noutp\n",
      "\ndef _compute_n_outputs(left, right):\n    \"\"\"\n    Compute the number of outputs of two models.\n\n    The two models are the left and right model to an operation in\n    the expression tree of a compound model.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    \"\"\"\n    if isinstance(left, Model):\n        lnout = left.n_outputs\n    else:\n        lnout = left.shape[0]\n    if isinstance(right, Model):\n        rnout = right.n_outputs\n    else:\n        rnout = right.shape[0]\n    noutp = lnout + rnout\n    return noutp\n",
      "\ndef _compute_n_outputs(left, right):\n    \"\"\"\n    Compute the number of outputs of two models.\n\n    The two models are the left and right model to an operation in\n    the expression tree of a compound model.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    \"\"\"\n    if isinstance(left, Model):\n        lnout = left.n_outputs\n    else:\n        if left.shape[0] is None:\n            raise ValueError(\"Left operand must have defined shape\")\n        lnout = left.shape[0]\n    if isinstance(right, Model):\n        rnout = right.n_outputs\n    else:\n        if right.shape[0] is None:\n            raise ValueError(\"Right operand must have defined shape\")\n        rnout = right.shape[0]\n    noutp = lnout + rnout\n    return noutp\n",
      "\ndef _compute_n_outputs(left, right):\n    \"\"\"\n    Compute the number of outputs of two models.\n\n    The two models are the left and right model to an operation in\n    the expression tree of a compound model.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    \"\"\"\n    if isinstance(left, Model):\n        lnout = left.n_outputs\n    else:\n        lnout = left.shape[0]\n    if isinstance(right, Model):\n        rnout = right.n_outputs\n    else:\n        rnout = right.shape[0]\n    noutp = lnout + rnout\n    return noutp\n",
      "\ndef _compute_n_outputs(left, right):\n    \"\"\"\n    Compute the number of outputs of two models.\n\n    The two models are the left and right model to an operation in\n    the expression tree of a compound model.\n\n    Parameters\n    ----------\n    left, right : `astropy.modeling.Model` or ndarray\n        If input is of an array, it is the output of `coord_matrix`.\n\n    \"\"\"\n    if isinstance(left, Model):\n        lnout = left.n_outputs\n    else:\n        lnout = left.shape[0]\n    if isinstance(right, Model):\n        rnout = right.n_outputs\n    else:\n        rnout = right.shape[0]\n    noutp = lnout + rnout\n    return noutp\n"
    ],
    "Location 4 (/Users/hanyu/isea/projects_1/astropy/astropy/modeling/functional_models.py lines 1-50)": [
      "\n    cright = np.zeros((max_n_inputs, max_n_outputs), dtype=bool)\n    if right.shape == (1, 1):\n        cright[:, :] = right[0, 0]\n    else:\n        cright[-right.shape[0]:, -right.shape[1]:] = right\n",
      "\ndef _cstack(left, right):\n    \"\"\"\n    Stack two separability matrices diagonally, preserving their structure.\n    \"\"\"\n    if left is None:\n        return right\n    if right is None:\n        return left\n    \n    # Create zero-filled output array\n    mat = np.zeros((left.shape[0] + right.shape[0], \n                   left.shape[1] + right.shape[1]), dtype=bool)\n    \n    # Insert left and right matrices\n    mat[:left.shape[0], :left.shape[1]] = left\n    mat[-right.shape[0]:, -right.shape[1]:] = right\n    \n    return mat\n",
      "\n    def _cstack(left, right):\n        \"\"\"\n        Stack two separability matrices diagonally.\n\n        Parameters\n        ----------\n        left : ndarray\n            Left separability matrix\n        right : ndarray\n            Right separability matrix\n\n        Returns\n        -------\n        ndarray\n            Block diagonal matrix combining left and right\n        \"\"\"\n        if left is None and right is None:\n            return None\n        elif left is None:\n            return right.copy()\n        elif right is None:\n            return left.copy()\n\n        cleft = np.zeros((left.shape[0] + right.shape[0],\n                          left.shape[1] + right.shape[1]), dtype=bool)\n        cleft[:left.shape[0], :left.shape[1]] = left\n        cright = np.zeros_like(cleft)\n        cright[-right.shape[0]:, -right.shape[1]:] = right\n        return cleft | cright\n",
      "\n    def _cstack(left, right):\n        \"\"\"\n        Combine the separability matrices of two models into a single array.\n\n        Parameters\n        ----------\n        left : ndarray\n            Separability matrix for the left model\n        right : ndarray\n            Separability matrix for the right model\n\n        Returns\n        -------\n        ndarray\n            Combined separability matrix\n        \"\"\"\n        if left is None and right is None:\n            return None\n\n        if left is None:\n            left = np.ones((1, 1), dtype=bool)\n        if right is None:\n            right = np.ones((1, 1), dtype=bool)\n\n        cleft = np.zeros((left.shape[0] + right.shape[0],\n                          left.shape[1] + right.shape[1]), dtype=bool)\n        cleft[:left.shape[0], :left.shape[1]] = left\n        cright = np.zeros_like(cleft)\n        cright[-right.shape[0]:, -right.shape[1]:] = right\n\n        return cleft + cright\n",
      "\n    cright = np.zeros((nright, nright))\n    cright[-right.shape[0]:, -right.shape[1]:] = right\n",
      "\ndef _cstack(left, right):\n    \"\"\"\n    Combine two separability matrices (left and right) diagonally, preserving\n    their original structure and separability information.\n    \"\"\"\n    if left is None and right is None:\n        return None\n\n    if left is None:\n        return right\n\n    if right is None:\n        return left\n\n    cleft = np.zeros((left.shape[0] + right.shape[0],\n                      left.shape[1] + right.shape[1]), dtype=bool)\n    cright = np.zeros_like(cleft)\n\n    # Fill the diagonal blocks\n    cleft[:left.shape[0], :left.shape[1]] = left\n    cright[-right.shape[0]:, -right.shape[1]:] = right  # Preserve right structure\n\n    return cleft | cright\n",
      "\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\"\"\"Mathematical models.\"\"\"\n# pylint: disable=line-too-long, too-many-lines, too-many-arguments, invalid-name\nimport numpy as np\n\nfrom astropy import units as u\nfrom astropy.units import Quantity, UnitsError\nfrom .core import (Fittable1DModel, Fittable2DModel)\n\nfrom .parameters import Parameter, InputParameterError\nfrom .utils import ellipse_extent\n\n\n__all__ = ['AiryDisk2D', 'Moffat1D', 'Moffat2D', 'Box1D', 'Box2D', 'Const1D',\n           'Const2D', 'Ellipse2D', 'Disk2D', 'Gaussian1D', 'Gaussian2D',\n           'Linear1D', 'Lorentz1D', 'RickerWavelet1D', 'RickerWavelet2D',\n           'RedshiftScaleFactor', 'Multiply', 'Planar2D', 'Scale',\n           'Sersic1D', 'Sersic2D', 'Shift',\n           'Sine1D', 'Cosine1D', 'Tangent1D',\n           'ArcSine1D', 'ArcCosine1D', 'ArcTangent1D',\n           'Trapezoid1D', 'TrapezoidDisk2D', 'Ring2D', 'Voigt1D',\n           'KingProjectedAnalytic1D', 'Exponential1D', 'Logarithmic1D']\n\nTWOPI = 2 * np.pi\nFLOAT_EPSILON = float(np.finfo(np.float32).tiny)\n\n# Note that we define this here rather than using the value defined in\n# astropy.stats to avoid importing astropy.stats every time astropy.modeling\n# is loaded.\nGAUSSIAN_SIGMA_TO_FWHM = 2.0 * np.sqrt(2.0 * np.log(2.0))\n\n\nclass Gaussian1D(Fittable1DModel):\n    \"\"\"\n    One dimensional Gaussian model.\n\n    Parameters\n    ----------\n    amplitude : float or `~astropy.units.Quantity`.\n        Amplitude (peak value) of the Gaussian - for a normalized profile\n        (integrating to 1), set amplitude = 1 / (stddev * np.sqrt(2 * np.pi))\n    mean : float or `~astropy.units.Quantity`.\n        Mean of the Gaussian.\n    stddev : float or `~astropy.units.Quantity`.\n        Standard deviation of the Gaussian with FWHM = 2 * stddev * np.sqrt(2 * np.log(2)).\n\n    Notes\n    -----\n    Either all or none of input ``x``, ``mean`` and ``stddev`` must be provided\n    consistently with compatible units or as unitless numbers.\n\n    Model formula:\n\n        .. math:: f(x) = A e^{- \\\\frac{\\\\left(x - x_{0}\\\\right)^{2}}{2 \\\\sigma^{2}}}\n\n    Examples\n    --------\n    >>> from astropy.modeling import models\n    >>> def tie_center(model):\n",
      "\n    def _cstack(left, right):\n        \"\"\"\n        Horizontally stacks two separability matrices.\n\n        Parameters\n        ----------\n        left : ndarray\n            Left separability matrix.\n        right : ndarray\n            Right separability matrix.\n\n        Returns\n        -------\n        result : ndarray\n            Combined separability matrix.\n        \"\"\"\n        # Create a matrix with the correct dimensions filled with False\n        cright = np.zeros((left.shape[0] + right.shape[0],\n                          left.shape[1] + right.shape[1]), bool)\n        # Fill in the left matrix\n        cright[:left.shape[0], :left.shape[1]] = left\n        # Fill in the right matrix\n        cright[-right.shape[0]:, -right.shape[1]:] = right\n        return cright\n"
    ],
    "Location 5 (/Users/hanyu/isea/projects_1/astropy/astropy/modeling/core.py lines 1-50)": [
      "\ndef _model_oper(oper, **kwargs):\n    \"\"\"\n    Returns a function that evaluates a given Python arithmetic operator\n    between two models.  The operator should be given as a string, like ``'+'``\n    or ``'**'``.\n    \"\"\"\n    def compound_model_wrapper(left, right):\n        if isinstance(left, CompoundModel) and isinstance(right, CompoundModel):\n            return CompoundModel(oper, left, right, **kwargs, _preserve_separability=True)\n        return CompoundModel(oper, left, right, **kwargs)\n    return compound_model_wrapper\n",
      "\ndef _cstack(left, right):\n    \"\"\"\n    Stack two coordinate matrices diagonally, preserving separability.\n    \"\"\"\n    if left is None and right is None:\n        return None\n    elif left is None:\n        return right\n    elif right is None:\n        return left\n    \n    left = np.asarray(left, dtype=bool)\n    right = np.asarray(right, dtype=bool)\n    \n    n_left = left.shape[0] if left.ndim >= 1 else 0\n    n_right = right.shape[0] if right.ndim >= 1 else 0\n    \n    cright = np.zeros((n_left + n_right, n_left + n_right), dtype=bool)\n    if left.shape:\n        cright[:n_left, :left.shape[1]] = left\n    if right.shape:\n        cright[-right.shape[0]:, -right.shape[1]:] = right\n    \n    return cright\n",
      "\n# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n\"\"\"\nThis module defines base classes for all models.  The base class of all\nmodels is `~astropy.modeling.Model`. `~astropy.modeling.FittableModel` is\nthe base class for all fittable models. Fittable models can be linear or\nnonlinear in a regression analysis sense.\n\nAll models provide a `__call__` method which performs the transformation in\na purely mathematical way, i.e. the models are unitless.  Model instances can\nrepresent either a single model, or a \"model set\" representing multiple copies\nof the same type of model, but with potentially different values of the\nparameters in each model making up the set.\n\"\"\"\n# pylint: disable=invalid-name, protected-access, redefined-outer-name\nimport abc\nimport copy\nimport inspect\nimport itertools\nimport functools\nimport operator\nimport types\n\nfrom collections import defaultdict, deque\nfrom inspect import signature\nfrom itertools import chain\n\nimport numpy as np\n\nfrom astropy.utils import indent, metadata\nfrom astropy.table import Table\nfrom astropy.units import Quantity, UnitsError, dimensionless_unscaled\nfrom astropy.units.utils import quantity_asanyarray\nfrom astropy.utils import (sharedmethod, find_current_module,\n                           check_broadcast, IncompatibleShapeError, isiterable)\nfrom astropy.utils.codegen import make_function_with_signature\nfrom astropy.nddata.utils import add_array, extract_array\nfrom .utils import (combine_labels, make_binary_operator_eval,\n                    get_inputs_and_params, _combine_equivalency_dict,\n                    _ConstraintsDict, _SpecialOperatorsDict)\nfrom .bounding_box import ModelBoundingBox, CompoundBoundingBox\nfrom .parameters import (Parameter, InputParameterError,\n                         param_repr_oneline, _tofloat)\n\n\n__all__ = ['Model', 'FittableModel', 'Fittable1DModel', 'Fittable2DModel',\n           'CompoundModel', 'fix_inputs', 'custom_model', 'ModelDefinitionError',\n           'bind_bounding_box', 'bind_compound_bounding_box']\n",
      "\ncright[-right.shape[0]:, -right.shape[1]:] = right\n",
      "\ndef _cstack(left, right):\n    \"\"\"\n    Stack two coordinate matrices diagonally to preserve separability.\n    \"\"\"\n    if left.ndim != 2 or right.ndim != 2:\n        raise ValueError(\"Input matrices must be 2-dimensional\")\n\n    n_left = left.shape[0]\n    m_left = left.shape[1]\n    n_right = right.shape[0]\n    m_right = right.shape[1]\n\n    cleft = np.zeros((n_left, m_left + m_right), dtype=bool)\n    cleft[:, :m_left] = left\n\n    cright = np.zeros((n_right, m_left + m_right), dtype=bool)\n    cright[:, m_left:] = right\n\n    return np.vstack([cleft, cright])\n",
      "\ndef _cstack(left, right):\n    \"\"\"Stack two coordinate matrices diagonally.\"\"\"\n    if left.ndim != 2 or right.ndim != 2:\n        raise ValueError(\"Inputs must be 2D arrays.\")\n\n    n_left = left.shape[0]\n    n_right = right.shape[0]\n    n_both = n_left + n_right\n\n    cleft = np.zeros((n_both, n_both), dtype=bool)\n    cright = np.zeros((n_both, n_both), dtype=bool)\n\n    cleft[:n_left, :n_left] = left\n    cright[-n_right:, -n_right:] = right\n\n    return cleft, cright\n",
      "\n    cright = np.zeros((n_right_out, n_right_in), dtype=bool)\n    if right.separable:\n        cright[-right.shape[0]:, -right.shape[1]:] = right\n    else:\n        cright[:] = True\n",
      "\ndef _cstack(left, right):\n    \"\"\"\n    Stack two separability matrices diagonally.\n    \"\"\"\n    if left is None and right is None:\n        return None\n\n    if left is None:\n        return right\n\n    if right is None:\n        return left\n\n    left = np.asarray(left, bool)\n    right = np.asarray(right, bool)\n\n    sleft0, sleft1 = left.shape\n    sright0, sright1 = right.shape\n\n    cleft = np.zeros((sleft0 + sright0, sleft1 + sright1), bool)\n    cleft[:sleft0, :sleft1] = left\n\n    cright = np.zeros((sleft0 + sright0, sleft1 + sright1), bool)\n    cright[-right.shape[0]:, -right.shape[1]:] = right\n\n    return cleft | cright\n"
    ]
  },
  "combined_diffs": {
    "raw_patch": "diff --git a/astropy/modeling/core.py b/astropy/modeling/core.py\nindex da4352cb0c..5367a65b2a 100644\n--- a/astropy/modeling/core.py\n+++ b/astropy/modeling/core.py\n@@ -1,53 +1,3 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n-\n-\"\"\"\n-This module defines base classes for all models.  The base class of all\n-models is `~astropy.modeling.Model`. `~astropy.modeling.FittableModel` is\n-the base class for all fittable models. Fittable models can be linear or\n-nonlinear in a regression analysis sense.\n-\n-All models provide a `__call__` method which performs the transformation in\n-a purely mathematical way, i.e. the models are unitless.  Model instances can\n-represent either a single model, or a \"model set\" representing multiple copies\n-of the same type of model, but with potentially different values of the\n-parameters in each model making up the set.\n-\"\"\"\n-# pylint: disable=invalid-name, protected-access, redefined-outer-name\n-import abc\n-import copy\n-import inspect\n-import itertools\n-import functools\n-import operator\n-import types\n-\n-from collections import defaultdict, deque\n-from inspect import signature\n-from itertools import chain\n-\n-import numpy as np\n-\n-from astropy.utils import indent, metadata\n-from astropy.table import Table\n-from astropy.units import Quantity, UnitsError, dimensionless_unscaled\n-from astropy.units.utils import quantity_asanyarray\n-from astropy.utils import (sharedmethod, find_current_module,\n-                           check_broadcast, IncompatibleShapeError, isiterable)\n-from astropy.utils.codegen import make_function_with_signature\n-from astropy.nddata.utils import add_array, extract_array\n-from .utils import (combine_labels, make_binary_operator_eval,\n-                    get_inputs_and_params, _combine_equivalency_dict,\n-                    _ConstraintsDict, _SpecialOperatorsDict)\n-from .bounding_box import ModelBoundingBox, CompoundBoundingBox\n-from .parameters import (Parameter, InputParameterError,\n-                         param_repr_oneline, _tofloat)\n-\n-\n-__all__ = ['Model', 'FittableModel', 'Fittable1DModel', 'Fittable2DModel',\n-           'CompoundModel', 'fix_inputs', 'custom_model', 'ModelDefinitionError',\n-           'bind_bounding_box', 'bind_compound_bounding_box']\n-\n-\n def _model_oper(oper, **kwargs):\n     \"\"\"\n     Returns a function that evaluates a given Python arithmetic operator\ndiff --git a/astropy/modeling/functional_models.py b/astropy/modeling/functional_models.py\nindex ed13dc043d..442e21acaf 100644\n--- a/astropy/modeling/functional_models.py\n+++ b/astropy/modeling/functional_models.py\n@@ -1,53 +1,3 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n-\n-\"\"\"Mathematical models.\"\"\"\n-# pylint: disable=line-too-long, too-many-lines, too-many-arguments, invalid-name\n-import numpy as np\n-\n-from astropy import units as u\n-from astropy.units import Quantity, UnitsError\n-from .core import (Fittable1DModel, Fittable2DModel)\n-\n-from .parameters import Parameter, InputParameterError\n-from .utils import ellipse_extent\n-\n-\n-__all__ = ['AiryDisk2D', 'Moffat1D', 'Moffat2D', 'Box1D', 'Box2D', 'Const1D',\n-           'Const2D', 'Ellipse2D', 'Disk2D', 'Gaussian1D', 'Gaussian2D',\n-           'Linear1D', 'Lorentz1D', 'RickerWavelet1D', 'RickerWavelet2D',\n-           'RedshiftScaleFactor', 'Multiply', 'Planar2D', 'Scale',\n-           'Sersic1D', 'Sersic2D', 'Shift',\n-           'Sine1D', 'Cosine1D', 'Tangent1D',\n-           'ArcSine1D', 'ArcCosine1D', 'ArcTangent1D',\n-           'Trapezoid1D', 'TrapezoidDisk2D', 'Ring2D', 'Voigt1D',\n-           'KingProjectedAnalytic1D', 'Exponential1D', 'Logarithmic1D']\n-\n-TWOPI = 2 * np.pi\n-FLOAT_EPSILON = float(np.finfo(np.float32).tiny)\n-\n-# Note that we define this here rather than using the value defined in\n-# astropy.stats to avoid importing astropy.stats every time astropy.modeling\n-# is loaded.\n-GAUSSIAN_SIGMA_TO_FWHM = 2.0 * np.sqrt(2.0 * np.log(2.0))\n-\n-\n-class Gaussian1D(Fittable1DModel):\n-    \"\"\"\n-    One dimensional Gaussian model.\n-\n-    Parameters\n-    ----------\n-    amplitude : float or `~astropy.units.Quantity`.\n-        Amplitude (peak value) of the Gaussian - for a normalized profile\n-        (integrating to 1), set amplitude = 1 / (stddev * np.sqrt(2 * np.pi))\n-    mean : float or `~astropy.units.Quantity`.\n-        Mean of the Gaussian.\n-    stddev : float or `~astropy.units.Quantity`.\n-        Standard deviation of the Gaussian with FWHM = 2 * stddev * np.sqrt(2 * np.log(2)).\n-\n-    Notes\n-    -----\n-    Either all or none of input ``x``, ``mean`` and ``stddev`` must be provided\n     consistently with compatible units or as unitless numbers.\n \n     Model formula:\ndiff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e27297..74e14a1118 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -102,6 +102,7 @@ def separability_matrix(transform):\n     return separable_matrix\n \n \n+\n def _compute_n_outputs(left, right):\n     \"\"\"\n     Compute the number of outputs of two models.\n@@ -168,6 +169,7 @@ def _arith_oper(left, right):\n     return result\n \n \n+\n def _coord_matrix(model, pos, noutp):\n     \"\"\"\n     Create an array representing inputs and outputs of a simple model.\n@@ -216,6 +218,7 @@ def _coord_matrix(model, pos, noutp):\n     return mat\n \n \n+\n def _cstack(left, right):\n     \"\"\"\n     Function corresponding to '&' operation.\n@@ -242,7 +245,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \n",
    "variant_0": "diff --git a/astropy/modeling/core.py b/astropy/modeling/core.py\nindex da4352cb0c..51e79e7f10 100644\n--- a/astropy/modeling/core.py\n+++ b/astropy/modeling/core.py\n@@ -1,53 +1,23 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n-\n-\"\"\"\n-This module defines base classes for all models.  The base class of all\n-models is `~astropy.modeling.Model`. `~astropy.modeling.FittableModel` is\n-the base class for all fittable models. Fittable models can be linear or\n-nonlinear in a regression analysis sense.\n-\n-All models provide a `__call__` method which performs the transformation in\n-a purely mathematical way, i.e. the models are unitless.  Model instances can\n-represent either a single model, or a \"model set\" representing multiple copies\n-of the same type of model, but with potentially different values of the\n-parameters in each model making up the set.\n-\"\"\"\n-# pylint: disable=invalid-name, protected-access, redefined-outer-name\n-import abc\n-import copy\n-import inspect\n-import itertools\n-import functools\n-import operator\n-import types\n-\n-from collections import defaultdict, deque\n-from inspect import signature\n-from itertools import chain\n-\n-import numpy as np\n-\n-from astropy.utils import indent, metadata\n-from astropy.table import Table\n-from astropy.units import Quantity, UnitsError, dimensionless_unscaled\n-from astropy.units.utils import quantity_asanyarray\n-from astropy.utils import (sharedmethod, find_current_module,\n-                           check_broadcast, IncompatibleShapeError, isiterable)\n-from astropy.utils.codegen import make_function_with_signature\n-from astropy.nddata.utils import add_array, extract_array\n-from .utils import (combine_labels, make_binary_operator_eval,\n-                    get_inputs_and_params, _combine_equivalency_dict,\n-                    _ConstraintsDict, _SpecialOperatorsDict)\n-from .bounding_box import ModelBoundingBox, CompoundBoundingBox\n-from .parameters import (Parameter, InputParameterError,\n-                         param_repr_oneline, _tofloat)\n-\n-\n-__all__ = ['Model', 'FittableModel', 'Fittable1DModel', 'Fittable2DModel',\n-           'CompoundModel', 'fix_inputs', 'custom_model', 'ModelDefinitionError',\n-           'bind_bounding_box', 'bind_compound_bounding_box']\n \n+def _model_oper(oper, **kwargs):\n+    \"\"\"\n+    Returns a function that evaluates a given Python arithmetic operator\n+    between two models.  The operator should be given as a string, like ``'+'``\n+    or ``'**'``.\n+\n+    Parameters\n+    ----------\n+    oper : str\n+        The operator to use.\n+    **kwargs : dict\n+        Additional keyword arguments to pass to the CompoundModel.\n \n+    Returns\n+    -------\n+    function\n+        A function that takes two models and returns a CompoundModel.\n+    \"\"\"\n+    return lambda left, right: CompoundModel(oper, left, right, **kwargs)\n def _model_oper(oper, **kwargs):\n     \"\"\"\n     Returns a function that evaluates a given Python arithmetic operator\ndiff --git a/astropy/modeling/functional_models.py b/astropy/modeling/functional_models.py\nindex ed13dc043d..d32f975bc3 100644\n--- a/astropy/modeling/functional_models.py\n+++ b/astropy/modeling/functional_models.py\n@@ -1,53 +1,19 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n-\"\"\"Mathematical models.\"\"\"\n-# pylint: disable=line-too-long, too-many-lines, too-many-arguments, invalid-name\n-import numpy as np\n-\n-from astropy import units as u\n-from astropy.units import Quantity, UnitsError\n-from .core import (Fittable1DModel, Fittable2DModel)\n-\n-from .parameters import Parameter, InputParameterError\n-from .utils import ellipse_extent\n-\n-\n-__all__ = ['AiryDisk2D', 'Moffat1D', 'Moffat2D', 'Box1D', 'Box2D', 'Const1D',\n-           'Const2D', 'Ellipse2D', 'Disk2D', 'Gaussian1D', 'Gaussian2D',\n-           'Linear1D', 'Lorentz1D', 'RickerWavelet1D', 'RickerWavelet2D',\n-           'RedshiftScaleFactor', 'Multiply', 'Planar2D', 'Scale',\n-           'Sersic1D', 'Sersic2D', 'Shift',\n-           'Sine1D', 'Cosine1D', 'Tangent1D',\n-           'ArcSine1D', 'ArcCosine1D', 'ArcTangent1D',\n-           'Trapezoid1D', 'TrapezoidDisk2D', 'Ring2D', 'Voigt1D',\n-           'KingProjectedAnalytic1D', 'Exponential1D', 'Logarithmic1D']\n-\n-TWOPI = 2 * np.pi\n-FLOAT_EPSILON = float(np.finfo(np.float32).tiny)\n-\n-# Note that we define this here rather than using the value defined in\n-# astropy.stats to avoid importing astropy.stats every time astropy.modeling\n-# is loaded.\n-GAUSSIAN_SIGMA_TO_FWHM = 2.0 * np.sqrt(2.0 * np.log(2.0))\n-\n-\n-class Gaussian1D(Fittable1DModel):\n-    \"\"\"\n-    One dimensional Gaussian model.\n-\n-    Parameters\n-    ----------\n-    amplitude : float or `~astropy.units.Quantity`.\n-        Amplitude (peak value) of the Gaussian - for a normalized profile\n-        (integrating to 1), set amplitude = 1 / (stddev * np.sqrt(2 * np.pi))\n-    mean : float or `~astropy.units.Quantity`.\n-        Mean of the Gaussian.\n-    stddev : float or `~astropy.units.Quantity`.\n-        Standard deviation of the Gaussian with FWHM = 2 * stddev * np.sqrt(2 * np.log(2)).\n-\n-    Notes\n-    -----\n-    Either all or none of input ``x``, ``mean`` and ``stddev`` must be provided\n+    def _cstack(left, right):\n+        \"\"\"\n+        Combine the separability matrices of two models.\n+        \"\"\"\n+        n_left = left.shape[0]\n+        n_right = right.shape[0]\n+        cstack = np.zeros((n_left + n_right, n_left + n_right), dtype=bool)\n+        \n+        # Top-left quadrant\n+        cstack[:n_left, :n_left] = left\n+        \n+        # Bottom-right quadrant\n+        cstack[-n_right:, -n_right:] = right\n+        \n+        return cstack\n     consistently with compatible units or as unitless numbers.\n \n     Model formula:\ndiff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e27297..74e14a1118 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -102,6 +102,7 @@ def separability_matrix(transform):\n     return separable_matrix\n \n \n+\n def _compute_n_outputs(left, right):\n     \"\"\"\n     Compute the number of outputs of two models.\n@@ -168,6 +169,7 @@ def _arith_oper(left, right):\n     return result\n \n \n+\n def _coord_matrix(model, pos, noutp):\n     \"\"\"\n     Create an array representing inputs and outputs of a simple model.\n@@ -216,6 +218,7 @@ def _coord_matrix(model, pos, noutp):\n     return mat\n \n \n+\n def _cstack(left, right):\n     \"\"\"\n     Function corresponding to '&' operation.\n@@ -242,7 +245,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \n",
    "variant_1": "diff --git a/astropy/modeling/core.py b/astropy/modeling/core.py\nindex da4352cb0c..95ef888b93 100644\n--- a/astropy/modeling/core.py\n+++ b/astropy/modeling/core.py\n@@ -1,53 +1,15 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n-\n-\"\"\"\n-This module defines base classes for all models.  The base class of all\n-models is `~astropy.modeling.Model`. `~astropy.modeling.FittableModel` is\n-the base class for all fittable models. Fittable models can be linear or\n-nonlinear in a regression analysis sense.\n-\n-All models provide a `__call__` method which performs the transformation in\n-a purely mathematical way, i.e. the models are unitless.  Model instances can\n-represent either a single model, or a \"model set\" representing multiple copies\n-of the same type of model, but with potentially different values of the\n-parameters in each model making up the set.\n-\"\"\"\n-# pylint: disable=invalid-name, protected-access, redefined-outer-name\n-import abc\n-import copy\n-import inspect\n-import itertools\n-import functools\n-import operator\n-import types\n-\n-from collections import defaultdict, deque\n-from inspect import signature\n-from itertools import chain\n-\n-import numpy as np\n-\n-from astropy.utils import indent, metadata\n-from astropy.table import Table\n-from astropy.units import Quantity, UnitsError, dimensionless_unscaled\n-from astropy.units.utils import quantity_asanyarray\n-from astropy.utils import (sharedmethod, find_current_module,\n-                           check_broadcast, IncompatibleShapeError, isiterable)\n-from astropy.utils.codegen import make_function_with_signature\n-from astropy.nddata.utils import add_array, extract_array\n-from .utils import (combine_labels, make_binary_operator_eval,\n-                    get_inputs_and_params, _combine_equivalency_dict,\n-                    _ConstraintsDict, _SpecialOperatorsDict)\n-from .bounding_box import ModelBoundingBox, CompoundBoundingBox\n-from .parameters import (Parameter, InputParameterError,\n-                         param_repr_oneline, _tofloat)\n-\n-\n-__all__ = ['Model', 'FittableModel', 'Fittable1DModel', 'Fittable2DModel',\n-           'CompoundModel', 'fix_inputs', 'custom_model', 'ModelDefinitionError',\n-           'bind_bounding_box', 'bind_compound_bounding_box']\n-\n \n+def _model_oper(oper, **kwargs):\n+    \"\"\"\n+    Returns a function that evaluates a given Python arithmetic operator\n+    between two models.  The operator should be given as a string, like ``'+'``\n+    or ``'**'``.\n+    \"\"\"\n+    def compound_model_wrapper(left, right):\n+        if isinstance(left, CompoundModel) and isinstance(right, CompoundModel):\n+            return CompoundModel(oper, left, right, **kwargs, _preserve_separability=True)\n+        return CompoundModel(oper, left, right, **kwargs)\n+    return compound_model_wrapper\n def _model_oper(oper, **kwargs):\n     \"\"\"\n     Returns a function that evaluates a given Python arithmetic operator\ndiff --git a/astropy/modeling/functional_models.py b/astropy/modeling/functional_models.py\nindex ed13dc043d..aac35b18bd 100644\n--- a/astropy/modeling/functional_models.py\n+++ b/astropy/modeling/functional_models.py\n@@ -1,53 +1,9 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n-\"\"\"Mathematical models.\"\"\"\n-# pylint: disable=line-too-long, too-many-lines, too-many-arguments, invalid-name\n-import numpy as np\n-\n-from astropy import units as u\n-from astropy.units import Quantity, UnitsError\n-from .core import (Fittable1DModel, Fittable2DModel)\n-\n-from .parameters import Parameter, InputParameterError\n-from .utils import ellipse_extent\n-\n-\n-__all__ = ['AiryDisk2D', 'Moffat1D', 'Moffat2D', 'Box1D', 'Box2D', 'Const1D',\n-           'Const2D', 'Ellipse2D', 'Disk2D', 'Gaussian1D', 'Gaussian2D',\n-           'Linear1D', 'Lorentz1D', 'RickerWavelet1D', 'RickerWavelet2D',\n-           'RedshiftScaleFactor', 'Multiply', 'Planar2D', 'Scale',\n-           'Sersic1D', 'Sersic2D', 'Shift',\n-           'Sine1D', 'Cosine1D', 'Tangent1D',\n-           'ArcSine1D', 'ArcCosine1D', 'ArcTangent1D',\n-           'Trapezoid1D', 'TrapezoidDisk2D', 'Ring2D', 'Voigt1D',\n-           'KingProjectedAnalytic1D', 'Exponential1D', 'Logarithmic1D']\n-\n-TWOPI = 2 * np.pi\n-FLOAT_EPSILON = float(np.finfo(np.float32).tiny)\n-\n-# Note that we define this here rather than using the value defined in\n-# astropy.stats to avoid importing astropy.stats every time astropy.modeling\n-# is loaded.\n-GAUSSIAN_SIGMA_TO_FWHM = 2.0 * np.sqrt(2.0 * np.log(2.0))\n-\n-\n-class Gaussian1D(Fittable1DModel):\n-    \"\"\"\n-    One dimensional Gaussian model.\n-\n-    Parameters\n-    ----------\n-    amplitude : float or `~astropy.units.Quantity`.\n-        Amplitude (peak value) of the Gaussian - for a normalized profile\n-        (integrating to 1), set amplitude = 1 / (stddev * np.sqrt(2 * np.pi))\n-    mean : float or `~astropy.units.Quantity`.\n-        Mean of the Gaussian.\n-    stddev : float or `~astropy.units.Quantity`.\n-        Standard deviation of the Gaussian with FWHM = 2 * stddev * np.sqrt(2 * np.log(2)).\n-\n-    Notes\n-    -----\n-    Either all or none of input ``x``, ``mean`` and ``stddev`` must be provided\n+    cright = np.zeros((max_n_inputs, max_n_outputs), dtype=bool)\n+    if right.shape == (1, 1):\n+        cright[:, :] = right[0, 0]\n+    else:\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n     consistently with compatible units or as unitless numbers.\n \n     Model formula:\ndiff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e27297..74e14a1118 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -102,6 +102,7 @@ def separability_matrix(transform):\n     return separable_matrix\n \n \n+\n def _compute_n_outputs(left, right):\n     \"\"\"\n     Compute the number of outputs of two models.\n@@ -168,6 +169,7 @@ def _arith_oper(left, right):\n     return result\n \n \n+\n def _coord_matrix(model, pos, noutp):\n     \"\"\"\n     Create an array representing inputs and outputs of a simple model.\n@@ -216,6 +218,7 @@ def _coord_matrix(model, pos, noutp):\n     return mat\n \n \n+\n def _cstack(left, right):\n     \"\"\"\n     Function corresponding to '&' operation.\n@@ -242,7 +245,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \n",
    "variant_2": "diff --git a/astropy/modeling/core.py b/astropy/modeling/core.py\nindex da4352cb0c..75a50a46c7 100644\n--- a/astropy/modeling/core.py\n+++ b/astropy/modeling/core.py\n@@ -1,53 +1,28 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n-\n-\"\"\"\n-This module defines base classes for all models.  The base class of all\n-models is `~astropy.modeling.Model`. `~astropy.modeling.FittableModel` is\n-the base class for all fittable models. Fittable models can be linear or\n-nonlinear in a regression analysis sense.\n-\n-All models provide a `__call__` method which performs the transformation in\n-a purely mathematical way, i.e. the models are unitless.  Model instances can\n-represent either a single model, or a \"model set\" representing multiple copies\n-of the same type of model, but with potentially different values of the\n-parameters in each model making up the set.\n-\"\"\"\n-# pylint: disable=invalid-name, protected-access, redefined-outer-name\n-import abc\n-import copy\n-import inspect\n-import itertools\n-import functools\n-import operator\n-import types\n-\n-from collections import defaultdict, deque\n-from inspect import signature\n-from itertools import chain\n-\n-import numpy as np\n-\n-from astropy.utils import indent, metadata\n-from astropy.table import Table\n-from astropy.units import Quantity, UnitsError, dimensionless_unscaled\n-from astropy.units.utils import quantity_asanyarray\n-from astropy.utils import (sharedmethod, find_current_module,\n-                           check_broadcast, IncompatibleShapeError, isiterable)\n-from astropy.utils.codegen import make_function_with_signature\n-from astropy.nddata.utils import add_array, extract_array\n-from .utils import (combine_labels, make_binary_operator_eval,\n-                    get_inputs_and_params, _combine_equivalency_dict,\n-                    _ConstraintsDict, _SpecialOperatorsDict)\n-from .bounding_box import ModelBoundingBox, CompoundBoundingBox\n-from .parameters import (Parameter, InputParameterError,\n-                         param_repr_oneline, _tofloat)\n-\n-\n-__all__ = ['Model', 'FittableModel', 'Fittable1DModel', 'Fittable2DModel',\n-           'CompoundModel', 'fix_inputs', 'custom_model', 'ModelDefinitionError',\n-           'bind_bounding_box', 'bind_compound_bounding_box']\n-\n \n+def _cstack(left, right):\n+    \"\"\"\n+    Stack two coordinate matrices diagonally, preserving separability.\n+    \"\"\"\n+    if left is None and right is None:\n+        return None\n+    elif left is None:\n+        return right\n+    elif right is None:\n+        return left\n+    \n+    left = np.asarray(left, dtype=bool)\n+    right = np.asarray(right, dtype=bool)\n+    \n+    n_left = left.shape[0] if left.ndim >= 1 else 0\n+    n_right = right.shape[0] if right.ndim >= 1 else 0\n+    \n+    cright = np.zeros((n_left + n_right, n_left + n_right), dtype=bool)\n+    if left.shape:\n+        cright[:n_left, :left.shape[1]] = left\n+    if right.shape:\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n+    \n+    return cright\n def _model_oper(oper, **kwargs):\n     \"\"\"\n     Returns a function that evaluates a given Python arithmetic operator\ndiff --git a/astropy/modeling/functional_models.py b/astropy/modeling/functional_models.py\nindex ed13dc043d..66cc1ce285 100644\n--- a/astropy/modeling/functional_models.py\n+++ b/astropy/modeling/functional_models.py\n@@ -1,53 +1,22 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n-\"\"\"Mathematical models.\"\"\"\n-# pylint: disable=line-too-long, too-many-lines, too-many-arguments, invalid-name\n-import numpy as np\n-\n-from astropy import units as u\n-from astropy.units import Quantity, UnitsError\n-from .core import (Fittable1DModel, Fittable2DModel)\n-\n-from .parameters import Parameter, InputParameterError\n-from .utils import ellipse_extent\n-\n-\n-__all__ = ['AiryDisk2D', 'Moffat1D', 'Moffat2D', 'Box1D', 'Box2D', 'Const1D',\n-           'Const2D', 'Ellipse2D', 'Disk2D', 'Gaussian1D', 'Gaussian2D',\n-           'Linear1D', 'Lorentz1D', 'RickerWavelet1D', 'RickerWavelet2D',\n-           'RedshiftScaleFactor', 'Multiply', 'Planar2D', 'Scale',\n-           'Sersic1D', 'Sersic2D', 'Shift',\n-           'Sine1D', 'Cosine1D', 'Tangent1D',\n-           'ArcSine1D', 'ArcCosine1D', 'ArcTangent1D',\n-           'Trapezoid1D', 'TrapezoidDisk2D', 'Ring2D', 'Voigt1D',\n-           'KingProjectedAnalytic1D', 'Exponential1D', 'Logarithmic1D']\n-\n-TWOPI = 2 * np.pi\n-FLOAT_EPSILON = float(np.finfo(np.float32).tiny)\n-\n-# Note that we define this here rather than using the value defined in\n-# astropy.stats to avoid importing astropy.stats every time astropy.modeling\n-# is loaded.\n-GAUSSIAN_SIGMA_TO_FWHM = 2.0 * np.sqrt(2.0 * np.log(2.0))\n-\n-\n-class Gaussian1D(Fittable1DModel):\n-    \"\"\"\n-    One dimensional Gaussian model.\n-\n-    Parameters\n-    ----------\n-    amplitude : float or `~astropy.units.Quantity`.\n-        Amplitude (peak value) of the Gaussian - for a normalized profile\n-        (integrating to 1), set amplitude = 1 / (stddev * np.sqrt(2 * np.pi))\n-    mean : float or `~astropy.units.Quantity`.\n-        Mean of the Gaussian.\n-    stddev : float or `~astropy.units.Quantity`.\n-        Standard deviation of the Gaussian with FWHM = 2 * stddev * np.sqrt(2 * np.log(2)).\n-\n-    Notes\n-    -----\n-    Either all or none of input ``x``, ``mean`` and ``stddev`` must be provided\n+def _cstack(left, right):\n+    \"\"\"\n+    Stack two separability matrices diagonally, preserving their structure.\n+    \"\"\"\n+    if left is None:\n+        return right\n+    if right is None:\n+        return left\n+    \n+    # Create zero-filled output array\n+    mat = np.zeros((left.shape[0] + right.shape[0], \n+                   left.shape[1] + right.shape[1]), dtype=bool)\n+    \n+    # Insert left and right matrices\n+    mat[:left.shape[0], :left.shape[1]] = left\n+    mat[-right.shape[0]:, -right.shape[1]:] = right\n+    \n+    return mat\n     consistently with compatible units or as unitless numbers.\n \n     Model formula:\ndiff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e27297..99e1f1299c 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -102,6 +102,7 @@ def separability_matrix(transform):\n     return separable_matrix\n \n \n+\n def _compute_n_outputs(left, right):\n     \"\"\"\n     Compute the number of outputs of two models.\n@@ -168,6 +169,7 @@ def _arith_oper(left, right):\n     return result\n \n \n+\n def _coord_matrix(model, pos, noutp):\n     \"\"\"\n     Create an array representing inputs and outputs of a simple model.\n@@ -212,10 +214,11 @@ def _coord_matrix(model, pos, noutp):\n         for i in range(model.n_inputs):\n             mat[i, i] = 1\n         if pos == 'right':\n-            mat = np.roll(mat, (noutp - model.n_outputs))\n+            mat = np.roll(mat, (noutp - model.n_outputs, 0))\n     return mat\n \n \n+\n def _cstack(left, right):\n     \"\"\"\n     Function corresponding to '&' operation.\n@@ -242,7 +245,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \n",
    "variant_3": "diff --git a/astropy/modeling/core.py b/astropy/modeling/core.py\nindex da4352cb0c..77f97022db 100644\n--- a/astropy/modeling/core.py\n+++ b/astropy/modeling/core.py\n@@ -1,3 +1,4 @@\n+\n # Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n \"\"\"\n@@ -46,8 +47,6 @@ from .parameters import (Parameter, InputParameterError,\n __all__ = ['Model', 'FittableModel', 'Fittable1DModel', 'Fittable2DModel',\n            'CompoundModel', 'fix_inputs', 'custom_model', 'ModelDefinitionError',\n            'bind_bounding_box', 'bind_compound_bounding_box']\n-\n-\n def _model_oper(oper, **kwargs):\n     \"\"\"\n     Returns a function that evaluates a given Python arithmetic operator\ndiff --git a/astropy/modeling/functional_models.py b/astropy/modeling/functional_models.py\nindex ed13dc043d..8dd3a961db 100644\n--- a/astropy/modeling/functional_models.py\n+++ b/astropy/modeling/functional_models.py\n@@ -1,53 +1,33 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n-\"\"\"Mathematical models.\"\"\"\n-# pylint: disable=line-too-long, too-many-lines, too-many-arguments, invalid-name\n-import numpy as np\n-\n-from astropy import units as u\n-from astropy.units import Quantity, UnitsError\n-from .core import (Fittable1DModel, Fittable2DModel)\n-\n-from .parameters import Parameter, InputParameterError\n-from .utils import ellipse_extent\n-\n-\n-__all__ = ['AiryDisk2D', 'Moffat1D', 'Moffat2D', 'Box1D', 'Box2D', 'Const1D',\n-           'Const2D', 'Ellipse2D', 'Disk2D', 'Gaussian1D', 'Gaussian2D',\n-           'Linear1D', 'Lorentz1D', 'RickerWavelet1D', 'RickerWavelet2D',\n-           'RedshiftScaleFactor', 'Multiply', 'Planar2D', 'Scale',\n-           'Sersic1D', 'Sersic2D', 'Shift',\n-           'Sine1D', 'Cosine1D', 'Tangent1D',\n-           'ArcSine1D', 'ArcCosine1D', 'ArcTangent1D',\n-           'Trapezoid1D', 'TrapezoidDisk2D', 'Ring2D', 'Voigt1D',\n-           'KingProjectedAnalytic1D', 'Exponential1D', 'Logarithmic1D']\n-\n-TWOPI = 2 * np.pi\n-FLOAT_EPSILON = float(np.finfo(np.float32).tiny)\n-\n-# Note that we define this here rather than using the value defined in\n-# astropy.stats to avoid importing astropy.stats every time astropy.modeling\n-# is loaded.\n-GAUSSIAN_SIGMA_TO_FWHM = 2.0 * np.sqrt(2.0 * np.log(2.0))\n-\n-\n-class Gaussian1D(Fittable1DModel):\n-    \"\"\"\n-    One dimensional Gaussian model.\n-\n-    Parameters\n-    ----------\n-    amplitude : float or `~astropy.units.Quantity`.\n-        Amplitude (peak value) of the Gaussian - for a normalized profile\n-        (integrating to 1), set amplitude = 1 / (stddev * np.sqrt(2 * np.pi))\n-    mean : float or `~astropy.units.Quantity`.\n-        Mean of the Gaussian.\n-    stddev : float or `~astropy.units.Quantity`.\n-        Standard deviation of the Gaussian with FWHM = 2 * stddev * np.sqrt(2 * np.log(2)).\n+    def _cstack(left, right):\n+        \"\"\"\n+        Stack two separability matrices diagonally.\n \n-    Notes\n-    -----\n-    Either all or none of input ``x``, ``mean`` and ``stddev`` must be provided\n+        Parameters\n+        ----------\n+        left : ndarray\n+            Left separability matrix\n+        right : ndarray\n+            Right separability matrix\n+\n+        Returns\n+        -------\n+        ndarray\n+            Block diagonal matrix combining left and right\n+        \"\"\"\n+        if left is None and right is None:\n+            return None\n+        elif left is None:\n+            return right.copy()\n+        elif right is None:\n+            return left.copy()\n+\n+        cleft = np.zeros((left.shape[0] + right.shape[0],\n+                          left.shape[1] + right.shape[1]), dtype=bool)\n+        cleft[:left.shape[0], :left.shape[1]] = left\n+        cright = np.zeros_like(cleft)\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n+        return cleft | cright\n     consistently with compatible units or as unitless numbers.\n \n     Model formula:\ndiff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e27297..29cd32a05a 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -102,6 +102,7 @@ def separability_matrix(transform):\n     return separable_matrix\n \n \n+\n def _compute_n_outputs(left, right):\n     \"\"\"\n     Compute the number of outputs of two models.\n@@ -118,11 +119,17 @@ def _compute_n_outputs(left, right):\n     if isinstance(left, Model):\n         lnout = left.n_outputs\n     else:\n-        lnout = left.shape[0]\n+        if left.shape[0] == 0:\n+            lnout = 0\n+        else:\n+            lnout = left.shape[0]\n     if isinstance(right, Model):\n         rnout = right.n_outputs\n     else:\n-        rnout = right.shape[0]\n+        if right.shape[0] == 0:\n+            rnout = 0\n+        else:\n+            rnout = right.shape[0]\n     noutp = lnout + rnout\n     return noutp\n \n@@ -168,6 +175,7 @@ def _arith_oper(left, right):\n     return result\n \n \n+\n def _coord_matrix(model, pos, noutp):\n     \"\"\"\n     Create an array representing inputs and outputs of a simple model.\n@@ -212,10 +220,11 @@ def _coord_matrix(model, pos, noutp):\n         for i in range(model.n_inputs):\n             mat[i, i] = 1\n         if pos == 'right':\n-            mat = np.roll(mat, (noutp - model.n_outputs))\n+            mat = np.roll(mat, noutp - model.n_outputs)\n     return mat\n \n \n+\n def _cstack(left, right):\n     \"\"\"\n     Function corresponding to '&' operation.\n@@ -242,7 +251,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \n",
    "variant_4": "diff --git a/astropy/modeling/core.py b/astropy/modeling/core.py\nindex da4352cb0c..07d398882d 100644\n--- a/astropy/modeling/core.py\n+++ b/astropy/modeling/core.py\n@@ -1,53 +1,5 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n-\n-\"\"\"\n-This module defines base classes for all models.  The base class of all\n-models is `~astropy.modeling.Model`. `~astropy.modeling.FittableModel` is\n-the base class for all fittable models. Fittable models can be linear or\n-nonlinear in a regression analysis sense.\n-\n-All models provide a `__call__` method which performs the transformation in\n-a purely mathematical way, i.e. the models are unitless.  Model instances can\n-represent either a single model, or a \"model set\" representing multiple copies\n-of the same type of model, but with potentially different values of the\n-parameters in each model making up the set.\n-\"\"\"\n-# pylint: disable=invalid-name, protected-access, redefined-outer-name\n-import abc\n-import copy\n-import inspect\n-import itertools\n-import functools\n-import operator\n-import types\n-\n-from collections import defaultdict, deque\n-from inspect import signature\n-from itertools import chain\n-\n-import numpy as np\n-\n-from astropy.utils import indent, metadata\n-from astropy.table import Table\n-from astropy.units import Quantity, UnitsError, dimensionless_unscaled\n-from astropy.units.utils import quantity_asanyarray\n-from astropy.utils import (sharedmethod, find_current_module,\n-                           check_broadcast, IncompatibleShapeError, isiterable)\n-from astropy.utils.codegen import make_function_with_signature\n-from astropy.nddata.utils import add_array, extract_array\n-from .utils import (combine_labels, make_binary_operator_eval,\n-                    get_inputs_and_params, _combine_equivalency_dict,\n-                    _ConstraintsDict, _SpecialOperatorsDict)\n-from .bounding_box import ModelBoundingBox, CompoundBoundingBox\n-from .parameters import (Parameter, InputParameterError,\n-                         param_repr_oneline, _tofloat)\n-\n-\n-__all__ = ['Model', 'FittableModel', 'Fittable1DModel', 'Fittable2DModel',\n-           'CompoundModel', 'fix_inputs', 'custom_model', 'ModelDefinitionError',\n-           'bind_bounding_box', 'bind_compound_bounding_box']\n-\n \n+cright[-right.shape[0]:, -right.shape[1]:] = right\n def _model_oper(oper, **kwargs):\n     \"\"\"\n     Returns a function that evaluates a given Python arithmetic operator\ndiff --git a/astropy/modeling/functional_models.py b/astropy/modeling/functional_models.py\nindex ed13dc043d..b8dc7e60d3 100644\n--- a/astropy/modeling/functional_models.py\n+++ b/astropy/modeling/functional_models.py\n@@ -1,53 +1,35 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n-\"\"\"Mathematical models.\"\"\"\n-# pylint: disable=line-too-long, too-many-lines, too-many-arguments, invalid-name\n-import numpy as np\n-\n-from astropy import units as u\n-from astropy.units import Quantity, UnitsError\n-from .core import (Fittable1DModel, Fittable2DModel)\n-\n-from .parameters import Parameter, InputParameterError\n-from .utils import ellipse_extent\n-\n-\n-__all__ = ['AiryDisk2D', 'Moffat1D', 'Moffat2D', 'Box1D', 'Box2D', 'Const1D',\n-           'Const2D', 'Ellipse2D', 'Disk2D', 'Gaussian1D', 'Gaussian2D',\n-           'Linear1D', 'Lorentz1D', 'RickerWavelet1D', 'RickerWavelet2D',\n-           'RedshiftScaleFactor', 'Multiply', 'Planar2D', 'Scale',\n-           'Sersic1D', 'Sersic2D', 'Shift',\n-           'Sine1D', 'Cosine1D', 'Tangent1D',\n-           'ArcSine1D', 'ArcCosine1D', 'ArcTangent1D',\n-           'Trapezoid1D', 'TrapezoidDisk2D', 'Ring2D', 'Voigt1D',\n-           'KingProjectedAnalytic1D', 'Exponential1D', 'Logarithmic1D']\n-\n-TWOPI = 2 * np.pi\n-FLOAT_EPSILON = float(np.finfo(np.float32).tiny)\n-\n-# Note that we define this here rather than using the value defined in\n-# astropy.stats to avoid importing astropy.stats every time astropy.modeling\n-# is loaded.\n-GAUSSIAN_SIGMA_TO_FWHM = 2.0 * np.sqrt(2.0 * np.log(2.0))\n+    def _cstack(left, right):\n+        \"\"\"\n+        Combine the separability matrices of two models into a single array.\n \n+        Parameters\n+        ----------\n+        left : ndarray\n+            Separability matrix for the left model\n+        right : ndarray\n+            Separability matrix for the right model\n+\n+        Returns\n+        -------\n+        ndarray\n+            Combined separability matrix\n+        \"\"\"\n+        if left is None and right is None:\n+            return None\n \n-class Gaussian1D(Fittable1DModel):\n-    \"\"\"\n-    One dimensional Gaussian model.\n+        if left is None:\n+            left = np.ones((1, 1), dtype=bool)\n+        if right is None:\n+            right = np.ones((1, 1), dtype=bool)\n \n-    Parameters\n-    ----------\n-    amplitude : float or `~astropy.units.Quantity`.\n-        Amplitude (peak value) of the Gaussian - for a normalized profile\n-        (integrating to 1), set amplitude = 1 / (stddev * np.sqrt(2 * np.pi))\n-    mean : float or `~astropy.units.Quantity`.\n-        Mean of the Gaussian.\n-    stddev : float or `~astropy.units.Quantity`.\n-        Standard deviation of the Gaussian with FWHM = 2 * stddev * np.sqrt(2 * np.log(2)).\n+        cleft = np.zeros((left.shape[0] + right.shape[0],\n+                          left.shape[1] + right.shape[1]), dtype=bool)\n+        cleft[:left.shape[0], :left.shape[1]] = left\n+        cright = np.zeros_like(cleft)\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n-    Notes\n-    -----\n-    Either all or none of input ``x``, ``mean`` and ``stddev`` must be provided\n+        return cleft + cright\n     consistently with compatible units or as unitless numbers.\n \n     Model formula:\ndiff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e27297..1963f48e31 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -102,6 +102,7 @@ def separability_matrix(transform):\n     return separable_matrix\n \n \n+\n def _compute_n_outputs(left, right):\n     \"\"\"\n     Compute the number of outputs of two models.\n@@ -168,52 +169,34 @@ def _arith_oper(left, right):\n     return result\n \n \n-def _coord_matrix(model, pos, noutp):\n-    \"\"\"\n-    Create an array representing inputs and outputs of a simple model.\n \n-    The array has a shape (noutp, model.n_inputs).\n+def _cstack(left, right):\n+    \"\"\"\n+    Function corresponding to '&' operation.\n \n     Parameters\n     ----------\n-    model : `astropy.modeling.Model`\n-        model\n-    pos : str\n-        Position of this model in the expression tree.\n-        One of ['left', 'right'].\n-    noutp : int\n-        Number of outputs of the compound model of which the input model\n-        is a left or right child.\n+    left, right : `astropy.modeling.Model` or ndarray\n+        If input is of an array, it is the output of `coord_matrix`.\n \n+    Returns\n+    -------\n+    result : ndarray\n+        Array with shape (left.shape[0] + right.shape[0], left.shape[1])\n     \"\"\"\n-    if isinstance(model, Mapping):\n-        axes = []\n-        for i in model.mapping:\n-            axis = np.zeros((model.n_inputs,))\n-            axis[i] = 1\n-            axes.append(axis)\n-        m = np.vstack(axes)\n-        mat = np.zeros((noutp, model.n_inputs))\n-        if pos == 'left':\n-            mat[: model.n_outputs, :model.n_inputs] = m\n-        else:\n-            mat[-model.n_outputs:, -model.n_inputs:] = m\n-        return mat\n-    if not model.separable:\n-        # this does not work for more than 2 coordinates\n-        mat = np.zeros((noutp, model.n_inputs))\n-        if pos == 'left':\n-            mat[:model.n_outputs, : model.n_inputs] = 1\n-        else:\n-            mat[-model.n_outputs:, -model.n_inputs:] = 1\n+    if not isinstance(left, np.ndarray):\n+        cleft = _coord_matrix(left, 'left', left.n_outputs + right.n_outputs)\n+    else:\n+        cleft = left\n+    if not isinstance(right, np.ndarray):\n+        cright = _coord_matrix(right, 'right', left.n_outputs + right.n_outputs)\n     else:\n-        mat = np.zeros((noutp, model.n_inputs))\n+        cright = right\n+    result = np.zeros((cleft.shape[0] + cright.shape[0], cleft.shape[1]))\n+    result[:cleft.shape[0], :cleft.shape[1]] = cleft\n+    result[-cright.shape[0]:, -cright.shape[1]:] = cright\n+    return result\n \n-        for i in range(model.n_inputs):\n-            mat[i, i] = 1\n-        if pos == 'right':\n-            mat = np.roll(mat, (noutp - model.n_outputs))\n-    return mat\n \n \n def _cstack(left, right):\n@@ -242,7 +225,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \n",
    "variant_5": "diff --git a/astropy/modeling/core.py b/astropy/modeling/core.py\nindex da4352cb0c..1d82fb14a0 100644\n--- a/astropy/modeling/core.py\n+++ b/astropy/modeling/core.py\n@@ -1,53 +1,23 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n-\n-\"\"\"\n-This module defines base classes for all models.  The base class of all\n-models is `~astropy.modeling.Model`. `~astropy.modeling.FittableModel` is\n-the base class for all fittable models. Fittable models can be linear or\n-nonlinear in a regression analysis sense.\n-\n-All models provide a `__call__` method which performs the transformation in\n-a purely mathematical way, i.e. the models are unitless.  Model instances can\n-represent either a single model, or a \"model set\" representing multiple copies\n-of the same type of model, but with potentially different values of the\n-parameters in each model making up the set.\n-\"\"\"\n-# pylint: disable=invalid-name, protected-access, redefined-outer-name\n-import abc\n-import copy\n-import inspect\n-import itertools\n-import functools\n-import operator\n-import types\n-\n-from collections import defaultdict, deque\n-from inspect import signature\n-from itertools import chain\n-\n-import numpy as np\n-\n-from astropy.utils import indent, metadata\n-from astropy.table import Table\n-from astropy.units import Quantity, UnitsError, dimensionless_unscaled\n-from astropy.units.utils import quantity_asanyarray\n-from astropy.utils import (sharedmethod, find_current_module,\n-                           check_broadcast, IncompatibleShapeError, isiterable)\n-from astropy.utils.codegen import make_function_with_signature\n-from astropy.nddata.utils import add_array, extract_array\n-from .utils import (combine_labels, make_binary_operator_eval,\n-                    get_inputs_and_params, _combine_equivalency_dict,\n-                    _ConstraintsDict, _SpecialOperatorsDict)\n-from .bounding_box import ModelBoundingBox, CompoundBoundingBox\n-from .parameters import (Parameter, InputParameterError,\n-                         param_repr_oneline, _tofloat)\n-\n-\n-__all__ = ['Model', 'FittableModel', 'Fittable1DModel', 'Fittable2DModel',\n-           'CompoundModel', 'fix_inputs', 'custom_model', 'ModelDefinitionError',\n-           'bind_bounding_box', 'bind_compound_bounding_box']\n \n+def _cstack(left, right):\n+    \"\"\"\n+    Stack two coordinate matrices diagonally to preserve separability.\n+    \"\"\"\n+    if left.ndim != 2 or right.ndim != 2:\n+        raise ValueError(\"Input matrices must be 2-dimensional\")\n+\n+    n_left = left.shape[0]\n+    m_left = left.shape[1]\n+    n_right = right.shape[0]\n+    m_right = right.shape[1]\n+\n+    cleft = np.zeros((n_left, m_left + m_right), dtype=bool)\n+    cleft[:, :m_left] = left\n+\n+    cright = np.zeros((n_right, m_left + m_right), dtype=bool)\n+    cright[:, m_left:] = right\n \n+    return np.vstack([cleft, cright])\n def _model_oper(oper, **kwargs):\n     \"\"\"\n     Returns a function that evaluates a given Python arithmetic operator\ndiff --git a/astropy/modeling/functional_models.py b/astropy/modeling/functional_models.py\nindex ed13dc043d..a4e8df6d0b 100644\n--- a/astropy/modeling/functional_models.py\n+++ b/astropy/modeling/functional_models.py\n@@ -1,53 +1,6 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n-\"\"\"Mathematical models.\"\"\"\n-# pylint: disable=line-too-long, too-many-lines, too-many-arguments, invalid-name\n-import numpy as np\n-\n-from astropy import units as u\n-from astropy.units import Quantity, UnitsError\n-from .core import (Fittable1DModel, Fittable2DModel)\n-\n-from .parameters import Parameter, InputParameterError\n-from .utils import ellipse_extent\n-\n-\n-__all__ = ['AiryDisk2D', 'Moffat1D', 'Moffat2D', 'Box1D', 'Box2D', 'Const1D',\n-           'Const2D', 'Ellipse2D', 'Disk2D', 'Gaussian1D', 'Gaussian2D',\n-           'Linear1D', 'Lorentz1D', 'RickerWavelet1D', 'RickerWavelet2D',\n-           'RedshiftScaleFactor', 'Multiply', 'Planar2D', 'Scale',\n-           'Sersic1D', 'Sersic2D', 'Shift',\n-           'Sine1D', 'Cosine1D', 'Tangent1D',\n-           'ArcSine1D', 'ArcCosine1D', 'ArcTangent1D',\n-           'Trapezoid1D', 'TrapezoidDisk2D', 'Ring2D', 'Voigt1D',\n-           'KingProjectedAnalytic1D', 'Exponential1D', 'Logarithmic1D']\n-\n-TWOPI = 2 * np.pi\n-FLOAT_EPSILON = float(np.finfo(np.float32).tiny)\n-\n-# Note that we define this here rather than using the value defined in\n-# astropy.stats to avoid importing astropy.stats every time astropy.modeling\n-# is loaded.\n-GAUSSIAN_SIGMA_TO_FWHM = 2.0 * np.sqrt(2.0 * np.log(2.0))\n-\n-\n-class Gaussian1D(Fittable1DModel):\n-    \"\"\"\n-    One dimensional Gaussian model.\n-\n-    Parameters\n-    ----------\n-    amplitude : float or `~astropy.units.Quantity`.\n-        Amplitude (peak value) of the Gaussian - for a normalized profile\n-        (integrating to 1), set amplitude = 1 / (stddev * np.sqrt(2 * np.pi))\n-    mean : float or `~astropy.units.Quantity`.\n-        Mean of the Gaussian.\n-    stddev : float or `~astropy.units.Quantity`.\n-        Standard deviation of the Gaussian with FWHM = 2 * stddev * np.sqrt(2 * np.log(2)).\n-\n-    Notes\n-    -----\n-    Either all or none of input ``x``, ``mean`` and ``stddev`` must be provided\n+    cright = np.zeros((nright, nright))\n+    cright[-right.shape[0]:, -right.shape[1]:] = right\n     consistently with compatible units or as unitless numbers.\n \n     Model formula:\ndiff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e27297..74e14a1118 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -102,6 +102,7 @@ def separability_matrix(transform):\n     return separable_matrix\n \n \n+\n def _compute_n_outputs(left, right):\n     \"\"\"\n     Compute the number of outputs of two models.\n@@ -168,6 +169,7 @@ def _arith_oper(left, right):\n     return result\n \n \n+\n def _coord_matrix(model, pos, noutp):\n     \"\"\"\n     Create an array representing inputs and outputs of a simple model.\n@@ -216,6 +218,7 @@ def _coord_matrix(model, pos, noutp):\n     return mat\n \n \n+\n def _cstack(left, right):\n     \"\"\"\n     Function corresponding to '&' operation.\n@@ -242,7 +245,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \n",
    "variant_6": "diff --git a/astropy/modeling/core.py b/astropy/modeling/core.py\nindex da4352cb0c..eaa0b97e09 100644\n--- a/astropy/modeling/core.py\n+++ b/astropy/modeling/core.py\n@@ -1,53 +1,20 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n-\n-\"\"\"\n-This module defines base classes for all models.  The base class of all\n-models is `~astropy.modeling.Model`. `~astropy.modeling.FittableModel` is\n-the base class for all fittable models. Fittable models can be linear or\n-nonlinear in a regression analysis sense.\n-\n-All models provide a `__call__` method which performs the transformation in\n-a purely mathematical way, i.e. the models are unitless.  Model instances can\n-represent either a single model, or a \"model set\" representing multiple copies\n-of the same type of model, but with potentially different values of the\n-parameters in each model making up the set.\n-\"\"\"\n-# pylint: disable=invalid-name, protected-access, redefined-outer-name\n-import abc\n-import copy\n-import inspect\n-import itertools\n-import functools\n-import operator\n-import types\n-\n-from collections import defaultdict, deque\n-from inspect import signature\n-from itertools import chain\n-\n-import numpy as np\n-\n-from astropy.utils import indent, metadata\n-from astropy.table import Table\n-from astropy.units import Quantity, UnitsError, dimensionless_unscaled\n-from astropy.units.utils import quantity_asanyarray\n-from astropy.utils import (sharedmethod, find_current_module,\n-                           check_broadcast, IncompatibleShapeError, isiterable)\n-from astropy.utils.codegen import make_function_with_signature\n-from astropy.nddata.utils import add_array, extract_array\n-from .utils import (combine_labels, make_binary_operator_eval,\n-                    get_inputs_and_params, _combine_equivalency_dict,\n-                    _ConstraintsDict, _SpecialOperatorsDict)\n-from .bounding_box import ModelBoundingBox, CompoundBoundingBox\n-from .parameters import (Parameter, InputParameterError,\n-                         param_repr_oneline, _tofloat)\n-\n-\n-__all__ = ['Model', 'FittableModel', 'Fittable1DModel', 'Fittable2DModel',\n-           'CompoundModel', 'fix_inputs', 'custom_model', 'ModelDefinitionError',\n-           'bind_bounding_box', 'bind_compound_bounding_box']\n \n+def _cstack(left, right):\n+    \"\"\"Stack two coordinate matrices diagonally.\"\"\"\n+    if left.ndim != 2 or right.ndim != 2:\n+        raise ValueError(\"Inputs must be 2D arrays.\")\n \n+    n_left = left.shape[0]\n+    n_right = right.shape[0]\n+    n_both = n_left + n_right\n+\n+    cleft = np.zeros((n_both, n_both), dtype=bool)\n+    cright = np.zeros((n_both, n_both), dtype=bool)\n+\n+    cleft[:n_left, :n_left] = left\n+    cright[-n_right:, -n_right:] = right\n+\n+    return cleft, cright\n def _model_oper(oper, **kwargs):\n     \"\"\"\n     Returns a function that evaluates a given Python arithmetic operator\ndiff --git a/astropy/modeling/functional_models.py b/astropy/modeling/functional_models.py\nindex ed13dc043d..b8ad6fba4f 100644\n--- a/astropy/modeling/functional_models.py\n+++ b/astropy/modeling/functional_models.py\n@@ -1,53 +1,27 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n-\"\"\"Mathematical models.\"\"\"\n-# pylint: disable=line-too-long, too-many-lines, too-many-arguments, invalid-name\n-import numpy as np\n-\n-from astropy import units as u\n-from astropy.units import Quantity, UnitsError\n-from .core import (Fittable1DModel, Fittable2DModel)\n-\n-from .parameters import Parameter, InputParameterError\n-from .utils import ellipse_extent\n-\n-\n-__all__ = ['AiryDisk2D', 'Moffat1D', 'Moffat2D', 'Box1D', 'Box2D', 'Const1D',\n-           'Const2D', 'Ellipse2D', 'Disk2D', 'Gaussian1D', 'Gaussian2D',\n-           'Linear1D', 'Lorentz1D', 'RickerWavelet1D', 'RickerWavelet2D',\n-           'RedshiftScaleFactor', 'Multiply', 'Planar2D', 'Scale',\n-           'Sersic1D', 'Sersic2D', 'Shift',\n-           'Sine1D', 'Cosine1D', 'Tangent1D',\n-           'ArcSine1D', 'ArcCosine1D', 'ArcTangent1D',\n-           'Trapezoid1D', 'TrapezoidDisk2D', 'Ring2D', 'Voigt1D',\n-           'KingProjectedAnalytic1D', 'Exponential1D', 'Logarithmic1D']\n-\n-TWOPI = 2 * np.pi\n-FLOAT_EPSILON = float(np.finfo(np.float32).tiny)\n+def _cstack(left, right):\n+    \"\"\"\n+    Combine two separability matrices (left and right) diagonally, preserving\n+    their original structure and separability information.\n+    \"\"\"\n+    if left is None and right is None:\n+        return None\n \n-# Note that we define this here rather than using the value defined in\n-# astropy.stats to avoid importing astropy.stats every time astropy.modeling\n-# is loaded.\n-GAUSSIAN_SIGMA_TO_FWHM = 2.0 * np.sqrt(2.0 * np.log(2.0))\n+    if left is None:\n+        return right\n \n+    if right is None:\n+        return left\n \n-class Gaussian1D(Fittable1DModel):\n-    \"\"\"\n-    One dimensional Gaussian model.\n+    cleft = np.zeros((left.shape[0] + right.shape[0],\n+                      left.shape[1] + right.shape[1]), dtype=bool)\n+    cright = np.zeros_like(cleft)\n \n-    Parameters\n-    ----------\n-    amplitude : float or `~astropy.units.Quantity`.\n-        Amplitude (peak value) of the Gaussian - for a normalized profile\n-        (integrating to 1), set amplitude = 1 / (stddev * np.sqrt(2 * np.pi))\n-    mean : float or `~astropy.units.Quantity`.\n-        Mean of the Gaussian.\n-    stddev : float or `~astropy.units.Quantity`.\n-        Standard deviation of the Gaussian with FWHM = 2 * stddev * np.sqrt(2 * np.log(2)).\n+    # Fill the diagonal blocks\n+    cleft[:left.shape[0], :left.shape[1]] = left\n+    cright[-right.shape[0]:, -right.shape[1]:] = right  # Preserve right structure\n \n-    Notes\n-    -----\n-    Either all or none of input ``x``, ``mean`` and ``stddev`` must be provided\n+    return cleft | cright\n     consistently with compatible units or as unitless numbers.\n \n     Model formula:\ndiff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e27297..c0ed96919d 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -102,6 +102,7 @@ def separability_matrix(transform):\n     return separable_matrix\n \n \n+\n def _compute_n_outputs(left, right):\n     \"\"\"\n     Compute the number of outputs of two models.\n@@ -118,10 +119,14 @@ def _compute_n_outputs(left, right):\n     if isinstance(left, Model):\n         lnout = left.n_outputs\n     else:\n+        if left.shape[0] is None:\n+            raise ValueError(\"Left operand must have defined shape\")\n         lnout = left.shape[0]\n     if isinstance(right, Model):\n         rnout = right.n_outputs\n     else:\n+        if right.shape[0] is None:\n+            raise ValueError(\"Right operand must have defined shape\")\n         rnout = right.shape[0]\n     noutp = lnout + rnout\n     return noutp\n@@ -168,6 +173,7 @@ def _arith_oper(left, right):\n     return result\n \n \n+\n def _coord_matrix(model, pos, noutp):\n     \"\"\"\n     Create an array representing inputs and outputs of a simple model.\n@@ -216,6 +222,7 @@ def _coord_matrix(model, pos, noutp):\n     return mat\n \n \n+\n def _cstack(left, right):\n     \"\"\"\n     Function corresponding to '&' operation.\n@@ -242,7 +249,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \n",
    "variant_7": "diff --git a/astropy/modeling/core.py b/astropy/modeling/core.py\nindex da4352cb0c..a86ef78104 100644\n--- a/astropy/modeling/core.py\n+++ b/astropy/modeling/core.py\n@@ -1,53 +1,9 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n-\n-\"\"\"\n-This module defines base classes for all models.  The base class of all\n-models is `~astropy.modeling.Model`. `~astropy.modeling.FittableModel` is\n-the base class for all fittable models. Fittable models can be linear or\n-nonlinear in a regression analysis sense.\n-\n-All models provide a `__call__` method which performs the transformation in\n-a purely mathematical way, i.e. the models are unitless.  Model instances can\n-represent either a single model, or a \"model set\" representing multiple copies\n-of the same type of model, but with potentially different values of the\n-parameters in each model making up the set.\n-\"\"\"\n-# pylint: disable=invalid-name, protected-access, redefined-outer-name\n-import abc\n-import copy\n-import inspect\n-import itertools\n-import functools\n-import operator\n-import types\n-\n-from collections import defaultdict, deque\n-from inspect import signature\n-from itertools import chain\n-\n-import numpy as np\n-\n-from astropy.utils import indent, metadata\n-from astropy.table import Table\n-from astropy.units import Quantity, UnitsError, dimensionless_unscaled\n-from astropy.units.utils import quantity_asanyarray\n-from astropy.utils import (sharedmethod, find_current_module,\n-                           check_broadcast, IncompatibleShapeError, isiterable)\n-from astropy.utils.codegen import make_function_with_signature\n-from astropy.nddata.utils import add_array, extract_array\n-from .utils import (combine_labels, make_binary_operator_eval,\n-                    get_inputs_and_params, _combine_equivalency_dict,\n-                    _ConstraintsDict, _SpecialOperatorsDict)\n-from .bounding_box import ModelBoundingBox, CompoundBoundingBox\n-from .parameters import (Parameter, InputParameterError,\n-                         param_repr_oneline, _tofloat)\n-\n-\n-__all__ = ['Model', 'FittableModel', 'Fittable1DModel', 'Fittable2DModel',\n-           'CompoundModel', 'fix_inputs', 'custom_model', 'ModelDefinitionError',\n-           'bind_bounding_box', 'bind_compound_bounding_box']\n-\n \n+    cright = np.zeros((n_right_out, n_right_in), dtype=bool)\n+    if right.separable:\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n+    else:\n+        cright[:] = True\n def _model_oper(oper, **kwargs):\n     \"\"\"\n     Returns a function that evaluates a given Python arithmetic operator\ndiff --git a/astropy/modeling/functional_models.py b/astropy/modeling/functional_models.py\nindex ed13dc043d..955136a893 100644\n--- a/astropy/modeling/functional_models.py\n+++ b/astropy/modeling/functional_models.py\n@@ -1,3 +1,4 @@\n+\n # Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n \"\"\"Mathematical models.\"\"\"\n@@ -50,6 +51,16 @@ class Gaussian1D(Fittable1DModel):\n     Either all or none of input ``x``, ``mean`` and ``stddev`` must be provided\n     consistently with compatible units or as unitless numbers.\n \n+    Model formula:\n+\n+        .. math:: f(x) = A e^{- \\\\frac{\\\\left(x - x_{0}\\\\right)^{2}}{2 \\\\sigma^{2}}}\n+\n+    Examples\n+    --------\n+    >>> from astropy.modeling import models\n+    >>> def tie_center(model):\n+    consistently with compatible units or as unitless numbers.\n+\n     Model formula:\n \n         .. math:: f(x) = A e^{- \\\\frac{\\\\left(x - x_{0}\\\\right)^{2}}{2 \\\\sigma^{2}}}\ndiff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e27297..74e14a1118 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -102,6 +102,7 @@ def separability_matrix(transform):\n     return separable_matrix\n \n \n+\n def _compute_n_outputs(left, right):\n     \"\"\"\n     Compute the number of outputs of two models.\n@@ -168,6 +169,7 @@ def _arith_oper(left, right):\n     return result\n \n \n+\n def _coord_matrix(model, pos, noutp):\n     \"\"\"\n     Create an array representing inputs and outputs of a simple model.\n@@ -216,6 +218,7 @@ def _coord_matrix(model, pos, noutp):\n     return mat\n \n \n+\n def _cstack(left, right):\n     \"\"\"\n     Function corresponding to '&' operation.\n@@ -242,7 +245,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \n",
    "variant_8": "diff --git a/astropy/modeling/core.py b/astropy/modeling/core.py\nindex da4352cb0c..0ebb53dbbb 100644\n--- a/astropy/modeling/core.py\n+++ b/astropy/modeling/core.py\n@@ -1,53 +1,30 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n-\n-\"\"\"\n-This module defines base classes for all models.  The base class of all\n-models is `~astropy.modeling.Model`. `~astropy.modeling.FittableModel` is\n-the base class for all fittable models. Fittable models can be linear or\n-nonlinear in a regression analysis sense.\n-\n-All models provide a `__call__` method which performs the transformation in\n-a purely mathematical way, i.e. the models are unitless.  Model instances can\n-represent either a single model, or a \"model set\" representing multiple copies\n-of the same type of model, but with potentially different values of the\n-parameters in each model making up the set.\n-\"\"\"\n-# pylint: disable=invalid-name, protected-access, redefined-outer-name\n-import abc\n-import copy\n-import inspect\n-import itertools\n-import functools\n-import operator\n-import types\n-\n-from collections import defaultdict, deque\n-from inspect import signature\n-from itertools import chain\n-\n-import numpy as np\n-\n-from astropy.utils import indent, metadata\n-from astropy.table import Table\n-from astropy.units import Quantity, UnitsError, dimensionless_unscaled\n-from astropy.units.utils import quantity_asanyarray\n-from astropy.utils import (sharedmethod, find_current_module,\n-                           check_broadcast, IncompatibleShapeError, isiterable)\n-from astropy.utils.codegen import make_function_with_signature\n-from astropy.nddata.utils import add_array, extract_array\n-from .utils import (combine_labels, make_binary_operator_eval,\n-                    get_inputs_and_params, _combine_equivalency_dict,\n-                    _ConstraintsDict, _SpecialOperatorsDict)\n-from .bounding_box import ModelBoundingBox, CompoundBoundingBox\n-from .parameters import (Parameter, InputParameterError,\n-                         param_repr_oneline, _tofloat)\n-\n-\n-__all__ = ['Model', 'FittableModel', 'Fittable1DModel', 'Fittable2DModel',\n-           'CompoundModel', 'fix_inputs', 'custom_model', 'ModelDefinitionError',\n-           'bind_bounding_box', 'bind_compound_bounding_box']\n \n+def _cstack(left, right):\n+    \"\"\"\n+    Stack two separability matrices diagonally.\n+    \"\"\"\n+    if left is None and right is None:\n+        return None\n+\n+    if left is None:\n+        return right\n+\n+    if right is None:\n+        return left\n+\n+    left = np.asarray(left, bool)\n+    right = np.asarray(right, bool)\n+\n+    sleft0, sleft1 = left.shape\n+    sright0, sright1 = right.shape\n+\n+    cleft = np.zeros((sleft0 + sright0, sleft1 + sright1), bool)\n+    cleft[:sleft0, :sleft1] = left\n+\n+    cright = np.zeros((sleft0 + sright0, sleft1 + sright1), bool)\n+    cright[-right.shape[0]:, -right.shape[1]:] = right\n \n+    return cleft | cright\n def _model_oper(oper, **kwargs):\n     \"\"\"\n     Returns a function that evaluates a given Python arithmetic operator\ndiff --git a/astropy/modeling/functional_models.py b/astropy/modeling/functional_models.py\nindex ed13dc043d..5c0fcf58d7 100644\n--- a/astropy/modeling/functional_models.py\n+++ b/astropy/modeling/functional_models.py\n@@ -1,53 +1,28 @@\n-# Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n-\"\"\"Mathematical models.\"\"\"\n-# pylint: disable=line-too-long, too-many-lines, too-many-arguments, invalid-name\n-import numpy as np\n-\n-from astropy import units as u\n-from astropy.units import Quantity, UnitsError\n-from .core import (Fittable1DModel, Fittable2DModel)\n-\n-from .parameters import Parameter, InputParameterError\n-from .utils import ellipse_extent\n-\n-\n-__all__ = ['AiryDisk2D', 'Moffat1D', 'Moffat2D', 'Box1D', 'Box2D', 'Const1D',\n-           'Const2D', 'Ellipse2D', 'Disk2D', 'Gaussian1D', 'Gaussian2D',\n-           'Linear1D', 'Lorentz1D', 'RickerWavelet1D', 'RickerWavelet2D',\n-           'RedshiftScaleFactor', 'Multiply', 'Planar2D', 'Scale',\n-           'Sersic1D', 'Sersic2D', 'Shift',\n-           'Sine1D', 'Cosine1D', 'Tangent1D',\n-           'ArcSine1D', 'ArcCosine1D', 'ArcTangent1D',\n-           'Trapezoid1D', 'TrapezoidDisk2D', 'Ring2D', 'Voigt1D',\n-           'KingProjectedAnalytic1D', 'Exponential1D', 'Logarithmic1D']\n-\n-TWOPI = 2 * np.pi\n-FLOAT_EPSILON = float(np.finfo(np.float32).tiny)\n-\n-# Note that we define this here rather than using the value defined in\n-# astropy.stats to avoid importing astropy.stats every time astropy.modeling\n-# is loaded.\n-GAUSSIAN_SIGMA_TO_FWHM = 2.0 * np.sqrt(2.0 * np.log(2.0))\n-\n-\n-class Gaussian1D(Fittable1DModel):\n-    \"\"\"\n-    One dimensional Gaussian model.\n-\n-    Parameters\n-    ----------\n-    amplitude : float or `~astropy.units.Quantity`.\n-        Amplitude (peak value) of the Gaussian - for a normalized profile\n-        (integrating to 1), set amplitude = 1 / (stddev * np.sqrt(2 * np.pi))\n-    mean : float or `~astropy.units.Quantity`.\n-        Mean of the Gaussian.\n-    stddev : float or `~astropy.units.Quantity`.\n-        Standard deviation of the Gaussian with FWHM = 2 * stddev * np.sqrt(2 * np.log(2)).\n+    def _cstack(left, right):\n+        \"\"\"\n+        Horizontally stacks two separability matrices.\n \n-    Notes\n-    -----\n-    Either all or none of input ``x``, ``mean`` and ``stddev`` must be provided\n+        Parameters\n+        ----------\n+        left : ndarray\n+            Left separability matrix.\n+        right : ndarray\n+            Right separability matrix.\n+\n+        Returns\n+        -------\n+        result : ndarray\n+            Combined separability matrix.\n+        \"\"\"\n+        # Create a matrix with the correct dimensions filled with False\n+        cright = np.zeros((left.shape[0] + right.shape[0],\n+                          left.shape[1] + right.shape[1]), bool)\n+        # Fill in the left matrix\n+        cright[:left.shape[0], :left.shape[1]] = left\n+        # Fill in the right matrix\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n+        return cright\n     consistently with compatible units or as unitless numbers.\n \n     Model formula:\ndiff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e27297..74e14a1118 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -102,6 +102,7 @@ def separability_matrix(transform):\n     return separable_matrix\n \n \n+\n def _compute_n_outputs(left, right):\n     \"\"\"\n     Compute the number of outputs of two models.\n@@ -168,6 +169,7 @@ def _arith_oper(left, right):\n     return result\n \n \n+\n def _coord_matrix(model, pos, noutp):\n     \"\"\"\n     Create an array representing inputs and outputs of a simple model.\n@@ -216,6 +218,7 @@ def _coord_matrix(model, pos, noutp):\n     return mat\n \n \n+\n def _cstack(left, right):\n     \"\"\"\n     Function corresponding to '&' operation.\n@@ -242,7 +245,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \n"
  }
}